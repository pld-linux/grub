diff -rc2P -x CVS GRUB_0.94/configure GRUB/configure
*** GRUB_0.94/configure	2003-11-20 10:04:59.000000000 +0800
--- GRUB/configure	2003-11-20 12:58:37.000000000 +0800
***************
*** 870,914 ****
                            turn off packet retransmission
    --enable-pci-direct     access PCI directly instead of using BIOS
-   --enable-3c509          enable 3Com509 driver
-   --enable-3c529          enable 3Com529 driver
    --enable-3c595          enable 3Com595 driver
    --enable-3c90x          enable 3Com90x driver
-   --enable-cs89x0         enable CS89x0 driver
    --enable-davicom        enable Davicom driver
!   --enable-depca          enable DEPCA and EtherWORKS driver
!   --enable-eepro          enable Etherexpress Pro/10 driver
    --enable-eepro100       enable Etherexpress Pro/100 driver
    --enable-epic100        enable SMC 83c170 EPIC/100 driver
-   --enable-3c507          enable 3Com507 driver
-   --enable-exos205        enable EXOS205 driver
-   --enable-ni5210         enable Racal-Interlan NI5210 driver
-   --enable-lance          enable Lance PCI PCNet/32 driver
-   --enable-ne2100         enable Novell NE2100 driver
-   --enable-ni6510         enable Racal-Interlan NI6510 driver
    --enable-natsemi        enable NatSemi DP8381x driver
-   --enable-ni5010         enable Racal-Interlan NI5010 driver
-   --enable-3c503          enable 3Com503 driver
-   --enable-ne             enable NE1000/2000 ISA driver
    --enable-ns8390         enable NE2000 PCI driver
!   --enable-wd             enable WD8003/8013, SMC8216/8416 driver
!   --enable-otulip         enable old Tulip driver
    --enable-rtl8139        enable Realtek 8139 driver
    --enable-sis900         enable SIS 900 and SIS 7016 driver
!   --enable-sk-g16         enable Schneider and Koch G16 driver
!   --enable-smc9000        enable SMC9000 driver
!   --enable-tiara          enable Tiara driver
    --enable-tulip          enable Tulip driver
    --enable-via-rhine      enable Rhine-I/II driver
    --enable-w89c840        enable Winbond W89c840, Compex RL100-ATX driver
-   --enable-3c503-shmem    use 3c503 shared memory mode
-   --enable-3c503-aui      use AUI by default on 3c503 cards
    --enable-compex-rl2000-fix
                            specify this if you have a Compex RL2000 PCI
-   --enable-smc9000-scan=LIST
-                           probe for SMC9000 I/O addresses using LIST
    --enable-ne-scan=LIST   probe for NE base address using LIST
    --enable-wd-default-mem=MEM
                            set the default memory location for WD/SMC
-   --enable-cs-scan=LIST   probe for CS89x0 base address using LIST
    --enable-diskless       enable diskless support
    --disable-hercules      disable hercules terminal support
--- 870,895 ----
                            turn off packet retransmission
    --enable-pci-direct     access PCI directly instead of using BIOS
    --enable-3c595          enable 3Com595 driver
    --enable-3c90x          enable 3Com90x driver
    --enable-davicom        enable Davicom driver
!   --enable-e1000          enable Etherexpress Pro/1000 driver
    --enable-eepro100       enable Etherexpress Pro/100 driver
    --enable-epic100        enable SMC 83c170 EPIC/100 driver
    --enable-natsemi        enable NatSemi DP8381x driver
    --enable-ns8390         enable NE2000 PCI driver
!   --enable-pcnet32             enable AMD Lance/PCI PCNet/32 driver
    --enable-rtl8139        enable Realtek 8139 driver
    --enable-sis900         enable SIS 900 and SIS 7016 driver
!   --enable-tg3          enable Broadcom Tigon3 driver
    --enable-tulip          enable Tulip driver
+   --enable-tlan          enable  TI ThunderLAN driver
+   --enable-sundance          enable Sundance ST201 driver
    --enable-via-rhine      enable Rhine-I/II driver
    --enable-w89c840        enable Winbond W89c840, Compex RL100-ATX driver
    --enable-compex-rl2000-fix
                            specify this if you have a Compex RL2000 PCI
    --enable-ne-scan=LIST   probe for NE base address using LIST
    --enable-wd-default-mem=MEM
                            set the default memory location for WD/SMC
    --enable-diskless       enable diskless support
    --disable-hercules      disable hercules terminal support
***************
*** 5125,5129 ****
  fi;
  if test "x$enable_packet_retransmission" != xno; then
!   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1"
  fi
  
--- 5106,5110 ----
  fi;
  if test "x$enable_packet_retransmission" != xno; then
!   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1 -DCONFIG_PCI"
  fi
  
***************
*** 5137,5160 ****
  fi
  
- # Check whether --enable-3c509 or --disable-3c509 was given.
- if test "${enable_3c509+set}" = set; then
-   enableval="$enable_3c509"
- 
- fi;
- if test "x$enable_3c509" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C509"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c509.o"
- fi
- 
- # Check whether --enable-3c529 or --disable-3c529 was given.
- if test "${enable_3c529+set}" = set; then
-   enableval="$enable_3c529"
- 
- fi;
- if test "x$enable_3c529" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C529=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c529.o"
- fi
- 
  # Check whether --enable-3c595 or --disable-3c595 was given.
  if test "${enable_3c595+set}" = set; then
--- 5118,5121 ----
***************
*** 5177,5190 ****
  fi
  
- # Check whether --enable-cs89x0 or --disable-cs89x0 was given.
- if test "${enable_cs89x0+set}" = set; then
-   enableval="$enable_cs89x0"
- 
- fi;
- if test "x$enable_cs89x0" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_CS89X0=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS cs89x0.o"
- fi
- 
  # Check whether --enable-davicom or --disable-davicom was given.
  if test "${enable_davicom+set}" = set; then
--- 5138,5141 ----
***************
*** 5197,5218 ****
  fi
  
! # Check whether --enable-depca or --disable-depca was given.
! if test "${enable_depca+set}" = set; then
!   enableval="$enable_depca"
! 
! fi;
! if test "x$enable_depca" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_DEPCA=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS depca.o"
! fi
! 
! # Check whether --enable-eepro or --disable-eepro was given.
! if test "${enable_eepro+set}" = set; then
!   enableval="$enable_eepro"
  
  fi;
! if test "x$enable_eepro" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EEPRO=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS eepro.o"
  fi
  
--- 5148,5159 ----
  fi
  
! # Check whether --enable-e1000 or --disable-e1000 was given.
! if test "${enable_e1000+set}" = set; then
!   enableval="$enable_e1000"
  
  fi;
! if test "x$enable_e1000" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_E1000=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS e1000.o"
  fi
  
***************
*** 5237,5300 ****
  fi
  
- # Check whether --enable-3c507 or --disable-3c507 was given.
- if test "${enable_3c507+set}" = set; then
-   enableval="$enable_3c507"
- 
- fi;
- if test "x$enable_3c507" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C507=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c507.o"
- fi
- 
- # Check whether --enable-exos205 or --disable-exos205 was given.
- if test "${enable_exos205+set}" = set; then
-   enableval="$enable_exos205"
- 
- fi;
- if test "x$enable_exos205" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EXOS205=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS exos205.o"
- fi
- 
- # Check whether --enable-ni5210 or --disable-ni5210 was given.
- if test "${enable_ni5210+set}" = set; then
-   enableval="$enable_ni5210"
- 
- fi;
- if test "x$enable_ni5210" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5210=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5210.o"
- fi
- 
- # Check whether --enable-lance or --disable-lance was given.
- if test "${enable_lance+set}" = set; then
-   enableval="$enable_lance"
- 
- fi;
- if test "x$enable_lance" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_LANCE=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS lance.o"
- fi
- 
- # Check whether --enable-ne2100 or --disable-ne2100 was given.
- if test "${enable_ne2100+set}" = set; then
-   enableval="$enable_ne2100"
- 
- fi;
- if test "x$enable_ne2100" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE2100=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne2100.o"
- fi
- 
- # Check whether --enable-ni6510 or --disable-ni6510 was given.
- if test "${enable_ni6510+set}" = set; then
-   enableval="$enable_ni6510"
- 
- fi;
- if test "x$enable_ni6510" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI6510=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni6510.o"
- fi
- 
  # Check whether --enable-natsemi or --disable-natsemi was given.
  if test "${enable_natsemi+set}" = set; then
--- 5178,5181 ----
***************
*** 5307,5340 ****
  fi
  
- # Check whether --enable-ni5010 or --disable-ni5010 was given.
- if test "${enable_ni5010+set}" = set; then
-   enableval="$enable_ni5010"
- 
- fi;
- if test "x$enable_ni5010" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5010=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5010.o"
- fi
- 
- # Check whether --enable-3c503 or --disable-3c503 was given.
- if test "${enable_3c503+set}" = set; then
-   enableval="$enable_3c503"
- 
- fi;
- if test "x$enable_3c503" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C503=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c503.o"
- fi
- 
- # Check whether --enable-ne or --disable-ne was given.
- if test "${enable_ne+set}" = set; then
-   enableval="$enable_ne"
- 
- fi;
- if test "x$enable_ne" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne.o"
- fi
- 
  # Check whether --enable-ns8390 or --disable-ns8390 was given.
  if test "${enable_ns8390+set}" = set; then
--- 5188,5191 ----
***************
*** 5347,5368 ****
  fi
  
! # Check whether --enable-wd or --disable-wd was given.
! if test "${enable_wd+set}" = set; then
!   enableval="$enable_wd"
! 
! fi;
! if test "x$enable_wd" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_WD=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS wd.o"
! fi
! 
! # Check whether --enable-otulip or --disable-otulip was given.
! if test "${enable_otulip+set}" = set; then
!   enableval="$enable_otulip"
  
  fi;
! if test "x$enable_otulip" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_OTULIP=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS otulip.o"
  fi
  
--- 5198,5209 ----
  fi
  
! # Check whether --enable-pcnet32 or --disable-pcnet32 was given.
! if test "${enable_pcnet32+set}" = set; then
!   enableval="$enable_pcnet32"
  
  fi;
! if test "x$enable_pcnet32" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PCNET32=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS pcnet32.o"
  fi
  
***************
*** 5387,5428 ****
  fi
  
! # Check whether --enable-sk-g16 or --disable-sk-g16 was given.
! if test "${enable_sk_g16+set}" = set; then
!   enableval="$enable_sk_g16"
  
  fi;
! if test "x$enable_sk_g16" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SK_G16=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sk_g16.o"
  fi
  
! # Check whether --enable-smc9000 or --disable-smc9000 was given.
! if test "${enable_smc9000+set}" = set; then
!   enableval="$enable_smc9000"
  
  fi;
! if test "x$enable_smc9000" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SMC9000=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS smc9000.o"
  fi
  
! # Check whether --enable-tiara or --disable-tiara was given.
! if test "${enable_tiara+set}" = set; then
!   enableval="$enable_tiara"
  
  fi;
! if test "x$enable_tiara" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TIARA=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tiara.o"
  fi
  
! # Check whether --enable-tulip or --disable-tulip was given.
! if test "${enable_tulip+set}" = set; then
!   enableval="$enable_tulip"
  
  fi;
! if test "x$enable_tulip" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TULIP=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tulip.o"
  fi
  
--- 5228,5269 ----
  fi
  
! # Check whether --enable-tg3 or --disable-tg3 was given.
! if test "${enable_tg3+set}" = set; then
!   enableval="$enable_tg3"
  
  fi;
! if test "x$enable_tg3" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TG3=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tg3.o"
  fi
  
! # Check whether --enable-tulip or --disable-tulip was given.
! if test "${enable_tulip+set}" = set; then
!   enableval="$enable_tulip"
  
  fi;
! if test "x$enable_tulip" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TULIP=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tulip.o"
  fi
  
! # Check whether --enable-tlan or --disable-tlan was given.
! if test "${enable_tlan+set}" = set; then
!   enableval="$enable_tlan"
  
  fi;
! if test "x$enable_tlan" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TLAN=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tlan.o"
  fi
  
! # Check whether --enable-sundance or --disable-sundance was given.
! if test "${enable_sundance+set}" = set; then
!   enableval="$enable_sundance"
  
  fi;
! if test "x$enable_sundance" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SUNDANCE=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sundance.o"
  fi
  
***************
*** 5461,5482 ****
  fi
  
- # Check whether --enable-3c503-shmem or --disable-3c503-shmem was given.
- if test "${enable_3c503_shmem+set}" = set; then
-   enableval="$enable_3c503_shmem"
- 
- fi;
- if test "x$enable_3c503_shmem" = xyes; then
-   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_SHMEM=1"
- fi
- 
- # Check whether --enable-3c503-aui or --disable-3c503-aui was given.
- if test "${enable_3c503_aui+set}" = set; then
-   enableval="$enable_3c503_aui"
- 
- fi;
- if test "x$enable_3c503_aui" = xyes; then
-   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_AUI=1"
- fi
- 
  # Check whether --enable-compex-rl2000-fix or --disable-compex-rl2000-fix was given.
  if test "${enable_compex_rl2000_fix+set}" = set; then
--- 5302,5305 ----
***************
*** 5488,5497 ****
  fi
  
- # Check whether --enable-smc9000-scan or --disable-smc9000-scan was given.
- if test "${enable_smc9000_scan+set}" = set; then
-   enableval="$enable_smc9000_scan"
-   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DSMC9000_SCAN=$enable_smc9000_scan"
- fi;
- 
  # Check whether --enable-ne-scan or --disable-ne-scan was given.
  if test "${enable_ne_scan+set}" = set; then
--- 5311,5314 ----
***************
*** 5510,5519 ****
  fi;
  
- # Check whether --enable-cs-scan or --disable-cs-scan was given.
- if test "${enable_cs_scan+set}" = set; then
-   enableval="$enable_cs_scan"
-   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCS_SCAN=$enable_cs_scan"
- fi;
- 
  # Check whether --enable-diskless or --disable-diskless was given.
  if test "${enable_diskless+set}" = set; then
--- 5327,5330 ----
diff -rc2P -x CVS GRUB_0.94/configure.ac GRUB/configure.ac
*** GRUB_0.94/configure.ac	2003-11-20 10:04:59.000000000 +0800
--- GRUB/configure.ac	2003-11-20 12:57:51.000000000 +0800
***************
*** 289,293 ****
                            turn off packet retransmission])
  if test "x$enable_packet_retransmission" != xno; then
!   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1"
  fi
  
--- 289,293 ----
                            turn off packet retransmission])
  if test "x$enable_packet_retransmission" != xno; then
!   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1 -DCONFIG_PCI"
  fi
  
***************
*** 299,316 ****
  
  dnl Device drivers.
- AC_ARG_ENABLE(3c509,
-   [  --enable-3c509          enable 3Com509 driver])
- if test "x$enable_3c509" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C509"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c509.o"
- fi
- 
- AC_ARG_ENABLE(3c529,
-   [  --enable-3c529          enable 3Com529 driver])
- if test "x$enable_3c529" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C529=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c529.o"
- fi
- 
  AC_ARG_ENABLE(3c595,
    [  --enable-3c595          enable 3Com595 driver])
--- 299,302 ----
***************
*** 327,337 ****
  fi
  
- AC_ARG_ENABLE(cs89x0,
-   [  --enable-cs89x0         enable CS89x0 driver])
- if test "x$enable_cs89x0" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_CS89X0=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS cs89x0.o"
- fi
- 
  AC_ARG_ENABLE(davicom,
    [  --enable-davicom        enable Davicom driver])
--- 313,316 ----
***************
*** 341,356 ****
  fi
  
! AC_ARG_ENABLE(depca,
!   [  --enable-depca          enable DEPCA and EtherWORKS driver])
! if test "x$enable_depca" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_DEPCA=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS depca.o"
! fi
! 
! AC_ARG_ENABLE(eepro,
!   [  --enable-eepro          enable Etherexpress Pro/10 driver])
! if test "x$enable_eepro" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EEPRO=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS eepro.o"
  fi
  
--- 320,328 ----
  fi
  
! AC_ARG_ENABLE(e1000,
!   [  --enable-e1000          enable Etherexpress Pro/1000 driver])
! if test "x$enable_e1000" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_E1000=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS e1000.o"
  fi
  
***************
*** 369,414 ****
  fi
  
- AC_ARG_ENABLE(3c507,
-   [  --enable-3c507          enable 3Com507 driver])
- if test "x$enable_3c507" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C507=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c507.o"
- fi
- 
- AC_ARG_ENABLE(exos205,
-   [  --enable-exos205        enable EXOS205 driver])
- if test "x$enable_exos205" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EXOS205=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS exos205.o"
- fi
- 
- AC_ARG_ENABLE(ni5210,
-   [  --enable-ni5210         enable Racal-Interlan NI5210 driver])
- if test "x$enable_ni5210" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5210=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5210.o"
- fi
- 
- AC_ARG_ENABLE(lance,
-   [  --enable-lance          enable Lance PCI PCNet/32 driver])
- if test "x$enable_lance" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_LANCE=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS lance.o"
- fi
- 
- AC_ARG_ENABLE(ne2100,
-   [  --enable-ne2100         enable Novell NE2100 driver])
- if test "x$enable_ne2100" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE2100=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne2100.o"
- fi
- 
- AC_ARG_ENABLE(ni6510,
-   [  --enable-ni6510         enable Racal-Interlan NI6510 driver])
- if test "x$enable_ni6510" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI6510=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni6510.o"
- fi
- 
  AC_ARG_ENABLE(natsemi,
    [  --enable-natsemi        enable NatSemi DP8381x driver])
--- 341,344 ----
***************
*** 418,442 ****
  fi
  
- AC_ARG_ENABLE(ni5010,
-   [  --enable-ni5010         enable Racal-Interlan NI5010 driver])
- if test "x$enable_ni5010" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5010=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5010.o"
- fi
- 
- AC_ARG_ENABLE(3c503,
-   [  --enable-3c503          enable 3Com503 driver])
- if test "x$enable_3c503" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C503=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c503.o"
- fi
- 
- AC_ARG_ENABLE(ne,
-   [  --enable-ne             enable NE1000/2000 ISA driver])
- if test "x$enable_ne" = xyes; then
-   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE=1"
-   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne.o"
- fi
- 
  AC_ARG_ENABLE(ns8390,
    [  --enable-ns8390         enable NE2000 PCI driver])
--- 348,351 ----
***************
*** 446,461 ****
  fi
  
! AC_ARG_ENABLE(wd,
!   [  --enable-wd             enable WD8003/8013, SMC8216/8416 driver])
! if test "x$enable_wd" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_WD=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS wd.o"
! fi
! 
! AC_ARG_ENABLE(otulip,
!   [  --enable-otulip         enable old Tulip driver])
! if test "x$enable_otulip" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_OTULIP=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS otulip.o"
  fi
  
--- 355,363 ----
  fi
  
! AC_ARG_ENABLE(pcnet32,
!   [  --enable-pcnet32             enable AMD Lance/PCI PCNet/32 driver])
! if test "x$enable_pcnet32" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PCNET32=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS pcnet32.o"
  fi
  
***************
*** 474,496 ****
  fi
  
! AC_ARG_ENABLE(sk-g16,
!   [  --enable-sk-g16         enable Schneider and Koch G16 driver])
! if test "x$enable_sk_g16" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SK_G16=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sk_g16.o"
! fi
! 
! AC_ARG_ENABLE(smc9000,
!   [  --enable-smc9000        enable SMC9000 driver])
! if test "x$enable_smc9000" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SMC9000=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS smc9000.o"
! fi
! 
! AC_ARG_ENABLE(tiara,
!   [  --enable-tiara          enable Tiara driver])
! if test "x$enable_tiara" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TIARA=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tiara.o"
  fi
  
--- 376,384 ----
  fi
  
! AC_ARG_ENABLE(tg3,
!   [  --enable-tg3          enable Broadcom Tigon3 driver])
! if test "x$enable_tg3" = xyes; then
!   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TG3=1"
!   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tg3.o"
  fi
  
***************
*** 502,505 ****
--- 390,407 ----
  fi
  
+ AC_ARG_ENABLE(tlan,
+   [  --enable-tlan          enable  TI ThunderLAN driver])
+ if test "x$enable_tlan" = xyes; then
+   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TLAN=1"
+   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tlan.o"
+ fi
+ 
+ AC_ARG_ENABLE(sundance,
+   [  --enable-sundance          enable Sundance ST201 driver])
+ if test "x$enable_sundance" = xyes; then
+   NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SUNDANCE=1"
+   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sundance.o"
+ fi
+ 
  AC_ARG_ENABLE(via-rhine,
    [  --enable-via-rhine      enable Rhine-I/II driver])
***************
*** 522,538 ****
  fi
  
! dnl Extra options.
! AC_ARG_ENABLE(3c503-shmem,
!   [  --enable-3c503-shmem    use 3c503 shared memory mode])
! if test "x$enable_3c503_shmem" = xyes; then
!   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_SHMEM=1"
! fi
! 
! AC_ARG_ENABLE(3c503-aui,
!   [  --enable-3c503-aui      use AUI by default on 3c503 cards])
! if test "x$enable_3c503_aui" = xyes; then
!   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_AUI=1"
! fi
! 
  AC_ARG_ENABLE(compex-rl2000-fix,
    [  --enable-compex-rl2000-fix
--- 424,428 ----
  fi
  
! dnl extra flag for ns8390.c
  AC_ARG_ENABLE(compex-rl2000-fix,
    [  --enable-compex-rl2000-fix
***************
*** 542,550 ****
  fi
  
- AC_ARG_ENABLE(smc9000-scan,
-   [  --enable-smc9000-scan=LIST
-                           probe for SMC9000 I/O addresses using LIST],
-   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DSMC9000_SCAN=$enable_smc9000_scan"])
- 
  AC_ARG_ENABLE(ne-scan,
    [  --enable-ne-scan=LIST   probe for NE base address using LIST],
--- 432,435 ----
***************
*** 558,565 ****
    [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DWD_DEFAULT_MEM=0xCC000"])
  
- AC_ARG_ENABLE(cs-scan,
-   [  --enable-cs-scan=LIST   probe for CS89x0 base address using LIST],
-   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCS_SCAN=$enable_cs_scan"])
- 
  dnl Diskless
  AC_ARG_ENABLE(diskless,
--- 443,446 ----
Only in GRUB_0.94/netboot: 3c509.c
Only in GRUB_0.94/netboot: 3c509.h
diff -rc2P -x CVS GRUB_0.94/netboot/3c595.c GRUB/netboot/3c595.c
*** GRUB_0.94/netboot/3c595.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/3c595.c	2003-11-20 10:35:45.000000000 +0800
***************
*** 21,24 ****
--- 21,25 ----
  *  Copyright (c) 1994 Herb Peyerl <hpeyerl@novatel.ca>
  *
+ * timlegge	08-24-2003	Add Multicast Support
  */
  
***************
*** 31,35 ****
  #include "timer.h"
  
! static unsigned short	eth_nic_base, eth_asic_base;
  static unsigned short	vx_connector, vx_connectors;
  
--- 32,36 ----
  #include "timer.h"
  
! static unsigned short	eth_nic_base;
  static unsigned short	vx_connector, vx_connectors;
  
***************
*** 58,63 ****
  static void vxsetlink(void);
  
- #define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
- 
  /**************************************************************************
  ETH_RESET - Reset adapter
--- 59,62 ----
***************
*** 65,69 ****
  static void t595_reset(struct nic *nic)
  {
! 	int i, j;
  
  	/***********************************************************
--- 64,68 ----
  static void t595_reset(struct nic *nic)
  {
! 	int i;
  
  	/***********************************************************
***************
*** 134,138 ****
  
  	outw(SET_RX_FILTER | FIL_INDIVIDUAL |
! 	    FIL_BRDCST, BASE + VX_COMMAND);
  
  	vxsetlink();
--- 133,137 ----
  
  	outw(SET_RX_FILTER | FIL_INDIVIDUAL |
! 	    FIL_BRDCST|FIL_MULTICAST, BASE + VX_COMMAND);
  
  	vxsetlink();
***************
*** 229,233 ****
  {
  	/* common variables */
- 	unsigned short type = 0;	/* used by EDEBUG */
  	/* variables for 3C595 */
  	short status, cst;
--- 228,231 ----
***************
*** 301,304 ****
--- 299,304 ----
  	while (inw(BASE + VX_STATUS) & S_COMMAND_IN_PROGRESS);
  #ifdef EDEBUG
+ {
+ 	unsigned short type = 0;	/* used by EDEBUG */
  	type = (nic->packet[12]<<8) | nic->packet[13];
  	if(nic->packet[0]+nic->packet[1]+nic->packet[2]+nic->packet[3]+nic->packet[4]+
***************
*** 307,310 ****
--- 307,311 ----
  	else
  		printf(",t=%hX]",type);
+ }
  #endif
  	return 1;
***************
*** 383,389 ****
  vxsetlink(void)
  {       
!     int i, j, k;
      char *reason, *warning;
-     static short prev_flags;
      static char prev_conn = -1;
  
--- 384,389 ----
  vxsetlink(void)
  {       
!     int i, j;
      char *reason, *warning;
      static char prev_conn = -1;
  
***************
*** 439,449 ****
  }
  
! static void t595_disable(struct nic *nic)
  {
!     outw(STOP_TRANSCEIVER, BASE + VX_COMMAND);
!     udelay(8000);
!     GO_WINDOW(4);
!     outw(0, BASE + VX_W4_MEDIA_TYPE);
!     GO_WINDOW(1);
  }
  
--- 439,452 ----
  }
  
! static void t595_disable(struct dev *dev)
  {
! 	struct nic *nic = (struct nic *)dev;
! 	t595_reset(nic);
! 
! 	outw(STOP_TRANSCEIVER, BASE + VX_COMMAND);
! 	udelay(8000);
! 	GO_WINDOW(4);
! 	outw(0, BASE + VX_W4_MEDIA_TYPE);
! 	GO_WINDOW(1);
  }
  
***************
*** 451,460 ****
  ETH_PROBE - Look for an adapter
  ***************************************************************************/
! struct nic *t595_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *pci)
  {
  	int i;
  	unsigned short *p;
  
! 	if (probeaddrs == 0 || probeaddrs[0] == 0)
  		return 0;
  /*	eth_nic_base = probeaddrs[0] & ~3; */
--- 454,464 ----
  ETH_PROBE - Look for an adapter
  ***************************************************************************/
! static int t595_probe(struct dev *dev, struct pci_device *pci)
  {
+ 	struct nic *nic = (struct nic *)dev;
  	int i;
  	unsigned short *p;
  
! 	if (pci->ioaddr == 0)
  		return 0;
  /*	eth_nic_base = probeaddrs[0] & ~3; */
***************
*** 488,499 ****
  
  	t595_reset(nic);
! 	nic->reset = t595_reset;
! 	nic->poll = t595_poll;
  	nic->transmit = t595_transmit;
- 	nic->disable = t595_disable;
  	return nic;
  
  }
  
  /*
   * Local variables:
--- 492,528 ----
  
  	t595_reset(nic);
! 	dev->disable  = t595_disable;
! 	nic->poll     = t595_poll;
  	nic->transmit = t595_transmit;
  	return nic;
  
  }
  
+ static struct pci_id t595_nics[] = {
+ PCI_ROM(0x10b7, 0x5900, "3c590",           "3Com590"),		/* Vortex 10Mbps */
+ PCI_ROM(0x10b7, 0x5950, "3c595",           "3Com595"),		/* Vortex 100baseTx */
+ PCI_ROM(0x10b7, 0x5951, "3c595-1",         "3Com595"),		/* Vortex 100baseT4 */
+ PCI_ROM(0x10b7, 0x5952, "3c595-2",         "3Com595"),		/* Vortex 100base-MII */
+ PCI_ROM(0x10b7, 0x9000, "3c900-tpo",       "3Com900-TPO"),	/* 10 Base TPO */
+ PCI_ROM(0x10b7, 0x9001, "3c900-t4",        "3Com900-Combo"),	/* 10/100 T4 */
+ PCI_ROM(0x10b7, 0x9004, "3c900b-tpo",      "3Com900B-TPO"),	/* 10 Base TPO */
+ PCI_ROM(0x10b7, 0x9005, "3c900b-combo",    "3Com900B-Combo"),	/* 10 Base Combo */
+ PCI_ROM(0x10b7, 0x9006, "3c900b-tpb2",     "3Com900B-2/T"),	/* 10 Base TP and Base2 */
+ PCI_ROM(0x10b7, 0x900a, "3c900b-fl",       "3Com900B-FL"),	/* 10 Base F */
+ PCI_ROM(0x10b7, 0x9800, "3c980-cyclone-1", "3Com980-Cyclone"),	/* Cyclone */
+ PCI_ROM(0x10b7, 0x9805, "3c9805-1",        "3Com9805"),		/* Dual Port Server Cyclone */
+ PCI_ROM(0x10b7, 0x7646, "3csoho100-tx-1",  "3CSOHO100-TX"),	/* Hurricane */
+ PCI_ROM(0x10b7, 0x4500, "3c450-1",         "3Com450 HomePNA Tornado"),
+ };
+ 
+ struct pci_driver t595_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "3C595",
+ 	.probe    = t595_probe,
+ 	.ids      = t595_nics,
+ 	.id_count = sizeof(t595_nics)/sizeof(t595_nics[0]),
+ 	.class    = 0,
+ };
+ 
  /*
   * Local variables:
diff -rc2P -x CVS GRUB_0.94/netboot/3c90x.c GRUB/netboot/3c90x.c
*** GRUB_0.94/netboot/3c90x.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/3c90x.c	2003-11-20 10:35:47.000000000 +0800
***************
*** 2,6 ****
   * 3c90x.c -- This file implements the 3c90x driver for etherboot.  Written
   * by Greg Beeley, Greg.Beeley@LightSys.org.  Modified by Steve Smith,
!  * Steve.Smith@Juno.Com
   *
   * This program Copyright (C) 1999 LightSys Technology Services, Inc.
--- 2,6 ----
   * 3c90x.c -- This file implements the 3c90x driver for etherboot.  Written
   * by Greg Beeley, Greg.Beeley@LightSys.org.  Modified by Steve Smith,
!  * Steve.Smith@Juno.Com. Alignment bug fix Neil Newell (nn@icenoir.net).
   *
   * This program Copyright (C) 1999 LightSys Technology Services, Inc.
***************
*** 32,35 ****
--- 32,38 ----
   *					better error recovery and heavy
   *					network traffic operation
+  * v2.01    5-26-2993 NN Fixed driver alignment issue which
+  *                  caused system lockups if driver structures
+  *                  not 8-byte aligned.
   *
   */
***************
*** 38,42 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  #include "timer.h"
  
--- 41,44 ----
***************
*** 48,54 ****
  #define	XMIT_RETRIES	250
  
- #undef	virt_to_bus
- #define	virt_to_bus(x)	((unsigned long)x)
- 
  /*** Register definitions for the 3c905 ***/
  enum Registers
--- 50,53 ----
***************
*** 226,230 ****
      unsigned int	DataLength;
      }
!     TXD;
  
  /*** RX descriptor ***/
--- 225,229 ----
      unsigned int	DataLength;
      }
!     TXD __attribute__ ((aligned(8))); /* 64-bit aligned for bus mastering */
  
  /*** RX descriptor ***/
***************
*** 236,240 ****
      unsigned int	DataLength;
      }
!     RXD;
  
  /*** Global variables ***/
--- 235,239 ----
      unsigned int	DataLength;
      }
!     RXD __attribute__ ((aligned(8))); /* 64-bit aligned for bus mastering */
  
  /*** Global variables ***/
***************
*** 394,403 ****
   *** image.
   ***/
! static void
! a3c90x_reset(struct nic *nic)
      {
-     int cfg;
- 
  #ifdef	CFG_3C90X_PRESERVE_XCVR
      /** Read the current InternalConfig value. **/
      a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winTxRxOptions3);
--- 393,400 ----
   *** image.
   ***/
! static void a3c90x_reset(void)
      {
  #ifdef	CFG_3C90X_PRESERVE_XCVR
+     int cfg;
      /** Read the current InternalConfig value. **/
      a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winTxRxOptions3);
***************
*** 474,478 ****
   ***/
  static void
! a3c90x_transmit(struct nic *nic, const char *d, unsigned int t,
                  unsigned int s, const char *p)
      {
--- 471,475 ----
   ***/
  static void
! a3c90x_transmit(struct nic *nic __unused, const char *d, unsigned int t,
                  unsigned int s, const char *p)
      {
***************
*** 554,558 ****
  	    {
  	    printf("3C90X: Tx Reclaim Error (%hhX)\n", status);
! 	    a3c90x_reset(NULL);
  	    }
  	else if (status & 0x04)
--- 551,555 ----
  	    {
  	    printf("3C90X: Tx Reclaim Error (%hhX)\n", status);
! 	    a3c90x_reset();
  	    }
  	else if (status & 0x04)
***************
*** 573,582 ****
  	    {
  	    printf("3C90X: Tx Underrun (%hhX)\n", status);
! 	    a3c90x_reset(NULL);
  	    }
  	else if (status & 0x20)
  	    {
  	    printf("3C90X: Tx Jabber (%hhX)\n", status);
! 	    a3c90x_reset(NULL);
  	    }
  	else if ((status & 0x80) != 0x80)
--- 570,579 ----
  	    {
  	    printf("3C90X: Tx Underrun (%hhX)\n", status);
! 	    a3c90x_reset();
  	    }
  	else if (status & 0x20)
  	    {
  	    printf("3C90X: Tx Jabber (%hhX)\n", status);
! 	    a3c90x_reset();
  	    }
  	else if ((status & 0x80) != 0x80)
***************
*** 584,588 ****
  	    printf("3C90X: Internal Error - Incomplete Transmission (%hhX)\n",
  	           status);
! 	    a3c90x_reset(NULL);
  	    }
  	}
--- 581,585 ----
  	    printf("3C90X: Internal Error - Incomplete Transmission (%hhX)\n",
  	           status);
! 	    a3c90x_reset();
  	    }
  	}
***************
*** 664,673 ****
   ***/
  static void
! a3c90x_disable(struct nic *nic)
!     {
  	/* Disable the receiver and transmitter. */
  	outw(cmdRxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
  	outw(cmdTxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
!     }
  
  
--- 661,672 ----
   ***/
  static void
! a3c90x_disable(struct dev *dev __unused)
! {
! 	/* reset and disable merge */
! 	a3c90x_reset();
  	/* Disable the receiver and transmitter. */
  	outw(cmdRxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
  	outw(cmdTxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
! }
  
  
***************
*** 677,695 ****
   *** card.  We just have to init it here.
   ***/
! struct nic*
! a3c90x_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *pci)
!     {
      int i, c;
      unsigned short eeprom[0x21];
      unsigned int cfg;
      unsigned int mopt;
      unsigned short linktype;
  
!     if (probeaddrs == 0 || probeaddrs[0] == 0)
            return 0;
  
      adjust_pci_device(pci);
  
!     INF_3C90X.IOAddr = probeaddrs[0] & ~3;
      INF_3C90X.CurrentWindow = 255;
      switch (a3c90x_internal_ReadEeprom(INF_3C90X.IOAddr, 0x03))
--- 676,696 ----
   *** card.  We just have to init it here.
   ***/
! static int a3c90x_probe(struct dev *dev, struct pci_device *pci)
! {
!     struct nic *nic = (struct nic *)dev;
      int i, c;
      unsigned short eeprom[0x21];
      unsigned int cfg;
      unsigned int mopt;
+     unsigned int mstat;
      unsigned short linktype;
+ #define	HWADDR_OFFSET	10
  
!     if (pci->ioaddr == 0)
            return 0;
  
      adjust_pci_device(pci);
  
!     INF_3C90X.IOAddr = pci->ioaddr & ~3;
      INF_3C90X.CurrentWindow = 255;
      switch (a3c90x_internal_ReadEeprom(INF_3C90X.IOAddr, 0x03))
***************
*** 757,777 ****
             "Portions Copyright 1999 Steve Smith\n");
      printf("Provided with ABSOLUTELY NO WARRANTY.\n");
      printf("-------------------------------------------------------"
             "------------------------\n");
  
      /** Retrieve the Hardware address and print it on the screen. **/
!     INF_3C90X.HWAddr[0] = eeprom[0]>>8;
!     INF_3C90X.HWAddr[1] = eeprom[0]&0xFF;
!     INF_3C90X.HWAddr[2] = eeprom[1]>>8;
!     INF_3C90X.HWAddr[3] = eeprom[1]&0xFF;
!     INF_3C90X.HWAddr[4] = eeprom[2]>>8;
!     INF_3C90X.HWAddr[5] = eeprom[2]&0xFF;
      printf("MAC Address = %!\n", INF_3C90X.HWAddr);
  
      /** Program the MAC address into the station address registers **/
      a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winAddressing2);
!     outw(htons(eeprom[0]), INF_3C90X.IOAddr + regStationAddress_2_3w);
!     outw(htons(eeprom[1]), INF_3C90X.IOAddr + regStationAddress_2_3w+2);
!     outw(htons(eeprom[2]), INF_3C90X.IOAddr + regStationAddress_2_3w+4);
      outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+0);
      outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+2);
--- 758,793 ----
             "Portions Copyright 1999 Steve Smith\n");
      printf("Provided with ABSOLUTELY NO WARRANTY.\n");
+ #ifdef	CFG_3C90X_BOOTROM_FIX
+     if (INF_3C90X.isBrev)
+         {
+         printf("NOTE: 3c905b bootrom fix enabled; has side "
+ 	   "effects.  See 3c90x.txt for info.\n");
+ 	}
+ #endif
      printf("-------------------------------------------------------"
             "------------------------\n");
  
      /** Retrieve the Hardware address and print it on the screen. **/
!     INF_3C90X.HWAddr[0] = eeprom[HWADDR_OFFSET + 0]>>8;
!     INF_3C90X.HWAddr[1] = eeprom[HWADDR_OFFSET + 0]&0xFF;
!     INF_3C90X.HWAddr[2] = eeprom[HWADDR_OFFSET + 1]>>8;
!     INF_3C90X.HWAddr[3] = eeprom[HWADDR_OFFSET + 1]&0xFF;
!     INF_3C90X.HWAddr[4] = eeprom[HWADDR_OFFSET + 2]>>8;
!     INF_3C90X.HWAddr[5] = eeprom[HWADDR_OFFSET + 2]&0xFF;
      printf("MAC Address = %!\n", INF_3C90X.HWAddr);
  
+     /* Test if the link is good, if not continue */
+     a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winDiagnostics4);
+     mstat = inw(INF_3C90X.IOAddr + regMediaStatus_4_w);
+     if((mstat & (1<<11)) == 0) {
+ 	printf("Valid link not established\n");
+ 	return 0;
+     }
+ 
      /** Program the MAC address into the station address registers **/
      a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winAddressing2);
!     outw(htons(eeprom[HWADDR_OFFSET + 0]), INF_3C90X.IOAddr + regStationAddress_2_3w);
!     outw(htons(eeprom[HWADDR_OFFSET + 1]), INF_3C90X.IOAddr + regStationAddress_2_3w+2);
!     outw(htons(eeprom[HWADDR_OFFSET + 2]), INF_3C90X.IOAddr + regStationAddress_2_3w+4);
      outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+0);
      outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+2);
***************
*** 780,784 ****
      /** Fill in our entry in the etherboot arp table **/
      for(i=0;i<ETH_ALEN;i++)
! 	nic->node_addr[i] = (eeprom[i/2] >> (8*((i&1)^1))) & 0xff;
  
      /** Read the media options register, print a message and set default
--- 796,800 ----
      /** Fill in our entry in the etherboot arp table **/
      for(i=0;i<ETH_ALEN;i++)
! 	nic->node_addr[i] = (eeprom[HWADDR_OFFSET + i/2] >> (8*((i&1)^1))) & 0xff;
  
      /** Read the media options register, print a message and set default
***************
*** 904,909 ****
  	;
  
!     /** Set the RX filter = receive only individual pkts & bcast. **/
!     a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdSetRxFilter, 0x01 + 0x04);
      a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdRxEnable, 0);
  
--- 920,925 ----
  	;
  
!     /** Set the RX filter = receive only individual pkts & multicast & bcast. **/
!     a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdSetRxFilter, 0x01 + 0x02 + 0x04);
      a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdRxEnable, 0);
  
***************
*** 919,929 ****
  
      /** Set our exported functions **/
!     nic->reset    = a3c90x_reset;
      nic->poll     = a3c90x_poll;
      nic->transmit = a3c90x_transmit;
-     nic->disable  = a3c90x_disable;
  
!     return nic;
!     }
  
  
--- 935,975 ----
  
      /** Set our exported functions **/
!     dev->disable  = a3c90x_disable;
      nic->poll     = a3c90x_poll;
      nic->transmit = a3c90x_transmit;
  
!     return 1;
! }
  
  
+ static struct pci_id a3c90x_nics[] = {
+ /* Original 90x revisions: */
+ PCI_ROM(0x10b7, 0x9000, "3c905-tpo",     "3Com900-TPO"),	/* 10 Base TPO */
+ PCI_ROM(0x10b7, 0x9001, "3c905-t4",      "3Com900-Combo"),	/* 10/100 T4 */
+ PCI_ROM(0x10b7, 0x9050, "3c905-tpo100",  "3Com905-TX"),		/* 100 Base TX / 10/100 TPO */
+ PCI_ROM(0x10b7, 0x9051, "3c905-combo",   "3Com905-T4"),		/* 100 Base T4 / 10 Base Combo */
+ /* Newer 90xB revisions: */
+ PCI_ROM(0x10b7, 0x9004, "3c905b-tpo",    "3Com900B-TPO"),	/* 10 Base TPO */
+ PCI_ROM(0x10b7, 0x9005, "3c905b-combo",  "3Com900B-Combo"),	/* 10 Base Combo */
+ PCI_ROM(0x10b7, 0x9006, "3c905b-tpb2",   "3Com900B-2/T"),	/* 10 Base TP and Base2 */
+ PCI_ROM(0x10b7, 0x900a, "3c905b-fl",     "3Com900B-FL"),	/* 10 Base FL */
+ PCI_ROM(0x10b7, 0x9055, "3c905b-tpo100", "3Com905B-TX"),	/* 10/100 TPO */
+ PCI_ROM(0x10b7, 0x9056, "3c905b-t4",     "3Com905B-T4"),	/* 10/100 T4 */
+ PCI_ROM(0x10b7, 0x9058, "3c905b-9058",   "3Com905B-9058"),	/* Cyclone 10/100/BNC */
+ PCI_ROM(0x10b7, 0x905a, "3c905b-fx",     "3Com905B-FL"),	/* 100 Base FX / 10 Base FX */
+ /* Newer 90xC revision: */
+ PCI_ROM(0x10b7, 0x9200, "3c905c-tpo",    "3Com905C-TXM"),	/* 10/100 TPO (3C905C-TXM) */
+ PCI_ROM(0x10b7, 0x9800, "3c980",         "3Com980-Cyclone"),	/* Cyclone */
+ PCI_ROM(0x10b7, 0x9805, "3c9805",        "3Com9805"),		/* Dual Port Server Cyclone */
+ PCI_ROM(0x10b7, 0x7646, "3csoho100-tx",  "3CSOHO100-TX"),	/* Hurricane */
+ PCI_ROM(0x10b7, 0x4500, "3c450",         "3Com450 HomePNA Tornado"),
+ };
+ 
+ struct pci_driver a3c90x_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "3C90X",
+ 	.probe    = a3c90x_probe,
+ 	.ids      = a3c90x_nics,
+ 	.id_count = sizeof(a3c90x_nics)/sizeof(a3c90x_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/big_bswap.h GRUB/netboot/big_bswap.h
*** GRUB_0.94/netboot/big_bswap.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/big_bswap.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,17 ----
+ #ifndef ETHERBOOT_BIG_BSWAP_H
+ #define ETHERBOOT_BIG_BSWAP_H
+ 
+ #define ntohl(x) 	(x)
+ #define htonl(x) 	(x)
+ #define ntohs(x) 	(x)
+ #define htons(x) 	(x)
+ #define cpu_to_le32(x)	__bswap_32(x)
+ #define cpu_to_le16(x)	__bswap_16(x)
+ #define cpu_to_be32(x)	(x)
+ #define cpu_to_be16(x)	(x)
+ #define le32_to_cpu(x)	__bswap_32(x)
+ #define le16_to_cpu(x)	__bswap_16(x)
+ #define be32_to_cpu(x)	(x)
+ #define be16_to_cpu(x)	(x)
+ 
+ #endif /* ETHERBOOT_BIG_BSWAP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/bootp.h GRUB/netboot/bootp.h
*** GRUB_0.94/netboot/bootp.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/bootp.h	2003-11-11 20:43:02.000000000 +0800
***************
*** 0 ****
--- 1,182 ----
+ #ifndef	_BOOTP_H
+ #define	_BOOTP_H
+ 
+ #include "if_ether.h"
+ #include "ip.h"
+ #include "udp.h"
+ 
+ #ifndef	MAX_BOOTP_RETRIES
+ #define MAX_BOOTP_RETRIES	20
+ #endif
+ 
+ #ifdef	ALTERNATE_DHCP_PORTS_1067_1068
+ #undef	NON_STANDARD_BOOTP_SERVER
+ #define	NON_STANDARD_BOOTP_SERVER	1067
+ #undef	NON_STANDARD_BOOTP_CLIENT
+ #define	NON_STANDARD_BOOTP_CLIENT	1068
+ #endif
+ 
+ #ifdef	NON_STANDARD_BOOTP_SERVER
+ #define	BOOTP_SERVER	NON_STANDARD_BOOTP_SERVER
+ #else
+ #define BOOTP_SERVER	67
+ #endif
+ #ifdef	NON_STANDARD_BOOTP_CLIENT
+ #define	BOOTP_CLIENT	NON_STANDARD_BOOTP_CLIENT
+ #else
+ #define BOOTP_CLIENT	68
+ #endif
+ 
+ #define BOOTP_REQUEST	1
+ #define BOOTP_REPLY	2
+ 
+ #define TAG_LEN(p)		(*((p)+1))
+ #define RFC1533_COOKIE		99, 130, 83, 99
+ #define RFC1533_PAD		0
+ #define RFC1533_NETMASK		1
+ #define RFC1533_TIMEOFFSET	2
+ #define RFC1533_GATEWAY		3
+ #define RFC1533_TIMESERVER	4
+ #define RFC1533_IEN116NS	5
+ #define RFC1533_DNS		6
+ #define RFC1533_LOGSERVER	7
+ #define RFC1533_COOKIESERVER	8
+ #define RFC1533_LPRSERVER	9
+ #define RFC1533_IMPRESSSERVER	10
+ #define RFC1533_RESOURCESERVER	11
+ #define RFC1533_HOSTNAME	12
+ #define RFC1533_BOOTFILESIZE	13
+ #define RFC1533_MERITDUMPFILE	14
+ #define RFC1533_DOMAINNAME	15
+ #define RFC1533_SWAPSERVER	16
+ #define RFC1533_ROOTPATH	17
+ #define RFC1533_EXTENSIONPATH	18
+ #define RFC1533_IPFORWARDING	19
+ #define RFC1533_IPSOURCEROUTING	20
+ #define RFC1533_IPPOLICYFILTER	21
+ #define RFC1533_IPMAXREASSEMBLY	22
+ #define RFC1533_IPTTL		23
+ #define RFC1533_IPMTU		24
+ #define RFC1533_IPMTUPLATEAU	25
+ #define RFC1533_INTMTU		26
+ #define RFC1533_INTLOCALSUBNETS	27
+ #define RFC1533_INTBROADCAST	28
+ #define RFC1533_INTICMPDISCOVER	29
+ #define RFC1533_INTICMPRESPOND	30
+ #define RFC1533_INTROUTEDISCOVER 31
+ #define RFC1533_INTROUTESOLICIT	32
+ #define RFC1533_INTSTATICROUTES	33
+ #define RFC1533_LLTRAILERENCAP	34
+ #define RFC1533_LLARPCACHETMO	35
+ #define RFC1533_LLETHERNETENCAP	36
+ #define RFC1533_TCPTTL		37
+ #define RFC1533_TCPKEEPALIVETMO	38
+ #define RFC1533_TCPKEEPALIVEGB	39
+ #define RFC1533_NISDOMAIN	40
+ #define RFC1533_NISSERVER	41
+ #define RFC1533_NTPSERVER	42
+ #define RFC1533_VENDOR		43
+ #define RFC1533_NBNS		44
+ #define RFC1533_NBDD		45
+ #define RFC1533_NBNT		46
+ #define RFC1533_NBSCOPE		47
+ #define RFC1533_XFS		48
+ #define RFC1533_XDM		49
+ #ifndef	NO_DHCP_SUPPORT
+ #define RFC2132_REQ_ADDR	50
+ #define RFC2132_MSG_TYPE	53
+ #define RFC2132_SRV_ID		54
+ #define RFC2132_PARAM_LIST	55
+ #define RFC2132_MAX_SIZE	57
+ #define	RFC2132_VENDOR_CLASS_ID	60
+ 
+ #define DHCPDISCOVER		1
+ #define DHCPOFFER		2
+ #define DHCPREQUEST		3
+ #define DHCPACK			5
+ #endif	/* NO_DHCP_SUPPORT */
+ 
+ #define RFC1533_VENDOR_MAJOR	0
+ #define RFC1533_VENDOR_MINOR	0
+ 
+ #define RFC1533_VENDOR_MAGIC	128
+ #define RFC1533_VENDOR_ADDPARM	129
+ #define	RFC1533_VENDOR_ETHDEV	130
+ #ifdef	IMAGE_FREEBSD
+ #define RFC1533_VENDOR_HOWTO    132
+ #define RFC1533_VENDOR_KERNEL_ENV    133
+ #endif
+ #define RFC1533_VENDOR_ETHERBOOT_ENCAP 150
+ #define RFC1533_VENDOR_MNUOPTS	160
+ #define RFC1533_VENDOR_NIC_DEV_ID 175
+ #define RFC1533_VENDOR_SELECTION 176
+ #define RFC1533_VENDOR_ARCH     177
+ #define RFC1533_VENDOR_MOTD	184
+ #define RFC1533_VENDOR_NUMOFMOTD 8
+ #define RFC1533_VENDOR_IMG	192
+ #define RFC1533_VENDOR_NUMOFIMG	16
+ 
+ #define RFC1533_VENDOR_CONFIGFILE 150
+ 
+ #define RFC1533_END		255
+ 
+ #define BOOTP_VENDOR_LEN	64
+ 
+ #define DHCP_OPT_LEN		312
+ 
+ /* Format of a bootp packet */
+ struct bootp_t {
+ 	uint8_t  bp_op;
+ 	uint8_t  bp_htype;
+ 	uint8_t  bp_hlen;
+ 	uint8_t  bp_hops;
+ 	uint32_t bp_xid;
+ 	uint16_t bp_secs;
+ 	uint16_t unused;
+ 	in_addr bp_ciaddr;
+ 	in_addr bp_yiaddr;
+ 	in_addr bp_siaddr;
+ 	in_addr bp_giaddr;
+ 	uint8_t  bp_hwaddr[16];
+ 	uint8_t  bp_sname[64];
+ 	char     bp_file[128];
+ 	uint8_t  bp_vend[BOOTP_VENDOR_LEN];
+ };
+ 
+ struct dhcp_t {
+ 	uint8_t  bp_op;
+ 	uint8_t  bp_htype;
+ 	uint8_t  bp_hlen;
+ 	uint8_t  bp_hops;
+ 	uint32_t bp_xid;
+ 	uint16_t bp_secs;
+ 	uint16_t bp_flag;
+ 	in_addr bp_ciaddr;
+ 	in_addr bp_yiaddr;
+ 	in_addr bp_siaddr;
+ 	in_addr bp_giaddr;
+ 	uint8_t  bp_hwaddr[16];
+ 	uint8_t  bp_sname[64];
+ 	char     bp_file[128];
+ 	uint8_t  bp_vend[DHCP_OPT_LEN];
+ };
+ 
+ /* Format of a bootp IP packet */
+ struct bootpip_t
+ {
+ 	struct iphdr ip;
+ 	struct udphdr udp;
+ 	struct bootp_t bp;
+ };
+ struct dhcpip_t
+ {
+ 	struct iphdr ip;
+ 	struct udphdr udp;
+ 	struct dhcp_t bp;
+ };
+ 
+ #define MAX_RFC1533_VENDLEN (ETH_MAX_MTU - sizeof(struct bootpip_t) + BOOTP_VENDOR_LEN)
+ 
+ #define BOOTP_DATA_ADDR (&bootp_data)
+ 
+ #endif	/* _BOOTP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/byteswap.h GRUB/netboot/byteswap.h
*** GRUB_0.94/netboot/byteswap.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/byteswap.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,20 ----
+ #ifndef ETHERBOOT_BYTESWAP_H
+ #define ETHERBOOT_BYTESWAP_H
+ 
+ #include "endian.h"
+ #include "i386_byteswap.h"
+ 
+ #if __BYTE_ORDER == __LITTLE_ENDIAN
+ #include "little_bswap.h"
+ #endif
+ #if __BYTE_ORDER == __BIG_ENDIAN
+ #include "big_bswap.h"
+ #endif
+ 
+ /* Make routines available to all */
+ #define swap32(x)	__bswap_32(x)
+ #define swap16(x)	__bswap_16(x)
+ #define bswap_32(x)	__bswap_32(x)
+ #define bswap_16(x)	__bswap_16(x)
+ 	
+ #endif /* ETHERBOOT_BYTESWAP_H */
Only in GRUB_0.94/netboot: cards.h
diff -rc2P -x CVS GRUB_0.94/netboot/config.c GRUB/netboot/config.c
*** GRUB_0.94/netboot/config.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/config.c	2003-11-12 21:03:29.000000000 +0800
***************
*** 1,24 ****
  /*
-  *  GRUB  --  GRand Unified Bootloader
-  *  Copyright (C) 2001,2002  Free Software Foundation, Inc.
-  *
-  *  This program is free software; you can redistribute it and/or modify
-  *  it under the terms of the GNU General Public License as published by
-  *  the Free Software Foundation; either version 2 of the License, or
-  *  (at your option) any later version.
-  *
-  *  This program is distributed in the hope that it will be useful,
-  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  *  GNU General Public License for more details.
-  *
-  *  You should have received a copy of the GNU General Public License
-  *  along with this program; if not, write to the Free Software
-  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-  */
- 
- /* Based on "src/config.c" in etherboot-5.0.5.  */
- 
- /*
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU General Public License as
--- 1,3 ----
***************
*** 27,598 ****
   */
  
! #define GRUB	1
! #include <etherboot.h>
! #include <nic.h>
  
! #undef	INCLUDE_PCI
! #if	defined(INCLUDE_NS8390) || defined(INCLUDE_EEPRO100) || defined(INCLUDE_LANCE) || defined(INCLUDE_EPIC100) || defined(INCLUDE_TULIP) || defined(INCLUDE_OTULIP) || defined(INCLUDE_3C90X) ||  defined(INCLUDE_3C595) || defined(INCLUDE_RTL8139) || defined(INCLUDE_VIA_RHINE) || defined(INCLUDE_W89C840) || defined(INCLUDE_DAVICOM) || defined(INCLUDE_SIS900) || defined(INCLUDE_NATSEMI) || defined(INCLUDE_TLAN)
! 	/* || others later */
! # define INCLUDE_PCI
! # include <pci.h>
! static unsigned short pci_ioaddrs[16];
! 
! static struct pci_device pci_nic_list[] =
  {
! #ifdef	INCLUDE_NS8390
!   { PCI_VENDOR_ID_REALTEK,	PCI_DEVICE_ID_REALTEK_8029,
!     "Realtek 8029", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C940,
!     "Winbond NE2000-PCI", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_COMPEX,	PCI_DEVICE_ID_COMPEX_RL2000,
!     "Compex ReadyLink 2000", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_KTI,		PCI_DEVICE_ID_KTI_ET32P2,
!     "KTI ET32P2", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_NETVIN,	PCI_DEVICE_ID_NETVIN_NV5000SC,
!     "NetVin NV5000SC", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_HOLTEK,	PCI_DEVICE_ID_HOLTEK_HT80232,
!     "Holtek HT80232", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_3C90X
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900TPO,
!     "3Com900-TPO", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900COMBO,
!     "3Com900-Combo", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905TX,
!     "3Com905-TX", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905T4,
!     "3Com905-T4", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9004,
!     "3Com900B-TPO", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9005,
!     "3Com900B-Combo", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9006,
!     "3Com900B-2/T", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x900A,
!     "3Com900B-FL", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905B_TX,
!     "3Com905B-TX", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9056,
!     "3Com905B-T4", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x905A,
!     "3Com905B-FL", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905C_TXM,
!     "3Com905C-TXM", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9800,
!     "3Com980-Cyclone", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9805,
!     "3Com9805", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x7646,
!     "3CSOHO100-TX", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_3C595
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C590,
!     "3Com590", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595,
!     "3Com595", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595_1,
!     "3Com595", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595_2,
!     "3Com595", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900TPO,
!     "3Com900-TPO", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900COMBO,
!     "3Com900-Combo", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9004,
!     "3Com900B-TPO", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9005,
!     "3Com900B-Combo", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9006,
!     "3Com900B-2/T", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x900A,
!     "3Com900B-FL", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9800,
!     "3Com980-Cyclone", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x9805,
!     "3Com9805", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_3COM,		0x7646,
!     "3CSOHO100-TX", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_EEPRO100
!   { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82557,
!     "Intel EtherExpressPro100", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82559ER,
!     "Intel EtherExpressPro100 82559ER", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_ID1029,
!     "Intel EtherExpressPro100 ID1029", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_ID1030,
!     "Intel Corporation 82559 InBusiness 10/100", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82562,
!     "Intel EtherExpressPro100 82562EM", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_EPIC100
!   { PCI_VENDOR_ID_SMC,		PCI_DEVICE_ID_SMC_EPIC100,
!     "SMC EtherPowerII", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_LANCE
!   { PCI_VENDOR_ID_AMD,		PCI_DEVICE_ID_AMD_LANCE,
!     "AMD Lance/PCI", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_AMD_HOMEPNA,	PCI_DEVICE_ID_AMD_HOMEPNA,
!     "AMD Lance/HomePNA", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_RTL8139
!   { PCI_VENDOR_ID_REALTEK,	PCI_DEVICE_ID_REALTEK_8139,
!     "Realtek 8139", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DLINK,	PCI_DEVICE_ID_DFE530TXP,
!     "DFE530TX+/DFE538TX", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_SMC_1211,	PCI_DEVICE_ID_SMC_1211,
!     "SMC EZ10/100", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_OTULIP
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP,
!     "Digital Tulip", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_FAST,
!     "Digital Tulip Fast", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_PLUS,
!     "Digital Tulip+", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_21142,
!     "Digital Tulip 21142", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_TULIP
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP,
!     "Digital Tulip", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_FAST,
!     "Digital Tulip Fast", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_PLUS,
!     "Digital Tulip+", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_21142,
!     "Digital Tulip 21142", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_MACRONIX,	PCI_DEVICE_ID_MX987x5,
!     "Macronix MX987x5", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_LINKSYS,	PCI_DEVICE_ID_LC82C115,
!     "LinkSys LNE100TX", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_LINKSYS,	PCI_DEVICE_ID_DEC_TULIP,
!     "Netgear FA310TX", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9102,
!     "Davicom 9102", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9009,
!     "Davicom 9009", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_ADMTEK,	PCI_DEVICE_ID_ADMTEK_0985,
!     "ADMtek Centaur-P", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_ADMTEK,	0x0981,
!     "ADMtek AN981 Comet", 0, 0, 0, 0},
!   { 0x125B,			0x1400,
!     "ASIX AX88140", 0, 0, 0, 0 },
!   { 0x11F6,			0x9881,
!     "Compex RL100-TX", 0, 0, 0, 0 },
! #endif
! #ifdef	INCLUDE_DAVICOM
!   { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9102,
!     "Davicom 9102", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9009,
!     "Davicom 9009", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_VIA_RHINE
!   { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_VT6102,
!     "VIA 6102", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_RHINE_I,
!     "VIA 3043", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_86C100A,
!     "VIA 86C100A", 0, 0, 0, 0},
! #endif
! #ifdef	INCLUDE_W89C840
!   { PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C840,
!     "Winbond W89C840F", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_COMPEX,	PCI_DEVICE_ID_COMPEX_RL100ATX,
!     "Compex RL100ATX", 0, 0, 0, 0},
! #endif
! #ifdef INCLUDE_SIS900
!   { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS900,
!     "SIS900", 0, 0, 0, 0},
!   { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS7016,
!     "SIS7016", 0, 0, 0, 0},
! #endif
!   
! #ifdef INCLUDE_NATSEMI
!   { PCI_VENDOR_ID_NS,	     	PCI_DEVICE_ID_DP83815,
!     "DP83815", 0, 0, 0, 0},
! #endif
!   
! #ifdef INCLUDE_TLAN
!   { PCI_VENDOR_ID_OLICOM,	PCI_DEVICE_ID_OLICOM_OC2326,
!     "OC2326", 0, 0, 0, 0},
  #endif
  
!   /* other PCI NICs go here */
!   {0, 0, NULL, 0, 0, 0, 0}
! };
! #endif	/* INCLUDE_*PCI */
! 
! #include <cards.h>
! 
! #ifdef INCLUDE_PCI
! struct pci_dispatch_table
  {
-   unsigned short vendor;
-   unsigned short dev_id;
-   struct nic *(*eth_probe) (struct nic *, unsigned short *,
- 			    struct pci_device *);
- };
- 
- static struct pci_dispatch_table PCI_NIC[] =
- {
- # ifdef INCLUDE_NS8390
-   { PCI_VENDOR_ID_REALTEK,  PCI_DEVICE_ID_REALTEK_8029,    nepci_probe },
-   { PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C940, nepci_probe },
-   { PCI_VENDOR_ID_COMPEX,   PCI_DEVICE_ID_COMPEX_RL2000,   nepci_probe },
-   { PCI_VENDOR_ID_KTI,      PCI_DEVICE_ID_KTI_ET32P2,      nepci_probe },
-   { PCI_VENDOR_ID_NETVIN,   PCI_DEVICE_ID_NETVIN_NV5000SC, nepci_probe },
-   { PCI_VENDOR_ID_HOLTEK,   PCI_DEVICE_ID_HOLTEK_HT80232,  nepci_probe },
- # endif /* INCLUDE_NS8390 */
- # ifdef INCLUDE_3C90X
-   { PCI_VENDOR_ID_3COM,	    PCI_DEVICE_ID_3COM_3C900TPO,   a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900COMBO, a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905TX,    a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905T4,    a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x9004,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x9005,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x9006,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x900A,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905B_TX,  a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x9056,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x905A,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905C_TXM, a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x9800,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x9805,                        a3c90x_probe },
-   { PCI_VENDOR_ID_3COM,     0x7646,                        a3c90x_probe },
- # endif /* INCLUDE_3C90X */
- # ifdef	INCLUDE_3C595
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C590,      t595_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595,      t595_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595_1,    t595_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595_2,    t595_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900TPO,   t595_probe },
-   { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900COMBO, t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x9004,                        t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x9005,                        t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x9006,                        t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x900A,                        t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x9800,                        t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x9805,                        t595_probe },
-   { PCI_VENDOR_ID_3COM,     0x7646,                        t595_probe },
- # endif /* INCLUDE_3C595 */
- # ifdef	INCLUDE_EEPRO100
-   { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82557,     eepro100_probe },
-   { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82559ER,   eepro100_probe },
-   { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ID1029,    eepro100_probe },
-   { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ID1030,    eepro100_probe },
-   { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82562,     eepro100_probe },
- # endif /* INCLUDE_EEPRO100 */
- # ifdef	INCLUDE_EPIC100
-   { PCI_VENDOR_ID_SMC,      PCI_DEVICE_ID_SMC_EPIC100,     epic100_probe },
- # endif /* INCLUDE_EPIC100 */
- # ifdef	INCLUDE_LANCE
-   { PCI_VENDOR_ID_AMD,      PCI_DEVICE_ID_AMD_LANCE,       lancepci_probe },
-   { PCI_VENDOR_ID_AMD_HOMEPNA, PCI_DEVICE_ID_AMD_HOMEPNA,  lancepci_probe },
- # endif /* INCLUDE_LANCE */
- # ifdef	INCLUDE_RTL8139
-   { PCI_VENDOR_ID_REALTEK,  PCI_DEVICE_ID_REALTEK_8139,    rtl8139_probe },
-   { PCI_VENDOR_ID_DLINK,    PCI_DEVICE_ID_DFE530TXP,       rtl8139_probe },
-   { PCI_VENDOR_ID_SMC_1211, PCI_DEVICE_ID_SMC_1211,        rtl8139_probe },
- # endif /* INCLUDE_RTL8139 */
- # ifdef	INCLUDE_OTULIP
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP,       otulip_probe },
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_FAST,  otulip_probe },
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_PLUS,  otulip_probe },
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_21142,       otulip_probe },
- # endif /* INCLUDE_OTULIP */
- # ifdef	INCLUDE_TULIP
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP,       tulip_probe },
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_FAST,  tulip_probe },
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_PLUS,  tulip_probe },
-   { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_21142,       tulip_probe },
-   { PCI_VENDOR_ID_MACRONIX, PCI_DEVICE_ID_MX987x5,         tulip_probe },
-   { PCI_VENDOR_ID_LINKSYS,  PCI_DEVICE_ID_LC82C115,        tulip_probe },
-   { PCI_VENDOR_ID_LINKSYS,  PCI_DEVICE_ID_DEC_TULIP,       tulip_probe },
-   { PCI_VENDOR_ID_DAVICOM,  PCI_DEVICE_ID_DM9102,          tulip_probe },
-   { PCI_VENDOR_ID_DAVICOM,  PCI_DEVICE_ID_DM9009,          tulip_probe },
-   { PCI_VENDOR_ID_ADMTEK,   PCI_DEVICE_ID_ADMTEK_0985,     tulip_probe },
-   { PCI_VENDOR_ID_ADMTEK,   0x0981,                        tulip_probe },
-   { 0x125B,                 0x1400,                        tulip_probe },
-   { 0x11F6,                 0x9881,                        tulip_probe },
- # endif /* INCLUDE_TULIP */
- # ifdef INCLUDE_DAVICOM
-   { PCI_VENDOR_ID_DAVICOM,   PCI_DEVICE_ID_DM9102,           davicom_probe },
-   { PCI_VENDOR_ID_DAVICOM,   PCI_DEVICE_ID_DM9009,           davicom_probe },
- # endif /* INCLUDE_DAVICOM */
- # ifdef	INCLUDE_VIA_RHINE
-   { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_VT6102,      rhine_probe },
-   { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_RHINE_I,     rhine_probe },
-   { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_86C100A,     rhine_probe },
- # endif /* INCLUDE_VIA_RHINE */
- # ifdef INCLUDE_W89C840
-   { PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C840, w89c840_probe },
-   { PCI_VENDOR_ID_COMPEX,   PCI_DEVICE_ID_COMPEX_RL100ATX, w89c840_probe },
- # endif /* INCLUDE_W89C840 */
- # ifdef INCLUDE_SIS900
-   { PCI_VENDOR_ID_SIS,      PCI_DEVICE_ID_SIS900,          sis900_probe },
-   { PCI_VENDOR_ID_SIS,      PCI_DEVICE_ID_SIS7016,         sis900_probe },
- # endif /* INCLUDE_SIS900 */
- # ifdef INCLUDE_NATSEMI
-   { PCI_VENDOR_ID_NS,       PCI_DEVICE_ID_DP83815,         natsemi_probe },
- # endif /* INCLUDE_NATSEMI */
- # ifdef INCLUDE_TLAN
-   { PCI_VENDOR_ID_OLICOM,   PCI_DEVICE_ID_OLICOM_OC2326,   tlan_probe },
- # endif /* INCLUDE_TLAN */
-   { 0,                      0,                             0 }
- };
- #endif /* GRUB && INCLUDE_PCI */
- 
- struct dispatch_table
- {
-   const char	*nic_name;
- #ifdef	INCLUDE_PCI
-   struct nic	*(*eth_probe) (struct nic *, unsigned short *,
- 			       struct pci_device *);
- #else
-   struct nic	*(*eth_probe) (struct nic *, unsigned short *);
- #endif	/* INCLUDE_PCI */
-   unsigned short	*probe_ioaddrs;		/* for probe overrides */
- };
- 
  /*
!  *	NIC probing is in order of appearance in this table.
   *	If for some reason you want to change the order,
!  *	just rearrange the entries (bracketed by the #ifdef/#endif)
   */
! static struct dispatch_table	NIC[] =
! {
! #ifdef	INCLUDE_RTL8139
!   { "RTL8139", rtl8139_probe, pci_ioaddrs },
! #endif
! #ifdef INCLUDE_SIS900
!   { "SIS900", sis900_probe, pci_ioaddrs },	
! #endif
! #ifdef INCLUDE_NATSEMI
!   { "NATSEMI", natsemi_probe, pci_ioaddrs },	
! #endif
! #ifdef	INCLUDE_WD
!   { "WD", wd_probe, 0 },
! #endif
! #ifdef	INCLUDE_3C503
!   { "3C503", t503_probe, 0 },
! #endif
! #ifdef	INCLUDE_NE
!   { "NE*000", ne_probe, 0 },
! #endif
! #ifdef	INCLUDE_3C509
!   { "3C5x9", t509_probe, 0 },
! #endif
! #ifdef	INCLUDE_3C529
!   { "3C5x9", t529_probe, 0 },
! #endif
! #ifdef	INCLUDE_3C595
!   { "3C595", t595_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_3C90X
!   { "3C90X", a3c90x_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_EEPRO
!   { "EEPRO", eepro_probe, 0 },
! #endif
! #ifdef	INCLUDE_EEPRO100
!   { "EEPRO100", eepro100_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_EPIC100
!   { "EPIC100", epic100_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_OTULIP
!   { "OTulip", otulip_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_TULIP
!   { "Tulip", tulip_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_DAVICOM
!   { "DAVICOM", davicom_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_CS89X0
!   { "CS89x0", cs89x0_probe, 0 },
! #endif
! #ifdef	INCLUDE_NE2100
!   { "NE2100", ne2100_probe, 0 },
! #endif
! #ifdef	INCLUDE_NI6510
!   { "NI6510", ni6510_probe, 0 },
! #endif
! #ifdef	INCLUDE_SK_G16
!   { "SK_G16", SK_probe, 0 },
! #endif
! #ifdef	INCLUDE_3C507
!   { "3C507", t507_probe, 0 },
! #endif
! #ifdef	INCLUDE_NI5010
!   { "NI5010", ni5010_probe, 0 },
! #endif
! #ifdef	INCLUDE_NI5210
!   { "NI5210", ni5210_probe, 0 },
! #endif
! #ifdef	INCLUDE_EXOS205
!   { "EXOS205", exos205_probe, 0 },
! #endif
! #ifdef	INCLUDE_SMC9000
!   { "SMC9000", smc9000_probe, 0 },
! #endif
! #ifdef	INCLUDE_TIARA
!   { "TIARA", tiara_probe, 0 },
! #endif
! #ifdef	INCLUDE_DEPCA
!   { "DEPCA", depca_probe, 0 },
! #endif
! #ifdef	INCLUDE_NS8390
!   { "NE2000/PCI", nepci_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_LANCE
!   { "LANCE/PCI", lancepci_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_VIA_RHINE
!   { "VIA 86C100", rhine_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_W89C840
!   { "W89C840F", w89c840_probe, pci_ioaddrs },
! #endif
! #ifdef	INCLUDE_TLAN
!   { "Olicom 2326", tlan_probe, pci_ioaddrs },
! #endif
!   /* this entry must always be last to mark the end of list */
!   { 0, 0, 0 }
! };
! 
! #define	NIC_TABLE_SIZE	(sizeof (NIC) / sizeof (NIC[0]))
! 
! static int
! eth_dummy (struct nic *dummy)
! {
!   return 0;
  }
- 
- static char	packet[ETH_FRAME_LEN];
- 
- struct nic	nic =
- {
-   (void (*) (struct nic *)) eth_dummy,	/* reset */
-   eth_dummy,				/* poll */
-   (void (*) (struct nic *, const char *,
- 	     unsigned int, unsigned int,
- 	     const char *)) eth_dummy,	/* transmit */
-   (void (*) (struct nic *)) eth_dummy,	/* disable */
- #ifdef	T503_AUI
-   1,					/* aui */
  #else
!   0,					/* no aui */
  #endif
!   &rom,					/* rom_info */
!   arptable[ARP_CLIENT].node,		/* node_addr */
!   packet,				/* packet */
!   0,				/* packetlen */
!   0,				/* priv_data */
  };
! 
! void
! eth_reset (void)
  {
!   (*nic.reset) (&nic);
! }
  
! int
! eth_probe (void)
! {
!   struct pci_device	*p;
!   const struct dispatch_table	*t;
!   static int probed = 0;
  
!   /* If already probed, don't try to probe it any longer.  */
!   if (probed)
!     return 1;
!   
!   /* Clear the ready flag.  */
!   network_ready = 0;
!   /* Clear the ARP table.  */
!   grub_memset ((char *) arptable, 0,
! 	       MAX_ARP * sizeof (struct arptable_t));
!   
!   p = 0;
!   
! #ifdef	INCLUDE_PCI
!   /* In GRUB, the ROM info is initialized here.  */
!   rom = *((struct rom_info *) ROM_INFO_LOCATION);
!   
!   eth_pci_init(pci_nic_list);
!   pci_ioaddrs[0] = 0;
!   pci_ioaddrs[1] = 0;
!   /* at this point we have a list of possible PCI candidates
!      we just pick the first one with a non-zero ioaddr */
!   for (p = pci_nic_list; p->vendor != 0; ++p)
!     {
!       if (p->ioaddr != 0)
! 	{
! 	  pci_ioaddrs[0] = p->ioaddr;
! 	  break;
  	}
!     }
! #endif
!   
!   etherboot_printf("Probing...");
! 	
! #ifdef INCLUDE_PCI
!   if (p->vendor)
!     {
!       struct pci_dispatch_table *pt;
!       
!       for (pt = PCI_NIC; pt->eth_probe != 0; pt++)
! 	if (p->vendor == pt->vendor && p->dev_id == pt->dev_id)
! 	  {
! 	    etherboot_printf ("[%s]", p->name);
! 	    if ((pt->eth_probe) (&nic, pci_ioaddrs, p))
! 	      {
! 		probed = 1;
! 		return 1;
! 	      }
! 	  }
!     }
! #endif /* INCLUDE_PCI */
! 	
!   for (t = NIC; t->nic_name != 0; ++t)
!     {
!       etherboot_printf("[%s]", t->nic_name);
! #ifdef	INCLUDE_PCI
!       if ((*t->eth_probe) (&nic, t->probe_ioaddrs, p))
! 	{
! 	  probed = 1;
! 	  return 1;
  	}
! #else
!       if ((*t->eth_probe) (&nic, t->probe_ioaddrs))
! 	{
! 	  probed = 1;
! 	  return 1;
  	}
- #endif	/* INCLUDE_PCI */
-     }
-   
-   return 0;
- }
- 
- int
- eth_poll (void)
- {
-   return ((*nic.poll) (&nic));
- }
  
! void
! eth_transmit (const char *d, unsigned int t, unsigned int s, const void *p)
! {
!   (*nic.transmit) (&nic, d, t, s, p);
!   if (t == IP)
!     twiddle ();
  }
  
! void
! eth_disable (void)
  {
!   (*nic.disable) (&nic);
  }
--- 6,165 ----
   */
  
! #include	"grub.h"
! #include	"pci.h"
! #include	"isa.h"
! #include	"nic.h"
  
! #ifdef CONFIG_PCI
! static int pci_probe(struct dev *dev, const char *type_name)
  {
! /*
!  *	NIC probing is in pci device order, followed by the 
!  *      link order of the drivers.  A driver that matches 
!  *      on vendor and device id will supersede a driver
!  *      that matches on pci class.
!  *
!  *	If you want to probe for another device behind the same pci
!  *      device just increment index.  And the previous probe call
!  *      will be repeated.
!  */
! 	struct pci_probe_state *state = &dev->state.pci;
! 	printf("Probing pci %s...\n", type_name);
! 	if (dev->how_probe == PROBE_FIRST) {
! 		state->advance    = 1;
! 		state->dev.driver = 0;
! 		state->dev.bus    = 0;
! 		state->dev.devfn  = 0;
! 		dev->index        = -1;
! 	}
! 	for(;;) {
! 		if ((dev->how_probe != PROBE_AWAKE) && state->advance) {
! 			find_pci(dev->type, &state->dev);
! 			dev->index = -1;
! 		}
! 		state->advance = 1;
! 		
! 		if (state->dev.driver == 0)
! 			break;
! 		
! #if 0
! 		/* FIXME the romaddr code needs a total rethought to be useful */
! 		if (state->dev.romaddr != ((unsigned long) rom.rom_segment << 4)) {
! 			continue;
! 		}
! #endif
! 		if (dev->how_probe != PROBE_AWAKE) {
! 			dev->type_index++;
! 		}
! 		dev->devid.bus_type = PCI_BUS_TYPE;
! 		dev->devid.vendor_id = htons(state->dev.vendor);
! 		dev->devid.device_id = htons(state->dev.dev_id);
! 		/* FIXME how do I handle dev->index + PROBE_AGAIN?? */
! 		
! 		printf("[%s]", state->dev.name);
! 		if (state->dev.driver->probe(dev, &state->dev)) {
! 			state->advance = (dev->index == -1);
! 			return PROBE_WORKED;
! 		}
! 		putchar('\n');
! 	}
! 	return PROBE_FAILED;
! }
  #endif
  
! #ifdef CONFIG_ISA
! static int isa_probe(struct dev *dev, const char *type_name)
  {
  /*
!  *	NIC probing is in the order the drivers were linked togeter.
   *	If for some reason you want to change the order,
!  *	just change the order you list the drivers in.
   */
! 	struct isa_probe_state *state = &dev->state.isa;
! 	printf("Probing isa %s...\n", type_name);
! 	if (dev->how_probe == PROBE_FIRST) {
! 		state->advance = 0;
! 		state->driver  = isa_drivers;
! 		dev->index     = -1;
! 	}
! 	for(;;)
! 	{
! 		if ((dev->how_probe != PROBE_AWAKE) && state->advance) {
! 			state->driver++;
! 			dev->index = -1;
! 		}
! 		state->advance = 1;
! 		
! 		if (state->driver >= isa_drivers_end)
! 			break;
! 
! 		if (state->driver->type != dev->type)
! 			continue;
! 
! 		if (dev->how_probe != PROBE_AWAKE) {
! 			dev->type_index++;
! 		}
! 		printf("[%s]", state->driver->name);
! 		dev->devid.bus_type = ISA_BUS_TYPE;
! 		/* FIXME how do I handle dev->index + PROBE_AGAIN?? */
! 		/* driver will fill in vendor and device IDs */
! 		if (state->driver->probe(dev, state->driver->ioaddrs)) {
! 			state->advance = (dev->index == -1);
! 			return PROBE_WORKED;
! 		}
! 		putchar('\n');
! 	}
! 	return PROBE_FAILED;
  }
  #else
! #define isa_probe(d,tn) (PROBE_FAILED)
  #endif
! static const char *driver_name[] = {
! 	"nic", 
! 	"disk", 
! 	"floppy",
  };
! int probe(struct dev *dev)
  {
! 	const char *type_name;
  
! 	EnterFunction("probe");
  
! 	type_name = "";
! 	if ((dev->type >= 0) && 
! 		(dev->type < sizeof(driver_name)/sizeof(driver_name[0]))) {
! 		type_name = driver_name[dev->type];
  	}
! 	if (dev->how_probe == PROBE_FIRST) {
! 		dev->to_probe = PROBE_PCI;
! 		memset(&dev->state, 0, sizeof(dev->state));
  	}
! 	if (dev->to_probe == PROBE_PCI) {
! 		dev->how_probe = pci_probe(dev, type_name);
! 		if (dev->how_probe == PROBE_FAILED) {
! 			dev->to_probe = PROBE_ISA;
! 		}
! 	}
! 	if (dev->to_probe == PROBE_ISA) {
! 		dev->how_probe = isa_probe(dev, type_name);
! 		if (dev->how_probe == PROBE_FAILED) {
! 			dev->to_probe = PROBE_NONE;
! 		}
! 	}
! 	if ((dev->to_probe != PROBE_PCI) &&
! 		(dev->to_probe != PROBE_ISA)) {
! 		dev->how_probe = PROBE_FAILED;
! 		
  	}
  
! 	LeaveFunction("probe");
! 	return dev->how_probe;
  }
  
! void disable(struct dev *dev)
  {
! 	if (dev->disable) {
! 		dev->disable(dev);
! 		dev->disable = 0;
! 	}
  }
diff -rc2P -x CVS GRUB_0.94/netboot/cpu.h GRUB/netboot/cpu.h
*** GRUB_0.94/netboot/cpu.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/cpu.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,243 ----
+ #ifndef I386_BITS_CPU_H
+ #define I386_BITS_CPU_H
+ 
+ 
+ /* Sample usage: CPU_FEATURE_P(cpu.x86_capability, FPU) */
+ #define CPU_FEATURE_P(CAP, FEATURE) \
+ 	(!!(CAP[(X86_FEATURE_##FEATURE)/32] & ((X86_FEATURE_##FEATURE) & 0x1f)))
+ 
+ #define NCAPINTS	4	/* Currently we have 4 32-bit words worth of info */
+ 
+ /* Intel-defined CPU features, CPUID level 0x00000001, word 0 */
+ #define X86_FEATURE_FPU		(0*32+ 0) /* Onboard FPU */
+ #define X86_FEATURE_VME		(0*32+ 1) /* Virtual Mode Extensions */
+ #define X86_FEATURE_DE		(0*32+ 2) /* Debugging Extensions */
+ #define X86_FEATURE_PSE 	(0*32+ 3) /* Page Size Extensions */
+ #define X86_FEATURE_TSC		(0*32+ 4) /* Time Stamp Counter */
+ #define X86_FEATURE_MSR		(0*32+ 5) /* Model-Specific Registers, RDMSR, WRMSR */
+ #define X86_FEATURE_PAE		(0*32+ 6) /* Physical Address Extensions */
+ #define X86_FEATURE_MCE		(0*32+ 7) /* Machine Check Architecture */
+ #define X86_FEATURE_CX8		(0*32+ 8) /* CMPXCHG8 instruction */
+ #define X86_FEATURE_APIC	(0*32+ 9) /* Onboard APIC */
+ #define X86_FEATURE_SEP		(0*32+11) /* SYSENTER/SYSEXIT */
+ #define X86_FEATURE_MTRR	(0*32+12) /* Memory Type Range Registers */
+ #define X86_FEATURE_PGE		(0*32+13) /* Page Global Enable */
+ #define X86_FEATURE_MCA		(0*32+14) /* Machine Check Architecture */
+ #define X86_FEATURE_CMOV	(0*32+15) /* CMOV instruction (FCMOVCC and FCOMI too if FPU present) */
+ #define X86_FEATURE_PAT		(0*32+16) /* Page Attribute Table */
+ #define X86_FEATURE_PSE36	(0*32+17) /* 36-bit PSEs */
+ #define X86_FEATURE_PN		(0*32+18) /* Processor serial number */
+ #define X86_FEATURE_CLFLSH	(0*32+19) /* Supports the CLFLUSH instruction */
+ #define X86_FEATURE_DTES	(0*32+21) /* Debug Trace Store */
+ #define X86_FEATURE_ACPI	(0*32+22) /* ACPI via MSR */
+ #define X86_FEATURE_MMX		(0*32+23) /* Multimedia Extensions */
+ #define X86_FEATURE_FXSR	(0*32+24) /* FXSAVE and FXRSTOR instructions (fast save and restore */
+ 				          /* of FPU context), and CR4.OSFXSR available */
+ #define X86_FEATURE_XMM		(0*32+25) /* Streaming SIMD Extensions */
+ #define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
+ #define X86_FEATURE_SELFSNOOP	(0*32+27) /* CPU self snoop */
+ #define X86_FEATURE_HT		(0*32+28) /* Hyper-Threading */
+ #define X86_FEATURE_ACC		(0*32+29) /* Automatic clock control */
+ #define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
+ 
+ /* AMD-defined CPU features, CPUID level 0x80000001, word 1 */
+ /* Don't duplicate feature flags which are redundant with Intel! */
+ #define X86_FEATURE_SYSCALL	(1*32+11) /* SYSCALL/SYSRET */
+ #define X86_FEATURE_MMXEXT	(1*32+22) /* AMD MMX extensions */
+ #define X86_FEATURE_LM		(1*32+29) /* Long Mode (x86-64) */
+ #define X86_FEATURE_3DNOWEXT	(1*32+30) /* AMD 3DNow! extensions */
+ #define X86_FEATURE_3DNOW	(1*32+31) /* 3DNow! */
+ 
+ /* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 */
+ #define X86_FEATURE_RECOVERY	(2*32+ 0) /* CPU in recovery mode */
+ #define X86_FEATURE_LONGRUN	(2*32+ 1) /* Longrun power control */
+ #define X86_FEATURE_LRTI	(2*32+ 3) /* LongRun table interface */
+ 
+ /* Other features, Linux-defined mapping, word 3 */
+ /* This range is used for feature bits which conflict or are synthesized */
+ #define X86_FEATURE_CXMMX	(3*32+ 0) /* Cyrix MMX extensions */
+ #define X86_FEATURE_K6_MTRR	(3*32+ 1) /* AMD K6 nonstandard MTRRs */
+ #define X86_FEATURE_CYRIX_ARR	(3*32+ 2) /* Cyrix ARRs (= MTRRs) */
+ #define X86_FEATURE_CENTAUR_MCR	(3*32+ 3) /* Centaur MCRs (= MTRRs) */
+ 
+ #define MAX_X86_VENDOR_ID 16
+ struct cpuinfo_x86 {
+ 	uint8_t	 x86;		/* CPU family */
+ 	uint8_t	 x86_model;
+ 	uint8_t	 x86_mask;
+ 
+        	int	 cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
+ 	unsigned x86_capability[NCAPINTS];
+ 	char	 x86_vendor_id[MAX_X86_VENDOR_ID];
+ };
+ 
+ 
+ #define X86_VENDOR_INTEL 0
+ #define X86_VENDOR_CYRIX 1
+ #define X86_VENDOR_AMD 2
+ #define X86_VENDOR_UMC 3
+ #define X86_VENDOR_NEXGEN 4
+ #define X86_VENDOR_CENTAUR 5
+ #define X86_VENDOR_RISE 6
+ #define X86_VENDOR_TRANSMETA 7
+ #define X86_VENDOR_NSC 8
+ #define X86_VENDOR_UNKNOWN 0xff
+ 
+ /*
+  * EFLAGS bits
+  */
+ #define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
+ #define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
+ #define X86_EFLAGS_AF	0x00000010 /* Auxillary carry Flag */
+ #define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
+ #define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
+ #define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
+ #define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
+ #define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
+ #define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
+ #define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
+ #define X86_EFLAGS_NT	0x00004000 /* Nested Task */
+ #define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
+ #define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
+ #define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
+ #define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
+ #define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
+ #define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
+ 
+ /*
+  * Generic CPUID function
+  */
+ static inline void cpuid(int op, 
+ 	unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
+ {
+ 	__asm__("cpuid"
+ 		: "=a" (*eax),
+ 		  "=b" (*ebx),
+ 		  "=c" (*ecx),
+ 		  "=d" (*edx)
+ 		: "0" (op));
+ }
+ 
+ /*
+  * CPUID functions returning a single datum
+  */
+ static inline unsigned int cpuid_eax(unsigned int op)
+ {
+ 	unsigned int eax;
+ 
+ 	__asm__("cpuid"
+ 		: "=a" (eax)
+ 		: "0" (op)
+ 		: "bx", "cx", "dx");
+ 	return eax;
+ }
+ static inline unsigned int cpuid_ebx(unsigned int op)
+ {
+ 	unsigned int eax, ebx;
+ 
+ 	__asm__("cpuid"
+ 		: "=a" (eax), "=b" (ebx)
+ 		: "0" (op)
+ 		: "cx", "dx" );
+ 	return ebx;
+ }
+ static inline unsigned int cpuid_ecx(unsigned int op)
+ {
+ 	unsigned int eax, ecx;
+ 
+ 	__asm__("cpuid"
+ 		: "=a" (eax), "=c" (ecx)
+ 		: "0" (op)
+ 		: "bx", "dx" );
+ 	return ecx;
+ }
+ static inline unsigned int cpuid_edx(unsigned int op)
+ {
+ 	unsigned int eax, edx;
+ 
+ 	__asm__("cpuid"
+ 		: "=a" (eax), "=d" (edx)
+ 		: "0" (op)
+ 		: "bx", "cx");
+ 	return edx;
+ }
+ 
+ /*
+  * Intel CPU features in CR4
+  */
+ #define X86_CR4_VME		0x0001	/* enable vm86 extensions */
+ #define X86_CR4_PVI		0x0002	/* virtual interrupts flag enable */
+ #define X86_CR4_TSD		0x0004	/* disable time stamp at ipl 3 */
+ #define X86_CR4_DE		0x0008	/* enable debugging extensions */
+ #define X86_CR4_PSE		0x0010	/* enable page size extensions */
+ #define X86_CR4_PAE		0x0020	/* enable physical address extensions */
+ #define X86_CR4_MCE		0x0040	/* Machine check enable */
+ #define X86_CR4_PGE		0x0080	/* enable global pages */
+ #define X86_CR4_PCE		0x0100	/* enable performance counters at ipl 3 */
+ #define X86_CR4_OSFXSR		0x0200	/* enable fast FPU save and restore */
+ #define X86_CR4_OSXMMEXCPT	0x0400	/* enable unmasked SSE exceptions */
+ 
+ 
+ #define MSR_K6_EFER			0xC0000080
+ /* EFER bits: */ 
+ #define _EFER_SCE 0  /* SYSCALL/SYSRET */
+ #define _EFER_LME 8  /* Long mode enable */
+ #define _EFER_LMA 10 /* Long mode active (read-only) */
+ #define _EFER_NX 11  /* No execute enable */
+ 
+ #define EFER_SCE (1<<_EFER_SCE)
+ #define EFER_LME (1<<EFER_LME)
+ #define EFER_LMA (1<<EFER_LMA)
+ #define EFER_NX (1<<_EFER_NX)
+ 
+ #define rdmsr(msr,val1,val2) \
+      __asm__ __volatile__("rdmsr" \
+ 			  : "=a" (val1), "=d" (val2) \
+ 			  : "c" (msr))
+ 
+ #define wrmsr(msr,val1,val2) \
+      __asm__ __volatile__("wrmsr" \
+ 			  : /* no outputs */ \
+ 			  : "c" (msr), "a" (val1), "d" (val2))
+ 
+ 
+ #define read_cr0()	({ \
+ 	unsigned int __dummy; \
+ 	__asm__( \
+ 		"movl %%cr0, %0\n\t" \
+ 		:"=r" (__dummy)); \
+ 	__dummy; \
+ })
+ #define write_cr0(x) \
+ 	__asm__("movl %0,%%cr0": :"r" (x));
+ 
+ #define read_cr3()	({ \
+ 	unsigned int __dummy; \
+ 	__asm__( \
+ 		"movl %%cr3, %0\n\t" \
+ 		:"=r" (__dummy)); \
+ 	__dummy; \
+ })
+ #define write_cr3x(x) \
+ 	__asm__("movl %0,%%cr3": :"r" (x));
+ 
+ 
+ #define read_cr4()	({ \
+ 	unsigned int __dummy; \
+ 	__asm__( \
+ 		"movl %%cr4, %0\n\t" \
+ 		:"=r" (__dummy)); \
+ 	__dummy; \
+ })
+ #define write_cr4x(x) \
+ 	__asm__("movl %0,%%cr4": :"r" (x));
+ 
+ 
+ extern struct cpuinfo_x86 cpu_info;
+ #ifdef CONFIG_X86_64
+ extern void cpu_setup(void);
+ #else
+ #define cpu_setup() do {} while(0)
+ #endif
+ 
+ #endif /* I386_BITS_CPU_H */
Only in GRUB_0.94/netboot: cs89x0.c
Only in GRUB_0.94/netboot: cs89x0.h
Only in GRUB_0.94/netboot: cs89x0.txt
diff -rc2P -x CVS GRUB_0.94/netboot/davicom.c GRUB/netboot/davicom.c
*** GRUB_0.94/netboot/davicom.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/davicom.c	2003-11-08 22:47:26.000000000 +0800
***************
*** 1,2 ****
--- 1,5 ----
+ #ifdef ALLMULTI
+ #error multicast support is not yet implemented
+ #endif
  /*  
      DAVICOM DM9009/DM9102/DM9102A Etherboot Driver	V1.00
***************
*** 45,49 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  
  #undef DAVICOM_DEBUG
--- 48,51 ----
***************
*** 100,105 ****
  
  /* helpful macro if on a big_endian machine for changing byte order.
!    not strictly needed on Intel */
  #define le16_to_cpu(val) (val)
  
  /* transmit and receive descriptor format */
--- 102,109 ----
  
  /* helpful macro if on a big_endian machine for changing byte order.
!    not strictly needed on Intel
!    Already defined in Etherboot includes
  #define le16_to_cpu(val) (val)
+ */
  
  /* transmit and receive descriptor format */
***************
*** 139,156 ****
  #define NTXD 2
  static struct txdesc txd[NTXD] __attribute__ ((aligned(4)));
- #ifdef	USE_LOWMEM_BUFFER
- #define txb ((char *)0x10000 - BUFLEN)
- #else
  static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
- #endif
  
  /* receive descriptor(s) and buffer(s) */
  #define NRXD 4
  static struct rxdesc rxd[NRXD] __attribute__ ((aligned(4)));
- #ifdef	USE_LOWMEM_BUFFER
- #define rxb ((char *)0x10000 - NRXD * BUFLEN - BUFLEN)
- #else
  static unsigned char rxb[NRXD * BUFLEN] __attribute__ ((aligned(4)));
- #endif
  static int rxd_tail;
  static int TxPtr;
--- 143,152 ----
***************
*** 162,167 ****
  static void whereami(const char *str);
  static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
! struct nic *davicom_probe(struct nic *nic, unsigned short *io_addrs,
! 			struct pci_device *pci);
  static void davicom_init_chain(struct nic *nic);	/* Sten 10/9 */
  static void davicom_reset(struct nic *nic);
--- 158,162 ----
  static void whereami(const char *str);
  static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
! static int davicom_probe(struct dev *dev, struct pci_device *pci);
  static void davicom_init_chain(struct nic *nic);	/* Sten 10/9 */
  static void davicom_reset(struct nic *nic);
***************
*** 169,173 ****
  			   unsigned int s, const char *p);
  static int davicom_poll(struct nic *nic);
! static void davicom_disable(struct nic *nic);
  static void whereami (const char *str);
  #ifdef	DAVICOM_DEBUG
--- 164,168 ----
  			   unsigned int s, const char *p);
  static int davicom_poll(struct nic *nic);
! static void davicom_disable(struct dev *dev);
  static void whereami (const char *str);
  #ifdef	DAVICOM_DEBUG
***************
*** 361,365 ****
    Sense media mode and set CR6
  */
! static void davicom_media_chk(struct nic * nic)
  {
    unsigned long to, csr6;
--- 356,360 ----
    Sense media mode and set CR6
  */
! static void davicom_media_chk(struct nic * nic __unused)
  {
    unsigned long to, csr6;
***************
*** 447,452 ****
  	   it transmit a packet and wait complete every time. */
    for (i=0; i<NTXD; i++) {
!     txd[i].buf1addr = &txb[0];		/* Used same TX buffer */
!     txd[i].buf2addr = (unsigned char *)&txd[i+1]; /*  Point to Next TX desc */
      txd[i].buf1sz   = 0;
      txd[i].buf2sz   = 0;
--- 442,447 ----
  	   it transmit a packet and wait complete every time. */
    for (i=0; i<NTXD; i++) {
!     txd[i].buf1addr = virt_to_bus(&txb[0]);	/* Used same TX buffer */
!     txd[i].buf2addr = virt_to_bus(&txd[i+1]);	/*  Point to Next TX desc */
      txd[i].buf1sz   = 0;
      txd[i].buf2sz   = 0;
***************
*** 467,472 ****
    /* setup receive descriptor */
    for (i=0; i<NRXD; i++) {
!     rxd[i].buf1addr = &rxb[i * BUFLEN];
!     rxd[i].buf2addr = (unsigned char *)&rxd[i+1]; /* Point to Next RX desc */
      rxd[i].buf1sz   = BUFLEN;
      rxd[i].buf2sz   = 0;        /* not used */
--- 462,467 ----
    /* setup receive descriptor */
    for (i=0; i<NRXD; i++) {
!     rxd[i].buf1addr = virt_to_bus(&rxb[i * BUFLEN]);
!     rxd[i].buf2addr = virt_to_bus(&rxd[i+1]); /* Point to Next RX desc */
      rxd[i].buf1sz   = BUFLEN;
      rxd[i].buf2sz   = 0;        /* not used */
***************
*** 476,481 ****
  
    /* Chain the last descriptor to first */
!   txd[NTXD - 1].buf2addr = (unsigned char *)&txd[0];
!   rxd[NRXD - 1].buf2addr = (unsigned char *)&rxd[0];
    TxPtr = 0;
    rxd_tail = 0;
--- 471,476 ----
  
    /* Chain the last descriptor to first */
!   txd[NTXD - 1].buf2addr = virt_to_bus(&txd[0]);
!   rxd[NRXD - 1].buf2addr = virt_to_bus(&rxd[0]);
    TxPtr = 0;
    rxd_tail = 0;
***************
*** 489,493 ****
  {
    unsigned long to;
-   u32 addr_low, addr_high;
  
    whereami("davicom_reset\n");
--- 484,487 ----
***************
*** 508,513 ****
  
    /* Point to receive descriptor */
!   outl((unsigned long)&rxd[0], ioaddr + CSR3);
!   outl((unsigned long)&txd[0], ioaddr + CSR4);	/* Sten 10/9 */
  
    /* According phyxcer media mode to set CR6,
--- 502,507 ----
  
    /* Point to receive descriptor */
!   outl(virt_to_bus(&rxd[0]), ioaddr + CSR3);
!   outl(virt_to_bus(&txd[0]), ioaddr + CSR4);	/* Sten 10/9 */
  
    /* According phyxcer media mode to set CR6,
***************
*** 628,635 ****
  /* eth_disable - Disable the interface                               */
  /*********************************************************************/
! static void davicom_disable(struct nic *nic)
  {
    whereami("davicom_disable\n");
  
    /* disable interrupts */
    outl(0x00000000, ioaddr + CSR7);
--- 622,632 ----
  /* eth_disable - Disable the interface                               */
  /*********************************************************************/
! static void davicom_disable(struct dev *dev)
  {
+   struct nic *nic = (struct nic *)dev;
    whereami("davicom_disable\n");
  
+   davicom_reset(nic);
+ 
    /* disable interrupts */
    outl(0x00000000, ioaddr + CSR7);
***************
*** 645,662 ****
  /* eth_probe - Look for an adapter                                   */
  /*********************************************************************/
! struct nic *davicom_probe(struct nic *nic, unsigned short *io_addrs,
!                           struct pci_device *pci)
  {
    unsigned int i;
-   u32 l1, l2;
  
    whereami("davicom_probe\n");
  
!   if (io_addrs == 0 || *io_addrs == 0)
      return 0;
  
    vendor  = pci->vendor;
    dev_id  = pci->dev_id;
!   ioaddr  = *io_addrs;
  
    /* wakeup chip */
--- 642,658 ----
  /* eth_probe - Look for an adapter                                   */
  /*********************************************************************/
! static int davicom_probe(struct dev *dev, struct pci_device *pci)
  {
+   struct nic *nic = (struct nic *)dev;
    unsigned int i;
  
    whereami("davicom_probe\n");
  
!   if (pci->ioaddr == 0)
      return 0;
  
    vendor  = pci->vendor;
    dev_id  = pci->dev_id;
!   ioaddr  = pci->ioaddr;
  
    /* wakeup chip */
***************
*** 684,692 ****
    davicom_reset(nic);
  
!   nic->reset    = davicom_reset;
    nic->poll     = davicom_poll;
    nic->transmit = davicom_transmit;
-   nic->disable  = davicom_disable;
  
!   return nic;
  }
--- 680,703 ----
    davicom_reset(nic);
  
!   dev->disable  = davicom_disable;
    nic->poll     = davicom_poll;
    nic->transmit = davicom_transmit;
  
!   return 1;
  }
+ 
+ static struct pci_id davicom_nics[] = {
+ PCI_ROM(0x1282, 0x9100, "davicom9100", "Davicom 9100"),
+ PCI_ROM(0x1282, 0x9102, "davicom9102", "Davicom 9102"),
+ PCI_ROM(0x1282, 0x9009, "davicom9009", "Davicom 9009"),
+ PCI_ROM(0x1282, 0x9132, "davicom9132", "Davicom 9132"),	/* Needs probably some fixing */
+ };
+ 
+ struct pci_driver davicom_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "DAVICOM",
+ 	.probe    = davicom_probe,
+ 	.ids      = davicom_nics,
+ 	.id_count = sizeof(davicom_nics)/sizeof(davicom_nics[0]),
+ 	.class    = 0,
+ };
Only in GRUB_0.94/netboot: depca.c
diff -rc2P -x CVS GRUB_0.94/netboot/dev.h GRUB/netboot/dev.h
*** GRUB_0.94/netboot/dev.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/dev.h	2003-11-07 22:35:16.000000000 +0800
***************
*** 0 ****
--- 1,83 ----
+ #ifndef _DEV_H
+ #define _DEV_H
+ 
+ #include "isa.h"
+ #include "pci.h"
+ 
+ /* Need to check the packing of this struct if Etherboot is ported */
+ struct dev_id
+ {
+ 	unsigned short	vendor_id;
+ 	unsigned short	device_id;
+ 	unsigned char	bus_type;
+ #define	PCI_BUS_TYPE	1
+ #define	ISA_BUS_TYPE	2
+ };
+ 
+ /* Dont use sizeof, that will include the padding */
+ #define	DEV_ID_SIZE	8
+ 
+ 
+ struct pci_probe_state 
+ {
+ #ifdef CONFIG_PCI
+ 	struct pci_device dev;
+ 	int advance;
+ #else
+ 	int dummy;
+ #endif
+ };
+ struct isa_probe_state
+ {
+ #ifdef CONFIG_ISA
+ 	const struct isa_driver *driver;
+ 	int advance;
+ #else
+ 	int dummy;
+ #endif
+ };
+ 
+ union probe_state
+ {
+ 	struct pci_probe_state pci;
+ 	struct isa_probe_state isa;
+ };
+ 
+ struct dev
+ {
+ 	void		(*disable)P((struct dev *));
+ 	struct dev_id	devid;	/* device ID string (sent to DHCP server) */
+ 	int		index;  /* Index of next device on this controller to probe */
+ 	int		type;		/* Type of device I am probing for */
+ 	int		how_probe;	/* First, next or awake */
+ 	int 		to_probe;	/* Flavor of device I am probing */
+ 	int		failsafe;	/* Failsafe probe requested */
+ 	int		type_index;	/* Index of this device (within type) */
+ #define	PROBE_NONE 0
+ #define PROBE_PCI  1
+ #define PROBE_ISA  2
+ 	union probe_state state;
+ };
+ 
+ 
+ #define NIC_DRIVER    0
+ #define DISK_DRIVER   1
+ #define FLOPPY_DRIVER 2
+ 
+ #define BRIDGE_DRIVER 1000
+ 
+ #define PROBE_FIRST  (-1)
+ #define PROBE_NEXT   0
+ #define PROBE_AWAKE  1		/* After calling disable bring up the same device */
+ 
+ /* The probe result codes are selected
+  * to allow them to be fed back into the probe
+  * routine and get a successful probe.
+  */
+ #define PROBE_FAILED PROBE_FIRST
+ #define PROBE_WORKED  PROBE_NEXT
+ 
+ extern int probe(struct dev *dev);
+ extern void disable(struct dev *dev);
+ 
+ #endif /* _DEV_H */
diff -rc2P -x CVS GRUB_0.94/netboot/e1000.c GRUB/netboot/e1000.c
*** GRUB_0.94/netboot/e1000.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/e1000.c	2003-11-08 22:47:27.000000000 +0800
***************
*** 0 ****
--- 1,3312 ----
+ /**************************************************************************
+ Etherboot -  BOOTP/TFTP Bootstrap Program
+ Inter Pro 1000 for Etherboot
+ Drivers are port from Intel's Linux driver e1000-4.3.15
+ 
+ ***************************************************************************/
+ /*******************************************************************************
+ 
+   
+   Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+   
+   This program is free software; you can redistribute it and/or modify it 
+   under the terms of the GNU General Public License as published by the Free 
+   Software Foundation; either version 2 of the License, or (at your option) 
+   any later version.
+   
+   This program is distributed in the hope that it will be useful, but WITHOUT 
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+   more details.
+   
+   You should have received a copy of the GNU General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 
+   Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+   
+   The full GNU General Public License is included in this distribution in the
+   file called LICENSE.
+   
+   Contact Information:
+   Linux NICS <linux.nics@intel.com>
+   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ 
+ *******************************************************************************/
+ /*
+  *  Copyright (C) Archway Digital Solutions.
+  *
+  *  written by Chrsitopher Li <cli at arcyway dot com> or <chrisl at gnuchina dot org>
+  *  2/9/2002
+  *
+  *  Copyright (C) Linux Networx.
+  *  Massive upgrade to work with the new intel gigabit NICs.
+  *  <ebiederman at lnxi dot com>
+  *
+  *  Support for 82541ei & 82547ei chips from Intel's Linux driver 5.1.13 added by
+  *  Georg Baum <gbaum@users.sf.net>, sponsored by PetaMem GmbH and linkLINE Communications, Inc.
+  */
+ 
+ /* to get some global routines like printf */
+ #include "etherboot.h"
+ /* to get the interface to the body of the program */
+ #include "nic.h"
+ /* to get the PCI support functions, if this is a PCI NIC */
+ #include "pci.h"
+ #include "timer.h"
+ 
+ typedef unsigned char *dma_addr_t;
+ 
+ typedef enum {
+ 	FALSE = 0,
+ 	TRUE = 1
+ } boolean_t;
+ 
+ #define DEBUG 0
+ 
+ 
+ /* The following defines should not be needed normally,
+  * but may be helpful for debugging purposes. */
+ 
+ /* Define this if you want to program the transmission control register
+  * the way the Linux driver does it. */
+ #undef LINUX_DRIVER_TCTL
+ 
+ /* Define this to behave more like the Linux driver. */
+ #undef LINUX_DRIVER
+ 
+ /* Define this (and implement the needed functions) if you want to differ
+  * between port an memory mapped io. */
+ #undef PORT_IO_AND_MEMORY_IO_DIFFER
+ 
+ #include "e1000_hw.h"
+ 
+ /* NIC specific static variables go here */
+ static struct e1000_hw hw;
+ static char tx_pool[128 + 16];
+ static char rx_pool[128 + 16];
+ static char packet[2096];
+ 
+ static struct e1000_tx_desc *tx_base;
+ static struct e1000_rx_desc *rx_base;
+ 
+ static int tx_tail;
+ static int rx_tail, rx_last;
+ 
+ /* Function forward declarations */
+ static int e1000_setup_link(struct e1000_hw *hw);
+ static int e1000_setup_fiber_link(struct e1000_hw *hw);
+ static int e1000_setup_copper_link(struct e1000_hw *hw);
+ static int e1000_phy_setup_autoneg(struct e1000_hw *hw);
+ static void e1000_config_collision_dist(struct e1000_hw *hw);
+ static int e1000_config_mac_to_phy(struct e1000_hw *hw);
+ static int e1000_config_fc_after_link_up(struct e1000_hw *hw);
+ static int e1000_check_for_link(struct e1000_hw *hw);
+ static int e1000_wait_autoneg(struct e1000_hw *hw);
+ static void e1000_get_speed_and_duplex(struct e1000_hw *hw, uint16_t *speed, uint16_t *duplex);
+ static int e1000_read_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t *phy_data);
+ static int e1000_write_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t phy_data);
+ static void e1000_phy_hw_reset(struct e1000_hw *hw);
+ static int e1000_phy_reset(struct e1000_hw *hw);
+ static int e1000_detect_gig_phy(struct e1000_hw *hw);
+ 
+ /* Printing macros... */
+ 
+ #define E1000_ERR(args...) printf("e1000: " args)
+ 
+ #if DEBUG >= 3
+ #define E1000_DBG(args...) printf("e1000: " args)
+ #else
+ #define E1000_DBG(args...)
+ #endif
+ 
+ #define MSGOUT(S, A, B)     printk(S "\n", A, B)
+ #if DEBUG >= 2
+ #define DEBUGFUNC(F)        DEBUGOUT(F "\n");
+ #else
+ #define DEBUGFUNC(F)
+ #endif
+ #if DEBUG >= 1
+ #define DEBUGOUT(S) printf(S)
+ #define DEBUGOUT1(S,A) printf(S,A)
+ #define DEBUGOUT2(S,A,B) printf(S,A,B)
+ #define DEBUGOUT3(S,A,B,C) printf(S,A,B,C)
+ #define DEBUGOUT7(S,A,B,C,D,E,F,G) printf(S,A,B,C,D,E,F,G)
+ #else
+ #define DEBUGOUT(S)
+ #define DEBUGOUT1(S,A)
+ #define DEBUGOUT2(S,A,B)
+ #define DEBUGOUT3(S,A,B,C)
+ #define DEBUGOUT7(S,A,B,C,D,E,F,G)
+ #endif
+ 
+ #define E1000_WRITE_REG(a, reg, value) ( \
+     ((a)->mac_type >= e1000_82543) ? \
+         (writel((value), ((a)->hw_addr + E1000_##reg))) : \
+         (writel((value), ((a)->hw_addr + E1000_82542_##reg))))
+ 
+ #define E1000_READ_REG(a, reg) ( \
+     ((a)->mac_type >= e1000_82543) ? \
+         readl((a)->hw_addr + E1000_##reg) : \
+         readl((a)->hw_addr + E1000_82542_##reg))
+ 
+ #define E1000_WRITE_REG_ARRAY(a, reg, offset, value) ( \
+     ((a)->mac_type >= e1000_82543) ? \
+         writel((value), ((a)->hw_addr + E1000_##reg + ((offset) << 2))) : \
+         writel((value), ((a)->hw_addr + E1000_82542_##reg + ((offset) << 2))))
+ 
+ #define E1000_READ_REG_ARRAY(a, reg, offset) ( \
+     ((a)->mac_type >= e1000_82543) ? \
+         readl((a)->hw_addr + E1000_##reg + ((offset) << 2)) : \
+         readl((a)->hw_addr + E1000_82542_##reg + ((offset) << 2)))
+ 
+ #define E1000_WRITE_FLUSH(a) {uint32_t x; x = E1000_READ_REG(a, STATUS);}
+ 
+ static inline void e1000_pci_set_mwi(struct e1000_hw *hw)
+ {
+ 	pci_write_config_word(hw->pdev, PCI_COMMAND, hw->pci_cmd_word);
+ }
+ 
+ static inline void e1000_pci_clear_mwi(struct e1000_hw *hw)
+ {
+ 	pci_write_config_word(hw->pdev, PCI_COMMAND,
+ 			      hw->pci_cmd_word & ~PCI_COMMAND_INVALIDATE);
+ }
+ 
+ /******************************************************************************
+  * Raises the EEPROM's clock input.
+  *
+  * hw - Struct containing variables accessed by shared code
+  * eecd - EECD's current value
+  *****************************************************************************/
+ static void
+ e1000_raise_ee_clk(struct e1000_hw *hw,
+                    uint32_t *eecd)
+ {
+ 	/* Raise the clock input to the EEPROM (by setting the SK bit), and then
+ 	 * wait <delay> microseconds.
+ 	 */
+ 	*eecd = *eecd | E1000_EECD_SK;
+ 	E1000_WRITE_REG(hw, EECD, *eecd);
+ 	E1000_WRITE_FLUSH(hw);
+ 	udelay(hw->eeprom.delay_usec);
+ }
+ 
+ /******************************************************************************
+  * Lowers the EEPROM's clock input.
+  *
+  * hw - Struct containing variables accessed by shared code 
+  * eecd - EECD's current value
+  *****************************************************************************/
+ static void
+ e1000_lower_ee_clk(struct e1000_hw *hw,
+                    uint32_t *eecd)
+ {
+ 	/* Lower the clock input to the EEPROM (by clearing the SK bit), and then 
+ 	 * wait 50 microseconds. 
+ 	 */
+ 	*eecd = *eecd & ~E1000_EECD_SK;
+ 	E1000_WRITE_REG(hw, EECD, *eecd);
+ 	E1000_WRITE_FLUSH(hw);
+ 	udelay(hw->eeprom.delay_usec);
+ }
+ 
+ /******************************************************************************
+  * Shift data bits out to the EEPROM.
+  *
+  * hw - Struct containing variables accessed by shared code
+  * data - data to send to the EEPROM
+  * count - number of bits to shift out
+  *****************************************************************************/
+ static void
+ e1000_shift_out_ee_bits(struct e1000_hw *hw,
+                         uint16_t data,
+                         uint16_t count)
+ {
+ 	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+ 	uint32_t eecd;
+ 	uint32_t mask;
+ 	
+ 	/* We need to shift "count" bits out to the EEPROM. So, value in the
+ 	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
+ 	 * In order to do this, "data" must be broken down into bits. 
+ 	 */
+ 	mask = 0x01 << (count - 1);
+ 	eecd = E1000_READ_REG(hw, EECD);
+ 	if (eeprom->type == e1000_eeprom_microwire) {
+ 		eecd &= ~E1000_EECD_DO;
+ 	} else if (eeprom->type == e1000_eeprom_spi) {
+ 		eecd |= E1000_EECD_DO;
+ 	}
+ 	do {
+ 		/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",
+ 		 * and then raising and then lowering the clock (the SK bit controls
+ 		 * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM
+ 		 * by setting "DI" to "0" and then raising and then lowering the clock.
+ 		 */
+ 		eecd &= ~E1000_EECD_DI;
+ 		
+ 		if(data & mask)
+ 			eecd |= E1000_EECD_DI;
+ 		
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		
+ 		udelay(eeprom->delay_usec);
+ 		
+ 		e1000_raise_ee_clk(hw, &eecd);
+ 		e1000_lower_ee_clk(hw, &eecd);
+ 		
+ 		mask = mask >> 1;
+ 		
+ 	} while(mask);
+ 
+ 	/* We leave the "DI" bit set to "0" when we leave this routine. */
+ 	eecd &= ~E1000_EECD_DI;
+ 	E1000_WRITE_REG(hw, EECD, eecd);
+ }
+ 
+ /******************************************************************************
+  * Shift data bits in from the EEPROM
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static uint16_t
+ e1000_shift_in_ee_bits(struct e1000_hw *hw, uint16_t count)
+ {
+ 	uint32_t eecd;
+ 	uint32_t i;
+ 	uint16_t data;
+ 	
+ 	/* In order to read a register from the EEPROM, we need to shift 'count' 
+ 	 * bits in from the EEPROM. Bits are "shifted in" by raising the clock
+ 	 * input to the EEPROM (setting the SK bit), and then reading the value of
+ 	 * the "DO" bit.  During this "shifting in" process the "DI" bit should
+ 	 * always be clear.
+ 	 */
+ 	
+ 	eecd = E1000_READ_REG(hw, EECD);
+ 	
+ 	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
+ 	data = 0;
+ 	
+ 	for(i = 0; i < count; i++) {
+ 		data = data << 1;
+ 		e1000_raise_ee_clk(hw, &eecd);
+ 		
+ 		eecd = E1000_READ_REG(hw, EECD);
+ 		
+ 		eecd &= ~(E1000_EECD_DI);
+ 		if(eecd & E1000_EECD_DO)
+ 			data |= 1;
+ 		
+ 		e1000_lower_ee_clk(hw, &eecd);
+ 	}
+ 	
+ 	return data;
+ }
+ 
+ /******************************************************************************
+  * Prepares EEPROM for access
+  *
+  * hw - Struct containing variables accessed by shared code
+  *
+  * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This 
+  * function should be called before issuing a command to the EEPROM.
+  *****************************************************************************/
+ static int32_t
+ e1000_acquire_eeprom(struct e1000_hw *hw)
+ {
+ 	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+ 	uint32_t eecd, i=0;
+ 
+ 	eecd = E1000_READ_REG(hw, EECD);
+ 
+ 	/* Request EEPROM Access */
+ 	if(hw->mac_type > e1000_82544) {
+ 		eecd |= E1000_EECD_REQ;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		eecd = E1000_READ_REG(hw, EECD);
+ 		while((!(eecd & E1000_EECD_GNT)) &&
+ 		      (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
+ 			i++;
+ 			udelay(5);
+ 			eecd = E1000_READ_REG(hw, EECD);
+ 		}
+ 		if(!(eecd & E1000_EECD_GNT)) {
+ 			eecd &= ~E1000_EECD_REQ;
+ 			E1000_WRITE_REG(hw, EECD, eecd);
+ 			DEBUGOUT("Could not acquire EEPROM grant\n");
+ 			return -E1000_ERR_EEPROM;
+ 		}
+ 	}
+ 
+ 	/* Setup EEPROM for Read/Write */
+ 
+ 	if (eeprom->type == e1000_eeprom_microwire) {
+ 		/* Clear SK and DI */
+ 		eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 
+ 		/* Set CS */
+ 		eecd |= E1000_EECD_CS;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 	} else if (eeprom->type == e1000_eeprom_spi) {
+ 		/* Clear SK and CS */
+ 		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		udelay(1);
+ 	}
+ 
+ 	return E1000_SUCCESS;
+ }
+ 
+ /******************************************************************************
+  * Returns EEPROM to a "standby" state
+  * 
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static void
+ e1000_standby_eeprom(struct e1000_hw *hw)
+ {
+ 	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+ 	uint32_t eecd;
+ 	
+ 	eecd = E1000_READ_REG(hw, EECD);
+ 
+ 	if(eeprom->type == e1000_eeprom_microwire) {
+ 
+ 		/* Deselect EEPROM */
+ 		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(eeprom->delay_usec);
+ 	
+ 		/* Clock high */
+ 		eecd |= E1000_EECD_SK;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(eeprom->delay_usec);
+ 	
+ 		/* Select EEPROM */
+ 		eecd |= E1000_EECD_CS;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(eeprom->delay_usec);
+ 
+ 		/* Clock low */
+ 		eecd &= ~E1000_EECD_SK;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(eeprom->delay_usec);
+ 	} else if(eeprom->type == e1000_eeprom_spi) {
+ 		/* Toggle CS to flush commands */
+ 		eecd |= E1000_EECD_CS;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(eeprom->delay_usec);
+ 		eecd &= ~E1000_EECD_CS;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(eeprom->delay_usec);
+ 	}
+ }
+ 
+ /******************************************************************************
+  * Terminates a command by inverting the EEPROM's chip select pin
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static void
+ e1000_release_eeprom(struct e1000_hw *hw)
+ {
+ 	uint32_t eecd;
+ 
+ 	eecd = E1000_READ_REG(hw, EECD);
+ 
+ 	if (hw->eeprom.type == e1000_eeprom_spi) {
+ 		eecd |= E1000_EECD_CS;  /* Pull CS high */
+ 		eecd &= ~E1000_EECD_SK; /* Lower SCK */
+ 
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 
+ 		udelay(hw->eeprom.delay_usec);
+ 	} else if(hw->eeprom.type == e1000_eeprom_microwire) {
+ 		/* cleanup eeprom */
+ 
+ 		/* CS on Microwire is active-high */
+ 		eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);
+ 
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 
+ 		/* Rising edge of clock */
+ 		eecd |= E1000_EECD_SK;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(hw->eeprom.delay_usec);
+ 
+ 		/* Falling edge of clock */
+ 		eecd &= ~E1000_EECD_SK;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 		E1000_WRITE_FLUSH(hw);
+ 		udelay(hw->eeprom.delay_usec);
+ 	}
+ 
+ 	/* Stop requesting EEPROM access */
+ 	if(hw->mac_type > e1000_82544) {
+ 		eecd &= ~E1000_EECD_REQ;
+ 		E1000_WRITE_REG(hw, EECD, eecd);
+ 	}
+ }
+ 
+ /******************************************************************************
+  * Reads a 16 bit word from the EEPROM.
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static int32_t
+ e1000_spi_eeprom_ready(struct e1000_hw *hw)
+ {
+ 	uint16_t retry_count = 0;
+ 	uint8_t spi_stat_reg;
+ 
+ 	/* Read "Status Register" repeatedly until the LSB is cleared.  The
+ 	 * EEPROM will signal that the command has been completed by clearing
+ 	 * bit 0 of the internal status register.  If it's not cleared within
+ 	 * 5 milliseconds, then error out.
+ 	 */
+ 	retry_count = 0;
+ 	do {
+ 		e1000_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
+ 		hw->eeprom.opcode_bits);
+ 		spi_stat_reg = (uint8_t)e1000_shift_in_ee_bits(hw, 8);
+ 		if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
+ 			break;
+ 
+ 		udelay(5);
+ 		retry_count += 5;
+ 
+ 	} while(retry_count < EEPROM_MAX_RETRY_SPI);
+ 
+ 	/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
+ 	 * only 0-5mSec on 5V devices)
+ 	 */
+ 	if(retry_count >= EEPROM_MAX_RETRY_SPI) {
+ 		DEBUGOUT("SPI EEPROM Status error\n");
+ 		return -E1000_ERR_EEPROM;
+ 	}
+ 
+ 	return E1000_SUCCESS;
+ }
+ 
+ /******************************************************************************
+  * Reads a 16 bit word from the EEPROM.
+  *
+  * hw - Struct containing variables accessed by shared code
+  * offset - offset of  word in the EEPROM to read
+  * data - word read from the EEPROM
+  * words - number of words to read
+  *****************************************************************************/
+ static int
+ e1000_read_eeprom(struct e1000_hw *hw,
+                   uint16_t offset,
+ 		  uint16_t words,
+                   uint16_t *data)
+ {
+ 	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+ 	uint32_t i = 0;
+ 	
+ 	DEBUGFUNC("e1000_read_eeprom");
+ 
+ 	/* A check for invalid values:  offset too large, too many words, and not
+ 	 * enough words.
+ 	 */
+ 	if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
+ 	   (words == 0)) {
+ 		DEBUGOUT("\"words\" parameter out of bounds\n");
+ 		return -E1000_ERR_EEPROM;
+ 	}
+ 
+ 	/*  Prepare the EEPROM for reading  */
+ 	if (e1000_acquire_eeprom(hw) != E1000_SUCCESS)
+ 		return -E1000_ERR_EEPROM;
+ 
+ 	if(eeprom->type == e1000_eeprom_spi) {
+ 		uint8_t read_opcode = EEPROM_READ_OPCODE_SPI;
+ 
+ 		if(e1000_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
+ 
+ 		e1000_standby_eeprom(hw);
+ 
+ 		/* Some SPI eeproms use the 8th address bit embedded in the opcode */
+ 		if((eeprom->address_bits == 8) && (offset >= 128))
+ 			read_opcode |= EEPROM_A8_OPCODE_SPI;
+ 
+ 		/* Send the READ command (opcode + addr)  */
+ 		e1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
+ 		e1000_shift_out_ee_bits(hw, (uint16_t)(offset*2), eeprom->address_bits);
+ 	}
+ 	else if(eeprom->type == e1000_eeprom_microwire) {
+ 		/*  Send the READ command (opcode + addr)  */
+ 		e1000_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
+ 					eeprom->opcode_bits);
+ 		e1000_shift_out_ee_bits(hw, offset, eeprom->address_bits);
+ 	}
+ 
+ 	/* Read the data.  The address of the eeprom internally increments with
+ 	 * each word (microwire) or byte (spi) being read, saving on the overhead
+ 	 * of eeprom setup and tear-down.  The address counter will roll over if
+ 	 * reading beyond the size of the eeprom, thus allowing the entire memory
+ 	 * to be read starting from any offset. */
+ 	for (i = 0; i < words; i++) {
+ 		uint16_t word_in = e1000_shift_in_ee_bits(hw, 16);
+ 		if (eeprom->type == e1000_eeprom_spi)
+ 			word_in = (word_in >> 8) | (word_in << 8);
+ 		data[i] = word_in;
+ 	}
+ 
+ 	/* End this read operation */
+ 	e1000_release_eeprom(hw);
+ 
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Verifies that the EEPROM has a valid checksum
+  * 
+  * hw - Struct containing variables accessed by shared code
+  *
+  * Reads the first 64 16 bit words of the EEPROM and sums the values read.
+  * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
+  * valid.
+  *****************************************************************************/
+ static int
+ e1000_validate_eeprom_checksum(struct e1000_hw *hw)
+ {
+ 	uint16_t checksum = 0;
+ 	uint16_t i, eeprom_data;
+ 
+ 	DEBUGFUNC("e1000_validate_eeprom_checksum");
+ 
+ 	for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
+ 		if(e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
+ 			DEBUGOUT("EEPROM Read Error\n");
+ 			return -E1000_ERR_EEPROM;
+ 		}
+ 		checksum += eeprom_data;
+ 	}
+ 	
+ 	if(checksum == (uint16_t) EEPROM_SUM) {
+ 		return 0;
+ 	} else {
+ 		DEBUGOUT("EEPROM Checksum Invalid\n");    
+ 		return -E1000_ERR_EEPROM;
+ 	}
+ }
+ 
+ /******************************************************************************
+  * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the
+  * second function of dual function devices
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static int 
+ e1000_read_mac_addr(struct e1000_hw *hw)
+ {
+ 	uint16_t offset;
+ 	uint16_t eeprom_data;
+ 	int i;
+ 
+ 	DEBUGFUNC("e1000_read_mac_addr");
+ 
+ 	for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
+ 		offset = i >> 1;
+ 		if(e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
+ 			DEBUGOUT("EEPROM Read Error\n");
+ 			return -E1000_ERR_EEPROM;
+ 		}
+ 		hw->mac_addr[i] = eeprom_data & 0xff;
+ 		hw->mac_addr[i+1] = (eeprom_data >> 8) & 0xff;
+ 	}
+ 	if((hw->mac_type == e1000_82546) &&
+ 		(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
+ 		/* Invert the last bit if this is the second device */
+ 		hw->mac_addr[5] ^= 1;
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Initializes receive address filters.
+  *
+  * hw - Struct containing variables accessed by shared code 
+  *
+  * Places the MAC address in receive address register 0 and clears the rest
+  * of the receive addresss registers. Clears the multicast table. Assumes
+  * the receiver is in reset when the routine is called.
+  *****************************************************************************/
+ static void
+ e1000_init_rx_addrs(struct e1000_hw *hw)
+ {
+ 	uint32_t i;
+ 	uint32_t addr_low;
+ 	uint32_t addr_high;
+ 	
+ 	DEBUGFUNC("e1000_init_rx_addrs");
+ 	
+ 	/* Setup the receive address. */
+ 	DEBUGOUT("Programming MAC Address into RAR[0]\n");
+ 	addr_low = (hw->mac_addr[0] |
+ 		(hw->mac_addr[1] << 8) |
+ 		(hw->mac_addr[2] << 16) | (hw->mac_addr[3] << 24));
+ 	
+ 	addr_high = (hw->mac_addr[4] |
+ 		(hw->mac_addr[5] << 8) | E1000_RAH_AV);
+ 	
+ 	E1000_WRITE_REG_ARRAY(hw, RA, 0, addr_low);
+ 	E1000_WRITE_REG_ARRAY(hw, RA, 1, addr_high);
+ 	
+ 	/* Zero out the other 15 receive addresses. */
+ 	DEBUGOUT("Clearing RAR[1-15]\n");
+ 	for(i = 1; i < E1000_RAR_ENTRIES; i++) {
+ 		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
+ 		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
+ 	}
+ }
+ 
+ /******************************************************************************
+  * Clears the VLAN filer table
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static void
+ e1000_clear_vfta(struct e1000_hw *hw)
+ {
+ 	uint32_t offset;
+     
+ 	for(offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++)
+ 		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, 0);
+ }
+ 
+ /******************************************************************************
+  * Set the phy type member in the hw struct.
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static int32_t
+ e1000_set_phy_type(struct e1000_hw *hw)
+ {
+ 	DEBUGFUNC("e1000_set_phy_type");
+ 
+ 	switch(hw->phy_id) {
+ 	case M88E1000_E_PHY_ID:
+ 	case M88E1000_I_PHY_ID:
+ 	case M88E1011_I_PHY_ID:
+ 		hw->phy_type = e1000_phy_m88;
+ 		break;
+ 	case IGP01E1000_I_PHY_ID:
+ 		hw->phy_type = e1000_phy_igp;
+ 		break;
+ 	default:
+ 		/* Should never have loaded on this device */
+ 		hw->phy_type = e1000_phy_undefined;
+ 		return -E1000_ERR_PHY_TYPE;
+ 	}
+ 
+ 	return E1000_SUCCESS;
+ }
+ 
+ /******************************************************************************
+  * IGP phy init script - initializes the GbE PHY
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static void
+ e1000_phy_init_script(struct e1000_hw *hw)
+ {
+ 	DEBUGFUNC("e1000_phy_init_script");
+ 
+ 	if(hw->phy_init_script) {
+ 		mdelay(10);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
+ 		e1000_write_phy_reg(hw,0x0000,0x0140);
+ 
+ 		mdelay(5);
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F95);
+ 		e1000_write_phy_reg(hw,0x0015,0x0001);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F71);
+ 		e1000_write_phy_reg(hw,0x0011,0xBD21);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F79);
+ 		e1000_write_phy_reg(hw,0x0019,0x0018);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F30);
+ 		e1000_write_phy_reg(hw,0x0010,0x1600);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F31);
+ 		e1000_write_phy_reg(hw,0x0011,0x0014);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F32);
+ 		e1000_write_phy_reg(hw,0x0012,0x161C);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F94);
+ 		e1000_write_phy_reg(hw,0x0014,0x0003);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F96);
+ 		e1000_write_phy_reg(hw,0x0016,0x003F);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x2010);
+ 		e1000_write_phy_reg(hw,0x0010,0x0008);
+ 
+ 		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
+ 		e1000_write_phy_reg(hw,0x0000,0x3300);
+ 
+ 
+ 		if(hw->mac_type == e1000_82547) {
+ 			uint16_t fused, fine, coarse;
+ 
+ 			/* Move to analog registers page */
+ 			e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+ 					IGP01E1000_ANALOG_REGS_PAGE);
+ 
+ 			e1000_read_phy_reg(hw, IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);
+ 
+ 			if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
+ 				e1000_read_phy_reg(hw, IGP01E1000_ANALOG_FUSE_STATUS, &fused);
+ 
+ 				fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
+ 				coarse = fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;
+ 
+ 				if(coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
+ 					coarse -= IGP01E1000_ANALOG_FUSE_COARSE_10;
+ 					fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
+ 				} else if(coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
+ 					fine -= IGP01E1000_ANALOG_FUSE_FINE_10;
+ 
+ 				fused = (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
+ 					(fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
+ 					(coarse & IGP01E1000_ANALOG_FUSE_COARSE_MASK);
+ 
+ 				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_CONTROL, fused);
+ 				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_BYPASS,
+ 						IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
+ 			}
+ 			/* Return to first page of registers */
+ 			e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+ 					IGP01E1000_IEEE_REGS_PAGE);
+ 		}
+ 	}
+ }
+ 
+ /******************************************************************************
+  * Set the mac type member in the hw struct.
+  * 
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static int
+ e1000_set_mac_type(struct e1000_hw *hw)
+ {
+ 	DEBUGFUNC("e1000_set_mac_type");
+ 
+ 	switch (hw->device_id) {
+ 	case E1000_DEV_ID_82542:
+ 		switch (hw->revision_id) {
+ 		case E1000_82542_2_0_REV_ID:
+ 			hw->mac_type = e1000_82542_rev2_0;
+ 			break;
+ 		case E1000_82542_2_1_REV_ID:
+ 			hw->mac_type = e1000_82542_rev2_1;
+ 			break;
+ 		default:
+ 			/* Invalid 82542 revision ID */
+ 			return -E1000_ERR_MAC_TYPE;
+ 		}
+ 		break;
+ 	case E1000_DEV_ID_82543GC_FIBER:
+ 	case E1000_DEV_ID_82543GC_COPPER:
+ 		hw->mac_type = e1000_82543;
+ 		break;
+ 	case E1000_DEV_ID_82544EI_COPPER:
+ 	case E1000_DEV_ID_82544EI_FIBER:
+ 	case E1000_DEV_ID_82544GC_COPPER:
+ 	case E1000_DEV_ID_82544GC_LOM:
+ 		hw->mac_type = e1000_82544;
+ 		break;
+ 	case E1000_DEV_ID_82540EM:
+ 	case E1000_DEV_ID_82540EM_LOM:
+ 	case E1000_DEV_ID_82540EP:
+ 	case E1000_DEV_ID_82540EP_LOM:
+ 	case E1000_DEV_ID_82540EP_LP:
+ 		hw->mac_type = e1000_82540;
+ 		break;
+ 	case E1000_DEV_ID_82545EM_COPPER:
+ 	case E1000_DEV_ID_82545EM_FIBER:
+ 		hw->mac_type = e1000_82545;
+ 		break;
+ 	case E1000_DEV_ID_82546EB_COPPER:
+ 	case E1000_DEV_ID_82546EB_FIBER:
+ 	case E1000_DEV_ID_82546EB_QUAD_COPPER:
+ 		hw->mac_type = e1000_82546;
+ 		break;
+ 	case E1000_DEV_ID_82541EI:
+ 	case E1000_DEV_ID_82541EP:
+ 		hw->mac_type = e1000_82541;
+ 		break;
+ 	case E1000_DEV_ID_82547EI:
+ 		hw->mac_type = e1000_82547;
+ 		break;
+ 	default:
+ 		/* Should never have loaded on this device */
+ 		return -E1000_ERR_MAC_TYPE;
+ 	}
+ 
+ 
+ 	return E1000_SUCCESS;
+ }
+ 
+ /******************************************************************************
+  * Reset the transmit and receive units; mask and clear all interrupts.
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static void
+ e1000_reset_hw(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl;
+ 	uint32_t ctrl_ext;
+ 	uint32_t icr;
+ 	uint32_t manc;
+ 	
+ 	DEBUGFUNC("e1000_reset_hw");
+ 	
+ 	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
+ 	if(hw->mac_type == e1000_82542_rev2_0) {
+ 		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+ 		e1000_pci_clear_mwi(hw);
+ 	}
+ 
+ 	/* Clear interrupt mask to stop board from generating interrupts */
+ 	DEBUGOUT("Masking off all interrupts\n");
+ 	E1000_WRITE_REG(hw, IMC, 0xffffffff);
+ 	
+ 	/* Disable the Transmit and Receive units.  Then delay to allow
+ 	 * any pending transactions to complete before we hit the MAC with
+ 	 * the global reset.
+ 	 */
+ 	E1000_WRITE_REG(hw, RCTL, 0);
+ 	E1000_WRITE_REG(hw, TCTL, E1000_TCTL_PSP);
+ 	E1000_WRITE_FLUSH(hw);
+ 
+ 	/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
+ 	hw->tbi_compatibility_on = FALSE;
+ 
+ 	/* Delay to allow any outstanding PCI transactions to complete before
+ 	 * resetting the device
+ 	 */ 
+ 	mdelay(10);
+ 
+ 	/* Issue a global reset to the MAC.  This will reset the chip's
+ 	 * transmit, receive, DMA, and link units.  It will not effect
+ 	 * the current PCI configuration.  The global reset bit is self-
+ 	 * clearing, and should clear within a microsecond.
+ 	 */
+ 	DEBUGOUT("Issuing a global reset to MAC\n");
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 
+ 	/* Must reset the PHY before resetting the MAC */
+ 	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+ #ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+ 		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
+ #else
+ 		E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
+ #endif
+ 		mdelay(5);
+ 	}
+ 
+ #ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+ 	switch(hw->mac_type) {
+ 		case e1000_82544:
+ 		case e1000_82540:
+ 		case e1000_82545:
+ 		case e1000_82546:
+ 		case e1000_82541:
+ 			/* These controllers can't ack the 64-bit write when issuing the
+ 			 * reset, so use IO-mapping as a workaround to issue the reset */
+ 			E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
+ 			break;
+ 		default:
+ #endif
+ 			E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
+ #ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+ 			break;
+ 	}
+ #endif
+ 
+ 	/* Force a reload from the EEPROM if necessary */
+ 	if(hw->mac_type < e1000_82540) {
+ 		/* Wait for reset to complete */
+ 		udelay(10);
+ 		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+ 		ctrl_ext |= E1000_CTRL_EXT_EE_RST;
+ 		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+ 		E1000_WRITE_FLUSH(hw);
+ 		/* Wait for EEPROM reload */
+ 		mdelay(2);
+ 	} else {
+ 		/* Wait for EEPROM reload (it happens automatically) */
+ 		mdelay(5);
+ 		/* Dissable HW ARPs on ASF enabled adapters */
+ 		manc = E1000_READ_REG(hw, MANC);
+ 		manc &= ~(E1000_MANC_ARP_EN);
+ 		E1000_WRITE_REG(hw, MANC, manc);
+ 	}
+ 
+ 	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+ 		e1000_phy_init_script(hw);
+ 	}
+ 
+ 	/* Clear interrupt mask to stop board from generating interrupts */
+ 	DEBUGOUT("Masking off all interrupts\n");
+ 	E1000_WRITE_REG(hw, IMC, 0xffffffff);
+ 	
+ 	/* Clear any pending interrupt events. */
+ 	icr = E1000_READ_REG(hw, ICR);
+ 
+ 	/* If MWI was previously enabled, reenable it. */
+ 	if(hw->mac_type == e1000_82542_rev2_0) {
+ #ifdef LINUX_DRIVER
+ 		if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
+ #endif
+ 			e1000_pci_set_mwi(hw);
+ 	}
+ }
+ 
+ /******************************************************************************
+  * Performs basic configuration of the adapter.
+  *
+  * hw - Struct containing variables accessed by shared code
+  * 
+  * Assumes that the controller has previously been reset and is in a 
+  * post-reset uninitialized state. Initializes the receive address registers,
+  * multicast table, and VLAN filter table. Calls routines to setup link
+  * configuration and flow control settings. Clears all on-chip counters. Leaves
+  * the transmit and receive units disabled and uninitialized.
+  *****************************************************************************/
+ static int
+ e1000_init_hw(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl, status;
+ 	uint32_t i;
+ 	int32_t ret_val;
+ 	uint16_t pcix_cmd_word;
+ 	uint16_t pcix_stat_hi_word;
+ 	uint16_t cmd_mmrbc;
+ 	uint16_t stat_mmrbc;
+ 	e1000_bus_type bus_type = e1000_bus_type_unknown;
+ 
+ 	DEBUGFUNC("e1000_init_hw");
+ 
+ #if 0
+ 	/* Initialize Identification LED */
+ 	ret_val = e1000_id_led_init(hw);
+ 	if(ret_val < 0) {
+ 		DEBUGOUT("Error Initializing Identification LED\n");
+ 		return ret_val;
+ 	}
+ #endif
+ 	
+ 	/* Set the Media Type and exit with error if it is not valid. */
+ 	if(hw->mac_type != e1000_82543) {
+ 		/* tbi_compatibility is only valid on 82543 */
+ 		hw->tbi_compatibility_en = FALSE;
+ 	}
+ 	
+ 	if(hw->mac_type >= e1000_82543) {
+ 		status = E1000_READ_REG(hw, STATUS);
+ 		if(status & E1000_STATUS_TBIMODE) {
+ 			hw->media_type = e1000_media_type_fiber;
+ 			/* tbi_compatibility not valid on fiber */
+ 			hw->tbi_compatibility_en = FALSE;
+ 		} else {
+ 			hw->media_type = e1000_media_type_copper;
+ 		}
+ 	} else {
+ 		/* This is an 82542 (fiber only) */
+ 		hw->media_type = e1000_media_type_fiber;
+ 	}
+ 	
+ 	/* Disabling VLAN filtering. */
+ 	DEBUGOUT("Initializing the IEEE VLAN\n");
+ 	E1000_WRITE_REG(hw, VET, 0);
+ 	
+ 	e1000_clear_vfta(hw);
+ 	
+ 	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
+ 	if(hw->mac_type == e1000_82542_rev2_0) {
+ 		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+ 		e1000_pci_clear_mwi(hw);
+ 		E1000_WRITE_REG(hw, RCTL, E1000_RCTL_RST);
+ 		E1000_WRITE_FLUSH(hw);
+ 		mdelay(5);
+ 	}
+ 	
+ 	/* Setup the receive address. This involves initializing all of the Receive
+ 	 * Address Registers (RARs 0 - 15).
+ 	 */
+ 	e1000_init_rx_addrs(hw);
+ 	
+ 	/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
+ 	if(hw->mac_type == e1000_82542_rev2_0) {
+ 		E1000_WRITE_REG(hw, RCTL, 0);
+ 		E1000_WRITE_FLUSH(hw);
+ 		mdelay(1);
+ #ifdef LINUX_DRIVER
+ 		if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
+ #endif
+ 			e1000_pci_set_mwi(hw);
+ 	}
+ 	
+ 	/* Zero out the Multicast HASH table */
+ 	DEBUGOUT("Zeroing the MTA\n");
+ 	for(i = 0; i < E1000_MC_TBL_SIZE; i++)
+ 		E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
+ 	
+ #if 0
+ 	/* Set the PCI priority bit correctly in the CTRL register.  This
+ 	 * determines if the adapter gives priority to receives, or if it
+ 	 * gives equal priority to transmits and receives.
+ 	 */
+ 	if(hw->dma_fairness) {
+ 		ctrl = E1000_READ_REG(hw, CTRL);
+ 		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PRIOR);
+ 	}
+ #endif
+ 	if (hw->mac_type >= e1000_82543) {
+ 		status = E1000_READ_REG(hw, STATUS);
+ 		bus_type = (status & E1000_STATUS_PCIX_MODE) ?
+ 			e1000_bus_type_pcix : e1000_bus_type_pci;
+ 	}
+ 	
+ 	/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
+ 	if(bus_type == e1000_bus_type_pcix) {
+ 		pci_read_config_word(hw->pdev, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
+ 		pci_read_config_word(hw->pdev, PCIX_STATUS_REGISTER_HI, &pcix_stat_hi_word);
+ 		cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
+ 			PCIX_COMMAND_MMRBC_SHIFT;
+ 		stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
+ 			PCIX_STATUS_HI_MMRBC_SHIFT;
+ 		if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
+ 			stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
+ 		if(cmd_mmrbc > stat_mmrbc) {
+ 			pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
+ 			pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
+ 			pci_write_config_word(hw->pdev, PCIX_COMMAND_REGISTER, pcix_cmd_word);
+ 		}
+ 	}
+ 	
+ 	/* Call a subroutine to configure the link and setup flow control. */
+ 	ret_val = e1000_setup_link(hw);
+ 	
+ 	/* Set the transmit descriptor write-back policy */
+ 	if(hw->mac_type > e1000_82544) {
+ 		ctrl = E1000_READ_REG(hw, TXDCTL);
+ 		ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
+ 		E1000_WRITE_REG(hw, TXDCTL, ctrl);
+ 	}
+ #if 0
+ 	/* Clear all of the statistics registers (clear on read).  It is
+ 	 * important that we do this after we have tried to establish link
+ 	 * because the symbol error count will increment wildly if there
+ 	 * is no link.
+ 	 */
+ 	e1000_clear_hw_cntrs(hw);
+ #endif
+ 
+ 	return ret_val;
+ }
+ 
+ /******************************************************************************
+  * Configures flow control and link settings.
+  * 
+  * hw - Struct containing variables accessed by shared code
+  * 
+  * Determines which flow control settings to use. Calls the apropriate media-
+  * specific link configuration function. Configures the flow control settings.
+  * Assuming the adapter has a valid link partner, a valid link should be
+  * established. Assumes the hardware has previously been reset and the 
+  * transmitter and receiver are not enabled.
+  *****************************************************************************/
+ static int
+ e1000_setup_link(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl_ext;
+ 	int32_t ret_val;
+ 	uint16_t eeprom_data;
+ 
+ 	DEBUGFUNC("e1000_setup_link");
+ 	
+ 	/* Read and store word 0x0F of the EEPROM. This word contains bits
+ 	 * that determine the hardware's default PAUSE (flow control) mode,
+ 	 * a bit that determines whether the HW defaults to enabling or
+ 	 * disabling auto-negotiation, and the direction of the
+ 	 * SW defined pins. If there is no SW over-ride of the flow
+ 	 * control setting, then the variable hw->fc will
+ 	 * be initialized based on a value in the EEPROM.
+ 	 */
+ 	if(e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data) < 0) {
+ 		DEBUGOUT("EEPROM Read Error\n");
+ 		return -E1000_ERR_EEPROM;
+ 	}
+ 	
+ 	if(hw->fc == e1000_fc_default) {
+ 		if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
+ 			hw->fc = e1000_fc_none;
+ 		else if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 
+ 			EEPROM_WORD0F_ASM_DIR)
+ 			hw->fc = e1000_fc_tx_pause;
+ 		else
+ 			hw->fc = e1000_fc_full;
+ 	}
+ 	
+ 	/* We want to save off the original Flow Control configuration just
+ 	 * in case we get disconnected and then reconnected into a different
+ 	 * hub or switch with different Flow Control capabilities.
+ 	 */
+ 	if(hw->mac_type == e1000_82542_rev2_0)
+ 		hw->fc &= (~e1000_fc_tx_pause);
+ 	
+ 	if((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
+ 		hw->fc &= (~e1000_fc_rx_pause);
+ 	
+ 	hw->original_fc = hw->fc;
+ 	
+ 	DEBUGOUT1("After fix-ups FlowControl is now = %x\n", hw->fc);
+ 	
+ 	/* Take the 4 bits from EEPROM word 0x0F that determine the initial
+ 	 * polarity value for the SW controlled pins, and setup the
+ 	 * Extended Device Control reg with that info.
+ 	 * This is needed because one of the SW controlled pins is used for
+ 	 * signal detection.  So this should be done before e1000_setup_pcs_link()
+ 	 * or e1000_phy_setup() is called.
+ 	 */
+ 	if(hw->mac_type == e1000_82543) {
+ 		ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) << 
+ 			SWDPIO__EXT_SHIFT);
+ 		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+ 	}
+ 	
+ 	/* Call the necessary subroutine to configure the link. */
+ 	ret_val = (hw->media_type == e1000_media_type_fiber) ?
+ 		e1000_setup_fiber_link(hw) :
+ 		e1000_setup_copper_link(hw);
+ 	if (ret_val < 0) {
+ 		return ret_val;
+ 	}
+ 	
+ 	/* Initialize the flow control address, type, and PAUSE timer
+ 	 * registers to their default values.  This is done even if flow
+ 	 * control is disabled, because it does not hurt anything to
+ 	 * initialize these registers.
+ 	 */
+ 	DEBUGOUT("Initializing the Flow Control address, type and timer regs\n");
+ 	
+ 	E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
+ 	E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
+ 	E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
+ 	E1000_WRITE_REG(hw, FCTTV, hw->fc_pause_time);
+ 	
+ 	/* Set the flow control receive threshold registers.  Normally,
+ 	 * these registers will be set to a default threshold that may be
+ 	 * adjusted later by the driver's runtime code.  However, if the
+ 	 * ability to transmit pause frames in not enabled, then these
+ 	 * registers will be set to 0. 
+ 	 */
+ 	if(!(hw->fc & e1000_fc_tx_pause)) {
+ 		E1000_WRITE_REG(hw, FCRTL, 0);
+ 		E1000_WRITE_REG(hw, FCRTH, 0);
+ 	} else {
+ 		/* We need to set up the Receive Threshold high and low water marks
+ 		 * as well as (optionally) enabling the transmission of XON frames.
+ 		 */
+ 		if(hw->fc_send_xon) {
+ 			E1000_WRITE_REG(hw, FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
+ 			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
+ 		} else {
+ 			E1000_WRITE_REG(hw, FCRTL, hw->fc_low_water);
+ 			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
+ 		}
+ 	}
+ 	return ret_val;
+ }
+ 
+ /******************************************************************************
+  * Sets up link for a fiber based adapter
+  *
+  * hw - Struct containing variables accessed by shared code
+  *
+  * Manipulates Physical Coding Sublayer functions in order to configure
+  * link. Assumes the hardware has been previously reset and the transmitter
+  * and receiver are not enabled.
+  *****************************************************************************/
+ static int
+ e1000_setup_fiber_link(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl;
+ 	uint32_t status;
+ 	uint32_t txcw = 0;
+ 	uint32_t i;
+ 	uint32_t signal;
+ 	int32_t ret_val;
+ 
+ 	DEBUGFUNC("e1000_setup_fiber_link");
+ 
+ 	/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
+ 	 * set when the optics detect a signal. On older adapters, it will be 
+ 	 * cleared when there is a signal
+ 	 */
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	if(hw->mac_type > e1000_82544) signal = E1000_CTRL_SWDPIN1;
+ 	else signal = 0;
+ 	
+ 	/* Take the link out of reset */
+ 	ctrl &= ~(E1000_CTRL_LRST);
+ 	
+ 	e1000_config_collision_dist(hw);
+ 	
+ 	/* Check for a software override of the flow control settings, and setup
+ 	 * the device accordingly.  If auto-negotiation is enabled, then software
+ 	 * will have to set the "PAUSE" bits to the correct value in the Tranmsit
+ 	 * Config Word Register (TXCW) and re-start auto-negotiation.  However, if
+ 	 * auto-negotiation is disabled, then software will have to manually 
+ 	 * configure the two flow control enable bits in the CTRL register.
+ 	 *
+ 	 * The possible values of the "fc" parameter are:
+ 	 *      0:  Flow control is completely disabled
+ 	 *      1:  Rx flow control is enabled (we can receive pause frames, but 
+ 	 *          not send pause frames).
+ 	 *      2:  Tx flow control is enabled (we can send pause frames but we do
+ 	 *          not support receiving pause frames).
+ 	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
+ 	 */
+ 	switch (hw->fc) {
+ 	case e1000_fc_none:
+ 		/* Flow control is completely disabled by a software over-ride. */
+ 		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD);
+ 		break;
+ 	case e1000_fc_rx_pause:
+ 		/* RX Flow control is enabled and TX Flow control is disabled by a 
+ 		 * software over-ride. Since there really isn't a way to advertise 
+ 		 * that we are capable of RX Pause ONLY, we will advertise that we
+ 		 * support both symmetric and asymmetric RX PAUSE. Later, we will
+ 		 *  disable the adapter's ability to send PAUSE frames.
+ 		 */
+ 		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+ 		break;
+ 	case e1000_fc_tx_pause:
+ 		/* TX Flow control is enabled, and RX Flow control is disabled, by a 
+ 		 * software over-ride.
+ 		 */
+ 		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
+ 		break;
+ 	case e1000_fc_full:
+ 		/* Flow control (both RX and TX) is enabled by a software over-ride. */
+ 		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+ 		break;
+ 	default:
+ 		DEBUGOUT("Flow control param set incorrectly\n");
+ 		return -E1000_ERR_CONFIG;
+ 		break;
+ 	}
+ 	
+ 	/* Since auto-negotiation is enabled, take the link out of reset (the link
+ 	 * will be in reset, because we previously reset the chip). This will
+ 	 * restart auto-negotiation.  If auto-neogtiation is successful then the
+ 	 * link-up status bit will be set and the flow control enable bits (RFCE
+ 	 * and TFCE) will be set according to their negotiated value.
+ 	 */
+ 	DEBUGOUT("Auto-negotiation enabled\n");
+ 	
+ 	E1000_WRITE_REG(hw, TXCW, txcw);
+ 	E1000_WRITE_REG(hw, CTRL, ctrl);
+ 	E1000_WRITE_FLUSH(hw);
+ 	
+ 	hw->txcw = txcw;
+ 	mdelay(1);
+ 	
+ 	/* If we have a signal (the cable is plugged in) then poll for a "Link-Up"
+ 	 * indication in the Device Status Register.  Time-out if a link isn't 
+ 	 * seen in 500 milliseconds seconds (Auto-negotiation should complete in 
+ 	 * less than 500 milliseconds even if the other end is doing it in SW).
+ 	 */
+ 	if((E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
+ 		DEBUGOUT("Looking for Link\n");
+ 		for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
+ 			mdelay(10);
+ 			status = E1000_READ_REG(hw, STATUS);
+ 			if(status & E1000_STATUS_LU) break;
+ 		}
+ 		if(i == (LINK_UP_TIMEOUT / 10)) {
+ 			/* AutoNeg failed to achieve a link, so we'll call 
+ 			 * e1000_check_for_link. This routine will force the link up if we
+ 			 * detect a signal. This will allow us to communicate with
+ 			 * non-autonegotiating link partners.
+ 			 */
+ 			DEBUGOUT("Never got a valid link from auto-neg!!!\n");
+ 			hw->autoneg_failed = 1;
+ 			ret_val = e1000_check_for_link(hw);
+ 			if(ret_val < 0) {
+ 				DEBUGOUT("Error while checking for link\n");
+ 				return ret_val;
+ 			}
+ 			hw->autoneg_failed = 0;
+ 		} else {
+ 			hw->autoneg_failed = 0;
+ 			DEBUGOUT("Valid Link Found\n");
+ 		}
+ 	} else {
+ 		DEBUGOUT("No Signal Detected\n");
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+ * Detects which PHY is present and the speed and duplex
+ *
+ * hw - Struct containing variables accessed by shared code
+ ******************************************************************************/
+ static int
+ e1000_setup_copper_link(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl;
+ 	int32_t ret_val;
+ 	uint16_t i;
+ 	uint16_t phy_data;
+ 	
+ 	DEBUGFUNC("e1000_setup_copper_link");
+ 	
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	/* With 82543, we need to force speed and duplex on the MAC equal to what
+ 	 * the PHY speed and duplex configuration is. In addition, we need to
+ 	 * perform a hardware reset on the PHY to take it out of reset.
+ 	 */
+ 	if(hw->mac_type > e1000_82543) {
+ 		ctrl |= E1000_CTRL_SLU;
+ 		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+ 		E1000_WRITE_REG(hw, CTRL, ctrl);
+ 	} else {
+ 		ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
+ 		E1000_WRITE_REG(hw, CTRL, ctrl);
+ 		e1000_phy_hw_reset(hw);
+ 	}
+ 	
+ 	/* Make sure we have a valid PHY */
+ 	ret_val = e1000_detect_gig_phy(hw);
+ 	if(ret_val < 0) {
+ 		DEBUGOUT("Error, did not detect valid phy.\n");
+ 		return ret_val;
+ 	}
+ 	DEBUGOUT1("Phy ID = %x \n", hw->phy_id);
+ 
+ 	if (hw->phy_type == e1000_phy_igp) {
+ 
+ 		ret_val = e1000_phy_reset(hw);
+ 		if(ret_val < 0) {
+ 			DEBUGOUT("Error Resetting the PHY\n");
+ 			return ret_val;
+ 		}
+ 
+ 		/* Wait 10ms for MAC to configure PHY from eeprom settings */
+ 		mdelay(15);
+ 
+ 		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
+ 			DEBUGOUT("PHY Write Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 
+ 		if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
+ 			/* Disable SmartSpeed */
+ 			if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
+ 						&phy_data) < 0) {
+ 				DEBUGOUT("PHY Read Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
+ 			if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
+ 						phy_data) < 0) {
+ 				DEBUGOUT("PHY Write Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 			/* Set auto Master/Slave resolution process */
+ 			if(e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data) < 0) {
+ 				DEBUGOUT("PHY Read Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 			phy_data &= ~CR_1000T_MS_ENABLE;
+ 			if(e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data) < 0) {
+ 				DEBUGOUT("PHY Write Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 		}
+ 
+ 		if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 
+ 		/* Force MDI for IGP PHY */
+ 		phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
+ 			      IGP01E1000_PSCR_FORCE_MDI_MDIX);
+ 
+ 		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data) < 0) {
+ 			DEBUGOUT("PHY Write Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 
+ 	} else {
+ 		/* Enable CRS on TX. This must be set for half-duplex operation. */
+ 		if(e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+ 		phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+ 
+ 		/* Options:
+ 		 *   disable_polarity_correction = 0 (default)
+ 		 *       Automatic Correction for Reversed Cable Polarity
+ 		 *   0 - Disabled
+ 		 *   1 - Enabled
+ 		 */
+ 		phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+ 		if(e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
+ 			DEBUGOUT("PHY Write Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 
+ 		/* Force TX_CLK in the Extended PHY Specific Control Register
+ 		 * to 25MHz clock.
+ 		 */
+ 		if(e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		phy_data |= M88E1000_EPSCR_TX_CLK_25;
+ 
+ #ifdef LINUX_DRIVER
+ 		if (hw->phy_revision < M88E1011_I_REV_4) {
+ #endif
+ 			/* Configure Master and Slave downshift values */
+ 			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
+ 				M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
+ 			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
+ 				M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
+ 			if(e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+ 					       phy_data) < 0) {
+ 				DEBUGOUT("PHY Write Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 		}
+ 	
+ 		/* SW Reset the PHY so all changes take effect */
+ 		ret_val = e1000_phy_reset(hw);
+ 		if(ret_val < 0) {
+ 			DEBUGOUT("Error Resetting the PHY\n");
+ 			return ret_val;
+ #ifdef LINUX_DRIVER
+ 		}
+ #endif
+ 	}
+ 	
+ 	/* Options:
+ 	 *   autoneg = 1 (default)
+ 	 *      PHY will advertise value(s) parsed from
+ 	 *      autoneg_advertised and fc
+ 	 *   autoneg = 0
+ 	 *      PHY will be set to 10H, 10F, 100H, or 100F
+ 	 *      depending on value parsed from forced_speed_duplex.
+ 	 */
+ 	
+ 	/* Is autoneg enabled?  This is enabled by default or by software override.
+ 	 * If so, call e1000_phy_setup_autoneg routine to parse the
+ 	 * autoneg_advertised and fc options. If autoneg is NOT enabled, then the
+ 	 * user should have provided a speed/duplex override.  If so, then call
+ 	 * e1000_phy_force_speed_duplex to parse and set this up.
+ 	 */
+ 	/* Perform some bounds checking on the hw->autoneg_advertised
+ 	 * parameter.  If this variable is zero, then set it to the default.
+ 	 */
+ 	hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
+ 	
+ 	/* If autoneg_advertised is zero, we assume it was not defaulted
+ 	 * by the calling code so we set to advertise full capability.
+ 	 */
+ 	if(hw->autoneg_advertised == 0)
+ 		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+ 	
+ 	DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
+ 	ret_val = e1000_phy_setup_autoneg(hw);
+ 	if(ret_val < 0) {
+ 		DEBUGOUT("Error Setting up Auto-Negotiation\n");
+ 		return ret_val;
+ 	}
+ 	DEBUGOUT("Restarting Auto-Neg\n");
+ 	
+ 	/* Restart auto-negotiation by setting the Auto Neg Enable bit and
+ 	 * the Auto Neg Restart bit in the PHY control register.
+ 	 */
+ 	if(e1000_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
+ 		DEBUGOUT("PHY Read Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
+ 	if(e1000_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
+ 		DEBUGOUT("PHY Write Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 
+ #if 0	
+ 	/* Does the user want to wait for Auto-Neg to complete here, or
+ 	 * check at a later time (for example, callback routine).
+ 	 */
+ 	if(hw->wait_autoneg_complete) {
+ 		ret_val = e1000_wait_autoneg(hw);
+ 		if(ret_val < 0) {
+ 			DEBUGOUT("Error while waiting for autoneg to complete\n");
+ 			return ret_val;
+ 		}
+ 	}
+ #else
+ 	/* If we do not wait for autonegotiation to complete I 
+ 	 * do not see a valid link status.
+ 	 */
+ 	ret_val = e1000_wait_autoneg(hw);
+ 	if(ret_val < 0) {
+ 		DEBUGOUT("Error while waiting for autoneg to complete\n");
+ 		return ret_val;
+ 	}
+ #endif
+ 	
+ 	/* Check link status. Wait up to 100 microseconds for link to become
+ 	 * valid.
+ 	 */
+ 	for(i = 0; i < 10; i++) {
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(phy_data & MII_SR_LINK_STATUS) {
+ 			/* We have link, so we need to finish the config process:
+ 			 *   1) Set up the MAC to the current PHY speed/duplex
+ 			 *      if we are on 82543.  If we
+ 			 *      are on newer silicon, we only need to configure
+ 			 *      collision distance in the Transmit Control Register.
+ 			 *   2) Set up flow control on the MAC to that established with
+ 			 *      the link partner.
+ 			 */
+ 			if(hw->mac_type >= e1000_82544) {
+ 				e1000_config_collision_dist(hw);
+ 			} else {
+ 				ret_val = e1000_config_mac_to_phy(hw);
+ 				if(ret_val < 0) {
+ 					DEBUGOUT("Error configuring MAC to PHY settings\n");
+ 					return ret_val;
+ 				}
+ 			}
+ 			ret_val = e1000_config_fc_after_link_up(hw);
+ 			if(ret_val < 0) {
+ 				DEBUGOUT("Error Configuring Flow Control\n");
+ 				return ret_val;
+ 			}
+ 			DEBUGOUT("Valid link established!!!\n");
+ 			return 0;
+ 		}
+ 		udelay(10);
+ 	}
+ 	
+ 	DEBUGOUT("Unable to establish link!!!\n");
+ 	return -E1000_ERR_NOLINK;
+ }
+ 
+ /******************************************************************************
+ * Configures PHY autoneg and flow control advertisement settings
+ *
+ * hw - Struct containing variables accessed by shared code
+ ******************************************************************************/
+ static int
+ e1000_phy_setup_autoneg(struct e1000_hw *hw)
+ {
+ 	uint16_t mii_autoneg_adv_reg;
+ 	uint16_t mii_1000t_ctrl_reg;
+ 
+ 	DEBUGFUNC("e1000_phy_setup_autoneg");
+ 	
+ 	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
+ 	if(e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg) < 0) {
+ 		DEBUGOUT("PHY Read Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 
+ 	/* Read the MII 1000Base-T Control Register (Address 9). */
+ 	if(e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg) < 0) {
+ 		DEBUGOUT("PHY Read Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 
+ 	/* Need to parse both autoneg_advertised and fc and set up
+ 	 * the appropriate PHY registers.  First we will parse for
+ 	 * autoneg_advertised software override.  Since we can advertise
+ 	 * a plethora of combinations, we need to check each bit
+ 	 * individually.
+ 	 */
+ 	
+ 	/* First we clear all the 10/100 mb speed bits in the Auto-Neg
+ 	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
+ 	 * the  1000Base-T Control Register (Address 9).
+ 	 */
+ 	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
+ 	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
+ 
+ 	DEBUGOUT1("autoneg_advertised %x\n", hw->autoneg_advertised);
+ 
+ 	/* Do we want to advertise 10 Mb Half Duplex? */
+ 	if(hw->autoneg_advertised & ADVERTISE_10_HALF) {
+ 		DEBUGOUT("Advertise 10mb Half duplex\n");
+ 		mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
+ 	}
+ 
+ 	/* Do we want to advertise 10 Mb Full Duplex? */
+ 	if(hw->autoneg_advertised & ADVERTISE_10_FULL) {
+ 		DEBUGOUT("Advertise 10mb Full duplex\n");
+ 		mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
+ 	}
+ 
+ 	/* Do we want to advertise 100 Mb Half Duplex? */
+ 	if(hw->autoneg_advertised & ADVERTISE_100_HALF) {
+ 		DEBUGOUT("Advertise 100mb Half duplex\n");
+ 		mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
+ 	}
+ 
+ 	/* Do we want to advertise 100 Mb Full Duplex? */
+ 	if(hw->autoneg_advertised & ADVERTISE_100_FULL) {
+ 		DEBUGOUT("Advertise 100mb Full duplex\n");
+ 		mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
+ 	}
+ 
+ 	/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
+ 	if(hw->autoneg_advertised & ADVERTISE_1000_HALF) {
+ 		DEBUGOUT("Advertise 1000mb Half duplex requested, request denied!\n");
+ 	}
+ 
+ 	/* Do we want to advertise 1000 Mb Full Duplex? */
+ 	if(hw->autoneg_advertised & ADVERTISE_1000_FULL) {
+ 		DEBUGOUT("Advertise 1000mb Full duplex\n");
+ 		mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
+ 	}
+ 
+ 	/* Check for a software override of the flow control settings, and
+ 	 * setup the PHY advertisement registers accordingly.  If
+ 	 * auto-negotiation is enabled, then software will have to set the
+ 	 * "PAUSE" bits to the correct value in the Auto-Negotiation
+ 	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.
+ 	 *
+ 	 * The possible values of the "fc" parameter are:
+ 	 *      0:  Flow control is completely disabled
+ 	 *      1:  Rx flow control is enabled (we can receive pause frames
+ 	 *          but not send pause frames).
+ 	 *      2:  Tx flow control is enabled (we can send pause frames
+ 	 *          but we do not support receiving pause frames).
+ 	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
+ 	 *  other:  No software override.  The flow control configuration
+ 	 *          in the EEPROM is used.
+ 	 */
+ 	switch (hw->fc) {
+ 	case e1000_fc_none: /* 0 */
+ 		/* Flow control (RX & TX) is completely disabled by a
+ 		 * software over-ride.
+ 		 */
+ 		mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+ 		break;
+ 	case e1000_fc_rx_pause: /* 1 */
+ 		/* RX Flow control is enabled, and TX Flow control is
+ 		 * disabled, by a software over-ride.
+ 		 */
+ 		/* Since there really isn't a way to advertise that we are
+ 		 * capable of RX Pause ONLY, we will advertise that we
+ 		 * support both symmetric and asymmetric RX PAUSE.  Later
+ 		 * (in e1000_config_fc_after_link_up) we will disable the
+ 		 *hw's ability to send PAUSE frames.
+ 		 */
+ 		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+ 		break;
+ 	case e1000_fc_tx_pause: /* 2 */
+ 		/* TX Flow control is enabled, and RX Flow control is
+ 		 * disabled, by a software over-ride.
+ 		 */
+ 		mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
+ 		mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
+ 		break;
+ 	case e1000_fc_full: /* 3 */
+ 		/* Flow control (both RX and TX) is enabled by a software
+ 		 * over-ride.
+ 		 */
+ 		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+ 		break;
+ 	default:
+ 		DEBUGOUT("Flow control param set incorrectly\n");
+ 		return -E1000_ERR_CONFIG;
+ 	}
+ 
+ 	if(e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg) < 0) {
+ 		DEBUGOUT("PHY Write Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 
+ 	DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
+ 
+ 	if(e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg) < 0) {
+ 		DEBUGOUT("PHY Write Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+ * Sets the collision distance in the Transmit Control register
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Link should have been established previously. Reads the speed and duplex
+ * information from the Device Status register.
+ ******************************************************************************/
+ static void
+ e1000_config_collision_dist(struct e1000_hw *hw)
+ {
+ 	uint32_t tctl;
+ 
+ 	tctl = E1000_READ_REG(hw, TCTL);
+ 	
+ 	tctl &= ~E1000_TCTL_COLD;
+ 	tctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+ 	
+ 	E1000_WRITE_REG(hw, TCTL, tctl);
+ 	E1000_WRITE_FLUSH(hw);
+ }
+ 
+ /******************************************************************************
+ * Sets MAC speed and duplex settings to reflect the those in the PHY
+ *
+ * hw - Struct containing variables accessed by shared code
+ * mii_reg - data to write to the MII control register
+ *
+ * The contents of the PHY register containing the needed information need to
+ * be passed in.
+ ******************************************************************************/
+ static int
+ e1000_config_mac_to_phy(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl;
+ 	uint16_t phy_data;
+ 
+ 	DEBUGFUNC("e1000_config_mac_to_phy");
+ 
+ 	/* Read the Device Control Register and set the bits to Force Speed
+ 	 * and Duplex.
+ 	 */
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+ 	ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
+ 
+ 	/* Set up duplex in the Device Control and Transmit Control
+ 	 * registers depending on negotiated values.
+ 	 */
+ 	if (hw->phy_type == e1000_phy_igp) {
+ 		if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
+ 		else ctrl &= ~E1000_CTRL_FD;
+ 
+ 		e1000_config_collision_dist(hw);
+ 
+ 		/* Set up speed in the Device Control register depending on
+ 		 * negotiated values.
+ 		 */
+ 		if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
+ 		   IGP01E1000_PSSR_SPEED_1000MBPS)
+ 			ctrl |= E1000_CTRL_SPD_1000;
+ 		else if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
+ 			IGP01E1000_PSSR_SPEED_100MBPS)
+ 			ctrl |= E1000_CTRL_SPD_100;
+ 	} else {
+ 		if(e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
+ 		else ctrl &= ~E1000_CTRL_FD;
+ 
+ 		e1000_config_collision_dist(hw);
+ 
+ 		/* Set up speed in the Device Control register depending on
+ 		 * negotiated values.
+ 		 */
+ 		if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+ 			ctrl |= E1000_CTRL_SPD_1000;
+ 		else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+ 			ctrl |= E1000_CTRL_SPD_100;
+ 	}
+ 	/* Write the configured values back to the Device Control Reg. */
+ 	E1000_WRITE_REG(hw, CTRL, ctrl);
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Forces the MAC's flow control settings.
+  * 
+  * hw - Struct containing variables accessed by shared code
+  *
+  * Sets the TFCE and RFCE bits in the device control register to reflect
+  * the adapter settings. TFCE and RFCE need to be explicitly set by
+  * software when a Copper PHY is used because autonegotiation is managed
+  * by the PHY rather than the MAC. Software must also configure these
+  * bits when link is forced on a fiber connection.
+  *****************************************************************************/
+ static int
+ e1000_force_mac_fc(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl;
+ 	
+ 	DEBUGFUNC("e1000_force_mac_fc");
+ 	
+ 	/* Get the current configuration of the Device Control Register */
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	
+ 	/* Because we didn't get link via the internal auto-negotiation
+ 	 * mechanism (we either forced link or we got link via PHY
+ 	 * auto-neg), we have to manually enable/disable transmit an
+ 	 * receive flow control.
+ 	 *
+ 	 * The "Case" statement below enables/disable flow control
+ 	 * according to the "hw->fc" parameter.
+ 	 *
+ 	 * The possible values of the "fc" parameter are:
+ 	 *      0:  Flow control is completely disabled
+ 	 *      1:  Rx flow control is enabled (we can receive pause
+ 	 *          frames but not send pause frames).
+ 	 *      2:  Tx flow control is enabled (we can send pause frames
+ 	 *          frames but we do not receive pause frames).
+ 	 *      3:  Both Rx and TX flow control (symmetric) is enabled.
+ 	 *  other:  No other values should be possible at this point.
+ 	 */
+ 	
+ 	switch (hw->fc) {
+ 	case e1000_fc_none:
+ 		ctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
+ 		break;
+ 	case e1000_fc_rx_pause:
+ 		ctrl &= (~E1000_CTRL_TFCE);
+ 		ctrl |= E1000_CTRL_RFCE;
+ 		break;
+ 	case e1000_fc_tx_pause:
+ 		ctrl &= (~E1000_CTRL_RFCE);
+ 		ctrl |= E1000_CTRL_TFCE;
+ 		break;
+ 	case e1000_fc_full:
+ 		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
+ 		break;
+ 	default:
+ 		DEBUGOUT("Flow control param set incorrectly\n");
+ 		return -E1000_ERR_CONFIG;
+ 	}
+ 	
+ 	/* Disable TX Flow Control for 82542 (rev 2.0) */
+ 	if(hw->mac_type == e1000_82542_rev2_0)
+ 		ctrl &= (~E1000_CTRL_TFCE);
+ 	
+ 	E1000_WRITE_REG(hw, CTRL, ctrl);
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Configures flow control settings after link is established
+  * 
+  * hw - Struct containing variables accessed by shared code
+  *
+  * Should be called immediately after a valid link has been established.
+  * Forces MAC flow control settings if link was forced. When in MII/GMII mode
+  * and autonegotiation is enabled, the MAC flow control settings will be set
+  * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
+  * and RFCE bits will be automaticaly set to the negotiated flow control mode.
+  *****************************************************************************/
+ static int
+ e1000_config_fc_after_link_up(struct e1000_hw *hw)
+ {
+ 	int32_t ret_val;
+ 	uint16_t mii_status_reg;
+ 	uint16_t mii_nway_adv_reg;
+ 	uint16_t mii_nway_lp_ability_reg;
+ 	uint16_t speed;
+ 	uint16_t duplex;
+ 	
+ 	DEBUGFUNC("e1000_config_fc_after_link_up");
+ 	
+ 	/* Check for the case where we have fiber media and auto-neg failed
+ 	 * so we had to force link.  In this case, we need to force the
+ 	 * configuration of the MAC to match the "fc" parameter.
+ 	 */
+ 	if((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) {
+ 		ret_val = e1000_force_mac_fc(hw);
+ 		if(ret_val < 0) {
+ 			DEBUGOUT("Error forcing flow control settings\n");
+ 			return ret_val;
+ 		}
+ 	}
+ 	
+ 	/* Check for the case where we have copper media and auto-neg is
+ 	 * enabled.  In this case, we need to check and see if Auto-Neg
+ 	 * has completed, and if so, how the PHY and link partner has
+ 	 * flow control configured.
+ 	 */
+ 	if(hw->media_type == e1000_media_type_copper) {
+ 		/* Read the MII Status Register and check to see if AutoNeg
+ 		 * has completed.  We read this twice because this reg has
+ 		 * some "sticky" (latched) bits.
+ 		 */
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
+ 			DEBUGOUT("PHY Read Error \n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
+ 			DEBUGOUT("PHY Read Error \n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		
+ 		if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+ 			/* The AutoNeg process has completed, so we now need to
+ 			 * read both the Auto Negotiation Advertisement Register
+ 			 * (Address 4) and the Auto_Negotiation Base Page Ability
+ 			 * Register (Address 5) to determine how flow control was
+ 			 * negotiated.
+ 			 */
+ 			if(e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_nway_adv_reg) < 0) {
+ 				DEBUGOUT("PHY Read Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 			if(e1000_read_phy_reg(hw, PHY_LP_ABILITY, &mii_nway_lp_ability_reg) < 0) {
+ 				DEBUGOUT("PHY Read Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 
+ 			/* Two bits in the Auto Negotiation Advertisement Register
+ 			 * (Address 4) and two bits in the Auto Negotiation Base
+ 			 * Page Ability Register (Address 5) determine flow control
+ 			 * for both the PHY and the link partner.  The following
+ 			 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,
+ 			 * 1999, describes these PAUSE resolution bits and how flow
+ 			 * control is determined based upon these settings.
+ 			 * NOTE:  DC = Don't Care
+ 			 *
+ 			 *   LOCAL DEVICE  |   LINK PARTNER
+ 			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
+ 			 *-------|---------|-------|---------|--------------------
+ 			 *   0   |    0    |  DC   |   DC    | e1000_fc_none
+ 			 *   0   |    1    |   0   |   DC    | e1000_fc_none
+ 			 *   0   |    1    |   1   |    0    | e1000_fc_none
+ 			 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+ 			 *   1   |    0    |   0   |   DC    | e1000_fc_none
+ 			 *   1   |   DC    |   1   |   DC    | e1000_fc_full
+ 			 *   1   |    1    |   0   |    0    | e1000_fc_none
+ 			 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+ 			 *
+ 			 */
+ 			/* Are both PAUSE bits set to 1?  If so, this implies
+ 			 * Symmetric Flow Control is enabled at both ends.  The
+ 			 * ASM_DIR bits are irrelevant per the spec.
+ 			 *
+ 			 * For Symmetric Flow Control:
+ 			 *
+ 			 *   LOCAL DEVICE  |   LINK PARTNER
+ 			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+ 			 *-------|---------|-------|---------|--------------------
+ 			 *   1   |   DC    |   1   |   DC    | e1000_fc_full
+ 			 *
+ 			 */
+ 			if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+ 				(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
+ 				/* Now we need to check if the user selected RX ONLY
+ 				 * of pause frames.  In this case, we had to advertise
+ 				 * FULL flow control because we could not advertise RX
+ 				 * ONLY. Hence, we must now check to see if we need to
+ 				 * turn OFF  the TRANSMISSION of PAUSE frames.
+ 				 */
+ 				if(hw->original_fc == e1000_fc_full) {
+ 					hw->fc = e1000_fc_full;
+ 					DEBUGOUT("Flow Control = FULL.\r\n");
+ 				} else {
+ 					hw->fc = e1000_fc_rx_pause;
+ 					DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+ 				}
+ 			}
+ 			/* For receiving PAUSE frames ONLY.
+ 			 *
+ 			 *   LOCAL DEVICE  |   LINK PARTNER
+ 			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+ 			 *-------|---------|-------|---------|--------------------
+ 			 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+ 			 *
+ 			 */
+ 			else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+ 				(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+ 				(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+ 				(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+ 				hw->fc = e1000_fc_tx_pause;
+ 				DEBUGOUT("Flow Control = TX PAUSE frames only.\r\n");
+ 			}
+ 			/* For transmitting PAUSE frames ONLY.
+ 			 *
+ 			 *   LOCAL DEVICE  |   LINK PARTNER
+ 			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+ 			 *-------|---------|-------|---------|--------------------
+ 			 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+ 			 *
+ 			 */
+ 			else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+ 				(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+ 				!(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+ 				(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+ 				hw->fc = e1000_fc_rx_pause;
+ 				DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+ 			}
+ 			/* Per the IEEE spec, at this point flow control should be
+ 			 * disabled.  However, we want to consider that we could
+ 			 * be connected to a legacy switch that doesn't advertise
+ 			 * desired flow control, but can be forced on the link
+ 			 * partner.  So if we advertised no flow control, that is
+ 			 * what we will resolve to.  If we advertised some kind of
+ 			 * receive capability (Rx Pause Only or Full Flow Control)
+ 			 * and the link partner advertised none, we will configure
+ 			 * ourselves to enable Rx Flow Control only.  We can do
+ 			 * this safely for two reasons:  If the link partner really
+ 			 * didn't want flow control enabled, and we enable Rx, no
+ 			 * harm done since we won't be receiving any PAUSE frames
+ 			 * anyway.  If the intent on the link partner was to have
+ 			 * flow control enabled, then by us enabling RX only, we
+ 			 * can at least receive pause frames and process them.
+ 			 * This is a good idea because in most cases, since we are
+ 			 * predominantly a server NIC, more times than not we will
+ 			 * be asked to delay transmission of packets than asking
+ 			 * our link partner to pause transmission of frames.
+ 			 */
+ 			else if(hw->original_fc == e1000_fc_none ||
+ 				hw->original_fc == e1000_fc_tx_pause) {
+ 				hw->fc = e1000_fc_none;
+ 				DEBUGOUT("Flow Control = NONE.\r\n");
+ 			} else {
+ 				hw->fc = e1000_fc_rx_pause;
+ 				DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+ 			}
+ 			
+ 			/* Now we need to do one last check...  If we auto-
+ 			 * negotiated to HALF DUPLEX, flow control should not be
+ 			 * enabled per IEEE 802.3 spec.
+ 			 */
+ 			e1000_get_speed_and_duplex(hw, &speed, &duplex);
+ 			
+ 			if(duplex == HALF_DUPLEX)
+ 				hw->fc = e1000_fc_none;
+ 			
+ 			/* Now we call a subroutine to actually force the MAC
+ 			 * controller to use the correct flow control settings.
+ 			 */
+ 			ret_val = e1000_force_mac_fc(hw);
+ 			if(ret_val < 0) {
+ 				DEBUGOUT("Error forcing flow control settings\n");
+ 				return ret_val;
+ 			}
+ 		} else {
+ 			DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Checks to see if the link status of the hardware has changed.
+  *
+  * hw - Struct containing variables accessed by shared code
+  *
+  * Called by any function that needs to check the link status of the adapter.
+  *****************************************************************************/
+ static int
+ e1000_check_for_link(struct e1000_hw *hw)
+ {
+ 	uint32_t rxcw;
+ 	uint32_t ctrl;
+ 	uint32_t status;
+ 	uint32_t rctl;
+ 	uint32_t signal;
+ 	int32_t ret_val;
+ 	uint16_t phy_data;
+ 	uint16_t lp_capability;
+ 	
+ 	DEBUGFUNC("e1000_check_for_link");
+ 	
+ 	/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
+ 	 * set when the optics detect a signal. On older adapters, it will be 
+ 	 * cleared when there is a signal
+ 	 */
+ 	if(hw->mac_type > e1000_82544) signal = E1000_CTRL_SWDPIN1;
+ 	else signal = 0;
+ 	
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	status = E1000_READ_REG(hw, STATUS);
+ 	rxcw = E1000_READ_REG(hw, RXCW);
+ 	
+ 	/* If we have a copper PHY then we only want to go out to the PHY
+ 	 * registers to see if Auto-Neg has completed and/or if our link
+ 	 * status has changed.  The get_link_status flag will be set if we
+ 	 * receive a Link Status Change interrupt or we have Rx Sequence
+ 	 * Errors.
+ 	 */
+ 	if((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
+ 		/* First we want to see if the MII Status Register reports
+ 		 * link.  If so, then we want to get the current speed/duplex
+ 		 * of the PHY.
+ 		 * Read the register twice since the link bit is sticky.
+ 		 */
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		
+ 		if(phy_data & MII_SR_LINK_STATUS) {
+ 			hw->get_link_status = FALSE;
+ 		} else {
+ 			/* No link detected */
+ 			return -E1000_ERR_NOLINK;
+ 		}
+ 
+ 		/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
+ 		 * have Si on board that is 82544 or newer, Auto
+ 		 * Speed Detection takes care of MAC speed/duplex
+ 		 * configuration.  So we only need to configure Collision
+ 		 * Distance in the MAC.  Otherwise, we need to force
+ 		 * speed/duplex on the MAC to the current PHY speed/duplex
+ 		 * settings.
+ 		 */
+ 		if(hw->mac_type >= e1000_82544)
+ 			e1000_config_collision_dist(hw);
+ 		else {
+ 			ret_val = e1000_config_mac_to_phy(hw);
+ 			if(ret_val < 0) {
+ 				DEBUGOUT("Error configuring MAC to PHY settings\n");
+ 				return ret_val;
+ 			}
+ 		}
+ 		
+ 		/* Configure Flow Control now that Auto-Neg has completed. First, we 
+ 		 * need to restore the desired flow control settings because we may
+ 		 * have had to re-autoneg with a different link partner.
+ 		 */
+ 		ret_val = e1000_config_fc_after_link_up(hw);
+ 		if(ret_val < 0) {
+ 			DEBUGOUT("Error configuring flow control\n");
+ 			return ret_val;
+ 		}
+ 		
+ 		/* At this point we know that we are on copper and we have
+ 		 * auto-negotiated link.  These are conditions for checking the link
+ 		 * parter capability register.  We use the link partner capability to
+ 		 * determine if TBI Compatibility needs to be turned on or off.  If
+ 		 * the link partner advertises any speed in addition to Gigabit, then
+ 		 * we assume that they are GMII-based, and TBI compatibility is not
+ 		 * needed. If no other speeds are advertised, we assume the link
+ 		 * partner is TBI-based, and we turn on TBI Compatibility.
+ 		 */
+ 		if(hw->tbi_compatibility_en) {
+ 			if(e1000_read_phy_reg(hw, PHY_LP_ABILITY, &lp_capability) < 0) {
+ 				DEBUGOUT("PHY Read Error\n");
+ 				return -E1000_ERR_PHY;
+ 			}
+ 			if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
+                                 NWAY_LPAR_10T_FD_CAPS |
+                                 NWAY_LPAR_100TX_HD_CAPS |
+                                 NWAY_LPAR_100TX_FD_CAPS |
+                                 NWAY_LPAR_100T4_CAPS)) {
+ 				/* If our link partner advertises anything in addition to 
+ 				 * gigabit, we do not need to enable TBI compatibility.
+ 				 */
+ 				if(hw->tbi_compatibility_on) {
+ 					/* If we previously were in the mode, turn it off. */
+ 					rctl = E1000_READ_REG(hw, RCTL);
+ 					rctl &= ~E1000_RCTL_SBP;
+ 					E1000_WRITE_REG(hw, RCTL, rctl);
+ 					hw->tbi_compatibility_on = FALSE;
+ 				}
+ 			} else {
+ 				/* If TBI compatibility is was previously off, turn it on. For
+ 				 * compatibility with a TBI link partner, we will store bad
+ 				 * packets. Some frames have an additional byte on the end and
+ 				 * will look like CRC errors to to the hardware.
+ 				 */
+ 				if(!hw->tbi_compatibility_on) {
+ 					hw->tbi_compatibility_on = TRUE;
+ 					rctl = E1000_READ_REG(hw, RCTL);
+ 					rctl |= E1000_RCTL_SBP;
+ 					E1000_WRITE_REG(hw, RCTL, rctl);
+ 				}
+ 			}
+ 		}
+ 	}
+ 	/* If we don't have link (auto-negotiation failed or link partner cannot
+ 	 * auto-negotiate), the cable is plugged in (we have signal), and our
+ 	 * link partner is not trying to auto-negotiate with us (we are receiving
+ 	 * idles or data), we need to force link up. We also need to give
+ 	 * auto-negotiation time to complete, in case the cable was just plugged
+ 	 * in. The autoneg_failed flag does this.
+ 	 */
+ 	else if((hw->media_type == e1000_media_type_fiber) &&
+ 		(!(status & E1000_STATUS_LU)) &&
+ 		((ctrl & E1000_CTRL_SWDPIN1) == signal) &&
+ 		(!(rxcw & E1000_RXCW_C))) {
+ 		if(hw->autoneg_failed == 0) {
+ 			hw->autoneg_failed = 1;
+ 			return 0;
+ 		}
+ 		DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\r\n");
+ 		
+ 		/* Disable auto-negotiation in the TXCW register */
+ 		E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));
+ 		
+ 		/* Force link-up and also force full-duplex. */
+ 		ctrl = E1000_READ_REG(hw, CTRL);
+ 		ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
+ 		E1000_WRITE_REG(hw, CTRL, ctrl);
+ 		
+ 		/* Configure Flow Control after forcing link up. */
+ 		ret_val = e1000_config_fc_after_link_up(hw);
+ 		if(ret_val < 0) {
+ 			DEBUGOUT("Error configuring flow control\n");
+ 			return ret_val;
+ 		}
+ 	}
+ 	/* If we are forcing link and we are receiving /C/ ordered sets, re-enable
+ 	 * auto-negotiation in the TXCW register and disable forced link in the
+ 	 * Device Control register in an attempt to auto-negotiate with our link
+ 	 * partner.
+ 	 */
+ 	else if((hw->media_type == e1000_media_type_fiber) &&
+ 		(ctrl & E1000_CTRL_SLU) &&
+ 		(rxcw & E1000_RXCW_C)) {
+ 		DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
+ 		E1000_WRITE_REG(hw, TXCW, hw->txcw);
+ 		E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+  * Detects the current speed and duplex settings of the hardware.
+  *
+  * hw - Struct containing variables accessed by shared code
+  * speed - Speed of the connection
+  * duplex - Duplex setting of the connection
+  *****************************************************************************/
+ static void 
+ e1000_get_speed_and_duplex(struct e1000_hw *hw,
+                            uint16_t *speed,
+                            uint16_t *duplex)
+ {
+ 	uint32_t status;
+ 	
+ 	DEBUGFUNC("e1000_get_speed_and_duplex");
+ 	
+ 	if(hw->mac_type >= e1000_82543) {
+ 		status = E1000_READ_REG(hw, STATUS);
+ 		if(status & E1000_STATUS_SPEED_1000) {
+ 			*speed = SPEED_1000;
+ 			DEBUGOUT("1000 Mbs, ");
+ 		} else if(status & E1000_STATUS_SPEED_100) {
+ 			*speed = SPEED_100;
+ 			DEBUGOUT("100 Mbs, ");
+ 		} else {
+ 			*speed = SPEED_10;
+ 			DEBUGOUT("10 Mbs, ");
+ 		}
+ 		
+ 		if(status & E1000_STATUS_FD) {
+ 			*duplex = FULL_DUPLEX;
+ 			DEBUGOUT("Full Duplex\r\n");
+ 		} else {
+ 			*duplex = HALF_DUPLEX;
+ 			DEBUGOUT(" Half Duplex\r\n");
+ 		}
+ 	} else {
+ 		DEBUGOUT("1000 Mbs, Full Duplex\r\n");
+ 		*speed = SPEED_1000;
+ 		*duplex = FULL_DUPLEX;
+ 	}
+ }
+ 
+ /******************************************************************************
+ * Blocks until autoneg completes or times out (~4.5 seconds)
+ *
+ * hw - Struct containing variables accessed by shared code
+ ******************************************************************************/
+ static int
+ e1000_wait_autoneg(struct e1000_hw *hw)
+ {
+ 	uint16_t i;
+ 	uint16_t phy_data;
+ 	
+ 	DEBUGFUNC("e1000_wait_autoneg");
+ 	DEBUGOUT("Waiting for Auto-Neg to complete.\n");
+ 	
+ 	/* We will wait for autoneg to complete or 4.5 seconds to expire. */
+ 	for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
+ 		/* Read the MII Status Register and wait for Auto-Neg
+ 		 * Complete bit to be set.
+ 		 */
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+ 			DEBUGOUT("PHY Read Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(phy_data & MII_SR_AUTONEG_COMPLETE) {
+ 			DEBUGOUT("Auto-Neg complete.\n");
+ 			return 0;
+ 		}
+ 		mdelay(100);
+ 	}
+ 	DEBUGOUT("Auto-Neg timedout.\n");
+ 	return -E1000_ERR_TIMEOUT;
+ }
+ 
+ /******************************************************************************
+ * Raises the Management Data Clock
+ *
+ * hw - Struct containing variables accessed by shared code
+ * ctrl - Device control register's current value
+ ******************************************************************************/
+ static void
+ e1000_raise_mdi_clk(struct e1000_hw *hw,
+                     uint32_t *ctrl)
+ {
+ 	/* Raise the clock input to the Management Data Clock (by setting the MDC
+ 	 * bit), and then delay 2 microseconds.
+ 	 */
+ 	E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
+ 	E1000_WRITE_FLUSH(hw);
+ 	udelay(2);
+ }
+ 
+ /******************************************************************************
+ * Lowers the Management Data Clock
+ *
+ * hw - Struct containing variables accessed by shared code
+ * ctrl - Device control register's current value
+ ******************************************************************************/
+ static void
+ e1000_lower_mdi_clk(struct e1000_hw *hw,
+                     uint32_t *ctrl)
+ {
+ 	/* Lower the clock input to the Management Data Clock (by clearing the MDC
+ 	 * bit), and then delay 2 microseconds.
+ 	 */
+ 	E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
+ 	E1000_WRITE_FLUSH(hw);
+ 	udelay(2);
+ }
+ 
+ /******************************************************************************
+ * Shifts data bits out to the PHY
+ *
+ * hw - Struct containing variables accessed by shared code
+ * data - Data to send out to the PHY
+ * count - Number of bits to shift out
+ *
+ * Bits are shifted out in MSB to LSB order.
+ ******************************************************************************/
+ static void
+ e1000_shift_out_mdi_bits(struct e1000_hw *hw,
+                          uint32_t data,
+                          uint16_t count)
+ {
+ 	uint32_t ctrl;
+ 	uint32_t mask;
+ 
+ 	/* We need to shift "count" number of bits out to the PHY. So, the value
+ 	 * in the "data" parameter will be shifted out to the PHY one bit at a 
+ 	 * time. In order to do this, "data" must be broken down into bits.
+ 	 */
+ 	mask = 0x01;
+ 	mask <<= (count - 1);
+ 	
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	
+ 	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
+ 	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
+ 	
+ 	while(mask) {
+ 		/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
+ 		 * then raising and lowering the Management Data Clock. A "0" is
+ 		 * shifted out to the PHY by setting the MDIO bit to "0" and then
+ 		 * raising and lowering the clock.
+ 		 */
+ 		if(data & mask) ctrl |= E1000_CTRL_MDIO;
+ 		else ctrl &= ~E1000_CTRL_MDIO;
+ 		
+ 		E1000_WRITE_REG(hw, CTRL, ctrl);
+ 		E1000_WRITE_FLUSH(hw);
+ 		
+ 		udelay(2);
+ 
+ 		e1000_raise_mdi_clk(hw, &ctrl);
+ 		e1000_lower_mdi_clk(hw, &ctrl);
+ 
+ 		mask = mask >> 1;
+ 	}
+ }
+ 
+ /******************************************************************************
+ * Shifts data bits in from the PHY
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Bits are shifted in in MSB to LSB order. 
+ ******************************************************************************/
+ static uint16_t
+ e1000_shift_in_mdi_bits(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl;
+ 	uint16_t data = 0;
+ 	uint8_t i;
+ 
+ 	/* In order to read a register from the PHY, we need to shift in a total
+ 	 * of 18 bits from the PHY. The first two bit (turnaround) times are used
+ 	 * to avoid contention on the MDIO pin when a read operation is performed.
+ 	 * These two bits are ignored by us and thrown away. Bits are "shifted in"
+ 	 * by raising the input to the Management Data Clock (setting the MDC bit),
+ 	 * and then reading the value of the MDIO bit.
+ 	 */ 
+ 	ctrl = E1000_READ_REG(hw, CTRL);
+ 	
+ 	/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
+ 	ctrl &= ~E1000_CTRL_MDIO_DIR;
+ 	ctrl &= ~E1000_CTRL_MDIO;
+ 	
+ 	E1000_WRITE_REG(hw, CTRL, ctrl);
+ 	E1000_WRITE_FLUSH(hw);
+ 	
+ 	/* Raise and Lower the clock before reading in the data. This accounts for
+ 	 * the turnaround bits. The first clock occurred when we clocked out the
+ 	 * last bit of the Register Address.
+ 	 */
+ 	e1000_raise_mdi_clk(hw, &ctrl);
+ 	e1000_lower_mdi_clk(hw, &ctrl);
+ 	
+ 	for(data = 0, i = 0; i < 16; i++) {
+ 		data = data << 1;
+ 		e1000_raise_mdi_clk(hw, &ctrl);
+ 		ctrl = E1000_READ_REG(hw, CTRL);
+ 		/* Check to see if we shifted in a "1". */
+ 		if(ctrl & E1000_CTRL_MDIO) data |= 1;
+ 		e1000_lower_mdi_clk(hw, &ctrl);
+ 	}
+ 	
+ 	e1000_raise_mdi_clk(hw, &ctrl);
+ 	e1000_lower_mdi_clk(hw, &ctrl);
+ 	
+ 	return data;
+ }
+ 
+ /*****************************************************************************
+ * Reads the value from a PHY register
+ *
+ * hw - Struct containing variables accessed by shared code
+ * reg_addr - address of the PHY register to read
+ ******************************************************************************/
+ static int
+ e1000_read_phy_reg(struct e1000_hw *hw,
+                    uint32_t reg_addr,
+                    uint16_t *phy_data)
+ {
+ 	uint32_t i;
+ 	uint32_t mdic = 0;
+ 	const uint32_t phy_addr = 1;
+ 
+ 	DEBUGFUNC("e1000_read_phy_reg");
+ 	
+ 	if(reg_addr > MAX_PHY_REG_ADDRESS) {
+ 		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
+ 		return -E1000_ERR_PARAM;
+ 	}
+ 	
+ 	if(hw->mac_type > e1000_82543) {
+ 		/* Set up Op-code, Phy Address, and register address in the MDI
+ 		 * Control register.  The MAC will take care of interfacing with the
+ 		 * PHY to retrieve the desired data.
+ 		 */
+ 		mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
+ 			(phy_addr << E1000_MDIC_PHY_SHIFT) | 
+ 			(E1000_MDIC_OP_READ));
+ 		
+ 		E1000_WRITE_REG(hw, MDIC, mdic);
+ 
+ 		/* Poll the ready bit to see if the MDI read completed */
+ 		for(i = 0; i < 64; i++) {
+ 			udelay(10);
+ 			mdic = E1000_READ_REG(hw, MDIC);
+ 			if(mdic & E1000_MDIC_READY) break;
+ 		}
+ 		if(!(mdic & E1000_MDIC_READY)) {
+ 			DEBUGOUT("MDI Read did not complete\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		if(mdic & E1000_MDIC_ERROR) {
+ 			DEBUGOUT("MDI Error\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 		*phy_data = (uint16_t) mdic;
+ 	} else {
+ 		/* We must first send a preamble through the MDIO pin to signal the
+ 		 * beginning of an MII instruction.  This is done by sending 32
+ 		 * consecutive "1" bits.
+ 		 */
+ 		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+ 		
+ 		/* Now combine the next few fields that are required for a read
+ 		 * operation.  We use this method instead of calling the
+ 		 * e1000_shift_out_mdi_bits routine five different times. The format of
+ 		 * a MII read instruction consists of a shift out of 14 bits and is
+ 		 * defined as follows:
+ 		 *    <Preamble><SOF><Op Code><Phy Addr><Reg Addr>
+ 		 * followed by a shift in of 18 bits.  This first two bits shifted in
+ 		 * are TurnAround bits used to avoid contention on the MDIO pin when a
+ 		 * READ operation is performed.  These two bits are thrown away
+ 		 * followed by a shift in of 16 bits which contains the desired data.
+ 		 */
+ 		mdic = ((reg_addr) | (phy_addr << 5) | 
+ 			(PHY_OP_READ << 10) | (PHY_SOF << 12));
+ 		
+ 		e1000_shift_out_mdi_bits(hw, mdic, 14);
+ 		
+ 		/* Now that we've shifted out the read command to the MII, we need to
+ 		 * "shift in" the 16-bit value (18 total bits) of the requested PHY
+ 		 * register address.
+ 		 */
+ 		*phy_data = e1000_shift_in_mdi_bits(hw);
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+ * Writes a value to a PHY register
+ *
+ * hw - Struct containing variables accessed by shared code
+ * reg_addr - address of the PHY register to write
+ * data - data to write to the PHY
+ ******************************************************************************/
+ static int 
+ e1000_write_phy_reg(struct e1000_hw *hw,
+                     uint32_t reg_addr,
+                     uint16_t phy_data)
+ {
+ 	uint32_t i;
+ 	uint32_t mdic = 0;
+ 	const uint32_t phy_addr = 1;
+ 	
+ 	DEBUGFUNC("e1000_write_phy_reg");
+ 	
+ 	if(reg_addr > MAX_PHY_REG_ADDRESS) {
+ 		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
+ 		return -E1000_ERR_PARAM;
+ 	}
+ 	
+ 	if(hw->mac_type > e1000_82543) {
+ 		/* Set up Op-code, Phy Address, register address, and data intended
+ 		 * for the PHY register in the MDI Control register.  The MAC will take
+ 		 * care of interfacing with the PHY to send the desired data.
+ 		 */
+ 		mdic = (((uint32_t) phy_data) |
+ 			(reg_addr << E1000_MDIC_REG_SHIFT) |
+ 			(phy_addr << E1000_MDIC_PHY_SHIFT) | 
+ 			(E1000_MDIC_OP_WRITE));
+ 		
+ 		E1000_WRITE_REG(hw, MDIC, mdic);
+ 		
+ 		/* Poll the ready bit to see if the MDI read completed */
+ 		for(i = 0; i < 64; i++) {
+ 			udelay(10);
+ 			mdic = E1000_READ_REG(hw, MDIC);
+ 			if(mdic & E1000_MDIC_READY) break;
+ 		}
+ 		if(!(mdic & E1000_MDIC_READY)) {
+ 			DEBUGOUT("MDI Write did not complete\n");
+ 			return -E1000_ERR_PHY;
+ 		}
+ 	} else {
+ 		/* We'll need to use the SW defined pins to shift the write command
+ 		 * out to the PHY. We first send a preamble to the PHY to signal the
+ 		 * beginning of the MII instruction.  This is done by sending 32 
+ 		 * consecutive "1" bits.
+ 		 */
+ 		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+ 		
+ 		/* Now combine the remaining required fields that will indicate a 
+ 		 * write operation. We use this method instead of calling the
+ 		 * e1000_shift_out_mdi_bits routine for each field in the command. The
+ 		 * format of a MII write instruction is as follows:
+ 		 * <Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.
+ 		 */
+ 		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
+ 			(PHY_OP_WRITE << 12) | (PHY_SOF << 14));
+ 		mdic <<= 16;
+ 		mdic |= (uint32_t) phy_data;
+ 		
+ 		e1000_shift_out_mdi_bits(hw, mdic, 32);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+ * Returns the PHY to the power-on reset state
+ *
+ * hw - Struct containing variables accessed by shared code
+ ******************************************************************************/
+ static void
+ e1000_phy_hw_reset(struct e1000_hw *hw)
+ {
+ 	uint32_t ctrl, ctrl_ext;
+ 
+ 	DEBUGFUNC("e1000_phy_hw_reset");
+ 	
+ 	DEBUGOUT("Resetting Phy...\n");
+ 	
+ 	if(hw->mac_type > e1000_82543) {
+ 		/* Read the device control register and assert the E1000_CTRL_PHY_RST
+ 		 * bit. Then, take it out of reset.
+ 		 */
+ 		ctrl = E1000_READ_REG(hw, CTRL);
+ 		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PHY_RST);
+ 		E1000_WRITE_FLUSH(hw);
+ 		mdelay(10);
+ 		E1000_WRITE_REG(hw, CTRL, ctrl);
+ 		E1000_WRITE_FLUSH(hw);
+ 	} else {
+ 		/* Read the Extended Device Control Register, assert the PHY_RESET_DIR
+ 		 * bit to put the PHY into reset. Then, take it out of reset.
+ 		 */
+ 		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+ 		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
+ 		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
+ 		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+ 		E1000_WRITE_FLUSH(hw);
+ 		mdelay(10);
+ 		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
+ 		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+ 		E1000_WRITE_FLUSH(hw);
+ 	}
+ 	udelay(150);
+ 
+ 	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+ 		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
+ 			DEBUGOUT("PHY Write Error\n");
+ 			return;
+ 		}
+ 	}
+ }
+ 
+ /******************************************************************************
+ * Resets the PHY
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Sets bit 15 of the MII Control regiser
+ ******************************************************************************/
+ static int 
+ e1000_phy_reset(struct e1000_hw *hw)
+ {
+ 	uint16_t phy_data;
+ 
+ 	DEBUGFUNC("e1000_phy_reset");
+ 	
+ 	if(e1000_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
+ 		DEBUGOUT("PHY Read Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 	phy_data |= MII_CR_RESET;
+ 	if(e1000_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
+ 		DEBUGOUT("PHY Write Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 	udelay(1);
+ 	if (hw->phy_type == e1000_phy_igp) {
+ 		e1000_phy_init_script(hw);
+ 	}
+ 	return 0;
+ }
+ 
+ /******************************************************************************
+ * Probes the expected PHY address for known PHY IDs
+ *
+ * hw - Struct containing variables accessed by shared code
+ ******************************************************************************/
+ static int
+ e1000_detect_gig_phy(struct e1000_hw *hw)
+ {
+ 	uint16_t phy_id_high, phy_id_low;
+ 	boolean_t match = FALSE;
+ 	int32_t phy_init_status;
+ 
+ 	DEBUGFUNC("e1000_detect_gig_phy");
+ 	
+ 	/* Read the PHY ID Registers to identify which PHY is onboard. */
+ 	if(e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high) < 0) {
+ 		DEBUGOUT("PHY Read Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 	hw->phy_id = (uint32_t) (phy_id_high << 16);
+ 	udelay(20);
+ 	if(e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low) < 0) {
+ 		DEBUGOUT("PHY Read Error\n");
+ 		return -E1000_ERR_PHY;
+ 	}
+ 	hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
+ #ifdef LINUX_DRIVER
+ 	hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;
+ #endif
+ 	
+ 	switch(hw->mac_type) {
+ 	case e1000_82543:
+ 		if(hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
+ 		break;
+ 	case e1000_82544:
+ 		if(hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
+ 		break;
+ 	case e1000_82540:
+ 	case e1000_82545:
+ 	case e1000_82546:
+ 		if(hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
+ 		break;
+ 	case e1000_82541:
+ 	case e1000_82547:
+ 		if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
+ 		break;
+ 	default:
+ 		DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
+ 		return -E1000_ERR_CONFIG;
+ 	}
+ 	phy_init_status = e1000_set_phy_type(hw);
+ 
+ 	if ((match) && (phy_init_status == E1000_SUCCESS)) {
+ 		DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
+ 		return 0;
+ 	}
+ 	DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
+ 	return -E1000_ERR_PHY;
+ }
+ 
+ /******************************************************************************
+  * Sets up eeprom variables in the hw struct.  Must be called after mac_type
+  * is configured.
+  *
+  * hw - Struct containing variables accessed by shared code
+  *****************************************************************************/
+ static void
+ e1000_init_eeprom_params(struct e1000_hw *hw)
+ {
+ 	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+ 	uint32_t eecd = E1000_READ_REG(hw, EECD);
+ 	uint16_t eeprom_size;
+ 
+ 	DEBUGFUNC("e1000_init_eeprom_params");
+ 
+ 	switch (hw->mac_type) {
+ 	case e1000_82542_rev2_0:
+ 	case e1000_82542_rev2_1:
+ 	case e1000_82543:
+ 	case e1000_82544:
+ 		eeprom->type = e1000_eeprom_microwire;
+ 		eeprom->word_size = 64;
+ 		eeprom->opcode_bits = 3;
+ 		eeprom->address_bits = 6;
+ 		eeprom->delay_usec = 50;
+ 		break;
+ 	case e1000_82540:
+ 	case e1000_82545:
+ 	case e1000_82546:
+ 		eeprom->type = e1000_eeprom_microwire;
+ 		eeprom->opcode_bits = 3;
+ 		eeprom->delay_usec = 50;
+ 		if(eecd & E1000_EECD_SIZE) {
+ 			eeprom->word_size = 256;
+ 			eeprom->address_bits = 8;
+ 		} else {
+ 			eeprom->word_size = 64;
+ 			eeprom->address_bits = 6;
+ 		}
+ 		break;
+ 	case e1000_82541:
+ 	case e1000_82547:
+ 	default:
+ 		if (eecd & E1000_EECD_TYPE) {
+ 			eeprom->type = e1000_eeprom_spi;
+ 			eeprom->opcode_bits = 8;
+ 			eeprom->delay_usec = 1;
+ 			if (eecd & E1000_EECD_ADDR_BITS) {
+ 				eeprom->page_size = 32;
+ 				eeprom->address_bits = 16;
+ 			} else {
+ 				eeprom->page_size = 8;
+ 				eeprom->address_bits = 8;
+ 			}
+ 		} else {
+ 			eeprom->type = e1000_eeprom_microwire;
+ 			eeprom->opcode_bits = 3;
+ 			eeprom->delay_usec = 50;
+ 			if (eecd & E1000_EECD_ADDR_BITS) {
+ 				eeprom->word_size = 256;
+ 				eeprom->address_bits = 8;
+ 			} else {
+ 				eeprom->word_size = 64;
+ 				eeprom->address_bits = 6;
+ 			}
+ 		}
+ 		break;
+ 	}
+ 
+ 	if (eeprom->type == e1000_eeprom_spi) {
+ 		eeprom->word_size = 64;
+ 		if (e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size) == 0) {
+ 			eeprom_size &= EEPROM_SIZE_MASK;
+ 
+ 			switch (eeprom_size) {
+ 			case EEPROM_SIZE_16KB:
+ 				eeprom->word_size = 8192;
+ 				break;
+ 			case EEPROM_SIZE_8KB:
+ 				eeprom->word_size = 4096;
+ 				break;
+ 			case EEPROM_SIZE_4KB:
+ 				eeprom->word_size = 2048;
+ 				break;
+ 			case EEPROM_SIZE_2KB:
+ 				eeprom->word_size = 1024;
+ 				break;
+ 			case EEPROM_SIZE_1KB:
+ 				eeprom->word_size = 512;
+ 				break;
+ 			case EEPROM_SIZE_512B:
+ 				eeprom->word_size = 256;
+ 				break;
+ 			case EEPROM_SIZE_128B:
+ 			default:
+ 				eeprom->word_size = 64;
+ 				break;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ /**
+  * e1000_reset - Reset the adapter
+  */
+ 
+ static int
+ e1000_reset(struct e1000_hw *hw)
+ {
+ 	int ret_val;
+ 	uint32_t pba;
+ 	/* Repartition Pba for greater than 9k mtu
+ 	 * To take effect CTRL.RST is required.
+ 	 */
+ 
+ 	if(hw->mac_type < e1000_82547) {
+ 		pba = E1000_PBA_48K;
+ 	} else {
+ 		pba = E1000_PBA_30K;
+ 	}
+ 	E1000_WRITE_REG(hw, PBA, pba);
+ 
+ 	hw->fc = hw->original_fc;
+ 	e1000_reset_hw(hw);
+ 	if(hw->mac_type >= e1000_82544)
+ 		E1000_WRITE_REG(hw, WUC, 0);
+ 	ret_val = e1000_init_hw(hw);
+ 	if (ret_val < 0) {
+ 		return ret_val;
+ 	}
+ 	return ret_val;
+ }
+ 
+ /**
+  * e1000_sw_init - Initialize general software structures (struct e1000_adapter)
+  * @adapter: board private structure to initialize
+  *
+  * e1000_sw_init initializes the Adapter private data structure.
+  * Fields are initialized based on PCI device information and
+  * OS network device settings (MTU size).
+  **/
+ 
+ static int 
+ e1000_sw_init(struct pci_device *pdev, struct e1000_hw *hw)
+ {
+ 	int result;
+ 
+ 	/* PCI config space info */
+ 	pci_read_config_word(pdev, PCI_VENDOR_ID, &hw->vendor_id);
+ 	pci_read_config_word(pdev, PCI_DEVICE_ID, &hw->device_id);
+ 	pci_read_config_byte(pdev, PCI_REVISION, &hw->revision_id);
+ 	pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
+                              &hw->subsystem_vendor_id);
+ 	pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &hw->subsystem_id);
+ 
+ 	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
+ 
+ 	/* identify the MAC */
+ 
+ 	result = e1000_set_mac_type(hw);
+ 	if (result) {
+ 		E1000_ERR("Unknown MAC Type\n");
+ 		return result;
+ 	}
+ 
+ 	/* initialize eeprom parameters */
+ 
+ 	e1000_init_eeprom_params(hw);
+ 
+ 	/* flow control settings */
+ 
+ 	hw->fc_high_water = FC_DEFAULT_HI_THRESH;
+ 	hw->fc_low_water = FC_DEFAULT_LO_THRESH;
+ 	hw->fc_pause_time = FC_DEFAULT_TX_TIMER;
+ 	hw->fc_send_xon = 1;
+ 
+ 	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547))
+ 		hw->phy_init_script = 1;
+ 
+ 	/* Media type - copper or fiber */
+ 
+ 	if(hw->mac_type >= e1000_82543) {
+ 		uint32_t status = E1000_READ_REG(hw, STATUS);
+ 
+ 		if(status & E1000_STATUS_TBIMODE)
+ 			hw->media_type = e1000_media_type_fiber;
+ 		else
+ 			hw->media_type = e1000_media_type_copper;
+ 	} else {
+ 		hw->media_type = e1000_media_type_fiber;
+ 	}
+ 
+ 	if(hw->mac_type < e1000_82543)
+ 		hw->report_tx_early = 0;
+ 	else
+ 		hw->report_tx_early = 1;
+ 
+ 	hw->tbi_compatibility_en = TRUE;
+ #if 0
+ 	hw->wait_autoneg_complete = FALSE;
+ 	hw->adaptive_ifs = TRUE;
+ 
+ 	/* Copper options */
+ 	if(hw->media_type == e1000_media_type_copper) {
+ 		hw->mdix = AUTO_ALL_MODES;
+ 		hw->disable_polarity_correction = FALSE;
+ 	}
+ #endif
+ 	return E1000_SUCCESS;
+ }
+ 
+ static void fill_rx (void)
+ {
+ 	struct e1000_rx_desc *rd;
+ 	rx_last = rx_tail;
+ 	rd = rx_base + rx_tail;
+ 	rx_tail = (rx_tail + 1) % 8;
+ 	memset (rd, 0, 16);
+ 	rd->buffer_addr = virt_to_bus(&packet);
+ 	E1000_WRITE_REG (&hw, RDT, rx_tail);
+ }
+ 
+ static void init_descriptor (void)
+ {
+ 	unsigned long ptr;
+ 	unsigned long tctl;
+ 
+ 	ptr = virt_to_phys(tx_pool);
+ 	if (ptr & 0xf)
+ 		ptr = (ptr + 0x10) & (~0xf);
+ 
+ 	tx_base = phys_to_virt(ptr);
+ 
+ 	E1000_WRITE_REG (&hw, TDBAL, virt_to_bus(tx_base));
+ 	E1000_WRITE_REG (&hw, TDBAH, 0);
+ 	E1000_WRITE_REG (&hw, TDLEN, 128);
+ 
+ 	/* Setup the HW Tx Head and Tail descriptor pointers */
+ 
+ 	E1000_WRITE_REG (&hw, TDH, 0);
+ 	E1000_WRITE_REG (&hw, TDT, 0);
+ 	tx_tail = 0;
+ 
+ 	/* Program the Transmit Control Register */
+ 
+ #ifdef LINUX_DRIVER_TCTL
+ 	tctl = E1000_READ_REG(&hw, TCTL);
+ 
+ 	tctl &= ~E1000_TCTL_CT;
+ 	tctl |= E1000_TCTL_EN | E1000_TCTL_PSP |
+ 		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);
+ #else
+ 	tctl = E1000_TCTL_PSP | E1000_TCTL_EN |
+ 		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT) | 
+ 		(E1000_HDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);
+ #endif
+ 
+ 	E1000_WRITE_REG (&hw, TCTL, tctl);
+ 
+ 	e1000_config_collision_dist(&hw);
+ 
+ 
+ 	rx_tail = 0;
+ 	/* disable receive */
+ 	E1000_WRITE_REG (&hw, RCTL, 0);
+ 	ptr = virt_to_phys(rx_pool);
+ 	if (ptr & 0xf)
+ 		ptr = (ptr + 0x10) & (~0xf);
+ 	rx_base = phys_to_virt(ptr);
+ 
+ 	/* Setup the Base and Length of the Rx Descriptor Ring */
+ 
+ 	E1000_WRITE_REG (&hw, RDBAL, virt_to_bus(rx_base));
+ 	E1000_WRITE_REG (&hw, RDBAH, 0);
+ 
+ 	E1000_WRITE_REG (&hw, RDLEN, 128);
+ 
+ 	/* Setup the HW Rx Head and Tail Descriptor Pointers */
+ 	E1000_WRITE_REG (&hw, RDH, 0);
+ 	E1000_WRITE_REG (&hw, RDT, 0);
+ 
+ 	E1000_WRITE_REG (&hw, RCTL, 
+ 		E1000_RCTL_EN | 
+ 		E1000_RCTL_BAM | 
+ 		E1000_RCTL_SZ_2048 | 
+ 		E1000_RCTL_MPE);
+ 	fill_rx();
+ }
+ 
+ 
+ 
+ /**************************************************************************
+ POLL - Wait for a frame
+ ***************************************************************************/
+ static int
+ e1000_poll (struct nic *nic)
+ {
+ 	/* return true if there's an ethernet packet ready to read */
+ 	/* nic->packet should contain data on return */
+ 	/* nic->packetlen should contain length of data */
+ 	struct e1000_rx_desc *rd;
+ 	
+ 	rd = rx_base + rx_last;
+ 	if (!rd->status & E1000_RXD_STAT_DD)
+ 		return 0;
+ 	//      printf("recv: packet %! -> %! len=%d \n", packet+6, packet,rd->Length);
+ 	memcpy (nic->packet, packet, rd->length);
+ 	nic->packetlen = rd->length;
+ 	fill_rx ();
+ 	return 1;
+ }
+ 
+ /**************************************************************************
+ TRANSMIT - Transmit a frame
+ ***************************************************************************/
+ static void
+ e1000_transmit (struct nic *nic, const char *d,	/* Destination */
+ 		    unsigned int type,	/* Type */
+ 		    unsigned int size,	/* size */
+ 		    const char *p)	/* Packet */
+ {
+ 	/* send the packet to destination */
+ 	struct eth_hdr {
+ 		unsigned char dst_addr[ETH_ALEN];
+ 		unsigned char src_addr[ETH_ALEN];
+ 		unsigned short type;
+ 	} hdr;
+ 	struct e1000_tx_desc *txhd;	/* header */
+ 	struct e1000_tx_desc *txp;	/* payload */
+ 	DEBUGFUNC("send");
+ 
+ 	memcpy (&hdr.dst_addr, d, ETH_ALEN);
+ 	memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
+ 
+ 	hdr.type = htons (type);
+ 	txhd = tx_base + tx_tail;
+ 	tx_tail = (tx_tail + 1) % 8;
+ 	txp = tx_base + tx_tail;
+ 	tx_tail = (tx_tail + 1) % 8;
+ 
+ 	txhd->buffer_addr = virt_to_bus (&hdr);
+ 	txhd->lower.data = sizeof (hdr);
+ 	txhd->upper.data = 0;
+ 
+ 	txp->buffer_addr = virt_to_bus(p);
+ 	txp->lower.data = E1000_TXD_CMD_RPS | E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS | size;
+ 	txp->upper.data = 0;
+ 
+ 	E1000_WRITE_REG (&hw, TDT, tx_tail);
+ 	while (!(txp->upper.data & E1000_TXD_STAT_DD)) {
+ 		udelay(10);	/* give the nic a chance to write to the register */
+ 		poll_interruptions();
+ 	}
+ 	DEBUGFUNC("send end");
+ }
+ 
+ 
+ /**************************************************************************
+ DISABLE - Turn off ethernet interface
+ ***************************************************************************/
+ static void e1000_disable (struct dev *dev __unused)
+ {
+ 	/* Clear the transmit ring */
+ 	E1000_WRITE_REG (&hw, TDH, 0);
+ 	E1000_WRITE_REG (&hw, TDT, 0);
+ 
+ 	/* Clear the receive ring */
+ 	E1000_WRITE_REG (&hw, RDH, 0);
+ 	E1000_WRITE_REG (&hw, RDT, 0);
+ 
+ 	/* put the card in its initial state */
+ 	E1000_WRITE_REG (&hw, CTRL, E1000_CTRL_RST);
+ 
+ 	/* Turn off the ethernet interface */
+ 	E1000_WRITE_REG (&hw, RCTL, 0);
+ 	E1000_WRITE_REG (&hw, TCTL, 0);
+ 	mdelay (10);
+ 
+ 	/* Unmap my window to the device */
+ 	iounmap(hw.hw_addr);
+ }
+ 
+ /**************************************************************************
+ PROBE - Look for an adapter, this routine's visible to the outside
+ You should omit the last argument struct pci_device * for a non-PCI NIC
+ ***************************************************************************/
+ static int e1000_probe(struct dev *dev, struct pci_device *p)
+ {
+ 	struct nic *nic = (struct nic *)dev;
+ 	unsigned long mmio_start, mmio_len;
+ 	int ret_val;
+ 
+ 	if (p == 0)
+ 		return 0;
+ 	/* Initialize hw with default values */
+ 	memset(&hw, 0, sizeof(hw));
+ 	hw.pdev = p;
+ 
+ #if 1
+ 	/* Are these variables needed? */
+ 	hw.fc                    = e1000_fc_none;
+ 	hw.original_fc           = e1000_fc_none;
+ 	hw.autoneg_failed        = 0;
+ 	hw.get_link_status       = TRUE;
+ #endif
+ 
+ 	mmio_start = pci_bar_start(p, PCI_BASE_ADDRESS_0);
+ 	mmio_len   = pci_bar_size(p,  PCI_BASE_ADDRESS_0);
+ 	hw.hw_addr = ioremap(mmio_start, mmio_len);
+ 
+ 	hw.mac_type = e1000_undefined;
+ 	adjust_pci_device(p);
+ 
+ 	/* From Matt Hortman <mbhortman@acpthinclient.com> */
+ 	/* MAC and Phy settings */
+ 
+ 	/* setup the private structure */
+ 	if (e1000_sw_init(p, &hw) < 0) {
+ 		iounmap(hw.hw_addr);
+ 		return 0;
+ 	}
+ 
+ 	/* make sure the EEPROM is good */
+ 
+ 	if (e1000_validate_eeprom_checksum(&hw) < 0) {
+ 		printf ("The EEPROM Checksum Is Not Valid\n");
+ 		iounmap(hw.hw_addr);
+ 		return 0;
+ 	}
+ 
+ 	/* copy the MAC address out of the EEPROM */
+ 
+ 	e1000_read_mac_addr(&hw);
+ 	memcpy (nic->node_addr, hw.mac_addr, ETH_ALEN);
+ 	
+ 	printf("Ethernet addr: %!\n", nic->node_addr);
+ 
+ 	/* reset the hardware with the new settings */
+ 
+ 	ret_val = e1000_reset(&hw);
+ 	if (ret_val < 0) {
+ 		if ((ret_val == -E1000_ERR_NOLINK) ||
+ 			(ret_val == -E1000_ERR_TIMEOUT)) {
+ 			E1000_ERR("Valid Link not detected\n");
+ 		} else {
+ 			E1000_ERR("Hardware Initialization Failed\n");
+ 		}
+ 		iounmap(hw.hw_addr);
+ 		return 0;
+ 	}
+ 	init_descriptor();
+ 
+ 	/* point to NIC specific routines */
+ 	dev->disable  = e1000_disable;
+ 	nic->poll     = e1000_poll;
+ 	nic->transmit = e1000_transmit;
+ 	return 1;
+ }
+ 
+ static struct pci_id e1000_nics[] = {
+ PCI_ROM(0x8086, 0x1000, "e1000-82542",               "Intel EtherExpressPro1000"),
+ PCI_ROM(0x8086, 0x1001, "e1000-82543gc-fiber",       "Intel EtherExpressPro1000 82543GC Fiber"),
+ PCI_ROM(0x8086, 0x1004, "e1000-82543gc-copper",	     "Intel EtherExpressPro1000 82543GC Copper"),
+ PCI_ROM(0x8086, 0x1008, "e1000-82544ei-copper",      "Intel EtherExpressPro1000 82544EI Copper"),
+ PCI_ROM(0x8086, 0x1009, "e1000-82544ei-fiber",       "Intel EtherExpressPro1000 82544EI Fiber"),
+ PCI_ROM(0x8086, 0x100C, "e1000-82544gc-copper",      "Intel EtherExpressPro1000 82544GC Copper"),
+ PCI_ROM(0x8086, 0x100D, "e1000-82544gc-lom",         "Intel EtherExpressPro1000 82544GC LOM"),
+ PCI_ROM(0x8086, 0x100E, "e1000-82540em",     	     "Intel EtherExpressPro1000 82540EM"),
+ PCI_ROM(0x8086, 0x100F, "e1000-82545em-copper",      "Intel EtherExpressPro1000 82545EM Copper"),
+ PCI_ROM(0x8086, 0x1010, "e1000-82546eb-copper",      "Intel EtherExpressPro1000 82546EB Copper"),
+ PCI_ROM(0x8086, 0x1011, "e1000-82545em-fiber",       "Intel EtherExpressPro1000 82545EM Fiber"),
+ PCI_ROM(0x8086, 0x1012, "e1000-82546eb-fiber", 	     "Intel EtherExpressPro1000 82546EB Copper"),
+ PCI_ROM(0x8086, 0x1013, "e1000-82541ei",	     "Intel EtherExpressPro1000 82541EI"),
+ PCI_ROM(0x8086, 0x1015, "e1000-82540em-lom",  	     "Intel EtherExpressPro1000 82540EM LOM"),
+ PCI_ROM(0x8086, 0x1016, "e1000-82540ep-lom",	     "Intel EtherExpressPro1000 82540EP LOM"),
+ PCI_ROM(0x8086, 0x1017, "e1000-82540ep",	     "Intel EtherExpressPro1000 82540EP"),
+ PCI_ROM(0x8086, 0x1018, "e1000-82541ep",	     "Intel EtherExpressPro1000 82541EP"),
+ PCI_ROM(0x8086, 0x1019, "e1000-82547ei",	     "Intel EtherExpressPro1000 82547EI"),
+ PCI_ROM(0x8086, 0x101d, "e1000-82546eb-quad-copper", "Intel EtherExpressPro1000 82546EB Quad Copper"),
+ PCI_ROM(0x8086, 0x101e, "e1000-82540ep-lp",	     "Intel EtherExpressPro1000 82540EP LP"),
+ };
+ 
+ struct pci_driver e1000_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "E1000",
+ 	.probe    = e1000_probe,
+ 	.ids      = e1000_nics,
+ 	.id_count = sizeof(e1000_nics)/sizeof(e1000_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/e1000_hw.h GRUB/netboot/e1000_hw.h
*** GRUB_0.94/netboot/e1000_hw.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/e1000_hw.h	2003-11-04 05:20:01.000000000 +0800
***************
*** 0 ****
--- 1,1972 ----
+ /*******************************************************************************
+ 
+   
+   Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+   
+   This program is free software; you can redistribute it and/or modify it 
+   under the terms of the GNU General Public License as published by the Free 
+   Software Foundation; either version 2 of the License, or (at your option) 
+   any later version.
+   
+   This program is distributed in the hope that it will be useful, but WITHOUT 
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+   more details.
+   
+   You should have received a copy of the GNU General Public License along with
+   this program; if not, write to the Free Software Foundation, Inc., 59 
+   Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+   
+   The full GNU General Public License is included in this distribution in the
+   file called LICENSE.
+   
+   Contact Information:
+   Linux NICS <linux.nics@intel.com>
+   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ 
+ *******************************************************************************/
+ 
+ /* e1000_hw.h
+  * Structures, enums, and macros for the MAC
+  */
+ 
+ #ifndef _E1000_HW_H_
+ #define _E1000_HW_H_
+ 
+ /* Forward declarations of structures used by the shared code */
+ struct e1000_hw;
+ struct e1000_hw_stats;
+ 
+ /* Enumerated types specific to the e1000 hardware */
+ /* Media Access Controlers */
+ typedef enum {
+     e1000_undefined = 0,
+     e1000_82542_rev2_0,
+     e1000_82542_rev2_1,
+     e1000_82543,
+     e1000_82544,
+     e1000_82540,
+     e1000_82545,
+     e1000_82546,
+     e1000_82541,
+     e1000_82547,
+     e1000_num_macs
+ } e1000_mac_type;
+ 
+ typedef enum {
+     e1000_eeprom_uninitialized = 0,
+     e1000_eeprom_spi,
+     e1000_eeprom_microwire,
+     e1000_num_eeprom_types
+ } e1000_eeprom_type;
+ 
+ /* Media Types */
+ typedef enum {
+ 	e1000_media_type_copper = 0,
+ 	e1000_media_type_fiber = 1,
+ 	e1000_num_media_types
+ } e1000_media_type;
+ 
+ typedef enum {
+     e1000_10_half = 0,
+     e1000_10_full = 1,
+     e1000_100_half = 2,
+     e1000_100_full = 3
+ } e1000_speed_duplex_type;
+ 
+ /* Flow Control Settings */
+ typedef enum {
+ 	e1000_fc_none = 0,
+ 	e1000_fc_rx_pause = 1,
+ 	e1000_fc_tx_pause = 2,
+ 	e1000_fc_full = 3,
+ 	e1000_fc_default = 0xFF
+ } e1000_fc_type;
+ 
+ /* PCI bus types */
+ typedef enum {
+ 	e1000_bus_type_unknown = 0,
+ 	e1000_bus_type_pci,
+ 	e1000_bus_type_pcix
+ } e1000_bus_type;
+ 
+ /* PCI bus speeds */
+ typedef enum {
+ 	e1000_bus_speed_unknown = 0,
+ 	e1000_bus_speed_33,
+ 	e1000_bus_speed_66,
+ 	e1000_bus_speed_100,
+ 	e1000_bus_speed_120,
+ 	e1000_bus_speed_133,
+ 	e1000_bus_speed_reserved
+ } e1000_bus_speed;
+ 
+ /* PCI bus widths */
+ typedef enum {
+ 	e1000_bus_width_unknown = 0,
+ 	e1000_bus_width_32,
+ 	e1000_bus_width_64
+ } e1000_bus_width;
+ 
+ /* PHY status info structure and supporting enums */
+ typedef enum {
+ 	e1000_cable_length_50 = 0,
+ 	e1000_cable_length_50_80,
+ 	e1000_cable_length_80_110,
+ 	e1000_cable_length_110_140,
+ 	e1000_cable_length_140,
+ 	e1000_cable_length_undefined = 0xFF
+ } e1000_cable_length;
+ 
+ typedef enum {
+     e1000_igp_cable_length_10  = 10,
+     e1000_igp_cable_length_20  = 20,
+     e1000_igp_cable_length_30  = 30,
+     e1000_igp_cable_length_40  = 40,
+     e1000_igp_cable_length_50  = 50,
+     e1000_igp_cable_length_60  = 60,
+     e1000_igp_cable_length_70  = 70,
+     e1000_igp_cable_length_80  = 80,
+     e1000_igp_cable_length_90  = 90,
+     e1000_igp_cable_length_100 = 100,
+     e1000_igp_cable_length_110 = 110,
+     e1000_igp_cable_length_120 = 120,
+     e1000_igp_cable_length_130 = 130,
+     e1000_igp_cable_length_140 = 140,
+     e1000_igp_cable_length_150 = 150,
+     e1000_igp_cable_length_160 = 160,
+     e1000_igp_cable_length_170 = 170,
+     e1000_igp_cable_length_180 = 180
+ } e1000_igp_cable_length;
+ 
+ typedef enum {
+ 	e1000_10bt_ext_dist_enable_normal = 0,
+ 	e1000_10bt_ext_dist_enable_lower,
+ 	e1000_10bt_ext_dist_enable_undefined = 0xFF
+ } e1000_10bt_ext_dist_enable;
+ 
+ typedef enum {
+ 	e1000_rev_polarity_normal = 0,
+ 	e1000_rev_polarity_reversed,
+ 	e1000_rev_polarity_undefined = 0xFF
+ } e1000_rev_polarity;
+ 
+ typedef enum {
+     e1000_downshift_normal = 0,
+     e1000_downshift_activated,
+     e1000_downshift_undefined = 0xFF
+ } e1000_downshift;
+ 
+ typedef enum {
+ 	e1000_polarity_reversal_enabled = 0,
+ 	e1000_polarity_reversal_disabled,
+ 	e1000_polarity_reversal_undefined = 0xFF
+ } e1000_polarity_reversal;
+ 
+ typedef enum {
+ 	e1000_auto_x_mode_manual_mdi = 0,
+ 	e1000_auto_x_mode_manual_mdix,
+ 	e1000_auto_x_mode_auto1,
+ 	e1000_auto_x_mode_auto2,
+ 	e1000_auto_x_mode_undefined = 0xFF
+ } e1000_auto_x_mode;
+ 
+ typedef enum {
+ 	e1000_1000t_rx_status_not_ok = 0,
+ 	e1000_1000t_rx_status_ok,
+ 	e1000_1000t_rx_status_undefined = 0xFF
+ } e1000_1000t_rx_status;
+ 
+ typedef enum {
+     e1000_phy_m88 = 0,
+     e1000_phy_igp,
+     e1000_phy_undefined = 0xFF
+ } e1000_phy_type;
+ 
+ struct e1000_phy_info {
+ #if 0
+ 	e1000_cable_length cable_length;
+ #endif
+ 	e1000_10bt_ext_dist_enable extended_10bt_distance;
+ 	e1000_rev_polarity cable_polarity;
+ #if 0
+ 	e1000_downshift downshift;
+ #endif
+ 	e1000_polarity_reversal polarity_correction;
+ 	e1000_auto_x_mode mdix_mode;
+ 	e1000_1000t_rx_status local_rx;
+ 	e1000_1000t_rx_status remote_rx;
+ };
+ 
+ struct e1000_phy_stats {
+ 	uint32_t idle_errors;
+ 	uint32_t receive_errors;
+ };
+ 
+ struct e1000_eeprom_info {
+     e1000_eeprom_type type;
+     uint16_t word_size;
+     uint16_t opcode_bits;
+     uint16_t address_bits;
+     uint16_t delay_usec;
+     uint16_t page_size;
+ };
+ 
+ 
+ 
+ /* Error Codes */
+ #define E1000_SUCCESS      0
+ #define E1000_ERR_EEPROM   1
+ #define E1000_ERR_PHY      2
+ #define E1000_ERR_CONFIG   3
+ #define E1000_ERR_PARAM    4
+ #define E1000_ERR_MAC_TYPE 5
+ #define E1000_ERR_PHY_TYPE 6
+ #define E1000_ERR_NOLINK   7
+ #define E1000_ERR_TIMEOUT  8
+ 
+ #define E1000_READ_REG_IO(a, reg) \
+ 	e1000_read_reg_io((a), E1000_##reg)
+ #define E1000_WRITE_REG_IO(a, reg, val) \
+ 	e1000_write_reg_io((a), E1000_##reg, val)
+ 
+ /* PCI Device IDs */
+ #define E1000_DEV_ID_82542               0x1000
+ #define E1000_DEV_ID_82543GC_FIBER       0x1001
+ #define E1000_DEV_ID_82543GC_COPPER      0x1004
+ #define E1000_DEV_ID_82544EI_COPPER      0x1008
+ #define E1000_DEV_ID_82544EI_FIBER       0x1009
+ #define E1000_DEV_ID_82544GC_COPPER      0x100C
+ #define E1000_DEV_ID_82544GC_LOM         0x100D
+ #define E1000_DEV_ID_82540EM             0x100E
+ #define E1000_DEV_ID_82540EM_LOM         0x1015
+ #define E1000_DEV_ID_82540EP_LOM         0x1016
+ #define E1000_DEV_ID_82540EP             0x1017
+ #define E1000_DEV_ID_82540EP_LP          0x101E
+ #define E1000_DEV_ID_82545EM_COPPER      0x100F
+ #define E1000_DEV_ID_82545EM_FIBER       0x1011
+ #define E1000_DEV_ID_82546EB_COPPER      0x1010
+ #define E1000_DEV_ID_82546EB_FIBER       0x1012
+ #define E1000_DEV_ID_82546EB_QUAD_COPPER 0x101D
+ #define E1000_DEV_ID_82541EI             0x1013
+ #define E1000_DEV_ID_82541EP             0x1018
+ #define E1000_DEV_ID_82547EI             0x1019
+ #define NUM_DEV_IDS 20
+ 
+ #define NODE_ADDRESS_SIZE 6
+ #define ETH_LENGTH_OF_ADDRESS 6
+ 
+ /* MAC decode size is 128K - This is the size of BAR0 */
+ #define MAC_DECODE_SIZE (128 * 1024)
+ 
+ #define E1000_82542_2_0_REV_ID 2
+ #define E1000_82542_2_1_REV_ID 3
+ 
+ #define SPEED_10    10
+ #define SPEED_100   100
+ #define SPEED_1000  1000
+ #define HALF_DUPLEX 1
+ #define FULL_DUPLEX 2
+ 
+ /* The sizes (in bytes) of a ethernet packet */
+ #define ENET_HEADER_SIZE             14
+ #define MAXIMUM_ETHERNET_FRAME_SIZE  1518 /* With FCS */
+ #define MINIMUM_ETHERNET_FRAME_SIZE  64   /* With FCS */
+ #define ETHERNET_FCS_SIZE            4
+ #define MAXIMUM_ETHERNET_PACKET_SIZE \
+     (MAXIMUM_ETHERNET_FRAME_SIZE - ETHERNET_FCS_SIZE)
+ #define MINIMUM_ETHERNET_PACKET_SIZE \
+     (MINIMUM_ETHERNET_FRAME_SIZE - ETHERNET_FCS_SIZE)
+ #define CRC_LENGTH                   ETHERNET_FCS_SIZE
+ #define MAX_JUMBO_FRAME_SIZE         0x3F00
+ 
+ 
+ /* 802.1q VLAN Packet Sizes */
+ #define VLAN_TAG_SIZE                     4     /* 802.3ac tag (not DMAed) */
+ 
+ /* Ethertype field values */
+ #define ETHERNET_IEEE_VLAN_TYPE 0x8100  /* 802.3ac packet */
+ #define ETHERNET_IP_TYPE        0x0800  /* IP packets */
+ #define ETHERNET_ARP_TYPE       0x0806  /* Address Resolution Protocol (ARP) */
+ 
+ /* Packet Header defines */
+ #define IP_PROTOCOL_TCP    6
+ #define IP_PROTOCOL_UDP    0x11
+ 
+ /* This defines the bits that are set in the Interrupt Mask
+  * Set/Read Register.  Each bit is documented below:
+  *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+  *   o RXSEQ  = Receive Sequence Error 
+  */
+ #define POLL_IMS_ENABLE_MASK ( \
+     E1000_IMS_RXDMT0 |         \
+     E1000_IMS_RXSEQ)
+ 
+ /* This defines the bits that are set in the Interrupt Mask
+  * Set/Read Register.  Each bit is documented below:
+  *   o RXT0   = Receiver Timer Interrupt (ring 0)
+  *   o TXDW   = Transmit Descriptor Written Back
+  *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+  *   o RXSEQ  = Receive Sequence Error
+  *   o LSC    = Link Status Change
+  */
+ #define IMS_ENABLE_MASK ( \
+     E1000_IMS_RXT0   |    \
+     E1000_IMS_TXDW   |    \
+     E1000_IMS_RXDMT0 |    \
+     E1000_IMS_RXSEQ  |    \
+     E1000_IMS_LSC)
+ 
+ /* The number of high/low register pairs in the RAR. The RAR (Receive Address
+  * Registers) holds the directed and multicast addresses that we monitor. We
+  * reserve one of these spots for our directed address, allowing us room for
+  * E1000_RAR_ENTRIES - 1 multicast addresses. 
+  */
+ #define E1000_RAR_ENTRIES 15
+ 
+ #define MIN_NUMBER_OF_DESCRIPTORS 8
+ #define MAX_NUMBER_OF_DESCRIPTORS 0xFFF8
+ 
+ /* Receive Descriptor */
+ struct e1000_rx_desc {
+     uint64_t buffer_addr; /* Address of the descriptor's data buffer */
+     uint16_t length;     /* Length of data DMAed into data buffer */
+     uint16_t csum;       /* Packet checksum */
+     uint8_t status;      /* Descriptor status */
+     uint8_t errors;      /* Descriptor Errors */
+     uint16_t special;
+ };
+ 
+ /* Receive Decriptor bit definitions */
+ #define E1000_RXD_STAT_DD       0x01    /* Descriptor Done */
+ #define E1000_RXD_STAT_EOP      0x02    /* End of Packet */
+ #define E1000_RXD_STAT_IXSM     0x04    /* Ignore checksum */
+ #define E1000_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
+ #define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
+ #define E1000_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
+ #define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
+ #define E1000_RXD_ERR_CE        0x01    /* CRC Error */
+ #define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
+ #define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
+ #define E1000_RXD_ERR_CXE       0x10    /* Carrier Extension Error */
+ #define E1000_RXD_ERR_TCPE      0x20    /* TCP/UDP Checksum Error */
+ #define E1000_RXD_ERR_IPE       0x40    /* IP Checksum Error */
+ #define E1000_RXD_ERR_RXE       0x80    /* Rx Data Error */
+ #define E1000_RXD_SPC_VLAN_MASK 0x0FFF  /* VLAN ID is in lower 12 bits */
+ #define E1000_RXD_SPC_PRI_MASK  0xE000  /* Priority is in upper 3 bits */
+ #define E1000_RXD_SPC_PRI_SHIFT 0x000D  /* Priority is in upper 3 of 16 */
+ #define E1000_RXD_SPC_CFI_MASK  0x1000  /* CFI is bit 12 */
+ #define E1000_RXD_SPC_CFI_SHIFT 0x000C  /* CFI is bit 12 */
+ 
+ /* mask to determine if packets should be dropped due to frame errors */
+ #define E1000_RXD_ERR_FRAME_ERR_MASK ( \
+     E1000_RXD_ERR_CE  |                \
+     E1000_RXD_ERR_SE  |                \
+     E1000_RXD_ERR_SEQ |                \
+     E1000_RXD_ERR_CXE |                \
+     E1000_RXD_ERR_RXE)
+ 
+ /* Transmit Descriptor */
+ struct e1000_tx_desc {
+     uint64_t buffer_addr;       /* Address of the descriptor's data buffer */
+     union {
+         uint32_t data;
+         struct {
+             uint16_t length;    /* Data buffer length */
+             uint8_t cso;        /* Checksum offset */
+             uint8_t cmd;        /* Descriptor control */
+         } flags;
+     } lower;
+     union {
+         uint32_t data;
+         struct {
+             uint8_t status;     /* Descriptor status */
+             uint8_t css;        /* Checksum start */
+             uint16_t special;
+         } fields;
+     } upper;
+ };
+ 
+ /* Transmit Descriptor bit definitions */
+ #define E1000_TXD_DTYP_D     0x00100000 /* Data Descriptor */
+ #define E1000_TXD_DTYP_C     0x00000000 /* Context Descriptor */
+ #define E1000_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
+ #define E1000_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
+ #define E1000_TXD_CMD_EOP    0x01000000 /* End of Packet */
+ #define E1000_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
+ #define E1000_TXD_CMD_IC     0x04000000 /* Insert Checksum */
+ #define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+ #define E1000_TXD_CMD_RPS    0x10000000 /* Report Packet Sent */
+ #define E1000_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
+ #define E1000_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
+ #define E1000_TXD_CMD_IDE    0x80000000 /* Enable Tidv register */
+ #define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+ #define E1000_TXD_STAT_EC    0x00000002 /* Excess Collisions */
+ #define E1000_TXD_STAT_LC    0x00000004 /* Late Collisions */
+ #define E1000_TXD_STAT_TU    0x00000008 /* Transmit underrun */
+ #define E1000_TXD_CMD_TCP    0x01000000 /* TCP packet */
+ #define E1000_TXD_CMD_IP     0x02000000 /* IP packet */
+ #define E1000_TXD_CMD_TSE    0x04000000 /* TCP Seg enable */
+ #define E1000_TXD_STAT_TC    0x00000004 /* Tx Underrun */
+ 
+ /* Offload Context Descriptor */
+ struct e1000_context_desc {
+     union {
+         uint32_t ip_config;
+         struct {
+             uint8_t ipcss;      /* IP checksum start */
+             uint8_t ipcso;      /* IP checksum offset */
+             uint16_t ipcse;     /* IP checksum end */
+         } ip_fields;
+     } lower_setup;
+     union {
+         uint32_t tcp_config;
+         struct {
+             uint8_t tucss;      /* TCP checksum start */
+             uint8_t tucso;      /* TCP checksum offset */
+             uint16_t tucse;     /* TCP checksum end */
+         } tcp_fields;
+     } upper_setup;
+     uint32_t cmd_and_length;    /* */
+     union {
+         uint32_t data;
+         struct {
+             uint8_t status;     /* Descriptor status */
+             uint8_t hdr_len;    /* Header length */
+             uint16_t mss;       /* Maximum segment size */
+         } fields;
+     } tcp_seg_setup;
+ };
+ 
+ /* Offload data descriptor */
+ struct e1000_data_desc {
+     uint64_t buffer_addr;       /* Address of the descriptor's buffer address */
+     union {
+         uint32_t data;
+         struct {
+             uint16_t length;    /* Data buffer length */
+             uint8_t typ_len_ext;        /* */
+             uint8_t cmd;        /* */
+         } flags;
+     } lower;
+     union {
+         uint32_t data;
+         struct {
+             uint8_t status;     /* Descriptor status */
+             uint8_t popts;      /* Packet Options */
+             uint16_t special;   /* */
+         } fields;
+     } upper;
+ };
+ 
+ /* Filters */
+ #define E1000_NUM_UNICAST          16   /* Unicast filter entries */
+ #define E1000_MC_TBL_SIZE          128  /* Multicast Filter Table (4096 bits) */
+ #define E1000_VLAN_FILTER_TBL_SIZE 128  /* VLAN Filter Table (4096 bits) */
+ 
+ 
+ /* Receive Address Register */
+ struct e1000_rar {
+     volatile uint32_t low;      /* receive address low */
+     volatile uint32_t high;     /* receive address high */
+ };
+ 
+ /* The number of entries in the Multicast Table Array (MTA). */
+ #define E1000_NUM_MTA_REGISTERS 128
+ 
+ /* IPv4 Address Table Entry */
+ struct e1000_ipv4_at_entry {
+     volatile uint32_t ipv4_addr;        /* IP Address (RW) */
+     volatile uint32_t reserved;
+ };
+ 
+ /* Four wakeup IP addresses are supported */
+ #define E1000_WAKEUP_IP_ADDRESS_COUNT_MAX 4
+ #define E1000_IP4AT_SIZE                  E1000_WAKEUP_IP_ADDRESS_COUNT_MAX
+ #define E1000_IP6AT_SIZE                  1
+ 
+ /* IPv6 Address Table Entry */
+ struct e1000_ipv6_at_entry {
+     volatile uint8_t ipv6_addr[16];
+ };
+ 
+ /* Flexible Filter Length Table Entry */
+ struct e1000_fflt_entry {
+     volatile uint32_t length;   /* Flexible Filter Length (RW) */
+     volatile uint32_t reserved;
+ };
+ 
+ /* Flexible Filter Mask Table Entry */
+ struct e1000_ffmt_entry {
+     volatile uint32_t mask;     /* Flexible Filter Mask (RW) */
+     volatile uint32_t reserved;
+ };
+ 
+ /* Flexible Filter Value Table Entry */
+ struct e1000_ffvt_entry {
+     volatile uint32_t value;    /* Flexible Filter Value (RW) */
+     volatile uint32_t reserved;
+ };
+ 
+ /* Four Flexible Filters are supported */
+ #define E1000_FLEXIBLE_FILTER_COUNT_MAX 4
+ 
+ /* Each Flexible Filter is at most 128 (0x80) bytes in length */
+ #define E1000_FLEXIBLE_FILTER_SIZE_MAX  128
+ 
+ #define E1000_FFLT_SIZE E1000_FLEXIBLE_FILTER_COUNT_MAX
+ #define E1000_FFMT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+ #define E1000_FFVT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+ 
+ /* Register Set. (82543, 82544)
+  *
+  * Registers are defined to be 32 bits and  should be accessed as 32 bit values.
+  * These registers are physically located on the NIC, but are mapped into the 
+  * host memory address space.
+  *
+  * RW - register is both readable and writable
+  * RO - register is read only
+  * WO - register is write only
+  * R/clr - register is read only and is cleared when read
+  * A - register array
+  */
+ #define E1000_CTRL     0x00000  /* Device Control - RW */
+ #define E1000_STATUS   0x00008  /* Device Status - RO */
+ #define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
+ #define E1000_EERD     0x00014  /* EEPROM Read - RW */
+ #define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
+ #define E1000_FLA      0x0001C  /* Flash Access - RW */
+ #define E1000_MDIC     0x00020  /* MDI Control - RW */
+ #define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
+ #define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
+ #define E1000_FCT      0x00030  /* Flow Control Type - RW */
+ #define E1000_VET      0x00038  /* VLAN Ether Type - RW */
+ #define E1000_ICR      0x000C0  /* Interrupt Cause Read - R/clr */
+ #define E1000_ITR      0x000C4  /* Interrupt Throttling Rate - RW */
+ #define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
+ #define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
+ #define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
+ #define E1000_RCTL     0x00100  /* RX Control - RW */
+ #define E1000_FCTTV    0x00170  /* Flow Control Transmit Timer Value - RW */
+ #define E1000_TXCW     0x00178  /* TX Configuration Word - RW */
+ #define E1000_RXCW     0x00180  /* RX Configuration Word - RO */
+ #define E1000_TCTL     0x00400  /* TX Control - RW */
+ #define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
+ #define E1000_TBT      0x00448  /* TX Burst Timer - RW */
+ #define E1000_AIT      0x00458  /* Adaptive Interframe Spacing Throttle - RW */
+ #define E1000_LEDCTL   0x00E00  /* LED Control - RW */
+ #define E1000_PBA      0x01000  /* Packet Buffer Allocation - RW */
+ #define E1000_FCRTL    0x02160  /* Flow Control Receive Threshold Low - RW */
+ #define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
+ #define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
+ #define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
+ #define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
+ #define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
+ #define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
+ #define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
+ #define E1000_RXDCTL   0x02828  /* RX Descriptor Control - RW */
+ #define E1000_RADV     0x0282C  /* RX Interrupt Absolute Delay Timer - RW */
+ #define E1000_RSRPD    0x02C00  /* RX Small Packet Detect - RW */
+ #define E1000_TXDMAC   0x03000  /* TX DMA Control - RW */
+ #define E1000_TDFH     0x03410  /* TX Data FIFO Head - RW */
+ #define E1000_TDFT     0x03418  /* TX Data FIFO Tail - RW */
+ #define E1000_TDFHS    0x03420  /* TX Data FIFO Head Saved - RW */
+ #define E1000_TDFTS    0x03428  /* TX Data FIFO Tail Saved - RW */
+ #define E1000_TDFPC    0x03430  /* TX Data FIFO Packet Count - RW */
+ #define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
+ #define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
+ #define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
+ #define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
+ #define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
+ #define E1000_TIDV     0x03820  /* TX Interrupt Delay Value - RW */
+ #define E1000_TXDCTL   0x03828  /* TX Descriptor Control - RW */
+ #define E1000_TADV     0x0382C  /* TX Interrupt Absolute Delay Val - RW */
+ #define E1000_TSPMT    0x03830  /* TCP Segmentation PAD & Min Threshold - RW */
+ #define E1000_CRCERRS  0x04000  /* CRC Error Count - R/clr */
+ #define E1000_ALGNERRC 0x04004  /* Alignment Error Count - R/clr */
+ #define E1000_SYMERRS  0x04008  /* Symbol Error Count - R/clr */
+ #define E1000_RXERRC   0x0400C  /* Receive Error Count - R/clr */
+ #define E1000_MPC      0x04010  /* Missed Packet Count - R/clr */
+ #define E1000_SCC      0x04014  /* Single Collision Count - R/clr */
+ #define E1000_ECOL     0x04018  /* Excessive Collision Count - R/clr */
+ #define E1000_MCC      0x0401C  /* Multiple Collision Count - R/clr */
+ #define E1000_LATECOL  0x04020  /* Late Collision Count - R/clr */
+ #define E1000_COLC     0x04028  /* Collision Count - R/clr */
+ #define E1000_DC       0x04030  /* Defer Count - R/clr */
+ #define E1000_TNCRS    0x04034  /* TX-No CRS - R/clr */
+ #define E1000_SEC      0x04038  /* Sequence Error Count - R/clr */
+ #define E1000_CEXTERR  0x0403C  /* Carrier Extension Error Count - R/clr */
+ #define E1000_RLEC     0x04040  /* Receive Length Error Count - R/clr */
+ #define E1000_XONRXC   0x04048  /* XON RX Count - R/clr */
+ #define E1000_XONTXC   0x0404C  /* XON TX Count - R/clr */
+ #define E1000_XOFFRXC  0x04050  /* XOFF RX Count - R/clr */
+ #define E1000_XOFFTXC  0x04054  /* XOFF TX Count - R/clr */
+ #define E1000_FCRUC    0x04058  /* Flow Control RX Unsupported Count- R/clr */
+ #define E1000_PRC64    0x0405C  /* Packets RX (64 bytes) - R/clr */
+ #define E1000_PRC127   0x04060  /* Packets RX (65-127 bytes) - R/clr */
+ #define E1000_PRC255   0x04064  /* Packets RX (128-255 bytes) - R/clr */
+ #define E1000_PRC511   0x04068  /* Packets RX (255-511 bytes) - R/clr */
+ #define E1000_PRC1023  0x0406C  /* Packets RX (512-1023 bytes) - R/clr */
+ #define E1000_PRC1522  0x04070  /* Packets RX (1024-1522 bytes) - R/clr */
+ #define E1000_GPRC     0x04074  /* Good Packets RX Count - R/clr */
+ #define E1000_BPRC     0x04078  /* Broadcast Packets RX Count - R/clr */
+ #define E1000_MPRC     0x0407C  /* Multicast Packets RX Count - R/clr */
+ #define E1000_GPTC     0x04080  /* Good Packets TX Count - R/clr */
+ #define E1000_GORCL    0x04088  /* Good Octets RX Count Low - R/clr */
+ #define E1000_GORCH    0x0408C  /* Good Octets RX Count High - R/clr */
+ #define E1000_GOTCL    0x04090  /* Good Octets TX Count Low - R/clr */
+ #define E1000_GOTCH    0x04094  /* Good Octets TX Count High - R/clr */
+ #define E1000_RNBC     0x040A0  /* RX No Buffers Count - R/clr */
+ #define E1000_RUC      0x040A4  /* RX Undersize Count - R/clr */
+ #define E1000_RFC      0x040A8  /* RX Fragment Count - R/clr */
+ #define E1000_ROC      0x040AC  /* RX Oversize Count - R/clr */
+ #define E1000_RJC      0x040B0  /* RX Jabber Count - R/clr */
+ #define E1000_MGTPRC   0x040B4  /* Management Packets RX Count - R/clr */
+ #define E1000_MGTPDC   0x040B8  /* Management Packets Dropped Count - R/clr */
+ #define E1000_MGTPTC   0x040BC  /* Management Packets TX Count - R/clr */
+ #define E1000_TORL     0x040C0  /* Total Octets RX Low - R/clr */
+ #define E1000_TORH     0x040C4  /* Total Octets RX High - R/clr */
+ #define E1000_TOTL     0x040C8  /* Total Octets TX Low - R/clr */
+ #define E1000_TOTH     0x040CC  /* Total Octets TX High - R/clr */
+ #define E1000_TPR      0x040D0  /* Total Packets RX - R/clr */
+ #define E1000_TPT      0x040D4  /* Total Packets TX - R/clr */
+ #define E1000_PTC64    0x040D8  /* Packets TX (64 bytes) - R/clr */
+ #define E1000_PTC127   0x040DC  /* Packets TX (65-127 bytes) - R/clr */
+ #define E1000_PTC255   0x040E0  /* Packets TX (128-255 bytes) - R/clr */
+ #define E1000_PTC511   0x040E4  /* Packets TX (256-511 bytes) - R/clr */
+ #define E1000_PTC1023  0x040E8  /* Packets TX (512-1023 bytes) - R/clr */
+ #define E1000_PTC1522  0x040EC  /* Packets TX (1024-1522 Bytes) - R/clr */
+ #define E1000_MPTC     0x040F0  /* Multicast Packets TX Count - R/clr */
+ #define E1000_BPTC     0x040F4  /* Broadcast Packets TX Count - R/clr */
+ #define E1000_TSCTC    0x040F8  /* TCP Segmentation Context TX - R/clr */
+ #define E1000_TSCTFC   0x040FC  /* TCP Segmentation Context TX Fail - R/clr */
+ #define E1000_RXCSUM   0x05000  /* RX Checksum Control - RW */
+ #define E1000_MTA      0x05200  /* Multicast Table Array - RW Array */
+ #define E1000_RA       0x05400  /* Receive Address - RW Array */
+ #define E1000_VFTA     0x05600  /* VLAN Filter Table Array - RW Array */
+ #define E1000_WUC      0x05800  /* Wakeup Control - RW */
+ #define E1000_WUFC     0x05808  /* Wakeup Filter Control - RW */
+ #define E1000_WUS      0x05810  /* Wakeup Status - RO */
+ #define E1000_MANC     0x05820  /* Management Control - RW */
+ #define E1000_IPAV     0x05838  /* IP Address Valid - RW */
+ #define E1000_IP4AT    0x05840  /* IPv4 Address Table - RW Array */
+ #define E1000_IP6AT    0x05880  /* IPv6 Address Table - RW Array */
+ #define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
+ #define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
+ #define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
+ #define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
+ #define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
+ 
+ /* Register Set (82542)
+  *
+  * Some of the 82542 registers are located at different offsets than they are
+  * in more current versions of the 8254x. Despite the difference in location,
+  * the registers function in the same manner.
+  */
+ #define E1000_82542_CTRL     E1000_CTRL
+ #define E1000_82542_CTRL_DUP E1000_CTRL_DUP
+ #define E1000_82542_STATUS   E1000_STATUS
+ #define E1000_82542_EECD     E1000_EECD
+ #define E1000_82542_EERD     E1000_EERD
+ #define E1000_82542_CTRL_EXT E1000_CTRL_EXT
+ #define E1000_82542_FLA      E1000_FLA
+ #define E1000_82542_MDIC     E1000_MDIC
+ #define E1000_82542_FCAL     E1000_FCAL
+ #define E1000_82542_FCAH     E1000_FCAH
+ #define E1000_82542_FCT      E1000_FCT
+ #define E1000_82542_VET      E1000_VET
+ #define E1000_82542_RA       0x00040
+ #define E1000_82542_ICR      E1000_ICR
+ #define E1000_82542_ITR      E1000_ITR
+ #define E1000_82542_ICS      E1000_ICS
+ #define E1000_82542_IMS      E1000_IMS
+ #define E1000_82542_IMC      E1000_IMC
+ #define E1000_82542_RCTL     E1000_RCTL
+ #define E1000_82542_RDTR     0x00108
+ #define E1000_82542_RDBAL    0x00110
+ #define E1000_82542_RDBAH    0x00114
+ #define E1000_82542_RDLEN    0x00118
+ #define E1000_82542_RDH      0x00120
+ #define E1000_82542_RDT      0x00128
+ #define E1000_82542_FCRTH    0x00160
+ #define E1000_82542_FCRTL    0x00168
+ #define E1000_82542_FCTTV    E1000_FCTTV
+ #define E1000_82542_TXCW     E1000_TXCW
+ #define E1000_82542_RXCW     E1000_RXCW
+ #define E1000_82542_MTA      0x00200
+ #define E1000_82542_TCTL     E1000_TCTL
+ #define E1000_82542_TIPG     E1000_TIPG
+ #define E1000_82542_TDBAL    0x00420
+ #define E1000_82542_TDBAH    0x00424
+ #define E1000_82542_TDLEN    0x00428
+ #define E1000_82542_TDH      0x00430
+ #define E1000_82542_TDT      0x00438
+ #define E1000_82542_TIDV     0x00440
+ #define E1000_82542_TBT      E1000_TBT
+ #define E1000_82542_AIT      E1000_AIT
+ #define E1000_82542_VFTA     0x00600
+ #define E1000_82542_LEDCTL   E1000_LEDCTL
+ #define E1000_82542_PBA      E1000_PBA
+ #define E1000_82542_RXDCTL   E1000_RXDCTL
+ #define E1000_82542_RADV     E1000_RADV
+ #define E1000_82542_RSRPD    E1000_RSRPD
+ #define E1000_82542_TXDMAC   E1000_TXDMAC
+ #define E1000_82542_TDFHS    E1000_TDFHS
+ #define E1000_82542_TDFTS    E1000_TDFTS
+ #define E1000_82542_TDFPC    E1000_TDFPC
+ #define E1000_82542_TXDCTL   E1000_TXDCTL
+ #define E1000_82542_TADV     E1000_TADV
+ #define E1000_82542_TSPMT    E1000_TSPMT
+ #define E1000_82542_CRCERRS  E1000_CRCERRS
+ #define E1000_82542_ALGNERRC E1000_ALGNERRC
+ #define E1000_82542_SYMERRS  E1000_SYMERRS
+ #define E1000_82542_RXERRC   E1000_RXERRC
+ #define E1000_82542_MPC      E1000_MPC
+ #define E1000_82542_SCC      E1000_SCC
+ #define E1000_82542_ECOL     E1000_ECOL
+ #define E1000_82542_MCC      E1000_MCC
+ #define E1000_82542_LATECOL  E1000_LATECOL
+ #define E1000_82542_COLC     E1000_COLC
+ #define E1000_82542_DC       E1000_DC
+ #define E1000_82542_TNCRS    E1000_TNCRS
+ #define E1000_82542_SEC      E1000_SEC
+ #define E1000_82542_CEXTERR  E1000_CEXTERR
+ #define E1000_82542_RLEC     E1000_RLEC
+ #define E1000_82542_XONRXC   E1000_XONRXC
+ #define E1000_82542_XONTXC   E1000_XONTXC
+ #define E1000_82542_XOFFRXC  E1000_XOFFRXC
+ #define E1000_82542_XOFFTXC  E1000_XOFFTXC
+ #define E1000_82542_FCRUC    E1000_FCRUC
+ #define E1000_82542_PRC64    E1000_PRC64
+ #define E1000_82542_PRC127   E1000_PRC127
+ #define E1000_82542_PRC255   E1000_PRC255
+ #define E1000_82542_PRC511   E1000_PRC511
+ #define E1000_82542_PRC1023  E1000_PRC1023
+ #define E1000_82542_PRC1522  E1000_PRC1522
+ #define E1000_82542_GPRC     E1000_GPRC
+ #define E1000_82542_BPRC     E1000_BPRC
+ #define E1000_82542_MPRC     E1000_MPRC
+ #define E1000_82542_GPTC     E1000_GPTC
+ #define E1000_82542_GORCL    E1000_GORCL
+ #define E1000_82542_GORCH    E1000_GORCH
+ #define E1000_82542_GOTCL    E1000_GOTCL
+ #define E1000_82542_GOTCH    E1000_GOTCH
+ #define E1000_82542_RNBC     E1000_RNBC
+ #define E1000_82542_RUC      E1000_RUC
+ #define E1000_82542_RFC      E1000_RFC
+ #define E1000_82542_ROC      E1000_ROC
+ #define E1000_82542_RJC      E1000_RJC
+ #define E1000_82542_MGTPRC   E1000_MGTPRC
+ #define E1000_82542_MGTPDC   E1000_MGTPDC
+ #define E1000_82542_MGTPTC   E1000_MGTPTC
+ #define E1000_82542_TORL     E1000_TORL
+ #define E1000_82542_TORH     E1000_TORH
+ #define E1000_82542_TOTL     E1000_TOTL
+ #define E1000_82542_TOTH     E1000_TOTH
+ #define E1000_82542_TPR      E1000_TPR
+ #define E1000_82542_TPT      E1000_TPT
+ #define E1000_82542_PTC64    E1000_PTC64
+ #define E1000_82542_PTC127   E1000_PTC127
+ #define E1000_82542_PTC255   E1000_PTC255
+ #define E1000_82542_PTC511   E1000_PTC511
+ #define E1000_82542_PTC1023  E1000_PTC1023
+ #define E1000_82542_PTC1522  E1000_PTC1522
+ #define E1000_82542_MPTC     E1000_MPTC
+ #define E1000_82542_BPTC     E1000_BPTC
+ #define E1000_82542_TSCTC    E1000_TSCTC
+ #define E1000_82542_TSCTFC   E1000_TSCTFC
+ #define E1000_82542_RXCSUM   E1000_RXCSUM
+ #define E1000_82542_WUC      E1000_WUC
+ #define E1000_82542_WUFC     E1000_WUFC
+ #define E1000_82542_WUS      E1000_WUS
+ #define E1000_82542_MANC     E1000_MANC
+ #define E1000_82542_IPAV     E1000_IPAV
+ #define E1000_82542_IP4AT    E1000_IP4AT
+ #define E1000_82542_IP6AT    E1000_IP6AT
+ #define E1000_82542_WUPL     E1000_WUPL
+ #define E1000_82542_WUPM     E1000_WUPM
+ #define E1000_82542_FFLT     E1000_FFLT
+ #define E1000_82542_TDFH     0x08010
+ #define E1000_82542_TDFT     0x08018
+ #define E1000_82542_FFMT     E1000_FFMT
+ #define E1000_82542_FFVT     E1000_FFVT
+ 
+ /* Statistics counters collected by the MAC */
+ struct e1000_hw_stats {
+     uint64_t crcerrs;
+     uint64_t algnerrc;
+     uint64_t symerrs;
+     uint64_t rxerrc;
+     uint64_t mpc;
+     uint64_t scc;
+     uint64_t ecol;
+     uint64_t mcc;
+     uint64_t latecol;
+     uint64_t colc;
+     uint64_t dc;
+     uint64_t tncrs;
+     uint64_t sec;
+     uint64_t cexterr;
+     uint64_t rlec;
+     uint64_t xonrxc;
+     uint64_t xontxc;
+     uint64_t xoffrxc;
+     uint64_t xofftxc;
+     uint64_t fcruc;
+     uint64_t prc64;
+     uint64_t prc127;
+     uint64_t prc255;
+     uint64_t prc511;
+     uint64_t prc1023;
+     uint64_t prc1522;
+     uint64_t gprc;
+     uint64_t bprc;
+     uint64_t mprc;
+     uint64_t gptc;
+     uint64_t gorcl;
+     uint64_t gorch;
+     uint64_t gotcl;
+     uint64_t gotch;
+     uint64_t rnbc;
+     uint64_t ruc;
+     uint64_t rfc;
+     uint64_t roc;
+     uint64_t rjc;
+     uint64_t mgprc;
+     uint64_t mgpdc;
+     uint64_t mgptc;
+     uint64_t torl;
+     uint64_t torh;
+     uint64_t totl;
+     uint64_t toth;
+     uint64_t tpr;
+     uint64_t tpt;
+     uint64_t ptc64;
+     uint64_t ptc127;
+     uint64_t ptc255;
+     uint64_t ptc511;
+     uint64_t ptc1023;
+     uint64_t ptc1522;
+     uint64_t mptc;
+     uint64_t bptc;
+     uint64_t tsctc;
+     uint64_t tsctfc;
+ };
+ 
+ /* Structure containing variables used by the shared code (e1000_hw.c) */
+ struct e1000_hw {
+ 	struct pci_device *pdev;
+ 	uint8_t *hw_addr;
+ 	e1000_mac_type   mac_type;
+ 	e1000_phy_type phy_type;
+ 	uint32_t phy_init_script;
+ 	e1000_media_type media_type;
+ 	e1000_fc_type    fc;
+ #if 0
+ 	e1000_bus_speed bus_speed;
+ 	e1000_bus_width bus_width;
+ 	e1000_bus_type  bus_type;
+ #endif
+ 	struct e1000_eeprom_info eeprom;
+ #if 0
+ 	uint32_t io_base;
+ #endif
+ 	uint32_t phy_id;
+ #ifdef LINUX_DRIVER
+ 	uint32_t phy_revision;
+ #endif
+ 	uint32_t phy_addr;
+ 	uint32_t original_fc;
+ 	uint32_t txcw;
+ 	uint32_t autoneg_failed;
+ #if 0
+ 	uint32_t max_frame_size;
+ 	uint32_t min_frame_size;
+ 	uint32_t mc_filter_type;
+ 	uint32_t num_mc_addrs;
+ 	uint32_t collision_delta;
+ 	uint32_t tx_packet_delta;
+ 	uint32_t ledctl_default;
+ 	uint32_t ledctl_mode1;
+ 	uint32_t ledctl_mode2;
+ #endif
+ 	uint16_t autoneg_advertised;
+ 	uint16_t pci_cmd_word;
+ 	uint16_t fc_high_water;
+ 	uint16_t fc_low_water;
+ 	uint16_t fc_pause_time;
+ #if 0
+ 	uint16_t current_ifs_val;
+ 	uint16_t ifs_min_val;
+ 	uint16_t ifs_max_val;
+ 	uint16_t ifs_step_size;
+ 	uint16_t ifs_ratio;
+ #endif
+ 	uint16_t device_id;
+ 	uint16_t vendor_id;
+ 	uint16_t subsystem_id;
+ 	uint16_t subsystem_vendor_id;
+ 	uint8_t revision_id;
+ #if 0
+ 	uint8_t autoneg;
+ 	uint8_t mdix;
+ 	uint8_t forced_speed_duplex;
+ 	uint8_t wait_autoneg_complete;
+ 	uint8_t dma_fairness;
+ #endif
+ 	uint8_t mac_addr[NODE_ADDRESS_SIZE];
+ #if 0
+ 	uint8_t perm_mac_addr[NODE_ADDRESS_SIZE];
+ 	boolean_t disable_polarity_correction;
+ 	boolean_t speed_downgraded;
+ #endif
+ 	boolean_t get_link_status;
+ 	boolean_t tbi_compatibility_en;
+ 	boolean_t tbi_compatibility_on;
+ 	boolean_t fc_send_xon;
+ 	boolean_t report_tx_early;
+ #if 0
+ 	boolean_t adaptive_ifs;
+ 	boolean_t ifs_params_forced;
+ 	boolean_t in_ifs_mode;
+ #endif
+ };
+ 
+ 
+ #define E1000_EEPROM_SWDPIN0   0x0001   /* SWDPIN 0 EEPROM Value */
+ #define E1000_EEPROM_LED_LOGIC 0x0020   /* Led Logic Word */
+ 
+ /* Register Bit Masks */
+ /* Device Control */
+ #define E1000_CTRL_FD       0x00000001  /* Full duplex.0=half; 1=full */
+ #define E1000_CTRL_BEM      0x00000002  /* Endian Mode.0=little,1=big */
+ #define E1000_CTRL_PRIOR    0x00000004  /* Priority on PCI. 0=rx,1=fair */
+ #define E1000_CTRL_LRST     0x00000008  /* Link reset. 0=normal,1=reset */
+ #define E1000_CTRL_TME      0x00000010  /* Test mode. 0=normal,1=test */
+ #define E1000_CTRL_SLE      0x00000020  /* Serial Link on 0=dis,1=en */
+ #define E1000_CTRL_ASDE     0x00000020  /* Auto-speed detect enable */
+ #define E1000_CTRL_SLU      0x00000040  /* Set link up (Force Link) */
+ #define E1000_CTRL_ILOS     0x00000080  /* Invert Loss-Of Signal */
+ #define E1000_CTRL_SPD_SEL  0x00000300  /* Speed Select Mask */
+ #define E1000_CTRL_SPD_10   0x00000000  /* Force 10Mb */
+ #define E1000_CTRL_SPD_100  0x00000100  /* Force 100Mb */
+ #define E1000_CTRL_SPD_1000 0x00000200  /* Force 1Gb */
+ #define E1000_CTRL_BEM32    0x00000400  /* Big Endian 32 mode */
+ #define E1000_CTRL_FRCSPD   0x00000800  /* Force Speed */
+ #define E1000_CTRL_FRCDPX   0x00001000  /* Force Duplex */
+ #define E1000_CTRL_SWDPIN0  0x00040000  /* SWDPIN 0 value */
+ #define E1000_CTRL_SWDPIN1  0x00080000  /* SWDPIN 1 value */
+ #define E1000_CTRL_SWDPIN2  0x00100000  /* SWDPIN 2 value */
+ #define E1000_CTRL_SWDPIN3  0x00200000  /* SWDPIN 3 value */
+ #define E1000_CTRL_SWDPIO0  0x00400000  /* SWDPIN 0 Input or output */
+ #define E1000_CTRL_SWDPIO1  0x00800000  /* SWDPIN 1 input or output */
+ #define E1000_CTRL_SWDPIO2  0x01000000  /* SWDPIN 2 input or output */
+ #define E1000_CTRL_SWDPIO3  0x02000000  /* SWDPIN 3 input or output */
+ #define E1000_CTRL_RST      0x04000000  /* Global reset */
+ #define E1000_CTRL_RFCE     0x08000000  /* Receive Flow Control enable */
+ #define E1000_CTRL_TFCE     0x10000000  /* Transmit flow control enable */
+ #define E1000_CTRL_RTE      0x20000000  /* Routing tag enable */
+ #define E1000_CTRL_VME      0x40000000  /* IEEE VLAN mode enable */
+ #define E1000_CTRL_PHY_RST  0x80000000  /* PHY Reset */
+ 
+ /* Device Status */
+ #define E1000_STATUS_FD         0x00000001      /* Full duplex.0=half,1=full */
+ #define E1000_STATUS_LU         0x00000002      /* Link up.0=no,1=link */
+ #define E1000_STATUS_FUNC_MASK  0x0000000C      /* PCI Function Mask */
+ #define E1000_STATUS_FUNC_0     0x00000000      /* Function 0 */
+ #define E1000_STATUS_FUNC_1     0x00000004      /* Function 1 */
+ #define E1000_STATUS_TXOFF      0x00000010      /* transmission paused */
+ #define E1000_STATUS_TBIMODE    0x00000020      /* TBI mode */
+ #define E1000_STATUS_SPEED_MASK 0x000000C0
+ #define E1000_STATUS_SPEED_10   0x00000000      /* Speed 10Mb/s */
+ #define E1000_STATUS_SPEED_100  0x00000040      /* Speed 100Mb/s */
+ #define E1000_STATUS_SPEED_1000 0x00000080      /* Speed 1000Mb/s */
+ #define E1000_STATUS_ASDV       0x00000300      /* Auto speed detect value */
+ #define E1000_STATUS_MTXCKOK    0x00000400      /* MTX clock running OK */
+ #define E1000_STATUS_PCI66      0x00000800      /* In 66Mhz slot */
+ #define E1000_STATUS_BUS64      0x00001000      /* In 64 bit slot */
+ #define E1000_STATUS_PCIX_MODE  0x00002000      /* PCI-X mode */
+ #define E1000_STATUS_PCIX_SPEED 0x0000C000      /* PCI-X bus speed */
+ 
+ /* Constants used to intrepret the masked PCI-X bus speed. */
+ #define E1000_STATUS_PCIX_SPEED_66  0x00000000 /* PCI-X bus speed  50-66 MHz */
+ #define E1000_STATUS_PCIX_SPEED_100 0x00004000 /* PCI-X bus speed  66-100 MHz */
+ #define E1000_STATUS_PCIX_SPEED_133 0x00008000 /* PCI-X bus speed 100-133 MHz */
+ 
+ /* EEPROM/Flash Control */
+ #define E1000_EECD_SK        0x00000001 /* EEPROM Clock */
+ #define E1000_EECD_CS        0x00000002 /* EEPROM Chip Select */
+ #define E1000_EECD_DI        0x00000004 /* EEPROM Data In */
+ #define E1000_EECD_DO        0x00000008 /* EEPROM Data Out */
+ #define E1000_EECD_FWE_MASK  0x00000030 
+ #define E1000_EECD_FWE_DIS   0x00000010 /* Disable FLASH writes */
+ #define E1000_EECD_FWE_EN    0x00000020 /* Enable FLASH writes */
+ #define E1000_EECD_FWE_SHIFT 4
+ #define E1000_EECD_REQ       0x00000040 /* EEPROM Access Request */
+ #define E1000_EECD_GNT       0x00000080 /* EEPROM Access Grant */
+ #define E1000_EECD_PRES      0x00000100 /* EEPROM Present */
+ #define E1000_EECD_SIZE      0x00000200 /* EEPROM Size (0=64 word 1=256 word) */
+ #define E1000_EECD_ADDR_BITS 0x00000400 /* EEPROM Addressing bits based on type
+                                          * (0-small, 1-large) */
+ #define E1000_EECD_TYPE      0x00002000 /* EEPROM Type (1-SPI, 0-Microwire) */
+ #ifndef E1000_EEPROM_GRANT_ATTEMPTS
+ #define E1000_EEPROM_GRANT_ATTEMPTS 1000 /* EEPROM # attempts to gain grant */
+ #endif
+ 
+ /* EEPROM Read */
+ #define E1000_EERD_START      0x00000001 /* Start Read */
+ #define E1000_EERD_DONE       0x00000010 /* Read Done */
+ #define E1000_EERD_ADDR_SHIFT 8
+ #define E1000_EERD_ADDR_MASK  0x0000FF00 /* Read Address */
+ #define E1000_EERD_DATA_SHIFT 16
+ #define E1000_EERD_DATA_MASK  0xFFFF0000 /* Read Data */
+ 
+ /* SPI EEPROM Status Register */
+ #define EEPROM_STATUS_RDY_SPI  0x01
+ #define EEPROM_STATUS_WEN_SPI  0x02
+ #define EEPROM_STATUS_BP0_SPI  0x04
+ #define EEPROM_STATUS_BP1_SPI  0x08
+ #define EEPROM_STATUS_WPEN_SPI 0x80
+ 
+ /* Extended Device Control */
+ #define E1000_CTRL_EXT_GPI0_EN   0x00000001 /* Maps SDP4 to GPI0 */ 
+ #define E1000_CTRL_EXT_GPI1_EN   0x00000002 /* Maps SDP5 to GPI1 */
+ #define E1000_CTRL_EXT_PHYINT_EN E1000_CTRL_EXT_GPI1_EN
+ #define E1000_CTRL_EXT_GPI2_EN   0x00000004 /* Maps SDP6 to GPI2 */
+ #define E1000_CTRL_EXT_GPI3_EN   0x00000008 /* Maps SDP7 to GPI3 */
+ #define E1000_CTRL_EXT_SDP4_DATA 0x00000010 /* Value of SW Defineable Pin 4 */
+ #define E1000_CTRL_EXT_SDP5_DATA 0x00000020 /* Value of SW Defineable Pin 5 */
+ #define E1000_CTRL_EXT_PHY_INT   E1000_CTRL_EXT_SDP5_DATA
+ #define E1000_CTRL_EXT_SDP6_DATA 0x00000040 /* Value of SW Defineable Pin 6 */
+ #define E1000_CTRL_EXT_SDP7_DATA 0x00000080 /* Value of SW Defineable Pin 7 */
+ #define E1000_CTRL_EXT_SDP4_DIR  0x00000100 /* Direction of SDP4 0=in 1=out */
+ #define E1000_CTRL_EXT_SDP5_DIR  0x00000200 /* Direction of SDP5 0=in 1=out */
+ #define E1000_CTRL_EXT_SDP6_DIR  0x00000400 /* Direction of SDP6 0=in 1=out */
+ #define E1000_CTRL_EXT_SDP7_DIR  0x00000800 /* Direction of SDP7 0=in 1=out */
+ #define E1000_CTRL_EXT_ASDCHK    0x00001000 /* Initiate an ASD sequence */
+ #define E1000_CTRL_EXT_EE_RST    0x00002000 /* Reinitialize from EEPROM */
+ #define E1000_CTRL_EXT_IPS       0x00004000 /* Invert Power State */
+ #define E1000_CTRL_EXT_SPD_BYPS  0x00008000 /* Speed Select Bypass */
+ #define E1000_CTRL_EXT_LINK_MODE_MASK 0x00C00000
+ #define E1000_CTRL_EXT_LINK_MODE_GMII 0x00000000
+ #define E1000_CTRL_EXT_LINK_MODE_TBI  0x00C00000
+ #define E1000_CTRL_EXT_WR_WMARK_MASK  0x03000000
+ #define E1000_CTRL_EXT_WR_WMARK_256   0x00000000
+ #define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
+ #define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
+ #define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+ 
+ /* MDI Control */
+ #define E1000_MDIC_DATA_MASK 0x0000FFFF
+ #define E1000_MDIC_REG_MASK  0x001F0000
+ #define E1000_MDIC_REG_SHIFT 16
+ #define E1000_MDIC_PHY_MASK  0x03E00000
+ #define E1000_MDIC_PHY_SHIFT 21
+ #define E1000_MDIC_OP_WRITE  0x04000000
+ #define E1000_MDIC_OP_READ   0x08000000
+ #define E1000_MDIC_READY     0x10000000
+ #define E1000_MDIC_INT_EN    0x20000000
+ #define E1000_MDIC_ERROR     0x40000000
+ 
+ /* LED Control */
+ #define E1000_LEDCTL_LED0_MODE_MASK  0x0000000F
+ #define E1000_LEDCTL_LED0_MODE_SHIFT 0
+ #define E1000_LEDCTL_LED0_IVRT       0x00000040
+ #define E1000_LEDCTL_LED0_BLINK      0x00000080
+ #define E1000_LEDCTL_LED1_MODE_MASK  0x00000F00
+ #define E1000_LEDCTL_LED1_MODE_SHIFT 8
+ #define E1000_LEDCTL_LED1_IVRT       0x00004000
+ #define E1000_LEDCTL_LED1_BLINK      0x00008000
+ #define E1000_LEDCTL_LED2_MODE_MASK  0x000F0000
+ #define E1000_LEDCTL_LED2_MODE_SHIFT 16
+ #define E1000_LEDCTL_LED2_IVRT       0x00400000
+ #define E1000_LEDCTL_LED2_BLINK      0x00800000
+ #define E1000_LEDCTL_LED3_MODE_MASK  0x0F000000
+ #define E1000_LEDCTL_LED3_MODE_SHIFT 24
+ #define E1000_LEDCTL_LED3_IVRT       0x40000000
+ #define E1000_LEDCTL_LED3_BLINK      0x80000000
+ 
+ #define E1000_LEDCTL_MODE_LINK_10_1000  0x0
+ #define E1000_LEDCTL_MODE_LINK_100_1000 0x1
+ #define E1000_LEDCTL_MODE_LINK_UP       0x2
+ #define E1000_LEDCTL_MODE_ACTIVITY      0x3
+ #define E1000_LEDCTL_MODE_LINK_ACTIVITY 0x4
+ #define E1000_LEDCTL_MODE_LINK_10       0x5
+ #define E1000_LEDCTL_MODE_LINK_100      0x6
+ #define E1000_LEDCTL_MODE_LINK_1000     0x7
+ #define E1000_LEDCTL_MODE_PCIX_MODE     0x8
+ #define E1000_LEDCTL_MODE_FULL_DUPLEX   0x9
+ #define E1000_LEDCTL_MODE_COLLISION     0xA
+ #define E1000_LEDCTL_MODE_BUS_SPEED     0xB
+ #define E1000_LEDCTL_MODE_BUS_SIZE      0xC
+ #define E1000_LEDCTL_MODE_PAUSED        0xD
+ #define E1000_LEDCTL_MODE_LED_ON        0xE
+ #define E1000_LEDCTL_MODE_LED_OFF       0xF
+ 
+ /* Receive Address */
+ #define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */
+ 
+ /* Interrupt Cause Read */
+ #define E1000_ICR_TXDW    0x00000001    /* Transmit desc written back */
+ #define E1000_ICR_TXQE    0x00000002    /* Transmit Queue empty */
+ #define E1000_ICR_LSC     0x00000004    /* Link Status Change */
+ #define E1000_ICR_RXSEQ   0x00000008    /* rx sequence error */
+ #define E1000_ICR_RXDMT0  0x00000010    /* rx desc min. threshold (0) */
+ #define E1000_ICR_RXO     0x00000040    /* rx overrun */
+ #define E1000_ICR_RXT0    0x00000080    /* rx timer intr (ring 0) */
+ #define E1000_ICR_MDAC    0x00000200    /* MDIO access complete */
+ #define E1000_ICR_RXCFG   0x00000400    /* RX /c/ ordered set */
+ #define E1000_ICR_GPI_EN0 0x00000800    /* GP Int 0 */
+ #define E1000_ICR_GPI_EN1 0x00001000    /* GP Int 1 */
+ #define E1000_ICR_GPI_EN2 0x00002000    /* GP Int 2 */
+ #define E1000_ICR_GPI_EN3 0x00004000    /* GP Int 3 */
+ #define E1000_ICR_TXD_LOW 0x00008000
+ #define E1000_ICR_SRPD    0x00010000
+ 
+ /* Interrupt Cause Set */
+ #define E1000_ICS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+ #define E1000_ICS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+ #define E1000_ICS_LSC     E1000_ICR_LSC         /* Link Status Change */
+ #define E1000_ICS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+ #define E1000_ICS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+ #define E1000_ICS_RXO     E1000_ICR_RXO         /* rx overrun */
+ #define E1000_ICS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+ #define E1000_ICS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+ #define E1000_ICS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+ #define E1000_ICS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+ #define E1000_ICS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+ #define E1000_ICS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+ #define E1000_ICS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+ #define E1000_ICS_TXD_LOW E1000_ICR_TXD_LOW
+ #define E1000_ICS_SRPD    E1000_ICR_SRPD
+ 
+ /* Interrupt Mask Set */
+ #define E1000_IMS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+ #define E1000_IMS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+ #define E1000_IMS_LSC     E1000_ICR_LSC         /* Link Status Change */
+ #define E1000_IMS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+ #define E1000_IMS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+ #define E1000_IMS_RXO     E1000_ICR_RXO         /* rx overrun */
+ #define E1000_IMS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+ #define E1000_IMS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+ #define E1000_IMS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+ #define E1000_IMS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+ #define E1000_IMS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+ #define E1000_IMS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+ #define E1000_IMS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+ #define E1000_IMS_TXD_LOW E1000_ICR_TXD_LOW
+ #define E1000_IMS_SRPD    E1000_ICR_SRPD
+ 
+ /* Interrupt Mask Clear */
+ #define E1000_IMC_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+ #define E1000_IMC_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+ #define E1000_IMC_LSC     E1000_ICR_LSC         /* Link Status Change */
+ #define E1000_IMC_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+ #define E1000_IMC_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+ #define E1000_IMC_RXO     E1000_ICR_RXO         /* rx overrun */
+ #define E1000_IMC_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+ #define E1000_IMC_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+ #define E1000_IMC_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+ #define E1000_IMC_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+ #define E1000_IMC_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+ #define E1000_IMC_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+ #define E1000_IMC_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+ #define E1000_IMC_TXD_LOW E1000_ICR_TXD_LOW
+ #define E1000_IMC_SRPD    E1000_ICR_SRPD
+ 
+ /* Receive Control */
+ #define E1000_RCTL_RST          0x00000001      /* Software reset */
+ #define E1000_RCTL_EN           0x00000002      /* enable */
+ #define E1000_RCTL_SBP          0x00000004      /* store bad packet */
+ #define E1000_RCTL_UPE          0x00000008      /* unicast promiscuous enable */
+ #define E1000_RCTL_MPE          0x00000010      /* multicast promiscuous enab */
+ #define E1000_RCTL_LPE          0x00000020      /* long packet enable */
+ #define E1000_RCTL_LBM_NO       0x00000000      /* no loopback mode */
+ #define E1000_RCTL_LBM_MAC      0x00000040      /* MAC loopback mode */
+ #define E1000_RCTL_LBM_SLP      0x00000080      /* serial link loopback mode */
+ #define E1000_RCTL_LBM_TCVR     0x000000C0      /* tcvr loopback mode */
+ #define E1000_RCTL_RDMTS_HALF   0x00000000      /* rx desc min threshold size */
+ #define E1000_RCTL_RDMTS_QUAT   0x00000100      /* rx desc min threshold size */
+ #define E1000_RCTL_RDMTS_EIGTH  0x00000200      /* rx desc min threshold size */
+ #define E1000_RCTL_MO_SHIFT     12              /* multicast offset shift */
+ #define E1000_RCTL_MO_0         0x00000000      /* multicast offset 11:0 */
+ #define E1000_RCTL_MO_1         0x00001000      /* multicast offset 12:1 */
+ #define E1000_RCTL_MO_2         0x00002000      /* multicast offset 13:2 */
+ #define E1000_RCTL_MO_3         0x00003000      /* multicast offset 15:4 */
+ #define E1000_RCTL_MDR          0x00004000      /* multicast desc ring 0 */
+ #define E1000_RCTL_BAM          0x00008000      /* broadcast enable */
+ /* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
+ #define E1000_RCTL_SZ_2048      0x00000000      /* rx buffer size 2048 */
+ #define E1000_RCTL_SZ_1024      0x00010000      /* rx buffer size 1024 */
+ #define E1000_RCTL_SZ_512       0x00020000      /* rx buffer size 512 */
+ #define E1000_RCTL_SZ_256       0x00030000      /* rx buffer size 256 */
+ /* these buffer sizes are valid if E1000_RCTL_BSEX is 1 */
+ #define E1000_RCTL_SZ_16384     0x00010000      /* rx buffer size 16384 */
+ #define E1000_RCTL_SZ_8192      0x00020000      /* rx buffer size 8192 */
+ #define E1000_RCTL_SZ_4096      0x00030000      /* rx buffer size 4096 */
+ #define E1000_RCTL_VFE          0x00040000      /* vlan filter enable */
+ #define E1000_RCTL_CFIEN        0x00080000      /* canonical form enable */
+ #define E1000_RCTL_CFI          0x00100000      /* canonical form indicator */
+ #define E1000_RCTL_DPF          0x00400000      /* discard pause frames */
+ #define E1000_RCTL_PMCF         0x00800000      /* pass MAC control frames */
+ #define E1000_RCTL_BSEX         0x02000000      /* Buffer size extension */
+ 
+ /* Receive Descriptor */
+ #define E1000_RDT_DELAY 0x0000ffff      /* Delay timer (1=1024us) */
+ #define E1000_RDT_FPDB  0x80000000      /* Flush descriptor block */
+ #define E1000_RDLEN_LEN 0x0007ff80      /* descriptor length */
+ #define E1000_RDH_RDH   0x0000ffff      /* receive descriptor head */
+ #define E1000_RDT_RDT   0x0000ffff      /* receive descriptor tail */
+ 
+ /* Flow Control */
+ #define E1000_FCRTH_RTH  0x0000FFF8     /* Mask Bits[15:3] for RTH */
+ #define E1000_FCRTH_XFCE 0x80000000     /* External Flow Control Enable */
+ #define E1000_FCRTL_RTL  0x0000FFF8     /* Mask Bits[15:3] for RTL */
+ #define E1000_FCRTL_XONE 0x80000000     /* Enable XON frame transmission */
+ 
+ /* Receive Descriptor Control */
+ #define E1000_RXDCTL_PTHRESH 0x0000003F /* RXDCTL Prefetch Threshold */
+ #define E1000_RXDCTL_HTHRESH 0x00003F00 /* RXDCTL Host Threshold */
+ #define E1000_RXDCTL_WTHRESH 0x003F0000 /* RXDCTL Writeback Threshold */
+ #define E1000_RXDCTL_GRAN    0x01000000 /* RXDCTL Granularity */
+ 
+ /* Transmit Descriptor Control */
+ #define E1000_TXDCTL_PTHRESH 0x000000FF /* TXDCTL Prefetch Threshold */
+ #define E1000_TXDCTL_HTHRESH 0x0000FF00 /* TXDCTL Host Threshold */
+ #define E1000_TXDCTL_WTHRESH 0x00FF0000 /* TXDCTL Writeback Threshold */
+ #define E1000_TXDCTL_GRAN    0x01000000 /* TXDCTL Granularity */
+ #define E1000_TXDCTL_LWTHRESH 0xFE000000 /* TXDCTL Low Threshold */
+ #define E1000_TXDCTL_FULL_TX_DESC_WB 0x01010000 /* GRAN=1, WTHRESH=1 */
+ 
+ /* Transmit Configuration Word */
+ #define E1000_TXCW_FD         0x00000020        /* TXCW full duplex */
+ #define E1000_TXCW_HD         0x00000040        /* TXCW half duplex */
+ #define E1000_TXCW_PAUSE      0x00000080        /* TXCW sym pause request */
+ #define E1000_TXCW_ASM_DIR    0x00000100        /* TXCW astm pause direction */
+ #define E1000_TXCW_PAUSE_MASK 0x00000180        /* TXCW pause request mask */
+ #define E1000_TXCW_RF         0x00003000        /* TXCW remote fault */
+ #define E1000_TXCW_NP         0x00008000        /* TXCW next page */
+ #define E1000_TXCW_CW         0x0000ffff        /* TxConfigWord mask */
+ #define E1000_TXCW_TXC        0x40000000        /* Transmit Config control */
+ #define E1000_TXCW_ANE        0x80000000        /* Auto-neg enable */
+ 
+ /* Receive Configuration Word */
+ #define E1000_RXCW_CW    0x0000ffff     /* RxConfigWord mask */
+ #define E1000_RXCW_NC    0x04000000     /* Receive config no carrier */
+ #define E1000_RXCW_IV    0x08000000     /* Receive config invalid */
+ #define E1000_RXCW_CC    0x10000000     /* Receive config change */
+ #define E1000_RXCW_C     0x20000000     /* Receive config */
+ #define E1000_RXCW_SYNCH 0x40000000     /* Receive config synch */
+ #define E1000_RXCW_ANC   0x80000000     /* Auto-neg complete */
+ 
+ /* Transmit Control */
+ #define E1000_TCTL_RST    0x00000001    /* software reset */
+ #define E1000_TCTL_EN     0x00000002    /* enable tx */
+ #define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+ #define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+ #define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+ #define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+ #define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+ #define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+ #define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+ #define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+ 
+ /* Receive Checksum Control */
+ #define E1000_RXCSUM_PCSS_MASK 0x000000FF   /* Packet Checksum Start */
+ #define E1000_RXCSUM_IPOFL     0x00000100   /* IPv4 checksum offload */
+ #define E1000_RXCSUM_TUOFL     0x00000200   /* TCP / UDP checksum offload */
+ #define E1000_RXCSUM_IPV6OFL   0x00000400   /* IPv6 checksum offload */
+ 
+ /* Definitions for power management and wakeup registers */
+ /* Wake Up Control */
+ #define E1000_WUC_APME       0x00000001 /* APM Enable */
+ #define E1000_WUC_PME_EN     0x00000002 /* PME Enable */
+ #define E1000_WUC_PME_STATUS 0x00000004 /* PME Status */
+ #define E1000_WUC_APMPME     0x00000008 /* Assert PME on APM Wakeup */
+ #define E1000_WUC_SPM        0x80000000 /* Enable SPM */
+ 
+ /* Wake Up Filter Control */
+ #define E1000_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
+ #define E1000_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
+ #define E1000_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
+ #define E1000_WUFC_MC   0x00000008 /* Directed Multicast Wakeup Enable */
+ #define E1000_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
+ #define E1000_WUFC_ARP  0x00000020 /* ARP Request Packet Wakeup Enable */
+ #define E1000_WUFC_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Enable */
+ #define E1000_WUFC_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Enable */
+ #define E1000_WUFC_FLX0 0x00010000 /* Flexible Filter 0 Enable */
+ #define E1000_WUFC_FLX1 0x00020000 /* Flexible Filter 1 Enable */
+ #define E1000_WUFC_FLX2 0x00040000 /* Flexible Filter 2 Enable */
+ #define E1000_WUFC_FLX3 0x00080000 /* Flexible Filter 3 Enable */
+ #define E1000_WUFC_ALL_FILTERS 0x000F00FF /* Mask for all wakeup filters */
+ #define E1000_WUFC_FLX_OFFSET 16       /* Offset to the Flexible Filters bits */
+ #define E1000_WUFC_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+ 
+ /* Wake Up Status */
+ #define E1000_WUS_LNKC 0x00000001 /* Link Status Changed */
+ #define E1000_WUS_MAG  0x00000002 /* Magic Packet Received */
+ #define E1000_WUS_EX   0x00000004 /* Directed Exact Received */
+ #define E1000_WUS_MC   0x00000008 /* Directed Multicast Received */
+ #define E1000_WUS_BC   0x00000010 /* Broadcast Received */
+ #define E1000_WUS_ARP  0x00000020 /* ARP Request Packet Received */
+ #define E1000_WUS_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Received */
+ #define E1000_WUS_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Received */
+ #define E1000_WUS_FLX0 0x00010000 /* Flexible Filter 0 Match */
+ #define E1000_WUS_FLX1 0x00020000 /* Flexible Filter 1 Match */
+ #define E1000_WUS_FLX2 0x00040000 /* Flexible Filter 2 Match */
+ #define E1000_WUS_FLX3 0x00080000 /* Flexible Filter 3 Match */
+ #define E1000_WUS_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+ 
+ /* Management Control */
+ #define E1000_MANC_SMBUS_EN      0x00000001 /* SMBus Enabled - RO */
+ #define E1000_MANC_ASF_EN        0x00000002 /* ASF Enabled - RO */
+ #define E1000_MANC_R_ON_FORCE    0x00000004 /* Reset on Force TCO - RO */
+ #define E1000_MANC_RMCP_EN       0x00000100 /* Enable RCMP 026Fh Filtering */
+ #define E1000_MANC_0298_EN       0x00000200 /* Enable RCMP 0298h Filtering */
+ #define E1000_MANC_IPV4_EN       0x00000400 /* Enable IPv4 */
+ #define E1000_MANC_IPV6_EN       0x00000800 /* Enable IPv6 */
+ #define E1000_MANC_SNAP_EN       0x00001000 /* Accept LLC/SNAP */
+ #define E1000_MANC_ARP_EN        0x00002000 /* Enable ARP Request Filtering */
+ #define E1000_MANC_NEIGHBOR_EN   0x00004000 /* Enable Neighbor Discovery 
+                                              * Filtering */
+ #define E1000_MANC_TCO_RESET     0x00010000 /* TCO Reset Occurred */
+ #define E1000_MANC_RCV_TCO_EN    0x00020000 /* Receive TCO Packets Enabled */
+ #define E1000_MANC_REPORT_STATUS 0x00040000 /* Status Reporting Enabled */
+ #define E1000_MANC_SMB_REQ       0x01000000 /* SMBus Request */
+ #define E1000_MANC_SMB_GNT       0x02000000 /* SMBus Grant */
+ #define E1000_MANC_SMB_CLK_IN    0x04000000 /* SMBus Clock In */
+ #define E1000_MANC_SMB_DATA_IN   0x08000000 /* SMBus Data In */
+ #define E1000_MANC_SMB_DATA_OUT  0x10000000 /* SMBus Data Out */
+ #define E1000_MANC_SMB_CLK_OUT   0x20000000 /* SMBus Clock Out */
+ 
+ #define E1000_MANC_SMB_DATA_OUT_SHIFT  28 /* SMBus Data Out Shift */
+ #define E1000_MANC_SMB_CLK_OUT_SHIFT   29 /* SMBus Clock Out Shift */
+ 
+ /* Wake Up Packet Length */
+ #define E1000_WUPL_LENGTH_MASK 0x0FFF   /* Only the lower 12 bits are valid */
+ 
+ #define E1000_MDALIGN          4096
+ 
+ /* EEPROM Commands - Microwire */
+ #define EEPROM_READ_OPCODE_MICROWIRE  0x6  /* EEPROM read opcode */
+ #define EEPROM_WRITE_OPCODE_MICROWIRE 0x5  /* EEPROM write opcode */
+ #define EEPROM_ERASE_OPCODE_MICROWIRE 0x7  /* EEPROM erase opcode */
+ #define EEPROM_EWEN_OPCODE_MICROWIRE  0x13 /* EEPROM erase/write enable */
+ #define EEPROM_EWDS_OPCODE_MICROWIRE  0x10 /* EEPROM erast/write disable */
+ 
+ /* EEPROM Commands - SPI */
+ #define EEPROM_MAX_RETRY_SPI    5000 /* Max wait of 5ms, for RDY signal */
+ #define EEPROM_READ_OPCODE_SPI  0x3  /* EEPROM read opcode */
+ #define EEPROM_WRITE_OPCODE_SPI 0x2  /* EEPROM write opcode */
+ #define EEPROM_A8_OPCODE_SPI    0x8  /* opcode bit-3 = address bit-8 */
+ #define EEPROM_WREN_OPCODE_SPI  0x6  /* EEPROM set Write Enable latch */
+ #define EEPROM_WRDI_OPCODE_SPI  0x4  /* EEPROM reset Write Enable latch */
+ #define EEPROM_RDSR_OPCODE_SPI  0x5  /* EEPROM read Status register */
+ #define EEPROM_WRSR_OPCODE_SPI  0x1  /* EEPROM write Status register */
+ 
+ /* EEPROM Size definitions */
+ #define EEPROM_SIZE_16KB        0x1800
+ #define EEPROM_SIZE_8KB         0x1400
+ #define EEPROM_SIZE_4KB         0x1000
+ #define EEPROM_SIZE_2KB         0x0C00
+ #define EEPROM_SIZE_1KB         0x0800
+ #define EEPROM_SIZE_512B        0x0400
+ #define EEPROM_SIZE_128B        0x0000
+ #define EEPROM_SIZE_MASK        0x1C00
+ 
+ 
+ /* EEPROM Word Offsets */
+ #define EEPROM_COMPAT              0x0003
+ #define EEPROM_ID_LED_SETTINGS     0x0004
+ #define EEPROM_INIT_CONTROL1_REG   0x000A
+ #define EEPROM_INIT_CONTROL2_REG   0x000F
+ #define EEPROM_CFG                 0x0012
+ #define EEPROM_FLASH_VERSION       0x0032
+ #define EEPROM_CHECKSUM_REG        0x003F
+ 
+ /* Word definitions for ID LED Settings */
+ #define ID_LED_RESERVED_0000 0x0000
+ #define ID_LED_RESERVED_FFFF 0xFFFF
+ #define ID_LED_DEFAULT       ((ID_LED_OFF1_ON2 << 12) | \
+                               (ID_LED_OFF1_OFF2 << 8) | \
+                               (ID_LED_DEF1_DEF2 << 4) | \
+                               (ID_LED_DEF1_DEF2))
+ #define ID_LED_DEF1_DEF2     0x1
+ #define ID_LED_DEF1_ON2      0x2
+ #define ID_LED_DEF1_OFF2     0x3
+ #define ID_LED_ON1_DEF2      0x4
+ #define ID_LED_ON1_ON2       0x5
+ #define ID_LED_ON1_OFF2      0x6
+ #define ID_LED_OFF1_DEF2     0x7
+ #define ID_LED_OFF1_ON2      0x8
+ #define ID_LED_OFF1_OFF2     0x9
+ 
+ #define IGP_ACTIVITY_LED_MASK   0xFFFFF0FF
+ #define IGP_ACTIVITY_LED_ENABLE 0x0300
+ #define IGP_LED3_MODE           0x07000000
+ 
+ 
+ /* Mask bits for fields in Word 0x0a of the EEPROM */
+ #define EEPROM_WORD0A_ILOS   0x0010
+ #define EEPROM_WORD0A_SWDPIO 0x01E0
+ #define EEPROM_WORD0A_LRST   0x0200
+ #define EEPROM_WORD0A_FD     0x0400
+ #define EEPROM_WORD0A_66MHZ  0x0800
+ 
+ /* Mask bits for fields in Word 0x0f of the EEPROM */
+ #define EEPROM_WORD0F_PAUSE_MASK 0x3000
+ #define EEPROM_WORD0F_PAUSE      0x1000
+ #define EEPROM_WORD0F_ASM_DIR    0x2000
+ #define EEPROM_WORD0F_ANE        0x0800
+ #define EEPROM_WORD0F_SWPDIO_EXT 0x00F0
+ 
+ /* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
+ #define EEPROM_SUM 0xBABA
+ 
+ /* EEPROM Map defines (WORD OFFSETS)*/
+ #define EEPROM_NODE_ADDRESS_BYTE_0 0
+ #define EEPROM_PBA_BYTE_1          8
+ 
+ /* EEPROM Map Sizes (Byte Counts) */
+ #define PBA_SIZE 4
+ 
+ /* Collision related configuration parameters */
+ #define E1000_COLLISION_THRESHOLD       16
+ #define E1000_CT_SHIFT                  4
+ #define E1000_COLLISION_DISTANCE        64
+ #define E1000_FDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
+ #define E1000_HDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
+ #define E1000_COLD_SHIFT                12
+ 
+ /* The number of Transmit and Receive Descriptors must be a multiple of 8 */
+ #define REQ_TX_DESCRIPTOR_MULTIPLE  8
+ #define REQ_RX_DESCRIPTOR_MULTIPLE  8
+ 
+ /* Default values for the transmit IPG register */
+ #define DEFAULT_82542_TIPG_IPGT        10
+ #define DEFAULT_82543_TIPG_IPGT_FIBER  9
+ #define DEFAULT_82543_TIPG_IPGT_COPPER 8
+ 
+ #define E1000_TIPG_IPGT_MASK  0x000003FF
+ #define E1000_TIPG_IPGR1_MASK 0x000FFC00
+ #define E1000_TIPG_IPGR2_MASK 0x3FF00000
+ 
+ #define DEFAULT_82542_TIPG_IPGR1 2
+ #define DEFAULT_82543_TIPG_IPGR1 8
+ #define E1000_TIPG_IPGR1_SHIFT  10
+ 
+ #define DEFAULT_82542_TIPG_IPGR2 10
+ #define DEFAULT_82543_TIPG_IPGR2 6
+ #define E1000_TIPG_IPGR2_SHIFT  20
+ 
+ #define E1000_TXDMAC_DPP 0x00000001
+ 
+ /* Adaptive IFS defines */
+ #define TX_THRESHOLD_START     8
+ #define TX_THRESHOLD_INCREMENT 10
+ #define TX_THRESHOLD_DECREMENT 1
+ #define TX_THRESHOLD_STOP      190
+ #define TX_THRESHOLD_DISABLE   0
+ #define TX_THRESHOLD_TIMER_MS  10000
+ #define MIN_NUM_XMITS          1000
+ #define IFS_MAX                80
+ #define IFS_STEP               10
+ #define IFS_MIN                40
+ #define IFS_RATIO              4
+ 
+ /* PBA constants */
+ #define E1000_PBA_16K 0x0010    /* 16KB, default TX allocation */
+ #define E1000_PBA_22K 0x0016
+ #define E1000_PBA_24K 0x0018
+ #define E1000_PBA_30K 0x001E
+ #define E1000_PBA_40K 0x0028
+ #define E1000_PBA_48K 0x0030    /* 48KB, default RX allocation */
+ 
+ /* Flow Control Constants */
+ #define FLOW_CONTROL_ADDRESS_LOW  0x00C28001
+ #define FLOW_CONTROL_ADDRESS_HIGH 0x00000100
+ #define FLOW_CONTROL_TYPE         0x8808
+ 
+ /* The historical defaults for the flow control values are given below. */
+ #define FC_DEFAULT_HI_THRESH        (0x8000)    /* 32KB */
+ #define FC_DEFAULT_LO_THRESH        (0x4000)    /* 16KB */
+ #define FC_DEFAULT_TX_TIMER         (0x100)     /* ~130 us */
+ 
+ /* PCIX Config space */
+ #define PCIX_COMMAND_REGISTER    0xE6
+ #define PCIX_STATUS_REGISTER_LO  0xE8
+ #define PCIX_STATUS_REGISTER_HI  0xEA
+ 
+ #define PCIX_COMMAND_MMRBC_MASK      0x000C
+ #define PCIX_COMMAND_MMRBC_SHIFT     0x2
+ #define PCIX_STATUS_HI_MMRBC_MASK    0x0060
+ #define PCIX_STATUS_HI_MMRBC_SHIFT   0x5
+ #define PCIX_STATUS_HI_MMRBC_4K      0x3
+ #define PCIX_STATUS_HI_MMRBC_2K      0x2
+ 
+ 
+ /* The number of bits that we need to shift right to move the "pause"
+  * bits from the EEPROM (bits 13:12) to the "pause" (bits 8:7) field
+  * in the TXCW register 
+  */
+ #define PAUSE_SHIFT 5
+ 
+ /* The number of bits that we need to shift left to move the "SWDPIO"
+  * bits from the EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field
+  * in the CTRL register 
+  */
+ #define SWDPIO_SHIFT 17
+ 
+ /* The number of bits that we need to shift left to move the "SWDPIO_EXT"
+  * bits from the EEPROM word F (bits 7:4) to the bits 11:8 of The
+  * Extended CTRL register.
+  * in the CTRL register 
+  */
+ #define SWDPIO__EXT_SHIFT 4
+ 
+ /* The number of bits that we need to shift left to move the "ILOS"
+  * bit from the EEPROM (bit 4) to the "ILOS" (bit 7) field
+  * in the CTRL register 
+  */
+ #define ILOS_SHIFT  3
+ 
+ 
+ #define RECEIVE_BUFFER_ALIGN_SIZE  (256)
+ 
+ /* The number of milliseconds we wait for auto-negotiation to complete */
+ #define LINK_UP_TIMEOUT             500
+ 
+ #define E1000_TX_BUFFER_SIZE ((uint32_t)1514)
+ 
+ /* The carrier extension symbol, as received by the NIC. */
+ #define CARRIER_EXTENSION   0x0F
+ 
+ /* TBI_ACCEPT macro definition:
+  *
+  * This macro requires:
+  *      adapter = a pointer to struct e1000_hw 
+  *      status = the 8 bit status field of the RX descriptor with EOP set
+  *      error = the 8 bit error field of the RX descriptor with EOP set
+  *      length = the sum of all the length fields of the RX descriptors that
+  *               make up the current frame
+  *      last_byte = the last byte of the frame DMAed by the hardware
+  *      max_frame_length = the maximum frame length we want to accept.
+  *      min_frame_length = the minimum frame length we want to accept.
+  *
+  * This macro is a conditional that should be used in the interrupt 
+  * handler's Rx processing routine when RxErrors have been detected.
+  *
+  * Typical use:
+  *  ...
+  *  if (TBI_ACCEPT) {
+  *      accept_frame = TRUE;
+  *      e1000_tbi_adjust_stats(adapter, MacAddress);
+  *      frame_length--;
+  *  } else {
+  *      accept_frame = FALSE;
+  *  }
+  *  ...
+  */
+ 
+ #define TBI_ACCEPT(adapter, status, errors, length, last_byte) \
+     ((adapter)->tbi_compatibility_on && \
+      (((errors) & E1000_RXD_ERR_FRAME_ERR_MASK) == E1000_RXD_ERR_CE) && \
+      ((last_byte) == CARRIER_EXTENSION) && \
+      (((status) & E1000_RXD_STAT_VP) ? \
+           (((length) > ((adapter)->min_frame_size - VLAN_TAG_SIZE)) && \
+            ((length) <= ((adapter)->max_frame_size + 1))) : \
+           (((length) > (adapter)->min_frame_size) && \
+            ((length) <= ((adapter)->max_frame_size + VLAN_TAG_SIZE + 1)))))
+ 
+ 
+ /* Structures, enums, and macros for the PHY */
+ 
+ /* Bit definitions for the Management Data IO (MDIO) and Management Data
+  * Clock (MDC) pins in the Device Control Register.
+  */
+ #define E1000_CTRL_PHY_RESET_DIR  E1000_CTRL_SWDPIO0
+ #define E1000_CTRL_PHY_RESET      E1000_CTRL_SWDPIN0
+ #define E1000_CTRL_MDIO_DIR       E1000_CTRL_SWDPIO2
+ #define E1000_CTRL_MDIO           E1000_CTRL_SWDPIN2
+ #define E1000_CTRL_MDC_DIR        E1000_CTRL_SWDPIO3
+ #define E1000_CTRL_MDC            E1000_CTRL_SWDPIN3
+ #define E1000_CTRL_PHY_RESET_DIR4 E1000_CTRL_EXT_SDP4_DIR
+ #define E1000_CTRL_PHY_RESET4     E1000_CTRL_EXT_SDP4_DATA
+ 
+ /* PHY 1000 MII Register/Bit Definitions */
+ /* PHY Registers defined by IEEE */
+ #define PHY_CTRL         0x00 /* Control Register */
+ #define PHY_STATUS       0x01 /* Status Regiser */
+ #define PHY_ID1          0x02 /* Phy Id Reg (word 1) */
+ #define PHY_ID2          0x03 /* Phy Id Reg (word 2) */
+ #define PHY_AUTONEG_ADV  0x04 /* Autoneg Advertisement */
+ #define PHY_LP_ABILITY   0x05 /* Link Partner Ability (Base Page) */
+ #define PHY_AUTONEG_EXP  0x06 /* Autoneg Expansion Reg */
+ #define PHY_NEXT_PAGE_TX 0x07 /* Next Page TX */
+ #define PHY_LP_NEXT_PAGE 0x08 /* Link Partner Next Page */
+ #define PHY_1000T_CTRL   0x09 /* 1000Base-T Control Reg */
+ #define PHY_1000T_STATUS 0x0A /* 1000Base-T Status Reg */
+ #define PHY_EXT_STATUS   0x0F /* Extended Status Reg */
+ 
+ /* M88E1000 Specific Registers */
+ #define M88E1000_PHY_SPEC_CTRL     0x10  /* PHY Specific Control Register */
+ #define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
+ #define M88E1000_INT_ENABLE        0x12  /* Interrupt Enable Register */
+ #define M88E1000_INT_STATUS        0x13  /* Interrupt Status Register */
+ #define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
+ #define M88E1000_RX_ERR_CNTR       0x15  /* Receive Error Counter */
+ 
+ #define IGP01E1000_IEEE_REGS_PAGE  0x0000
+ /* IGP01E1000 Specific Registers */
+ #define IGP01E1000_PHY_PORT_CONFIG 0x10 /* PHY Specific Port Config Register */
+ #define IGP01E1000_PHY_PORT_STATUS 0x11 /* PHY Specific Status Register */
+ #define IGP01E1000_PHY_PORT_CTRL   0x12 /* PHY Specific Control Register */
+ #define IGP01E1000_PHY_LINK_HEALTH 0x13 /* PHY Link Health Register */
+ #define IGP01E1000_GMII_FIFO       0x14 /* GMII FIFO Register */
+ #define IGP01E1000_PHY_CHANNEL_QUALITY 0x15 /* PHY Channel Quality Register */
+ #define IGP01E1000_PHY_PAGE_SELECT     0x1F /* PHY Page Select Core Register */
+ 
+ /* IGP01E1000 AGC Registers - stores the cable length values*/
+ #define IGP01E1000_PHY_AGC_A        0x1172
+ #define IGP01E1000_PHY_AGC_B        0x1272
+ #define IGP01E1000_PHY_AGC_C        0x1472
+ #define IGP01E1000_PHY_AGC_D        0x1872
+ 
+ /* Number of AGC registers */
+ #define IGP01E1000_PHY_AGC_NUM     4
+ 
+ /* IGP01E1000 PCS Initialization register - stores the polarity status when
+  * speed = 1000 Mbps. */
+ #define IGP01E1000_PHY_PCS_INIT_REG  0x00B4
+ 
+ #define IGP01E1000_ANALOG_REGS_PAGE  0x20C0
+   
+ #define MAX_PHY_REG_ADDRESS 0x1F        /* 5 bit address bus (0-0x1F) */
+ 
+ /* PHY Control Register */
+ #define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+ #define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
+ #define MII_CR_FULL_DUPLEX      0x0100  /* FDX =1, half duplex =0 */
+ #define MII_CR_RESTART_AUTO_NEG 0x0200  /* Restart auto negotiation */
+ #define MII_CR_ISOLATE          0x0400  /* Isolate PHY from MII */
+ #define MII_CR_POWER_DOWN       0x0800  /* Power down */
+ #define MII_CR_AUTO_NEG_EN      0x1000  /* Auto Neg Enable */
+ #define MII_CR_SPEED_SELECT_LSB 0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
+ #define MII_CR_LOOPBACK         0x4000  /* 0 = normal, 1 = loopback */
+ #define MII_CR_RESET            0x8000  /* 0 = normal, 1 = PHY reset */
+ 
+ /* PHY Status Register */
+ #define MII_SR_EXTENDED_CAPS     0x0001 /* Extended register capabilities */
+ #define MII_SR_JABBER_DETECT     0x0002 /* Jabber Detected */
+ #define MII_SR_LINK_STATUS       0x0004 /* Link Status 1 = link */
+ #define MII_SR_AUTONEG_CAPS      0x0008 /* Auto Neg Capable */
+ #define MII_SR_REMOTE_FAULT      0x0010 /* Remote Fault Detect */
+ #define MII_SR_AUTONEG_COMPLETE  0x0020 /* Auto Neg Complete */
+ #define MII_SR_PREAMBLE_SUPPRESS 0x0040 /* Preamble may be suppressed */
+ #define MII_SR_EXTENDED_STATUS   0x0100 /* Ext. status info in Reg 0x0F */
+ #define MII_SR_100T2_HD_CAPS     0x0200 /* 100T2 Half Duplex Capable */
+ #define MII_SR_100T2_FD_CAPS     0x0400 /* 100T2 Full Duplex Capable */
+ #define MII_SR_10T_HD_CAPS       0x0800 /* 10T   Half Duplex Capable */
+ #define MII_SR_10T_FD_CAPS       0x1000 /* 10T   Full Duplex Capable */
+ #define MII_SR_100X_HD_CAPS      0x2000 /* 100X  Half Duplex Capable */
+ #define MII_SR_100X_FD_CAPS      0x4000 /* 100X  Full Duplex Capable */
+ #define MII_SR_100T4_CAPS        0x8000 /* 100T4 Capable */
+ 
+ /* Autoneg Advertisement Register */
+ #define NWAY_AR_SELECTOR_FIELD 0x0001   /* indicates IEEE 802.3 CSMA/CD */
+ #define NWAY_AR_10T_HD_CAPS    0x0020   /* 10T   Half Duplex Capable */
+ #define NWAY_AR_10T_FD_CAPS    0x0040   /* 10T   Full Duplex Capable */
+ #define NWAY_AR_100TX_HD_CAPS  0x0080   /* 100TX Half Duplex Capable */
+ #define NWAY_AR_100TX_FD_CAPS  0x0100   /* 100TX Full Duplex Capable */
+ #define NWAY_AR_100T4_CAPS     0x0200   /* 100T4 Capable */
+ #define NWAY_AR_PAUSE          0x0400   /* Pause operation desired */
+ #define NWAY_AR_ASM_DIR        0x0800   /* Asymmetric Pause Direction bit */
+ #define NWAY_AR_REMOTE_FAULT   0x2000   /* Remote Fault detected */
+ #define NWAY_AR_NEXT_PAGE      0x8000   /* Next Page ability supported */
+ 
+ /* Link Partner Ability Register (Base Page) */
+ #define NWAY_LPAR_SELECTOR_FIELD 0x0000 /* LP protocol selector field */
+ #define NWAY_LPAR_10T_HD_CAPS    0x0020 /* LP is 10T   Half Duplex Capable */
+ #define NWAY_LPAR_10T_FD_CAPS    0x0040 /* LP is 10T   Full Duplex Capable */
+ #define NWAY_LPAR_100TX_HD_CAPS  0x0080 /* LP is 100TX Half Duplex Capable */
+ #define NWAY_LPAR_100TX_FD_CAPS  0x0100 /* LP is 100TX Full Duplex Capable */
+ #define NWAY_LPAR_100T4_CAPS     0x0200 /* LP is 100T4 Capable */
+ #define NWAY_LPAR_PAUSE          0x0400 /* LP Pause operation desired */
+ #define NWAY_LPAR_ASM_DIR        0x0800 /* LP Asymmetric Pause Direction bit */
+ #define NWAY_LPAR_REMOTE_FAULT   0x2000 /* LP has detected Remote Fault */
+ #define NWAY_LPAR_ACKNOWLEDGE    0x4000 /* LP has rx'd link code word */
+ #define NWAY_LPAR_NEXT_PAGE      0x8000 /* Next Page ability supported */
+ 
+ /* Autoneg Expansion Register */
+ #define NWAY_ER_LP_NWAY_CAPS      0x0001 /* LP has Auto Neg Capability */
+ #define NWAY_ER_PAGE_RXD          0x0002 /* LP is 10T   Half Duplex Capable */
+ #define NWAY_ER_NEXT_PAGE_CAPS    0x0004 /* LP is 10T   Full Duplex Capable */
+ #define NWAY_ER_LP_NEXT_PAGE_CAPS 0x0008 /* LP is 100TX Half Duplex Capable */
+ #define NWAY_ER_PAR_DETECT_FAULT  0x0010 /* LP is 100TX Full Duplex Capable */
+ 
+ /* Next Page TX Register */
+ #define NPTX_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+ #define NPTX_TOGGLE         0x0800 /* Toggles between exchanges
+                                     * of different NP
+                                     */
+ #define NPTX_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg
+                                     * 0 = cannot comply with msg
+                                     */
+ #define NPTX_MSG_PAGE       0x2000 /* formatted(1)/unformatted(0) pg */
+ #define NPTX_NEXT_PAGE      0x8000 /* 1 = addition NP will follow 
+                                     * 0 = sending last NP
+                                     */
+ 
+ /* Link Partner Next Page Register */
+ #define LP_RNPR_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+ #define LP_RNPR_TOGGLE         0x0800 /* Toggles between exchanges
+                                        * of different NP
+                                        */
+ #define LP_RNPR_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg 
+                                        * 0 = cannot comply with msg
+                                        */
+ #define LP_RNPR_MSG_PAGE       0x2000  /* formatted(1)/unformatted(0) pg */
+ #define LP_RNPR_ACKNOWLDGE     0x4000  /* 1 = ACK / 0 = NO ACK */
+ #define LP_RNPR_NEXT_PAGE      0x8000  /* 1 = addition NP will follow
+                                         * 0 = sending last NP 
+                                         */
+ 
+ /* 1000BASE-T Control Register */
+ #define CR_1000T_ASYM_PAUSE      0x0080 /* Advertise asymmetric pause bit */
+ #define CR_1000T_HD_CAPS         0x0100 /* Advertise 1000T HD capability */
+ #define CR_1000T_FD_CAPS         0x0200 /* Advertise 1000T FD capability  */
+ #define CR_1000T_REPEATER_DTE    0x0400 /* 1=Repeater/switch device port */
+                                         /* 0=DTE device */
+ #define CR_1000T_MS_VALUE        0x0800 /* 1=Configure PHY as Master */
+                                         /* 0=Configure PHY as Slave */
+ #define CR_1000T_MS_ENABLE       0x1000 /* 1=Master/Slave manual config value */
+                                         /* 0=Automatic Master/Slave config */
+ #define CR_1000T_TEST_MODE_NORMAL 0x0000 /* Normal Operation */
+ #define CR_1000T_TEST_MODE_1     0x2000 /* Transmit Waveform test */
+ #define CR_1000T_TEST_MODE_2     0x4000 /* Master Transmit Jitter test */
+ #define CR_1000T_TEST_MODE_3     0x6000 /* Slave Transmit Jitter test */
+ #define CR_1000T_TEST_MODE_4     0x8000 /* Transmitter Distortion test */
+ 
+ /* 1000BASE-T Status Register */
+ #define SR_1000T_IDLE_ERROR_CNT   0x00FF /* Num idle errors since last read */
+ #define SR_1000T_ASYM_PAUSE_DIR   0x0100 /* LP asymmetric pause direction bit */
+ #define SR_1000T_LP_HD_CAPS       0x0400 /* LP is 1000T HD capable */
+ #define SR_1000T_LP_FD_CAPS       0x0800 /* LP is 1000T FD capable */
+ #define SR_1000T_REMOTE_RX_STATUS 0x1000 /* Remote receiver OK */
+ #define SR_1000T_LOCAL_RX_STATUS  0x2000 /* Local receiver OK */
+ #define SR_1000T_MS_CONFIG_RES    0x4000 /* 1=Local TX is Master, 0=Slave */
+ #define SR_1000T_MS_CONFIG_FAULT  0x8000 /* Master/Slave config fault */
+ #define SR_1000T_REMOTE_RX_STATUS_SHIFT 12
+ #define SR_1000T_LOCAL_RX_STATUS_SHIFT  13
+ 
+ /* Extended Status Register */
+ #define IEEE_ESR_1000T_HD_CAPS 0x1000 /* 1000T HD capable */
+ #define IEEE_ESR_1000T_FD_CAPS 0x2000 /* 1000T FD capable */
+ #define IEEE_ESR_1000X_HD_CAPS 0x4000 /* 1000X HD capable */
+ #define IEEE_ESR_1000X_FD_CAPS 0x8000 /* 1000X FD capable */
+ 
+ #define PHY_TX_POLARITY_MASK   0x0100 /* register 10h bit 8 (polarity bit) */
+ #define PHY_TX_NORMAL_POLARITY 0      /* register 10h bit 8 (normal polarity) */
+ 
+ #define AUTO_POLARITY_DISABLE  0x0010 /* register 11h bit 4 */
+                                       /* (0=enable, 1=disable) */
+ 
+ /* M88E1000 PHY Specific Control Register */
+ #define M88E1000_PSCR_JABBER_DISABLE    0x0001 /* 1=Jabber Function disabled */
+ #define M88E1000_PSCR_POLARITY_REVERSAL 0x0002 /* 1=Polarity Reversal enabled */
+ #define M88E1000_PSCR_SQE_TEST          0x0004 /* 1=SQE Test enabled */
+ #define M88E1000_PSCR_CLK125_DISABLE    0x0010 /* 1=CLK125 low, 
+                                                 * 0=CLK125 toggling
+                                                 */
+ #define M88E1000_PSCR_MDI_MANUAL_MODE  0x0000  /* MDI Crossover Mode bits 6:5 */
+                                                /* Manual MDI configuration */
+ #define M88E1000_PSCR_MDIX_MANUAL_MODE 0x0020  /* Manual MDIX configuration */
+ #define M88E1000_PSCR_AUTO_X_1000T     0x0040  /* 1000BASE-T: Auto crossover,
+                                                 *  100BASE-TX/10BASE-T: 
+                                                 *  MDI Mode
+                                                 */
+ #define M88E1000_PSCR_AUTO_X_MODE      0x0060  /* Auto crossover enabled 
+                                                 * all speeds. 
+                                                 */
+ #define M88E1000_PSCR_10BT_EXT_DIST_ENABLE 0x0080 
+                                         /* 1=Enable Extended 10BASE-T distance
+                                          * (Lower 10BASE-T RX Threshold)
+                                          * 0=Normal 10BASE-T RX Threshold */
+ #define M88E1000_PSCR_MII_5BIT_ENABLE      0x0100
+                                         /* 1=5-Bit interface in 100BASE-TX
+                                          * 0=MII interface in 100BASE-TX */
+ #define M88E1000_PSCR_SCRAMBLER_DISABLE    0x0200 /* 1=Scrambler disable */
+ #define M88E1000_PSCR_FORCE_LINK_GOOD      0x0400 /* 1=Force link good */
+ #define M88E1000_PSCR_ASSERT_CRS_ON_TX     0x0800 /* 1=Assert CRS on Transmit */
+ 
+ #define M88E1000_PSCR_POLARITY_REVERSAL_SHIFT    1
+ #define M88E1000_PSCR_AUTO_X_MODE_SHIFT          5
+ #define M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT 7
+ 
+ /* M88E1000 PHY Specific Status Register */
+ #define M88E1000_PSSR_JABBER             0x0001 /* 1=Jabber */
+ #define M88E1000_PSSR_REV_POLARITY       0x0002 /* 1=Polarity reversed */
+ #define M88E1000_PSSR_DOWNSHIFT          0x0020 /* 1=Downshifted */
+ #define M88E1000_PSSR_MDIX               0x0040 /* 1=MDIX; 0=MDI */
+ #define M88E1000_PSSR_CABLE_LENGTH       0x0380 /* 0=<50M;1=50-80M;2=80-110M;
+                                             * 3=110-140M;4=>140M */
+ #define M88E1000_PSSR_LINK               0x0400 /* 1=Link up, 0=Link down */
+ #define M88E1000_PSSR_SPD_DPLX_RESOLVED  0x0800 /* 1=Speed & Duplex resolved */
+ #define M88E1000_PSSR_PAGE_RCVD          0x1000 /* 1=Page received */
+ #define M88E1000_PSSR_DPLX               0x2000 /* 1=Duplex 0=Half Duplex */
+ #define M88E1000_PSSR_SPEED              0xC000 /* Speed, bits 14:15 */
+ #define M88E1000_PSSR_10MBS              0x0000 /* 00=10Mbs */
+ #define M88E1000_PSSR_100MBS             0x4000 /* 01=100Mbs */
+ #define M88E1000_PSSR_1000MBS            0x8000 /* 10=1000Mbs */
+ 
+ #define M88E1000_PSSR_REV_POLARITY_SHIFT 1
+ #define M88E1000_PSSR_DOWNSHIFT_SHIFT    5
+ #define M88E1000_PSSR_MDIX_SHIFT         6
+ #define M88E1000_PSSR_CABLE_LENGTH_SHIFT 7
+ 
+ /* M88E1000 Extended PHY Specific Control Register */
+ #define M88E1000_EPSCR_FIBER_LOOPBACK 0x4000 /* 1=Fiber loopback */
+ #define M88E1000_EPSCR_DOWN_NO_IDLE   0x8000 /* 1=Lost lock detect enabled.
+                                               * Will assert lost lock and bring
+                                               * link down if idle not seen
+                                               * within 1ms in 1000BASE-T 
+                                               */
+ /* Number of times we will attempt to autonegotiate before downshifting if we
+  * are the master */
+ #define M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK 0x0C00
+ #define M88E1000_EPSCR_MASTER_DOWNSHIFT_1X   0x0000    
+ #define M88E1000_EPSCR_MASTER_DOWNSHIFT_2X   0x0400
+ #define M88E1000_EPSCR_MASTER_DOWNSHIFT_3X   0x0800
+ #define M88E1000_EPSCR_MASTER_DOWNSHIFT_4X   0x0C00
+ /* Number of times we will attempt to autonegotiate before downshifting if we
+  * are the slave */
+ #define M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK  0x0300
+ #define M88E1000_EPSCR_SLAVE_DOWNSHIFT_DIS   0x0000
+ #define M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X    0x0100
+ #define M88E1000_EPSCR_SLAVE_DOWNSHIFT_2X    0x0200
+ #define M88E1000_EPSCR_SLAVE_DOWNSHIFT_3X    0x0300
+ #define M88E1000_EPSCR_TX_CLK_2_5     0x0060 /* 2.5 MHz TX_CLK */
+ #define M88E1000_EPSCR_TX_CLK_25      0x0070 /* 25  MHz TX_CLK */
+ #define M88E1000_EPSCR_TX_CLK_0       0x0000 /* NO  TX_CLK */
+ 
+ 
+ /* IGP01E1000 Specific Port Config Register - R/W */
+ #define IGP01E1000_PSCFR_AUTO_MDIX_PAR_DETECT  0x0010
+ #define IGP01E1000_PSCFR_PRE_EN                0x0020
+ #define IGP01E1000_PSCFR_SMART_SPEED           0x0080
+ #define IGP01E1000_PSCFR_DISABLE_TPLOOPBACK    0x0100
+ #define IGP01E1000_PSCFR_DISABLE_JABBER        0x0400
+ #define IGP01E1000_PSCFR_DISABLE_TRANSMIT      0x2000
+ 
+ /* IGP01E1000 Specific Port Status Register - R/O */
+ #define IGP01E1000_PSSR_AUTONEG_FAILED         0x0001 /* RO LH SC */
+ #define IGP01E1000_PSSR_POLARITY_REVERSED      0x0002
+ #define IGP01E1000_PSSR_CABLE_LENGTH           0x007C
+ #define IGP01E1000_PSSR_FULL_DUPLEX            0x0200
+ #define IGP01E1000_PSSR_LINK_UP                0x0400
+ #define IGP01E1000_PSSR_MDIX                   0x0800
+ #define IGP01E1000_PSSR_SPEED_MASK             0xC000 /* speed bits mask */
+ #define IGP01E1000_PSSR_SPEED_10MBPS           0x4000
+ #define IGP01E1000_PSSR_SPEED_100MBPS          0x8000
+ #define IGP01E1000_PSSR_SPEED_1000MBPS         0xC000
+ #define IGP01E1000_PSSR_CABLE_LENGTH_SHIFT     0x0002 /* shift right 2 */
+ #define IGP01E1000_PSSR_MDIX_SHIFT             0x000B /* shift right 11 */
+ 
+ /* IGP01E1000 Specific Port Control Register - R/W */
+ #define IGP01E1000_PSCR_TP_LOOPBACK            0x0001
+ #define IGP01E1000_PSCR_CORRECT_NC_SCMBLR      0x0200
+ #define IGP01E1000_PSCR_TEN_CRS_SELECT         0x0400
+ #define IGP01E1000_PSCR_FLIP_CHIP              0x0800
+ #define IGP01E1000_PSCR_AUTO_MDIX              0x1000
+ #define IGP01E1000_PSCR_FORCE_MDI_MDIX         0x2000 /* 0-MDI, 1-MDIX */
+ 
+ /* IGP01E1000 Specific Port Link Health Register */
+ #define IGP01E1000_PLHR_SS_DOWNGRADE           0x8000
+ #define IGP01E1000_PLHR_GIG_SCRAMBLER_ERROR    0x4000
+ #define IGP01E1000_PLHR_GIG_REM_RCVR_NOK       0x0800 /* LH */
+ #define IGP01E1000_PLHR_IDLE_ERROR_CNT_OFLOW   0x0400 /* LH */
+ #define IGP01E1000_PLHR_DATA_ERR_1             0x0200 /* LH */
+ #define IGP01E1000_PLHR_DATA_ERR_0             0x0100
+ #define IGP01E1000_PLHR_AUTONEG_FAULT          0x0010
+ #define IGP01E1000_PLHR_AUTONEG_ACTIVE         0x0008
+ #define IGP01E1000_PLHR_VALID_CHANNEL_D        0x0004
+ #define IGP01E1000_PLHR_VALID_CHANNEL_C        0x0002
+ #define IGP01E1000_PLHR_VALID_CHANNEL_B        0x0001
+ #define IGP01E1000_PLHR_VALID_CHANNEL_A        0x0000
+ 
+ /* IGP01E1000 Channel Quality Register */
+ #define IGP01E1000_MSE_CHANNEL_D        0x000F
+ #define IGP01E1000_MSE_CHANNEL_C        0x00F0
+ #define IGP01E1000_MSE_CHANNEL_B        0x0F00
+ #define IGP01E1000_MSE_CHANNEL_A        0xF000
+ 
+ /* IGP01E1000 AGC Registers */
+ 
+ #define IGP01E1000_AGC_LENGTH_SHIFT 7         /* Coarse - 13:11, Fine - 10:7 */
+ 
+ /* 7 bits (3 Coarse + 4 Fine) --> 128 optional values */
+ #define IGP01E1000_AGC_LENGTH_TABLE_SIZE 128
+ 
+ /* The precision of the length is +/- 10 meters */
+ #define IGP01E1000_AGC_RANGE    10
+ 
+ /* IGP01E1000 PCS Initialization register */
+ /* bits 3:6 in the PCS registers stores the channels polarity */
+ #define IGP01E1000_PHY_POLARITY_MASK    0x0078
+ 
+ /* IGP01E1000 GMII FIFO Register */
+ #define IGP01E1000_GMII_FLEX_SPD               0x10 /* Enable flexible speed
+                                                      * on Link-Up */
+ #define IGP01E1000_GMII_SPD                    0x20 /* Enable SPD */
+ /* IGP01E1000 Analog Register */
+ #define IGP01E1000_ANALOG_SPARE_FUSE_STATUS         0x0011
+ #define IGP01E1000_ANALOG_FUSE_STATUS               0x0010
+ #define IGP01E1000_ANALOG_FUSE_CONTROL              0x001C
+ #define IGP01E1000_ANALOG_FUSE_BYPASS               0x001E
+ 
+ #define IGP01E1000_ANALOG_FUSE_POLY_MASK            0xF000
+ #define IGP01E1000_ANALOG_FUSE_FINE_MASK            0x0F80
+ #define IGP01E1000_ANALOG_FUSE_COARSE_MASK          0x0070
+ #define IGP01E1000_ANALOG_SPARE_FUSE_ENABLED        0x0100
+ #define IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL    0x0002
+ 
+ #define IGP01E1000_ANALOG_FUSE_COARSE_THRESH        0x0040
+ #define IGP01E1000_ANALOG_FUSE_COARSE_10            0x0010
+ #define IGP01E1000_ANALOG_FUSE_FINE_1               0x0080
+ #define IGP01E1000_ANALOG_FUSE_FINE_10              0x0500
+ 
+ /* Bit definitions for valid PHY IDs. */
+ #define M88E1000_E_PHY_ID  0x01410C50
+ #define M88E1000_I_PHY_ID  0x01410C30
+ #define M88E1011_I_PHY_ID  0x01410C20
+ #define IGP01E1000_I_PHY_ID  0x02A80380
+ #define M88E1000_12_PHY_ID M88E1000_E_PHY_ID
+ #define M88E1000_14_PHY_ID M88E1000_E_PHY_ID
+ #define M88E1011_I_REV_4   0x04
+ 
+ /* Miscellaneous PHY bit definitions. */
+ #define PHY_PREAMBLE        0xFFFFFFFF
+ #define PHY_SOF             0x01
+ #define PHY_OP_READ         0x02
+ #define PHY_OP_WRITE        0x01
+ #define PHY_TURNAROUND      0x02
+ #define PHY_PREAMBLE_SIZE   32
+ #define MII_CR_SPEED_1000   0x0040
+ #define MII_CR_SPEED_100    0x2000
+ #define MII_CR_SPEED_10     0x0000
+ #define E1000_PHY_ADDRESS   0x01
+ #define PHY_AUTO_NEG_TIME   45  /* 4.5 Seconds */
+ #define PHY_FORCE_TIME      20  /* 2.0 Seconds */
+ #define PHY_REVISION_MASK   0xFFFFFFF0
+ #define DEVICE_SPEED_MASK   0x00000300  /* Device Ctrl Reg Speed Mask */
+ #define REG4_SPEED_MASK     0x01E0
+ #define REG9_SPEED_MASK     0x0300
+ #define ADVERTISE_10_HALF   0x0001
+ #define ADVERTISE_10_FULL   0x0002
+ #define ADVERTISE_100_HALF  0x0004
+ #define ADVERTISE_100_FULL  0x0008
+ #define ADVERTISE_1000_HALF 0x0010
+ #define ADVERTISE_1000_FULL 0x0020
+ #define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F  /* Everything but 1000-Half */
+ 
+ #endif /* _E1000_HW_H_ */
diff -rc2P -x CVS GRUB_0.94/netboot/eepro100.c GRUB/netboot/eepro100.c
*** GRUB_0.94/netboot/eepro100.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/eepro100.c	2003-11-21 12:24:59.000000000 +0800
***************
*** 81,86 ****
   * Caveats:
   *
!  * The etherboot framework moves the code to the 32k segment from
!  * 0x98000 to 0xa0000. There is just a little room between the end of
   * this driver and the 0xa0000 address. If you compile in too many
   * features, this will overflow.
--- 81,86 ----
   * Caveats:
   *
!  * The Etherboot framework moves the code to the 48k segment from
!  * 0x94000 to 0xa0000. There is just a little room between the end of
   * this driver and the 0xa0000 address. If you compile in too many
   * features, this will overflow.
***************
*** 93,107 ****
   * outb macros that Linux uses. I disklike the confusion that this
   * has caused even more.... This file uses the Linux argument ordering.  */
! /* Sorry not us. It's inherted code from FreeBSD. [The authors] */
  
  #include "etherboot.h"
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  #include "timer.h"
  
- #undef	virt_to_bus
- #define	virt_to_bus(x)	((unsigned long)x)
- 
  static int ioaddr;
  
--- 93,103 ----
   * outb macros that Linux uses. I disklike the confusion that this
   * has caused even more.... This file uses the Linux argument ordering.  */
! /* Sorry not us. It's inherited code from FreeBSD. [The authors] */
  
  #include "etherboot.h"
  #include "nic.h"
  #include "pci.h"
  #include "timer.h"
  
  static int ioaddr;
  
***************
*** 140,145 ****
  #define EE_ENB          (0x4800 | EE_CS)
  
- #define udelay(n)       waiton_timer2(((n)*TICKS_PER_MS)/1000)
- 
  /* The EEPROM commands include the alway-set leading bit. */
  #define EE_READ_CMD     6
--- 136,139 ----
***************
*** 185,191 ****
  static inline void wait_for_cmd_done(int cmd_ioaddr)
  {
!   short wait = 100;
!   do   ;
!   while(inb(cmd_ioaddr) && --wait >= 0);
  }
  
--- 179,194 ----
  static inline void wait_for_cmd_done(int cmd_ioaddr)
  {
!   int wait = 0;
!   int delayed_cmd;
! 
!   do
!     if (inb(cmd_ioaddr) == 0) return;
!   while(++wait <= 100);
!   delayed_cmd = inb(cmd_ioaddr);
!   do
!     if (inb(cmd_ioaddr) == 0) break;
!   while(++wait <= 10000);
!   printf("Command %2.2x was not immediately accepted, %d ticks!\n",
!       delayed_cmd, wait);
  }
  
***************
*** 213,245 ****
  /* A speedo3 TX buffer descriptor with two buffers... */
  static struct TxFD {
!   volatile s16 status;
!   s16 command;
!   u32 link;          /* void * */
!   u32 tx_desc_addr;  /* (almost) Always points to the tx_buf_addr element. */
!   s32 count;         /* # of TBD (=2), Tx start thresh., etc. */
!                      /* This constitutes two "TBD" entries: hdr and data */
!   u32 tx_buf_addr0;  /* void *, header of frame to be transmitted.  */
!   s32 tx_buf_size0;  /* Length of Tx hdr. */
!   u32 tx_buf_addr1;  /* void *, data to be transmitted.  */
!   s32 tx_buf_size1;  /* Length of Tx data. */
  } txfd;
  
  struct RxFD {               /* Receive frame descriptor. */
!   volatile s16 status;
!   s16 command;
!   u32 link;                 /* struct RxFD * */
!   u32 rx_buf_addr;          /* void * */
!   u16 count;
!   u16 size;
!   char packet[1518];
  };
  
- #ifdef	USE_LOWMEM_BUFFER
- #define rxfd ((struct RxFD *)(0x10000 - sizeof(struct RxFD)))
- #define ACCESS(x) x->
- #else
  static struct RxFD rxfd;
  #define ACCESS(x) x.
- #endif
  
  static int congenb = 0;         /* Enable congestion control in the DP83840. */
--- 216,243 ----
  /* A speedo3 TX buffer descriptor with two buffers... */
  static struct TxFD {
! 	volatile s16 status;
! 	s16 command;
! 	u32 link;          /* void * */
! 	u32 tx_desc_addr;  /* (almost) Always points to the tx_buf_addr element. */
! 	s32 count;         /* # of TBD (=2), Tx start thresh., etc. */
! 	/* This constitutes two "TBD" entries: hdr and data */
! 	u32 tx_buf_addr0;  /* void *, header of frame to be transmitted.  */
! 	s32 tx_buf_size0;  /* Length of Tx hdr. */
! 	u32 tx_buf_addr1;  /* void *, data to be transmitted.  */
! 	s32 tx_buf_size1;  /* Length of Tx data. */
  } txfd;
  
  struct RxFD {               /* Receive frame descriptor. */
! 	volatile s16 status;
! 	s16 command;
! 	u32 link;                 /* struct RxFD * */
! 	u32 rx_buf_addr;          /* void * */
! 	u16 count;
! 	u16 size;
! 	char packet[1518];
  };
  
  static struct RxFD rxfd;
  #define ACCESS(x) x.
  
  static int congenb = 0;         /* Enable congestion control in the DP83840. */
***************
*** 257,262 ****
    unsigned char data[22];
  } confcmd = {
!   0, CmdConfigure,
!   (u32) & txfd,
    {22, 0x08, 0, 0,  0, 0x80, 0x32, 0x03,  1, /* 1=Use MII  0=Use AUI */
     0, 0x2E, 0,  0x60, 0,
--- 255,259 ----
    unsigned char data[22];
  } confcmd = {
!   0, 0, 0, /* filled in later */
    {22, 0x08, 0, 0,  0, 0x80, 0x32, 0x03,  1, /* 1=Use MII  0=Use AUI */
     0, 0x2E, 0,  0x60, 0,
***************
*** 277,293 ****
  static int mdio_write(int phy_id, int location, int value)
  {
!   int val, boguscnt = 64*4;         /* <64 usec. to complete, typ 27 ticks */
  
!   outl(0x04000000 | (location<<16) | (phy_id<<21) | value,
!        ioaddr + SCBCtrlMDI);
!   do {
!     udelay(16);
! 
!     val = inl(ioaddr + SCBCtrlMDI);
!     if (--boguscnt < 0) {
!       printf(" mdio_write() timed out with val = %X.\n", val);
!     }
!   } while (! (val & 0x10000000));
!   return val & 0xffff;
  }
  
--- 274,291 ----
  static int mdio_write(int phy_id, int location, int value)
  {
! 	int val, boguscnt = 64*4;         /* <64 usec. to complete, typ 27 ticks */
  
! 	outl(0x04000000 | (location<<16) | (phy_id<<21) | value,
! 	     ioaddr + SCBCtrlMDI);
! 	do {
! 		udelay(16);
! 		
! 		val = inl(ioaddr + SCBCtrlMDI);
! 		if (--boguscnt < 0) {
! 			printf(" mdio_write() timed out with val = %X.\n", val);
! 			break;
! 		}
! 	} while (! (val & 0x10000000));
! 	return val & 0xffff;
  }
  
***************
*** 299,313 ****
  static int mdio_read(int phy_id, int location)
  {
!   int val, boguscnt = 64*4;               /* <64 usec. to complete, typ 27 ticks */
!   outl(0x08000000 | (location<<16) | (phy_id<<21), ioaddr + SCBCtrlMDI);
!   do {
!     udelay(16);
! 
!     val = inl(ioaddr + SCBCtrlMDI);
!     if (--boguscnt < 0) {
!       printf( " mdio_read() timed out with val = %X.\n", val);
!     }
!   } while (! (val & 0x10000000));
!   return val & 0xffff;
  }
  
--- 297,313 ----
  static int mdio_read(int phy_id, int location)
  {
! 	int val, boguscnt = 64*4;               /* <64 usec. to complete, typ 27 ticks */
! 	outl(0x08000000 | (location<<16) | (phy_id<<21), ioaddr + SCBCtrlMDI);
! 	do {
! 		udelay(16);
! 		
! 		val = inl(ioaddr + SCBCtrlMDI);
! 
! 		if (--boguscnt < 0) {
! 			printf( " mdio_read() timed out with val = %X.\n", val);
! 			break;
! 		}
! 	} while (! (val & 0x10000000));
! 	return val & 0xffff;
  }
  
***************
*** 341,364 ****
  }
  
  static inline void whereami (const char *str)
  {
- #if	0
    printf ("%s\n", str);
    sleep (2);
- #endif
- }
- 
- /* function: eepro100_reset
-  * resets the card. This is used to allow Etherboot to probe the card again
-  * from a "virginal" state....
-  * Arguments: none
-  *
-  * returns:   void.
-  */
- 
- static void eepro100_reset(struct nic *nic)
- {
-   outl(0, ioaddr + SCBPort);
  }
  
  /* function: eepro100_transmit
--- 341,353 ----
  }
  
+ #if 0
  static inline void whereami (const char *str)
  {
    printf ("%s\n", str);
    sleep (2);
  }
+ #else
+ #define whereami(s)
+ #endif
  
  /* function: eepro100_transmit
***************
*** 374,429 ****
  static void eepro100_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p)
  {
!   struct eth_hdr {
!     unsigned char dst_addr[ETH_ALEN];
!     unsigned char src_addr[ETH_ALEN];
!     unsigned short type;
!   } hdr;
!   unsigned short status;
!   int to;
!   int s1, s2;
! 
!   status = inw(ioaddr + SCBStatus);
!   /* Acknowledge all of the current interrupt sources ASAP. */
!   outw(status & 0xfc00, ioaddr + SCBStatus);
! 
! #ifdef	DEBUG
!   printf ("transmitting type %hX packet (%d bytes). status = %hX, cmd=%hX\n",
! 	  t, s, status, inw (ioaddr + SCBCmd));
  #endif
  
!   memcpy (&hdr.dst_addr, d, ETH_ALEN);
!   memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
  
!   hdr.type = htons (t);
  
!   txfd.status = 0;
!   txfd.command = CmdSuspend | CmdTx | CmdTxFlex;
!   txfd.link   = virt_to_bus (&txfd);
!   txfd.count   = 0x02208000;
!   txfd.tx_desc_addr = (u32)&txfd.tx_buf_addr0;
! 
!   txfd.tx_buf_addr0 = virt_to_bus (&hdr);
!   txfd.tx_buf_size0 = sizeof (hdr);
! 
!   txfd.tx_buf_addr1 = virt_to_bus (p);
!   txfd.tx_buf_size1 = s;
! 
! #ifdef	DEBUG
!   printf ("txfd: \n");
!   hd (&txfd, sizeof (txfd));
  #endif
  
!   outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
!   outw(INT_MASK | CU_START, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
! 
!   s1 = inw (ioaddr + SCBStatus);
!   load_timer2(10*TICKS_PER_MS);		/* timeout 10 ms for transmit */
!   while (!txfd.status && timer2_running())
!     /* Wait */;
!   s2 = inw (ioaddr + SCBStatus);
  
! #ifdef	DEBUG
!   printf ("s1 = %hX, s2 = %hX.\n", s1, s2);
  #endif
  }
--- 363,417 ----
  static void eepro100_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p)
  {
! 	struct eth_hdr {
! 		unsigned char dst_addr[ETH_ALEN];
! 		unsigned char src_addr[ETH_ALEN];
! 		unsigned short type;
! 	} hdr;
! 	unsigned short status;
! 	int s1, s2;
! 
! 	status = inw(ioaddr + SCBStatus);
! 	/* Acknowledge all of the current interrupt sources ASAP. */
! 	outw(status & 0xfc00, ioaddr + SCBStatus);
! 
! #if	DEBUG
! 	printf ("transmitting type %hX packet (%d bytes). status = %hX, cmd=%hX\n",
! 		t, s, status, inw (ioaddr + SCBCmd));
  #endif
  
! 	memcpy (&hdr.dst_addr, d, ETH_ALEN);
! 	memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
  
! 	hdr.type = htons (t);
  
! 	txfd.status = 0;
! 	txfd.command = CmdSuspend | CmdTx | CmdTxFlex;
! 	txfd.link   = virt_to_bus (&txfd);
! 	txfd.count   = 0x02208000;
! 	txfd.tx_desc_addr = virt_to_bus(&txfd.tx_buf_addr0);
! 
! 	txfd.tx_buf_addr0 = virt_to_bus (&hdr);
! 	txfd.tx_buf_size0 = sizeof (hdr);
! 
! 	txfd.tx_buf_addr1 = virt_to_bus (p);
! 	txfd.tx_buf_size1 = s;
! 
! #if	DEBUG
! 	printf ("txfd: \n");
! 	hd (&txfd, sizeof (txfd));
  #endif
  
! 	outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
! 	outw(INT_MASK | CU_START, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
! 
! 	s1 = inw (ioaddr + SCBStatus);
! 	load_timer2(10*TICKS_PER_MS);		/* timeout 10 ms for transmit */
! 	while (!txfd.status && timer2_running())
! 		/* Wait */;
! 	s2 = inw (ioaddr + SCBStatus);
  
! #if	DEBUG
! 	printf ("s1 = %hX, s2 = %hX.\n", s1, s2);
  #endif
  }
***************
*** 443,472 ****
  static int eepro100_poll(struct nic *nic)
  {
!   if (!ACCESS(rxfd)status)
!     return 0;
  
!   /* Ok. We got a packet. Now restart the reciever.... */
!   ACCESS(rxfd)status = 0;
!   ACCESS(rxfd)command = 0xc000;
!   outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
!   outw(INT_MASK | RX_START, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
  
! #ifdef	DEBUG
!   printf ("Got a packet: Len = %d.\n", ACCESS(rxfd)count & 0x3fff);
  #endif
!   nic->packetlen =  ACCESS(rxfd)count & 0x3fff;
!   memcpy (nic->packet, ACCESS(rxfd)packet, nic->packetlen);
! #ifdef	DEBUG
!   hd (nic->packet, 0x30);
  #endif
!   return 1;
  }
  
! static void eepro100_disable(struct nic *nic)
  {
!     /* See if this PartialReset solves the problem with interfering with
!        kernel operation after Etherboot hands over. - Ken 20001102 */
!     outl(2, ioaddr + SCBPort);
  }
  
--- 431,487 ----
  static int eepro100_poll(struct nic *nic)
  {
! 	if (!ACCESS(rxfd)status)
! 		return 0;
  
! 	/* Ok. We got a packet. Now restart the reciever.... */
! 	ACCESS(rxfd)status = 0;
! 	ACCESS(rxfd)command = 0xc000;
! 	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
! 	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
  
! #if	DEBUG
! 	printf ("Got a packet: Len = %d.\n", ACCESS(rxfd)count & 0x3fff);
  #endif
! 	nic->packetlen =  ACCESS(rxfd)count & 0x3fff;
! 	memcpy (nic->packet, ACCESS(rxfd)packet, nic->packetlen);
! #if	DEBUG
! 	hd (nic->packet, 0x30);
  #endif
! 	return 1;
  }
  
! /* function: eepro100_disable
!  * resets the card. This is used to allow Etherboot or Linux
!  * to probe the card again from a "virginal" state....
!  * Arguments: none
!  *
!  * returns:   void.
!  */
! static void eepro100_disable(struct dev *dev __unused)
  {
! /* from eepro100_reset */
! 	outl(0, ioaddr + SCBPort);
! /* from eepro100_disable */
! 	/* See if this PartialReset solves the problem with interfering with
! 	   kernel operation after Etherboot hands over. - Ken 20001102 */
! 	outl(2, ioaddr + SCBPort);
! 
! 	/* The following is from the Intel e100 driver.
! 	 * This hopefully solves the problem with hanging hard DOS images. */
! 
! 	/* wait for the reset to take effect */
! 	udelay(20);
! 
! 	/* Mask off our interrupt line -- it is unmasked after reset */
! 	{
! 		u16 intr_status;
! 		/* Disable interrupts on our PCI board by setting the mask bit */
! 		outw(INT_MASK, ioaddr + SCBCmd);
! 		intr_status = inw(ioaddr + SCBStatus);
! 		/* ack and clear intrs */
! 		outw(intr_status, ioaddr + SCBStatus);
! 		inw(ioaddr + SCBStatus);
! 	}
  }
  
***************
*** 479,490 ****
   */
  
! struct nic *eepro100_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *p)
  {
  	unsigned short sum = 0;
  	int i;
  	int read_cmd, ee_size;
- 	unsigned short value;
  	int options;
! 	int promisc;
  
  	/* we cache only the first few words of the EEPROM data
--- 494,505 ----
   */
  
! static int eepro100_probe(struct dev *dev, struct pci_device *p)
  {
+ 	struct nic *nic = (struct nic *)dev;
  	unsigned short sum = 0;
  	int i;
  	int read_cmd, ee_size;
  	int options;
! 	int rx_mode;
  
  	/* we cache only the first few words of the EEPROM data
***************
*** 492,498 ****
  	unsigned short eeprom[16];
  
! 	if (probeaddrs == 0 || probeaddrs[0] == 0)
  		return 0;
! 	ioaddr = probeaddrs[0] & ~3; /* Mask the bit that says "this is an io addr" */
  
  	adjust_pci_device(p);
--- 507,513 ----
  	unsigned short eeprom[16];
  
! 	if (p->ioaddr == 0)
  		return 0;
! 	ioaddr = p->ioaddr & ~3; /* Mask the bit that says "this is an io addr" */
  
  	adjust_pci_device(p);
***************
*** 514,654 ****
  	}
  
!   for (i=0;i<ETH_ALEN;i++) {
! 	nic->node_addr[i] =  (eeprom[i/2] >> (8*(i&1))) & 0xff;
!   }
!   printf ("Ethernet addr: %!\n", nic->node_addr);
! 
!   if (sum != 0xBABA)
! 	printf("eepro100: Invalid EEPROM checksum %#hX, "
! 	       "check settings before activating this device!\n", sum);
!   outl(0, ioaddr + SCBPort);
!   udelay (10000);
! 
!   whereami ("Got eeprom.");
! 
!   outl(virt_to_bus(&lstats), ioaddr + SCBPointer);
!   outw(INT_MASK | CU_STATSADDR, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
! 
!   whereami ("set stats addr.");
!   /* INIT RX stuff. */
! 
!   /* Base = 0 */
!   outl(0, ioaddr + SCBPointer);
!   outw(INT_MASK | RX_ADDR_LOAD, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
! 
!   whereami ("set rx base addr.");
! 
!   ACCESS(rxfd)status  = 0x0001;
!   ACCESS(rxfd)command = 0x0000;
!   ACCESS(rxfd)link    = virt_to_bus(&(ACCESS(rxfd)status));
!   ACCESS(rxfd)rx_buf_addr = (int) &nic->packet;
!   ACCESS(rxfd)count   = 0;
!   ACCESS(rxfd)size    = 1528;
! 
!   outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
!   outw(INT_MASK | RX_START, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
! 
!   whereami ("started RX process.");
! 
!   /* Start the reciever.... */
!   ACCESS(rxfd)status = 0;
!   ACCESS(rxfd)command = 0xc000;
!   outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
!   outw(INT_MASK | RX_START, ioaddr + SCBCmd);
! 
!   /* INIT TX stuff. */
! 
!   /* Base = 0 */
!   outl(0, ioaddr + SCBPointer);
!   outw(INT_MASK | CU_CMD_BASE, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
! 
!   whereami ("set TX base addr.");
! 
!   txfd.command      = (CmdIASetup);
!   txfd.status       = 0x0000;
!   txfd.link         = virt_to_bus (&confcmd);
! 
!   {
! 	char *t = (char *)&txfd.tx_desc_addr;
! 
! 	for (i=0;i<ETH_ALEN;i++)
! 		t[i] = nic->node_addr[i];
!   }
! 
! #ifdef	DEBUG
!   printf ("Setup_eaddr:\n");
!   hd (&txfd, 0x20);
  #endif
!   /*      options = 0x40; */ /* 10mbps half duplex... */
!   options = 0x00;            /* Autosense */
  
!   promisc = 0;
  
!   if (   ((eeprom[6]>>8) & 0x3f) == DP83840
! 	  || ((eeprom[6]>>8) & 0x3f) == DP83840A) {
! 	int mdi_reg23 = mdio_read(eeprom[6] & 0x1f, 23) | 0x0422;
! 	if (congenb)
! 	  mdi_reg23 |= 0x0100;
! 	printf("  DP83840 specific setup, setting register 23 to %hX.\n",
! 	       mdi_reg23);
! 	mdio_write(eeprom[6] & 0x1f, 23, mdi_reg23);
!   }
!   whereami ("Done DP8340 special setup.");
!   if (options != 0) {
! 	mdio_write(eeprom[6] & 0x1f, 0,
! 		   ((options & 0x20) ? 0x2000 : 0) |    /* 100mbps? */
! 		   ((options & 0x10) ? 0x0100 : 0)); /* Full duplex? */
! 	whereami ("set mdio_register.");
!   }
! 
!   confcmd.command  = CmdSuspend | CmdConfigure;
!   confcmd.status   = 0x0000;
!   confcmd.link     = virt_to_bus (&txfd);
!   confcmd.data[1]  = (txfifo << 4) | rxfifo;
!   confcmd.data[4]  = rxdmacount;
!   confcmd.data[5]  = txdmacount + 0x80;
!   confcmd.data[15] = promisc ? 0x49: 0x48;
!   confcmd.data[19] = (options & 0x10) ? 0xC0 : 0x80;
!   confcmd.data[21] = promisc ? 0x0D: 0x05;
! 
!   outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
!   outw(INT_MASK | CU_START, ioaddr + SCBCmd);
!   wait_for_cmd_done(ioaddr + SCBCmd);
! 
!   whereami ("started TX thingy (config, iasetup).");
! 
!   load_timer2(10*TICKS_PER_MS);
!   while (!txfd.status && timer2_running())
! 	/* Wait */;
! 
!   nic->reset = eepro100_reset;
!   nic->poll = eepro100_poll;
!   nic->transmit = eepro100_transmit;
!   nic->disable = eepro100_disable;
!   return nic;
  }
  
  /*********************************************************************/
  
! #ifdef	DEBUG
  
  /* Hexdump a number of bytes from memory... */
  void hd (void *where, int n)
  {
!   int i;
  
!   while (n > 0) {
!     printf ("%X ", where);
!     for (i=0;i < ( (n>16)?16:n);i++)
!       printf (" %hhX", ((char *)where)[i]);
!     printf ("\n");
!     n -= 16;
!     where += 16;
!   }
  }
  #endif
  
--- 529,726 ----
  	}
  
! 	for (i=0;i<ETH_ALEN;i++) {
! 		nic->node_addr[i] =  (eeprom[i/2] >> (8*(i&1))) & 0xff;
! 	}
! 	printf ("Ethernet addr: %!\n", nic->node_addr);
! 
! 	if (sum != 0xBABA)
! 		printf("eepro100: Invalid EEPROM checksum %#hX, "
! 		       "check settings before activating this device!\n", sum);
! 	outl(0, ioaddr + SCBPort);
! 	udelay (10000);
! 	whereami ("Got eeprom.");
! 
! 	/* Base = 0 */
! 	outl(0, ioaddr + SCBPointer);
! 	outw(INT_MASK | RX_ADDR_LOAD, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
! 	whereami ("set rx base addr.");
! 
! 	outl(virt_to_bus(&lstats), ioaddr + SCBPointer);
! 	outw(INT_MASK | CU_STATSADDR, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
! 	whereami ("set stats addr.");
! 
! 	/* INIT RX stuff. */
! 	ACCESS(rxfd)status  = 0x0001;
! 	ACCESS(rxfd)command = 0x0000;
! 	ACCESS(rxfd)link    = virt_to_bus(&(ACCESS(rxfd)status));
! 	ACCESS(rxfd)rx_buf_addr = virt_to_bus(&nic->packet);
! 	ACCESS(rxfd)count   = 0;
! 	ACCESS(rxfd)size    = 1528;
! 
! 	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
! 	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
! 
! 	whereami ("started RX process.");
! 
! 	/* Start the reciever.... */
! 	ACCESS(rxfd)status = 0;
! 	ACCESS(rxfd)command = 0xc000;
! 	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
! 	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
! 
! 	/* INIT TX stuff. */
! 
! 	/* Base = 0 */
! 	outl(0, ioaddr + SCBPointer);
! 	outw(INT_MASK | CU_CMD_BASE, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
! 
! 	whereami ("set TX base addr.");
! 
! 	txfd.command      = (CmdIASetup);
! 	txfd.status       = 0x0000;
! 	txfd.link         = virt_to_bus (&confcmd);
! 
! 	{
! 		char *t = (char *)&txfd.tx_desc_addr;
! 		
! 		for (i=0;i<ETH_ALEN;i++)
! 			t[i] = nic->node_addr[i];
! 	}
! 
! #if	DEBUG
! 	printf ("Setup_eaddr:\n");
! 	hd (&txfd, 0x20);
  #endif
! 	/*      options = 0x40; */ /* 10mbps half duplex... */
! 	options = 0x00;            /* Autosense */
! 
! #ifdef PROMISC
! 	rx_mode = 3;
! #elif ALLMULTI
! 	rx_mode = 1;
! #else
! 	rx_mode = 0;
! #endif
! 
! 	if (   ((eeprom[6]>>8) & 0x3f) == DP83840
! 	       || ((eeprom[6]>>8) & 0x3f) == DP83840A) {
! 		int mdi_reg23 = mdio_read(eeprom[6] & 0x1f, 23) | 0x0422;
! 		if (congenb)
! 			mdi_reg23 |= 0x0100;
! 		printf("  DP83840 specific setup, setting register 23 to %hX.\n",
! 		       mdi_reg23);
! 		mdio_write(eeprom[6] & 0x1f, 23, mdi_reg23);
! 	}
! 	whereami ("Done DP8340 special setup.");
! 	if (options != 0) {
! 		mdio_write(eeprom[6] & 0x1f, 0,
! 			   ((options & 0x20) ? 0x2000 : 0) |    /* 100mbps? */
! 			   ((options & 0x10) ? 0x0100 : 0)); /* Full duplex? */
! 		whereami ("set mdio_register.");
! 	}
  
! 	confcmd.command  = CmdSuspend | CmdConfigure;
! 	confcmd.status   = 0x0000;
! 	confcmd.link     = virt_to_bus (&txfd);
! 	confcmd.data[1]  = (txfifo << 4) | rxfifo;
! 	confcmd.data[4]  = rxdmacount;
! 	confcmd.data[5]  = txdmacount + 0x80;
! 	confcmd.data[15] = (rx_mode & 2) ? 0x49: 0x48;
! 	confcmd.data[19] = (options & 0x10) ? 0xC0 : 0x80;
! 	confcmd.data[21] = (rx_mode & 1) ? 0x0D: 0x05;
! 
! 	outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
! 	outw(INT_MASK | CU_START, ioaddr + SCBCmd);
! 	wait_for_cmd_done(ioaddr + SCBCmd);
! 
! 	whereami ("started TX thingy (config, iasetup).");
! 
! 	load_timer2(10*TICKS_PER_MS);
! 	while (!txfd.status && timer2_running())
! 		/* Wait */;
! 
! 	/* Read the status register once to disgard stale data */
! 	mdio_read(eeprom[6] & 0x1f, 1);
! 	/* Check to see if the network cable is plugged in.
! 	 * This allows for faster failure if there is nothing
! 	 * we can do.
! 	 */
! 	if (!(mdio_read(eeprom[6] & 0x1f, 1) & (1 << 2))) {
! 		printf("Valid link not established\n");
! 		eepro100_disable(dev);
! 		return 0;
! 	}
  
! 	dev->disable  = eepro100_disable;
! 	nic->poll     = eepro100_poll;
! 	nic->transmit = eepro100_transmit;
! 	return 1;
  }
  
  /*********************************************************************/
  
! #if	DEBUG
  
  /* Hexdump a number of bytes from memory... */
  void hd (void *where, int n)
  {
! 	int i;
  
! 	while (n > 0) {
! 		printf ("%X ", where);
! 		for (i=0;i < ( (n>16)?16:n);i++)
! 			printf (" %hhX", ((char *)where)[i]);
! 		printf ("\n");
! 		n -= 16;
! 		where += 16;
! 	}
  }
  #endif
  
+ static struct pci_id eepro100_nics[] = {
+ PCI_ROM(0x8086, 0x1029, "id1029",        "Intel EtherExpressPro100 ID1029"),
+ PCI_ROM(0x8086, 0x1030, "id1030",        "Intel EtherExpressPro100 ID1030"),
+ PCI_ROM(0x8086, 0x1031, "82801cam",      "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+ PCI_ROM(0x8086, 0x1032, "eepro100-1032", "Intel PRO/100 VE Network Connection"),
+ PCI_ROM(0x8086, 0x1033, "eepro100-1033", "Intel PRO/100 VM Network Connection"),
+ PCI_ROM(0x8086, 0x1034, "eepro100-1034", "Intel PRO/100 VM Network Connection"),
+ PCI_ROM(0x8086, 0x1035, "eepro100-1035", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+ PCI_ROM(0x8086, 0x1036, "eepro100-1036", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+ PCI_ROM(0x8086, 0x1037, "eepro100-1037", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+ PCI_ROM(0x8086, 0x1038, "id1038",        "Intel PRO/100 VM Network Connection"),
+ PCI_ROM(0x8086, 0x1039, "82562et",       "Intel PRO100 VE 82562ET"),
+ PCI_ROM(0x8086, 0x103a, "id103a",        "Intel Corporation 82559 InBusiness 10/100"),
+ PCI_ROM(0x8086, 0x103b, "82562etb",      "Intel PRO100 VE 82562ETB"),
+ PCI_ROM(0x8086, 0x103c, "eepro100-103c", "Intel PRO/100 VM Network Connection"),
+ PCI_ROM(0x8086, 0x103d, "eepro100-103d", "Intel PRO/100 VE Network Connection"),
+ PCI_ROM(0x8086, 0x103e, "eepro100-103e", "Intel PRO/100 VM Network Connection"),
+ PCI_ROM(0x8086, 0x1059, "82551qm",       "Intel PRO/100 M Mobile Connection"),
+ PCI_ROM(0x8086, 0x1209, "82559er",       "Intel EtherExpressPro100 82559ER"),
+ PCI_ROM(0x8086, 0x1227, "82865",         "Intel 82865 EtherExpress PRO/100A"),
+ PCI_ROM(0x8086, 0x1228, "82556",         "Intel 82556 EtherExpress PRO/100 Smart"),
+ PCI_ROM(0x8086, 0x1229, "eepro100",      "Intel EtherExpressPro100"),
+ PCI_ROM(0x8086, 0x2449, "82562em",       "Intel EtherExpressPro100 82562EM"),
+ PCI_ROM(0x8086, 0x2459, "82562-1",       "Intel 82562 based Fast Ethernet Connection"),
+ PCI_ROM(0x8086, 0x245d, "82562-2",       "Intel 82562 based Fast Ethernet Connection"),
+ PCI_ROM(0x8086, 0x1050, "82562ez",       "Intel 82562EZ Network Connection"),
+ PCI_ROM(0x8086, 0x5200, "eepro100-5200", "Intel EtherExpress PRO/100 Intelligent Server"),
+ PCI_ROM(0x8086, 0x5201, "eepro100-5201", "Intel EtherExpress PRO/100 Intelligent Server"),
+ };
+ 
+ /* Cards with device ids 0x1030 to 0x103F, 0x2449, 0x2459 or 0x245D might need
+  * a workaround for hardware bug on 10 mbit half duplex (see linux driver eepro100.c)
+  * 2003/03/17 gbaum */
+ 
+ 
+ struct pci_driver eepro100_driver = {
+ 	.type      = NIC_DRIVER,
+ 	.name      = "EEPRO100",
+ 	.probe     = eepro100_probe,
+ 	.ids       = eepro100_nics,
+ 	.id_count  = sizeof(eepro100_nics)/sizeof(eepro100_nics[0]),
+ 	.class     = 0
+ };
Only in GRUB_0.94/netboot: eepro.c
diff -rc2P -x CVS GRUB_0.94/netboot/elf.h GRUB/netboot/elf.h
*** GRUB_0.94/netboot/elf.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/elf.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,234 ----
+ #ifndef ELF_H
+ #define ELF_H
+ 
+ #define EI_NIDENT	16	/* Size of e_ident array. */
+ 
+ /* Values for e_type. */
+ #define ET_NONE		0	/* No file type */
+ #define ET_REL		1	/* Relocatable file */
+ #define ET_EXEC		2	/* Executable file */
+ #define ET_DYN		3	/* Shared object file */
+ #define ET_CORE		4	/* Core file */
+ 
+ /* Values for e_machine (architecute). */
+ #define EM_NONE		 0		/* No machine */
+ #define EM_M32		 1		/* AT&T WE 32100 */
+ #define EM_SPARC	 2		/* SUN SPARC */
+ #define EM_386		 3		/* Intel 80386+ */
+ #define EM_68K		 4		/* Motorola m68k family */
+ #define EM_88K		 5		/* Motorola m88k family */
+ #define EM_486		 6		/* Perhaps disused */
+ #define EM_860		 7		/* Intel 80860 */
+ #define EM_MIPS		 8		/* MIPS R3000 big-endian */
+ #define EM_S370		 9		/* IBM System/370 */
+ #define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
+ 
+ #define EM_PARISC	15		/* HPPA */
+ #define EM_VPP500	17		/* Fujitsu VPP500 */
+ #define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
+ #define EM_960		19		/* Intel 80960 */
+ #define EM_PPC		20		/* PowerPC */
+ #define EM_PPC64	21		/* PowerPC 64-bit */
+ #define EM_S390		22		/* IBM S390 */
+ 
+ #define EM_V800		36		/* NEC V800 series */
+ #define EM_FR20		37		/* Fujitsu FR20 */
+ #define EM_RH32		38		/* TRW RH-32 */
+ #define EM_RCE		39		/* Motorola RCE */
+ #define EM_ARM		40		/* ARM */
+ #define EM_FAKE_ALPHA	41		/* Digital Alpha */
+ #define EM_SH		42		/* Hitachi SH */
+ #define EM_SPARCV9	43		/* SPARC v9 64-bit */
+ #define EM_TRICORE	44		/* Siemens Tricore */
+ #define EM_ARC		45		/* Argonaut RISC Core */
+ #define EM_H8_300	46		/* Hitachi H8/300 */
+ #define EM_H8_300H	47		/* Hitachi H8/300H */
+ #define EM_H8S		48		/* Hitachi H8S */
+ #define EM_H8_500	49		/* Hitachi H8/500 */
+ #define EM_IA_64	50		/* Intel Merced */
+ #define EM_MIPS_X	51		/* Stanford MIPS-X */
+ #define EM_COLDFIRE	52		/* Motorola Coldfire */
+ #define EM_68HC12	53		/* Motorola M68HC12 */
+ #define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
+ #define EM_PCP		55		/* Siemens PCP */
+ #define EM_NCPU		56		/* Sony nCPU embeeded RISC */
+ #define EM_NDR1		57		/* Denso NDR1 microprocessor */
+ #define EM_STARCORE	58		/* Motorola Start*Core processor */
+ #define EM_ME16		59		/* Toyota ME16 processor */
+ #define EM_ST100	60		/* STMicroelectronic ST100 processor */
+ #define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
+ #define EM_X86_64	62		/* AMD x86-64 architecture */
+ #define EM_PDSP		63		/* Sony DSP Processor */
+ 
+ #define EM_FX66		66		/* Siemens FX66 microcontroller */
+ #define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
+ #define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
+ #define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
+ #define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
+ #define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
+ #define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
+ #define EM_SVX		73		/* Silicon Graphics SVx */
+ #define EM_AT19		74		/* STMicroelectronics ST19 8 bit mc */
+ #define EM_VAX		75		/* Digital VAX */
+ #define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
+ #define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
+ #define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
+ #define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
+ #define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
+ #define EM_HUANY	81		/* Harvard University machine-independent object files */
+ #define EM_PRISM	82		/* SiTera Prism */
+ #define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
+ #define EM_FR30		84		/* Fujitsu FR30 */
+ #define EM_D10V		85		/* Mitsubishi D10V */
+ #define EM_D30V		86		/* Mitsubishi D30V */
+ #define EM_V850		87		/* NEC v850 */
+ #define EM_M32R		88		/* Mitsubishi M32R */
+ #define EM_MN10300	89		/* Matsushita MN10300 */
+ #define EM_MN10200	90		/* Matsushita MN10200 */
+ #define EM_PJ		91		/* picoJava */
+ #define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
+ #define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
+ #define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
+ #define EM_NUM		95
+ 
+ /* Values for p_type. */
+ #define PT_NULL		0	/* Unused entry. */
+ #define PT_LOAD		1	/* Loadable segment. */
+ #define PT_DYNAMIC	2	/* Dynamic linking information segment. */
+ #define PT_INTERP	3	/* Pathname of interpreter. */
+ #define PT_NOTE		4	/* Auxiliary information. */
+ #define PT_SHLIB	5	/* Reserved (not used). */
+ #define PT_PHDR		6	/* Location of program header itself. */
+ 
+ /* Values for p_flags. */
+ #define PF_X		0x1	/* Executable. */
+ #define PF_W		0x2	/* Writable. */
+ #define PF_R		0x4	/* Readable. */
+ 
+ 
+ #define	ELF_PROGRAM_RETURNS_BIT	0x8000000	/* e_flags bit 31 */
+ 
+ #define EI_MAG0		0
+ #define ELFMAG0		0x7f
+ 
+ #define EI_MAG1		1
+ #define ELFMAG1		'E'
+ 
+ #define EI_MAG2		2
+ #define ELFMAG2		'L'
+ 
+ #define EI_MAG3		3
+ #define ELFMAG3		'F'
+ 
+ #define ELFMAG		"\177ELF"
+ 
+ #define EI_CLASS	4	/* File class byte index */
+ #define ELFCLASSNONE	0	/* Invalid class */
+ #define ELFCLASS32	1	/* 32-bit objects */
+ #define ELFCLASS64	2	/* 64-bit objects */
+ 
+ #define EI_DATA		5	/* Data encodeing byte index */
+ #define ELFDATANONE	0	/* Invalid data encoding */
+ #define ELFDATA2LSB	1	/* 2's complement little endian */
+ #define ELFDATA2MSB	2	/* 2's complement big endian */
+ 
+ #define EI_VERSION	6	/* File version byte index */
+ 				/* Value must be EV_CURRENT */
+ 
+ #define EV_NONE		0	/* Invalid ELF Version */
+ #define EV_CURRENT	1	/* Current version */
+ 
+ #define ELF32_PHDR_SIZE (8*4)	/* Size of an elf program header */
+ 
+ #ifndef ASSEMBLY
+ /*
+  * ELF definitions common to all 32-bit architectures.
+  */
+ 
+ typedef uint32_t	Elf32_Addr;
+ typedef uint16_t	Elf32_Half;
+ typedef uint32_t	Elf32_Off;
+ typedef int32_t		Elf32_Sword;
+ typedef uint32_t	Elf32_Word;
+ typedef uint32_t	Elf32_Size;
+ 
+ typedef uint64_t	Elf64_Addr;
+ typedef uint16_t	Elf64_Half;
+ typedef uint64_t	Elf64_Off;
+ typedef int32_t		Elf64_Sword;
+ typedef uint32_t	Elf64_Word;
+ typedef uint64_t	Elf64_Size;
+ 
+ /*
+  * ELF header.
+  */
+ typedef struct {
+ 	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+ 	Elf32_Half	e_type;		/* File type. */
+ 	Elf32_Half	e_machine;	/* Machine architecture. */
+ 	Elf32_Word	e_version;	/* ELF format version. */
+ 	Elf32_Addr	e_entry;	/* Entry point. */
+ 	Elf32_Off	e_phoff;	/* Program header file offset. */
+ 	Elf32_Off	e_shoff;	/* Section header file offset. */
+ 	Elf32_Word	e_flags;	/* Architecture-specific flags. */
+ 	Elf32_Half	e_ehsize;	/* Size of ELF header in bytes. */
+ 	Elf32_Half	e_phentsize;	/* Size of program header entry. */
+ 	Elf32_Half	e_phnum;	/* Number of program header entries. */
+ 	Elf32_Half	e_shentsize;	/* Size of section header entry. */
+ 	Elf32_Half	e_shnum;	/* Number of section header entries. */
+ 	Elf32_Half	e_shstrndx;	/* Section name strings section. */
+ } Elf32_Ehdr;
+ 
+ typedef struct {
+ 	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+ 	Elf64_Half	e_type;		/* File type. */
+ 	Elf64_Half	e_machine;	/* Machine architecture. */
+ 	Elf64_Word	e_version;	/* ELF format version. */
+ 	Elf64_Addr	e_entry;	/* Entry point. */
+ 	Elf64_Off	e_phoff;	/* Program header file offset. */
+ 	Elf64_Off	e_shoff;	/* Section header file offset. */
+ 	Elf64_Word	e_flags;	/* Architecture-specific flags. */
+ 	Elf64_Half	e_ehsize;	/* Size of ELF header in bytes. */
+ 	Elf64_Half	e_phentsize;	/* Size of program header entry. */
+ 	Elf64_Half	e_phnum;	/* Number of program header entries. */
+ 	Elf64_Half	e_shentsize;	/* Size of section header entry. */
+ 	Elf64_Half	e_shnum;	/* Number of section header entries. */
+ 	Elf64_Half	e_shstrndx;	/* Section name strings section. */
+ } Elf64_Ehdr;
+ 
+ /*
+  * Program header.
+  */
+ typedef struct {
+ 	Elf32_Word	p_type;		/* Entry type. */
+ 	Elf32_Off	p_offset;	/* File offset of contents. */
+ 	Elf32_Addr	p_vaddr;	/* Virtual address (not used). */
+ 	Elf32_Addr	p_paddr;	/* Physical address. */
+ 	Elf32_Size	p_filesz;	/* Size of contents in file. */
+ 	Elf32_Size	p_memsz;	/* Size of contents in memory. */
+ 	Elf32_Word	p_flags;	/* Access permission flags. */
+ 	Elf32_Size	p_align;	/* Alignment in memory and file. */
+ } Elf32_Phdr;
+ 
+ typedef struct {
+ 	Elf64_Word	p_type;		/* Entry type. */
+ 	Elf64_Word	p_flags;	/* Access permission flags. */
+ 	Elf64_Off	p_offset;	/* File offset of contents. */
+ 	Elf64_Addr	p_vaddr;	/* Virtual address (not used). */
+ 	Elf64_Addr	p_paddr;	/* Physical address. */
+ 	Elf64_Size	p_filesz;	/* Size of contents in file. */
+ 	Elf64_Size	p_memsz;	/* Size of contents in memory. */
+ 	Elf64_Size	p_align;	/* Alignment in memory and file. */
+ } Elf64_Phdr;
+ 
+ /* Standardized Elf image notes for booting... The name for all of these is ELFBoot */
+ 
+ 
+ /* ELF Defines for the current architecture */
+ #include "i386_elf.h"
+ 
+ #endif /* ASSEMBLY */
+ 
+ //#include "elf_boot.h"
+ 
+ #endif /* ELF_H */
diff -rc2P -x CVS GRUB_0.94/netboot/endian.h GRUB/netboot/endian.h
*** GRUB_0.94/netboot/endian.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/endian.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,19 ----
+ #ifndef ETHERBOOT_ENDIAN_H
+ #define ETHERBOOT_ENDIAN_H
+ 
+ /* Definitions for byte order, according to significance of bytes,
+    from low addresses to high addresses.  The value is what you get by
+    putting '4' in the most significant byte, '3' in the second most
+    significant byte, '2' in the second least significant byte, and '1'
+    in the least significant byte, and then writing down one digit for
+    each byte, starting with the byte at the lowest address at the left,
+    and proceeding to the byte with the highest address at the right.  */
+ 
+ #define __LITTLE_ENDIAN 1234
+ #define __BIG_ENDIAN    4321
+ #define __PDP_ENDIAN    3412
+ 
+ #include "i386_endian.h"
+ 
+ 
+ #endif /* ETHERBOOT_ENDIAN_H */
diff -rc2P -x CVS GRUB_0.94/netboot/epic100.c GRUB/netboot/epic100.c
*** GRUB_0.94/netboot/epic100.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/epic100.c	2003-11-20 11:09:34.000000000 +0800
***************
*** 1,14 ****
  /* epic100.c: A SMC 83c170 EPIC/100 fast ethernet driver for Etherboot */
  
  #define LINUX_OUT_MACROS
  
  #include "etherboot.h"
  #include "nic.h"
- #include "cards.h"
  #include "timer.h"
  #include "epic100.h"
  
! #undef	virt_to_bus
! #define	virt_to_bus(x)	((unsigned long)x)
  
  #define TX_RING_SIZE	2	/* use at least 2 buffers for TX */
--- 1,16 ----
  /* epic100.c: A SMC 83c170 EPIC/100 fast ethernet driver for Etherboot */
  
+ /* 05/06/2003	timlegge	Fixed relocation and implemented Multicast */
  #define LINUX_OUT_MACROS
  
  #include "etherboot.h"
+ #include "pci.h"
  #include "nic.h"
  #include "timer.h"
  #include "epic100.h"
  
! /* Condensed operations for readability */
! #define virt_to_le32desc(addr)	cpu_to_le32(virt_to_bus(addr))
! #define le32desc_to_virt(addr)	bus_to_virt(le32_to_cpu(addr))
  
  #define TX_RING_SIZE	2	/* use at least 2 buffers for TX */
***************
*** 27,47 ****
  /* The EPIC100 Rx and Tx buffer descriptors. */
  struct epic_rx_desc {
!     unsigned short status;
!     unsigned short rxlength;
!     unsigned long  bufaddr;
!     unsigned short buflength;
!     unsigned short control;
!     unsigned long  next;
  };
- 
  /* description of the tx descriptors control bits commonly used */
  #define TD_STDFLAGS	TD_LASTDESC
  
  struct epic_tx_desc {
!     unsigned short status;
!     unsigned short txlength;
!     unsigned long  bufaddr;
!     unsigned short buflength;
!     unsigned short control;
      unsigned long  next;
  };
--- 29,44 ----
  /* The EPIC100 Rx and Tx buffer descriptors. */
  struct epic_rx_desc {
!     unsigned long status;
!     unsigned long bufaddr;
!     unsigned long buflength;
!     unsigned long next;
  };
  /* description of the tx descriptors control bits commonly used */
  #define TD_STDFLAGS	TD_LASTDESC
  
  struct epic_tx_desc {
!     unsigned long status;
!     unsigned long bufaddr;
!     unsigned long buflength;
      unsigned long  next;
  };
***************
*** 52,60 ****
  static void	epic100_open(void);
  static void	epic100_init_ring(void);
! static void	epic100_disable(struct nic *nic);
  static int	epic100_poll(struct nic *nic);
  static void	epic100_transmit(struct nic *nic, const char *destaddr,
  				 unsigned int type, unsigned int len, const char *data);
  static int	read_eeprom(int location);
  static int	mii_read(int phy_id, int location);
  
--- 49,59 ----
  static void	epic100_open(void);
  static void	epic100_init_ring(void);
! static void	epic100_disable(struct dev *dev);
  static int	epic100_poll(struct nic *nic);
  static void	epic100_transmit(struct nic *nic, const char *destaddr,
  				 unsigned int type, unsigned int len, const char *data);
+ #ifdef	DEBUG_EEPROM
  static int	read_eeprom(int location);
+ #endif
  static int	mii_read(int phy_id, int location);
  
***************
*** 70,73 ****
--- 69,73 ----
  static int	mmdata ;
  static int	lan0   ;
+ static int	mc0    ;
  static int	rxcon  ;
  static int	txcon  ;
***************
*** 81,93 ****
  #endif
  static signed char	phys[4];		/* MII device addresses. */
! static struct epic_rx_desc	rx_ring[RX_RING_SIZE];
! static struct epic_tx_desc	tx_ring[TX_RING_SIZE];
! #ifdef	USE_LOWMEM_BUFFER
! #define rx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE)
! #define tx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE - PKT_BUF_SZ * TX_RING_SIZE)
! #else
! static char		rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
! static char		tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
! #endif
  
  /***********************************************************************/
--- 81,90 ----
  #endif
  static signed char	phys[4];		/* MII device addresses. */
! static struct epic_rx_desc	rx_ring[RX_RING_SIZE]
! 	__attribute__ ((aligned(4)));
! static struct epic_tx_desc	tx_ring[TX_RING_SIZE]
! 	__attribute__ ((aligned(4)));
! static unsigned char	 	rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
! static unsigned char		tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
  
  /***********************************************************************/
***************
*** 95,115 ****
  /***********************************************************************/
  
-     static void
- epic100_reset(struct nic *nic)
- {
-     /* Soft reset the chip. */
-     outl(GC_SOFT_RESET, genctl);
- }
  
!     struct nic*
! epic100_probe(struct nic *nic, unsigned short *probeaddrs)
  {
!     unsigned short sum = 0;
!     unsigned short value;
      int i;
      unsigned short* ap;
      unsigned int phy, phy_idx;
  
!     if (probeaddrs == 0 || probeaddrs[0] == 0)
  	return 0;
  
--- 92,105 ----
  /***********************************************************************/
  
  
!     static int
! epic100_probe(struct dev *dev, struct pci_device *pci)
  {
!     struct nic *nic = (struct nic *)dev;
      int i;
      unsigned short* ap;
      unsigned int phy, phy_idx;
  
!     if (pci->ioaddr == 0)
  	return 0;
  
***************
*** 119,123 ****
         Epic cards in slot order. */
  
!     ioaddr = probeaddrs[0] & ~3; /* Mask the bit that says "this is an io addr" */
  
      /* compute all used static epic100 registers address */
--- 109,113 ----
         Epic cards in slot order. */
  
!     ioaddr = pci->ioaddr;
  
      /* compute all used static epic100 registers address */
***************
*** 131,134 ****
--- 121,125 ----
      mmdata  = ioaddr + MMDATA;		/* MII Management Interface Data */
      lan0    = ioaddr + LAN0;		/* MAC address. (0x40-0x48) */
+     mc0     = ioaddr + MC0; 		/* Multicast Control */
      rxcon   = ioaddr + RXCON;		/* Receive Control */
      txcon   = ioaddr + TXCON;		/* Transmit Control */
***************
*** 161,164 ****
--- 152,158 ----
  
  #ifdef	DEBUG_EEPROM
+ {
+     unsigned short sum = 0;
+     unsigned short value;
      for (i = 0; i < 64; i++) {
  	value = read_eeprom(i);
***************
*** 166,169 ****
--- 160,164 ----
  	sum += value;
      }
+ }
  
  #if	(EPIC_DEBUG > 1)
***************
*** 203,215 ****
      epic100_open();
  
!     nic->reset    = epic100_reset;
      nic->poll     = epic100_poll;
      nic->transmit = epic100_transmit;
-     nic->disable  = epic100_disable;
  
!     return nic;
  }
  
!     static void
  epic100_open(void)
  {
--- 198,220 ----
      epic100_open();
  
!     dev->disable  = epic100_disable;
      nic->poll     = epic100_poll;
      nic->transmit = epic100_transmit;
  
!     return 1;
  }
  
! static void set_rx_mode(void)
! {
! 	unsigned char mc_filter[8];
! 	int i;
! 	memset(mc_filter, 0xff, sizeof(mc_filter));
! 	outl(0x0C, rxcon);
! 	for(i = 0; i < 4; i++)
! 		outw(((unsigned short *)mc_filter)[i], mc0 + i*4);
! 	return;
! }
! 	
!    static void
  epic100_open(void)
  {
***************
*** 238,246 ****
  
      /* Give adress of RX and TX ring to the chip */
!     outl(virt_to_bus(&rx_ring), prcdar);
!     outl(virt_to_bus(&tx_ring), ptcdar);
  
      /* Start the chip's Rx process: receive unicast and broadcast */
!     outl(0x04, rxcon);
      outl(CR_START_RX | CR_QUEUE_RX, command);
  
--- 243,251 ----
  
      /* Give adress of RX and TX ring to the chip */
!     outl(virt_to_le32desc(&rx_ring), prcdar);
!     outl(virt_to_le32desc(&tx_ring), ptcdar);
  
      /* Start the chip's Rx process: receive unicast and broadcast */
!     set_rx_mode();
      outl(CR_START_RX | CR_QUEUE_RX, command);
  
***************
*** 253,270 ****
  {
      int i;
-     char* p;
  
      cur_rx = cur_tx = 0;
  
-     p = &rx_packet[0];
      for (i = 0; i < RX_RING_SIZE; i++) {
! 	rx_ring[i].status    = RRING_OWN;	/* Owned by Epic chip */
! 	rx_ring[i].buflength = PKT_BUF_SZ;
! 	rx_ring[i].bufaddr   = virt_to_bus(p + (PKT_BUF_SZ * i));
! 	rx_ring[i].control   = 0;
! 	rx_ring[i].next      = virt_to_bus(&(rx_ring[i + 1]) );
      }
      /* Mark the last entry as wrapping the ring. */
!     rx_ring[i-1].next = virt_to_bus(&rx_ring[0]);
  
      /*
--- 258,272 ----
  {
      int i;
  
      cur_rx = cur_tx = 0;
  
      for (i = 0; i < RX_RING_SIZE; i++) {
! 	rx_ring[i].status    = cpu_to_le32(RRING_OWN);	/* Owned by Epic chip */
! 	rx_ring[i].buflength = cpu_to_le32(PKT_BUF_SZ);
! 	rx_ring[i].bufaddr   = virt_to_bus(&rx_packet[i * PKT_BUF_SZ]);
! 	rx_ring[i].next      = virt_to_le32desc(&rx_ring[i + 1]) ;
      }
      /* Mark the last entry as wrapping the ring. */
!     rx_ring[i-1].next = virt_to_le32desc(&rx_ring[0]);
  
      /*
***************
*** 272,284 ****
       * but we do need to clear the ownership bit.
       */
-     p = &tx_packet[0];
  
      for (i = 0; i < TX_RING_SIZE; i++) {
! 	tx_ring[i].status  = 0;			/* Owned by CPU */
! 	tx_ring[i].bufaddr = virt_to_bus(p + (PKT_BUF_SZ * i));
! 	tx_ring[i].control = TD_STDFLAGS;
! 	tx_ring[i].next    = virt_to_bus(&(tx_ring[i + 1]) );
      }
!     tx_ring[i-1].next = virt_to_bus(&tx_ring[0]);
  }
  
--- 274,285 ----
       * but we do need to clear the ownership bit.
       */
  
      for (i = 0; i < TX_RING_SIZE; i++) {
! 	tx_ring[i].status  = 0x0000;			/* Owned by CPU */
!     	tx_ring[i].buflength = 0x0000 | cpu_to_le32(TD_STDFLAGS << 16);
! 	tx_ring[i].bufaddr = virt_to_bus(&tx_packet[i * PKT_BUF_SZ]);
! 	tx_ring[i].next    = virt_to_le32desc(&tx_ring[i + 1]);
      }
! 	tx_ring[i-1].next    = virt_to_le32desc(&tx_ring[0]);
  }
  
***************
*** 297,301 ****
  {
      unsigned short nstype;
!     char* txp;
      int entry;
  
--- 298,302 ----
  {
      unsigned short nstype;
!     unsigned char *txp;
      int entry;
  
***************
*** 311,315 ****
      }
  
!     txp = (char*)tx_ring[entry].bufaddr;
  
      memcpy(txp, destaddr, ETH_ALEN);
--- 312,316 ----
      }
  
!     txp = tx_packet + (entry * PKT_BUF_SZ);
  
      memcpy(txp, destaddr, ETH_ALEN);
***************
*** 320,324 ****
  
      len += ETH_HLEN;
! 
      /*
       * Caution: the write order is important here,
--- 321,327 ----
  
      len += ETH_HLEN;
! 	len &= 0x0FFF;
! 	while(len < ETH_ZLEN)
! 		txp[len++] = '\0';
      /*
       * Caution: the write order is important here,
***************
*** 326,343 ****
       * bits last.
       */
!     tx_ring[entry].txlength  = (len >= 60 ? len : 60);
!     tx_ring[entry].buflength = len;
!     tx_ring[entry].status    = TRING_OWN;	/* Pass ownership to the chip. */
  
      cur_tx++;
  
      /* Trigger an immediate transmit demand. */
!     outl(CR_QUEUE_TX, command);
! 
      load_timer2(10*TICKS_PER_MS);         /* timeout 10 ms for transmit */
!     while ((tx_ring[entry].status & TRING_OWN) && timer2_running())
  	/* Wait */;
  
!     if ((tx_ring[entry].status & TRING_OWN) != 0)
  	printf("Oops, transmitter timeout, status=%hX\n",
  	    tx_ring[entry].status);
--- 329,347 ----
       * bits last.
       */
!     
!     tx_ring[entry].buflength |= cpu_to_le32(len);
!     tx_ring[entry].status = cpu_to_le32(len << 16) | 
! 	    cpu_to_le32(TRING_OWN);	/* Pass ownership to the chip. */
  
      cur_tx++;
  
      /* Trigger an immediate transmit demand. */
!     outl(CR_QUEUE_TX, command); 
!     
      load_timer2(10*TICKS_PER_MS);         /* timeout 10 ms for transmit */
!     while ((le32_to_cpu(tx_ring[entry].status) & (TRING_OWN)) && timer2_running())
  	/* Wait */;
  
!     if ((le32_to_cpu(tx_ring[entry].status) & TRING_OWN) != 0)
  	printf("Oops, transmitter timeout, status=%hX\n",
  	    tx_ring[entry].status);
***************
*** 360,371 ****
  {
      int entry;
-     int status;
      int retcode;
! 
      entry = cur_rx % RX_RING_SIZE;
  
!     if ((status = rx_ring[entry].status & RRING_OWN) == RRING_OWN)
  	return (0);
  
      /* We own the next entry, it's a new packet. Send it up. */
  
--- 364,375 ----
  {
      int entry;
      int retcode;
!     int status;
      entry = cur_rx % RX_RING_SIZE;
  
!     if ((rx_ring[entry].status & cpu_to_le32(RRING_OWN)) == RRING_OWN)
  	return (0);
  
+     status = le32_to_cpu(rx_ring[entry].status);
      /* We own the next entry, it's a new packet. Send it up. */
  
***************
*** 384,389 ****
      } else {
  	/* Omit the four octet CRC from the length. */
! 	nic->packetlen = rx_ring[entry].rxlength - 4;
! 	memcpy(nic->packet, (char*)rx_ring[entry].bufaddr, nic->packetlen);
  	retcode = 1;
      }
--- 388,393 ----
      } else {
  	/* Omit the four octet CRC from the length. */
! 	nic->packetlen = le32_to_cpu((rx_ring[entry].buflength))- 4;
! 	memcpy(nic->packet, &rx_packet[entry * PKT_BUF_SZ], nic->packetlen);
  	retcode = 1;
      }
***************
*** 396,400 ****
  
      /* Restart Receiver */
!     outl(CR_START_RX | CR_QUEUE_RX, command);
  
      return retcode;
--- 400,404 ----
  
      /* Restart Receiver */
!     outl(CR_START_RX | CR_QUEUE_RX, command); 
  
      return retcode;
***************
*** 403,408 ****
  
      static void
! epic100_disable(struct nic *nic)
  {
  }
  
--- 407,414 ----
  
      static void
! epic100_disable(struct dev *dev __unused)
  {
+ 	/* Soft reset the chip. */
+ 	outl(GC_SOFT_RESET, genctl);
  }
  
***************
*** 480,481 ****
--- 486,502 ----
      return inw(mmdata);
  }
+ 
+ 
+ static struct pci_id epic100_nics[] = {
+ PCI_ROM(0x10b8, 0x0005, "epic100",    "SMC EtherPowerII"),		/* SMC 83c170 EPIC/100 */
+ PCI_ROM(0x10b8, 0x0006, "smc-83c175", "SMC EPIC/C 83c175"),
+ };
+ 
+ struct pci_driver epic100_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "EPIC100",
+ 	.probe    = epic100_probe,
+ 	.ids      = epic100_nics,
+ 	.id_count = sizeof(epic100_nics)/sizeof(epic100_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/etherboot.h GRUB/netboot/etherboot.h
*** GRUB_0.94/netboot/etherboot.h	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/etherboot.h	2003-11-21 11:31:43.000000000 +0800
***************
*** 1,547 ****
- /*
-  *  GRUB  --  GRand Unified Bootloader
-  *  Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
-  *
-  *  This program is free software; you can redistribute it and/or modify
-  *  it under the terms of the GNU General Public License as published by
-  *  the Free Software Foundation; either version 2 of the License, or
-  *  (at your option) any later version.
-  *
-  *  This program is distributed in the hope that it will be useful,
-  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  *  GNU General Public License for more details.
-  *
-  *  You should have received a copy of the GNU General Public License
-  *  along with this program; if not, write to the Free Software
-  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-  */
  
! /* RULE: You must define the macro ``GRUB'' when including this header
!    file in GRUB code.  */
  
- /* Based on "src/etherboot.h" in etherboot-5.0.5.  */
- 
- /**************************************************************************
- ETHERBOOT -  BOOTP/TFTP Bootstrap Program
- 
- Author: Martin Renters
-   Date: Dec/93
- 
- **************************************************************************/
- 
- /* Include GRUB-specific macros and prototypes here.  */
- #include <shared.h>
- 
- /* FIXME: For now, enable the DHCP support. Perhaps I should segregate
-    the DHCP support from the BOOTP support, and permit both to
-    co-exist.  */
- #undef NO_DHCP_SUPPORT
- 
- /* In GRUB, the relocated address in Etherboot doesn't have any sense.
-    Just define it as a bogus value.  */
- #define RELOC	0
- 
- /* FIXME: Should be an option.  */
- #define BACKOFF_LIMIT	7
- 
- #include <osdep.h>
- 
- #define CTRL_C		3
- 
- #ifndef	MAX_TFTP_RETRIES
- # define MAX_TFTP_RETRIES	20
- #endif
- 
- #ifndef	MAX_BOOTP_RETRIES
- # define MAX_BOOTP_RETRIES	20
- #endif
- 
- #define MAX_BOOTP_EXTLEN	(ETH_FRAME_LEN - ETH_HLEN - \
- 				 sizeof (struct bootp_t))
- 
- #ifndef	MAX_ARP_RETRIES
- # define MAX_ARP_RETRIES	20
- #endif
- 
- #ifndef	MAX_RPC_RETRIES
- # define MAX_RPC_RETRIES	20
- #endif
- 
- #define	TICKS_PER_SEC		18
- 
- /* Inter-packet retry in ticks */
- #define TIMEOUT			(10 * TICKS_PER_SEC)
- 
- /* These settings have sense only if compiled with -DCONGESTED */
- /* total retransmission timeout in ticks */
- #define TFTP_TIMEOUT		(30 * TICKS_PER_SEC)
- /* packet retransmission timeout in ticks */
- #define TFTP_REXMT		(3 * TICKS_PER_SEC)
- 
- #ifndef	NULL
- # define NULL			((void *) 0)
- #endif
- 
- /*
-    I'm moving towards the defined names in linux/if_ether.h for clarity.
-    The confusion between 60/64 and 1514/1518 arose because the NS8390
-    counts the 4 byte frame checksum in the incoming packet, but not
-    in the outgoing packet. 60/1514 are the correct numbers for most
-    if not all of the other NIC controllers. I will be retiring the
-    64/1518 defines in the lead-up to 5.0.
- */
- 
- #define ETH_ALEN		6	/* Size of Ethernet address */
- #define ETH_HLEN		14	/* Size of ethernet header */
- #define	ETH_ZLEN		60	/* Minimum packet */
- /*#define ETH_MIN_PACKET		64*/
- #define	ETH_FRAME_LEN		1514	/* Maximum packet */
- /*#define ETH_MAX_PACKET		1518*/
- /* Because some DHCP/BOOTP servers don't treat the maximum length the same
-    as Etherboot, subtract the size of an IP header and that of an UDP
-    header.  */
- #define	ETH_MAX_MTU		(ETH_FRAME_LEN - ETH_HLEN \
- 				- sizeof (struct iphdr) \
- 				- sizeof (struct udphdr))
- 
- #define ARP_CLIENT	0
- #define ARP_SERVER	1
- #define ARP_GATEWAY	2
- #define ARP_ROOTSERVER	3
- #define ARP_SWAPSERVER	4
- #define MAX_ARP		ARP_SWAPSERVER+1
- 
- #define	RARP_REQUEST	3
- #define	RARP_REPLY	4
- 
- #define IP		0x0800
- #define ARP		0x0806
- #define	RARP		0x8035
- 
- #define BOOTP_SERVER	67
- #define BOOTP_CLIENT	68
- #define TFTP_PORT	69
- #define SUNRPC_PORT	111
- 
- #define IP_UDP		17
- /* Same after going through htonl */
- #define IP_BROADCAST	0xFFFFFFFF
- 
- #define ARP_REQUEST	1
- #define ARP_REPLY	2
- 
- #define BOOTP_REQUEST	1
- #define BOOTP_REPLY	2
- 
- #define TAG_LEN(p)		(*((p) + 1))
- #define RFC1533_COOKIE		99, 130, 83, 99
- #define RFC1533_PAD		0
- #define RFC1533_NETMASK		1
- #define RFC1533_TIMEOFFSET	2
- #define RFC1533_GATEWAY		3
- #define RFC1533_TIMESERVER	4
- #define RFC1533_IEN116NS	5
- #define RFC1533_DNS		6
- #define RFC1533_LOGSERVER	7
- #define RFC1533_COOKIESERVER	8
- #define RFC1533_LPRSERVER	9
- #define RFC1533_IMPRESSSERVER	10
- #define RFC1533_RESOURCESERVER	11
- #define RFC1533_HOSTNAME	12
- #define RFC1533_BOOTFILESIZE	13
- #define RFC1533_MERITDUMPFILE	14
- #define RFC1533_DOMAINNAME	15
- #define RFC1533_SWAPSERVER	16
- #define RFC1533_ROOTPATH	17
- #define RFC1533_EXTENSIONPATH	18
- #define RFC1533_IPFORWARDING	19
- #define RFC1533_IPSOURCEROUTING	20
- #define RFC1533_IPPOLICYFILTER	21
- #define RFC1533_IPMAXREASSEMBLY	22
- #define RFC1533_IPTTL		23
- #define RFC1533_IPMTU		24
- #define RFC1533_IPMTUPLATEAU	25
- #define RFC1533_INTMTU		26
- #define RFC1533_INTLOCALSUBNETS	27
- #define RFC1533_INTBROADCAST	28
- #define RFC1533_INTICMPDISCOVER	29
- #define RFC1533_INTICMPRESPOND	30
- #define RFC1533_INTROUTEDISCOVER 31
- #define RFC1533_INTROUTESOLICIT	32
- #define RFC1533_INTSTATICROUTES	33
- #define RFC1533_LLTRAILERENCAP	34
- #define RFC1533_LLARPCACHETMO	35
- #define RFC1533_LLETHERNETENCAP	36
- #define RFC1533_TCPTTL		37
- #define RFC1533_TCPKEEPALIVETMO	38
- #define RFC1533_TCPKEEPALIVEGB	39
- #define RFC1533_NISDOMAIN	40
- #define RFC1533_NISSERVER	41
- #define RFC1533_NTPSERVER	42
- #define RFC1533_VENDOR		43
- #define RFC1533_NBNS		44
- #define RFC1533_NBDD		45
- #define RFC1533_NBNT		46
- #define RFC1533_NBSCOPE		47
- #define RFC1533_XFS		48
- #define RFC1533_XDM		49
- #ifndef	NO_DHCP_SUPPORT
- #define RFC2132_REQ_ADDR	50
- #define RFC2132_MSG_TYPE	53
- #define RFC2132_SRV_ID		54
- #define RFC2132_PARAM_LIST	55
- #define RFC2132_MAX_SIZE	57
- #define RFC2132_VENDOR_CLASS_ID	60
- 
- #define DHCPDISCOVER		1
- #define DHCPOFFER		2
- #define DHCPREQUEST		3
- #define DHCPACK			5
- #endif	/* NO_DHCP_SUPPORT */
- 
- #define RFC1533_VENDOR_MAJOR	0
- #define RFC1533_VENDOR_MINOR	0
- 
- #define RFC1533_VENDOR_MAGIC	128
- #define RFC1533_VENDOR_ADDPARM	129
- #define RFC1533_VENDOR_MNUOPTS	160
- #define RFC1533_VENDOR_SELECTION 176
- #define RFC1533_VENDOR_MOTD	184
- #define RFC1533_VENDOR_NUMOFMOTD 8
- #define RFC1533_VENDOR_IMG	192
- #define RFC1533_VENDOR_NUMOFIMG	16
- 
- #define RFC1533_VENDOR_CONFIGFILE	150
- 
- #define RFC1533_END		255
- 
- #define BOOTP_VENDOR_LEN	64
- #ifndef	NO_DHCP_SUPPORT
- #define DHCP_OPT_LEN		312
- #endif	/* NO_DHCP_SUPPORT */
- 
- #define	TFTP_DEFAULTSIZE_PACKET	512
- #define	TFTP_MAX_PACKET		1432 /* 512 */
- 
- #define TFTP_RRQ	1
- #define TFTP_WRQ	2
- #define TFTP_DATA	3
- #define TFTP_ACK	4
- #define TFTP_ERROR	5
- #define TFTP_OACK	6
- 
- #define TFTP_CODE_EOF	1
- #define TFTP_CODE_MORE	2
- #define TFTP_CODE_ERROR	3
- #define TFTP_CODE_BOOT	4
- #define TFTP_CODE_CFG	5
- 
- #define AWAIT_ARP	0
- #define AWAIT_BOOTP	1
- #define AWAIT_TFTP	2
- #define AWAIT_RARP	3
- #define AWAIT_RPC	4
- #define AWAIT_QDRAIN	5	/* drain queue, process ARP requests */
- 
- typedef struct
- {
-   unsigned long	s_addr;
- }
- in_addr;
- 
- struct arptable_t
- {
-   in_addr ipaddr;
-   unsigned char node[6];
- };
- 
- /*
-  * A pity sipaddr and tipaddr are not longword aligned or we could use
-  * in_addr. No, I don't want to use #pragma packed.
-  */
- struct arprequest
- {
-   unsigned short hwtype;
-   unsigned short protocol;
-   char hwlen;
-   char protolen;
-   unsigned short opcode;
-   char shwaddr[6];
-   char sipaddr[4];
-   char thwaddr[6];
-   char tipaddr[4];
- };
- 
- struct iphdr
- {
-   char verhdrlen;
-   char service;
-   unsigned short len;
-   unsigned short ident;
-   unsigned short frags;
-   char ttl;
-   char protocol;
-   unsigned short chksum;
-   in_addr src;
-   in_addr dest;
- };
- 
- struct udphdr
- {
-   unsigned short src;
-   unsigned short dest;
-   unsigned short len;
-   unsigned short chksum;
- };
- 
- /* Format of a bootp packet.  */
- struct bootp_t
- {
-   char bp_op;
-   char bp_htype;
-   char bp_hlen;
-   char bp_hops;
-   unsigned long bp_xid;
-   unsigned short bp_secs;
-   unsigned short unused;
-   in_addr bp_ciaddr;
-   in_addr bp_yiaddr;
-   in_addr bp_siaddr;
-   in_addr bp_giaddr;
-   char bp_hwaddr[16];
-   char bp_sname[64];
-   char bp_file[128];
- #ifdef	NO_DHCP_SUPPORT
-   char bp_vend[BOOTP_VENDOR_LEN];
- #else
-   char bp_vend[DHCP_OPT_LEN];
- #endif	/* NO_DHCP_SUPPORT */
- };
- 
- /* Format of a bootp IP packet.  */
- struct bootpip_t
- {
-   struct iphdr ip;
-   struct udphdr udp;
-   struct bootp_t bp;
- };
- 
- /* Format of bootp packet with extensions.  */
- struct bootpd_t
- {
-   struct bootp_t bootp_reply;
-   unsigned char  bootp_extension[MAX_BOOTP_EXTLEN];
- };
- 
- struct tftp_t
- {
-   struct iphdr ip;
-   struct udphdr udp;
-   unsigned short opcode;
-   union
-   {
-     char rrq[TFTP_DEFAULTSIZE_PACKET];
-     
-     struct
-     {
-       unsigned short block;
-       char download[TFTP_MAX_PACKET];
-     }
-     data;
-     
-     struct
-     {
-       unsigned short block;
-     }
-     ack;
-     
-     struct
-     {
-       unsigned short errcode;
-       char errmsg[TFTP_DEFAULTSIZE_PACKET];
-     }
-     err;
-     
-     struct
-     {
-       char data[TFTP_DEFAULTSIZE_PACKET+2];
-     }
-     oack;
-   }
-   u;
- };
- 
- /* Define a smaller tftp packet solely for making requests to conserve stack
-    512 bytes should be enough.  */
- struct tftpreq_t
- {
-   struct iphdr ip;
-   struct udphdr udp;
-   unsigned short opcode;
-   union
-   {
-     char rrq[512];
-     
-     struct
-     {
-       unsigned short block;
-     }
-     ack;
-     
-     struct
-     {
-       unsigned short errcode;
-       char errmsg[512-2];
-     }
-     err;
-   }
-   u;
- };
- 
- #define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
- 
- struct rpc_t
- {
-   struct iphdr ip;
-   struct udphdr udp;
-   union
-   {
-     char data[300];		/* longest RPC call must fit!!!! */
-     
-     struct
-     {
-       long id;
-       long type;
-       long rpcvers;
-       long prog;
-       long vers;
-       long proc;
-       long data[1];
-     }
-     call;
-     
-     struct
-     {
-       long id;
-       long type;
-       long rstatus;
-       long verifier;
-       long v2;
-       long astatus;
-       long data[1];
-     }
-     reply;
-   }
-   u;
- };
- 
- #define PROG_PORTMAP	100000
- #define PROG_NFS	100003
- #define PROG_MOUNT	100005
- 
- #define MSG_CALL	0
- #define MSG_REPLY	1
- 
- #define PORTMAP_GETPORT	3
- 
- #define MOUNT_ADDENTRY	1
- #define MOUNT_UMOUNTALL	4
- 
- #define NFS_LOOKUP	4
- #define NFS_READ	6
- 
- #define NFS_FHSIZE	32
- 
- #define NFSERR_PERM	1
- #define NFSERR_NOENT	2
- #define NFSERR_ACCES	13
- 
- /* Block size used for NFS read accesses.  A RPC reply packet (including  all
-  * headers) must fit within a single Ethernet frame to avoid fragmentation.
-  * Chosen to be a power of two, as most NFS servers are optimized for this.  */
- #define NFS_READ_SIZE	1024
- 
- #define	FLOPPY_BOOT_LOCATION	0x7c00
- /* Must match offsets in loader.S */
- #define ROM_SEGMENT		0x1fa
- #define ROM_LENGTH		0x1fc
- 
- #define	ROM_INFO_LOCATION	(FLOPPY_BOOT_LOCATION + ROM_SEGMENT)
- /* at end of floppy boot block */
- 
- struct rom_info
- {
-   unsigned short	rom_segment;
-   unsigned short	rom_length;
- };
- 
- static inline int
- rom_address_ok (struct rom_info *rom, int assigned_rom_segment)
- {
-   return (assigned_rom_segment < 0xC000
- 	  || assigned_rom_segment == rom->rom_segment);
- }
- 
- /* Define a type for passing info to a loaded program.  */
- struct ebinfo
- {
-   unsigned char	major, minor;	/* Version */
-   unsigned short	flags;		/* Bit flags */
- };
- 
- /***************************************************************************
- External prototypes
- ***************************************************************************/
- /* main.c */
- extern void print_network_configuration (void);
- extern int ifconfig (char *ip, char *sm, char *gw, char *svr);
- extern int udp_transmit (unsigned long destip, unsigned int srcsock,
- 			 unsigned int destsock, int len, const void *buf);
- extern int await_reply (int type, int ival, void *ptr, int timeout);
- extern int decode_rfc1533 (unsigned char *, int, int, int);
- extern long rfc2131_sleep_interval (int base, int exp);
- extern void cleanup (void);
- extern int rarp (void);
- extern int bootp (void);
- extern void cleanup_net (void);
- 
- /* config.c */
- extern void print_config (void);
- extern void eth_reset (void);
- extern int eth_probe (void);
- extern int eth_poll (void);
- extern void eth_transmit (const char *d, unsigned int t,
- 			  unsigned int s, const void *p);
- extern void eth_disable (void);
- 
- /* misc.c */
- extern void twiddle (void);
- extern void sleep (int secs);
- extern int getdec (char **s);
- extern void etherboot_printf (const char *, ...);
- extern int etherboot_sprintf (char *, const char *, ...);
- extern int inet_aton (char *p, in_addr *i);
- 
- /***************************************************************************
- External variables
- ***************************************************************************/
- /* main.c */
- extern int ip_abort;
- extern int network_ready;
- extern struct rom_info rom;
- extern struct arptable_t arptable[MAX_ARP];
- extern struct bootpd_t bootp_data;
- #define	BOOTP_DATA_ADDR	(&bootp_data)
- extern unsigned char *end_of_rfc1533;
- 
- /* config.c */
- extern struct nic nic;
- 
- /* Local hack - define some macros to use etherboot source files "as is".  */
- #ifndef GRUB
- # undef printf
- # define printf	etherboot_printf
- # undef sprintf
- # define sprintf etherboot_sprintf
- #endif /* GRUB */
--- 1,15 ----
  
! #include "osdep.h"
! #include "if_ether.h"
! #include "in.h"
! #include "if_arp.h"
! #include "ip.h"
! #include "udp.h"
! #include "bootp.h"
! #include "tftp.h"
! #include "igmp.h"
! //#include "nfs.h"
! //#include "nic.h"
! #include "pci.h"
! #include "grub.h"
  
Only in GRUB_0.94/netboot: fa311.c
diff -rc2P -x CVS GRUB_0.94/netboot/fsys_tftp.c GRUB/netboot/fsys_tftp.c
*** GRUB_0.94/netboot/fsys_tftp.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/fsys_tftp.c	2003-11-05 18:10:24.000000000 +0800
***************
*** 30,41 ****
  
  #include <filesys.h>
  
! #define GRUB	1
! #include <etherboot.h>
! #include <nic.h>
  
  static int retry;
  static unsigned short iport = 2000;
! static unsigned short oport;
  static unsigned short block, prevblock;
  static int bcounter;
--- 30,42 ----
  
  #include <filesys.h>
+ #include <shared.h>
  
! #include "grub.h"
! #include "tftp.h"
! #include "nic.h"
  
  static int retry;
  static unsigned short iport = 2000;
! static unsigned short oport = 0;
  static unsigned short block, prevblock;
  static int bcounter;
***************
*** 47,50 ****
--- 48,217 ----
  static char *buf;
  
+ /**
+  * tftp_read
+  *
+  * Read file with _name_, data handled by _fnc_. In fact, grub never
+  * use it, we just use it to read dhcp config file.
+  */
+ static int await_tftp(int ival, void *ptr __unused, 
+ 		      unsigned short ptype __unused, struct iphdr *ip, 
+ 		      struct udphdr *udp)
+ {
+ 	if (!udp) {
+ 		return 0;
+ 	}
+ 	if (arptable[ARP_CLIENT].ipaddr.s_addr != ip->dest.s_addr)
+ 		return 0;
+ 	if (ntohs(udp->dest) != ival)
+ 		return 0;
+ 	return 1;
+ }
+ 
+ int tftp_file_read(const char *name, int (*fnc)(unsigned char *, unsigned int, unsigned int, int))
+ {
+ 	struct tftpreq_t tp;
+ 	struct tftp_t  *tr;
+ 	int		rc;
+ 
+ 	retry = 0;
+ 	block = 0;
+ 	prevblock = 0;
+ 	bcounter = 0;
+ 	
+ 
+ 	rx_qdrain();
+ 
+ 	tp.opcode = htons(TFTP_RRQ);
+ 	/* Warning: the following assumes the layout of bootp_t.
+ 	   But that's fixed by the IP, UDP and BOOTP specs. */
+ 	len = sizeof(tp.ip) + sizeof(tp.udp) + sizeof(tp.opcode) +
+ 		sprintf((char *)tp.u.rrq, "%s%coctet%cblksize%c%d",
+ 		name, 0, 0, 0, TFTP_MAX_PACKET) + 1;
+ 	if (!udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr, ++iport,
+ 			  TFTP_PORT, len, &tp))
+ 		return (0);
+ 	for (;;)
+ 	{
+ 		long timeout;
+ #ifdef	CONGESTED
+ 		timeout = rfc2131_sleep_interval(block?TFTP_REXMT: TIMEOUT, retry);
+ #else
+ 		timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+ #endif
+ 		if (!await_reply(await_tftp, iport, NULL, timeout))
+ 		{
+ 			if (!block && retry++ < MAX_TFTP_RETRIES)
+ 			{	/* maybe initial request was lost */
+ 				if (!udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+ 						  ++iport, TFTP_PORT, len, &tp))
+ 					return (0);
+ 				continue;
+ 			}
+ #ifdef	CONGESTED
+ 			if (block && ((retry += TFTP_REXMT) < TFTP_TIMEOUT))
+ 			{	/* we resend our last ack */
+ #ifdef	MDEBUG
+ 				printf("<REXMT>\n");
+ #endif
+ 				udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+ 					     iport, oport,
+ 					     TFTP_MIN_PACKET, &tp);
+ 				continue;
+ 			}
+ #endif
+ 			break;	/* timeout */
+ 		}
+ 		tr = (struct tftp_t *)&nic.packet[ETH_HLEN];
+ 		if (tr->opcode == ntohs(TFTP_ERROR))
+ 		{
+ 			printf("TFTP error %d (%s)\n",
+ 			       ntohs(tr->u.err.errcode),
+ 			       tr->u.err.errmsg);
+ 			break;
+ 		}
+ 
+ 		if (tr->opcode == ntohs(TFTP_OACK)) {
+ 			const char *p = tr->u.oack.data, *e;
+ 
+ 			if (prevblock)		/* shouldn't happen */
+ 				continue;	/* ignore it */
+ 			len = ntohs(tr->udp.len) - sizeof(struct udphdr) - 2;
+ 			if (len > TFTP_MAX_PACKET)
+ 				goto noak;
+ 			e = p + len;
+ 			while (*p != '\0' && p < e) {
+ /* 				if (!strcasecmp("blksize", p)) { */
+ 				if (!grub_strcmp("blksize", p)) {
+ 					p += 8;
+ /* 					if ((packetsize = strtoul(p, &p, 10)) < */
+ 					if ((packetsize = getdec(&p)) < TFTP_DEFAULTSIZE_PACKET)
+ 						goto noak;
+ 					while (p < e && *p) p++;
+ 					if (p < e)
+ 						p++;
+ 				}
+ 				else {
+ 				noak:
+ 					tp.opcode = htons(TFTP_ERROR);
+ 					tp.u.err.errcode = 8;
+ /*
+  *	Warning: the following assumes the layout of bootp_t.
+  *	But that's fixed by the IP, UDP and BOOTP specs.
+  */
+ 					len = sizeof(tp.ip) + sizeof(tp.udp) + sizeof(tp.opcode) + sizeof(tp.u.err.errcode) +
+ /*
+  *	Normally bad form to omit the format string, but in this case
+  *	the string we are copying from is fixed. sprintf is just being
+  *	used as a strcpy and strlen.
+  */
+ 						sprintf((char *)tp.u.err.errmsg,
+ 						"RFC1782 error") + 1;
+ 					udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+ 						     iport, ntohs(tr->udp.src),
+ 						     len, &tp);
+ 					return (0);
+ 				}
+ 			}
+ 			if (p > e)
+ 				goto noak;
+ 			block = tp.u.ack.block = 0; /* this ensures, that */
+ 						/* the packet does not get */
+ 						/* processed as data! */
+ 		}
+ 		else if (tr->opcode == htons(TFTP_DATA)) {
+ 			len = ntohs(tr->udp.len) - sizeof(struct udphdr) - 4;
+ 			if (len > packetsize)	/* shouldn't happen */
+ 				continue;	/* ignore it */
+ 			block = ntohs(tp.u.ack.block = tr->u.data.block); }
+ 		else {/* neither TFTP_OACK nor TFTP_DATA */
+ 			break;
+ 		}
+ 
+ 		if ((block || bcounter) && (block != (unsigned short)(prevblock+1))) {
+ 			/* Block order should be continuous */
+ 			tp.u.ack.block = htons(block = prevblock);
+ 		}
+ 		tp.opcode = htons(TFTP_ACK);
+ 		oport = ntohs(tr->udp.src);
+ 		udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr, iport,
+ 			     oport, TFTP_MIN_PACKET, &tp);	/* ack */
+ 		if ((unsigned short)(block-prevblock) != 1) {
+ 			/* Retransmission or OACK, don't process via callback
+ 			 * and don't change the value of prevblock.  */
+ 			continue;
+ 		}
+ 		prevblock = block;
+ 		retry = 0;	/* It's the right place to zero the timer? */
+ 		if ((rc = fnc(tr->u.data.download,
+ 			      ++bcounter, len, len < packetsize)) <= 0)
+ 			return(rc);
+ 		if (len < packetsize) {	/* End of data --- fnc should not have returned */
+ 			printf("tftp download complete, but\n");
+ 			return (1);
+ 		}
+ 	}
+ 	return (0);
+ }
+ 
  /* Fill the buffer by receiving the data via the TFTP protocol.  */
  static int
***************
*** 66,72 ****
  #endif
    
!       if (! await_reply (AWAIT_TFTP, iport, NULL, timeout))
  	{
! 	  if (ip_abort)
  	    return 0;
  
--- 233,239 ----
  #endif
    
!       if (! await_reply (await_tftp, iport, NULL, timeout))
  	{
! 	  if (user_abort)
  	    return 0;
  
***************
*** 271,281 ****
    saved_filepos = 0;
  
!   /* Clear out the Rx queue first.  It contains nothing of interest,
!    * except possibly ARP requests from the DHCP/TFTP server.  We use
!    * polling throughout Etherboot, so some time may have passed since we
!    * last polled the receive queue, which may now be filled with
!    * broadcast packets.  This will cause the reply to the packets we are
!    * about to send to be lost immediately.  Not very clever.  */
!   await_reply (AWAIT_QDRAIN, 0, NULL, 0);
    
  #ifdef TFTP_DEBUG
--- 438,442 ----
    saved_filepos = 0;
  
!   rx_qdrain();
    
  #ifdef TFTP_DEBUG
diff -rc2P -x CVS GRUB_0.94/netboot/grub.h GRUB/netboot/grub.h
*** GRUB_0.94/netboot/grub.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/grub.h	2003-11-21 12:22:14.000000000 +0800
***************
*** 0 ****
--- 1,162 ----
+ #ifndef GRUB_H
+ #define GRUB_H
+ 
+ #include "osdep.h"
+ #include "byteswap.h"
+ #include "in.h"
+ #include "ip.h"
+ #include "udp.h"
+ #include "if_ether.h"
+ #include "latch.h"
+ #include "io.h"
+ #include "nic.h"
+ #include <shared.h>
+ 
+ #define K_ESC		'\033'
+ #define K_EOF		'\04'  /* Ctrl-D */
+ #define K_INTR		'\03'  /* Ctrl-C */
+ 
+ #ifndef	MAX_RPC_RETRIES
+ #define MAX_RPC_RETRIES		20
+ #endif
+ 
+ /* Link configuration time in tenths of a second */
+ #ifndef VALID_LINK_TIMEOUT
+ #define VALID_LINK_TIMEOUT	100 /* 10.0 seconds */
+ #endif
+ 
+ /* Inter-packet retry in ticks */
+ #ifndef TIMEOUT
+ #define TIMEOUT			(10*TICKS_PER_SEC)
+ #endif
+ 
+ #ifndef	NULL
+ #define NULL	((void *)0)
+ #endif
+ 
+ 
+ #define ARP_CLIENT	0
+ #define ARP_SERVER	1
+ #define ARP_GATEWAY	2
+ #define MAX_ARP		ARP_GATEWAY+1
+ 
+ #define IGMP_SERVER	0
+ #define MAX_IGMP	IGMP_SERVER+1
+ 
+ #define	RARP_REQUEST	3
+ #define	RARP_REPLY	4
+ 
+ 
+ #define MULTICAST_MASK    0xF0000000
+ #define MULTICAST_NETWORK 0xE0000000
+ 
+ struct arptable_t {
+ 	in_addr ipaddr;
+ 	uint8_t node[6];
+ };
+ 
+ struct igmptable_t {
+ 	in_addr group;
+ 	unsigned long time;
+ };
+ 
+ #define	KERNEL_BUF	(BOOTP_DATA_ADDR->bootp_reply.bp_file)
+ 
+ #define	FLOPPY_BOOT_LOCATION	0x7c00
+ /* Must match offsets in loader.S */
+ #define ROM_SEGMENT		0x1fa
+ #define ROM_LENGTH		0x1fc
+ 
+ #define	ROM_INFO_LOCATION	(FLOPPY_BOOT_LOCATION+ROM_SEGMENT)
+ /* at end of floppy boot block */
+ 
+ 
+ 
+ /* Define a type for passing info to a loaded program */
+ struct ebinfo {
+ 	uint8_t  major, minor;	/* Version */
+ 	uint16_t flags;		/* Bit flags */
+ };
+ 
+ /***************************************************************************
+ External prototypes
+ ***************************************************************************/
+ extern void rx_qdrain P((void));
+ extern int tftp P((const char *name, int (*)(unsigned char *, unsigned int, unsigned int, int)));
+ extern int ip_transmit P((int len, const void *buf));
+ extern void build_ip_hdr P((unsigned long destip, int ttl, int protocol, 
+ 	int option_len, int len, const void *buf));
+ extern void build_udp_hdr P((unsigned long destip, 
+ 	unsigned int srcsock, unsigned int destsock, int ttl,
+ 	int len, const void *buf));
+ extern int udp_transmit P((unsigned long destip, unsigned int srcsock,
+ 	unsigned int destsock, int len, const void *buf));
+ typedef int (*reply_t)(int ival, void *ptr, unsigned short ptype, struct iphdr *ip, struct udphdr *udp);
+ extern int await_reply P((reply_t reply,	int ival, void *ptr, long timeout));
+ extern int decode_rfc1533 P((unsigned char *, unsigned int, unsigned int, int));
+ extern void join_group(int slot, unsigned long group);
+ extern void leave_group(int slot);
+ #define RAND_MAX 2147483647L
+ extern uint16_t ipchksum P((const void *ip, unsigned long len));
+ extern uint16_t add_ipchksums P((unsigned long offset, uint16_t sum, uint16_t new));
+ extern int32_t random P((void));
+ extern long rfc2131_sleep_interval P((long base, int exp));
+ extern long rfc1112_sleep_interval P((long base, int exp));
+ #ifndef DOWNLOAD_PROTO_TFTP
+ #define	tftp(fname, load_block) 0
+ #endif
+ extern void cleanup P((void));
+ 
+ /* misc.c */
+ extern void twiddle P((void));
+ extern void sleep P((int secs));
+ extern void interruptible_sleep P((int secs));
+ extern void poll_interruptions P((void));
+ extern int strcasecmp P((const char *a, const char *b));
+ extern char *substr P((const char *a, const char *b));
+ extern unsigned long strtoul P((const char *p, const char **, int base));
+ extern void printf P((const char *, ...));
+ extern int sprintf P((char *, const char *, ...));
+ extern int inet_aton P((char *p, in_addr *i));
+ #ifdef PCBIOS
+ extern void gateA20_set P((void));
+ #ifdef	RELOCATE
+ #define gateA20_unset()
+ #else
+ extern void gateA20_unset P((void));
+ #endif
+ #else
+ #define gateA20_set()
+ #define gateA20_unset()
+ #endif
+ extern void putchar P((int));
+ extern int getchar P((void));
+ extern int iskey P((void));
+ 
+ extern void grub_printf(const char *, ...);
+ extern char config_file[128];
+ extern void etherboot_printf(const char *,  ...);
+ extern int etherboot_sprintf(char *, const char *, ...);
+ extern int getdec(char **s);
+ extern void cleanup_net(void);
+ extern void print_network_configuration (void);
+ extern int ifconfig (char *, char *, char *, char *);
+ extern struct arptable_t arptable[MAX_ARP];
+ 
+ #define EnterFunction(func)
+ #define LeaveFunction(func)
+ #undef printf
+ #undef sprintf
+ #define printf etherboot_printf
+ #define sprintf etherboot_sprintf
+ 
+ /*
+  * Some codes from etherboot use a level in DEBUG. Define it to be
+  * zero means no debug info output, that will make them silence in
+  * compiling. Up it as you want.
+  */
+ #ifndef DEBUG
+ #  define DEBUG 0
+ #endif
+ 
+ #endif /* GRUB_H */
diff -rc2P -x CVS GRUB_0.94/netboot/i386_byteswap.h GRUB/netboot/i386_byteswap.h
*** GRUB_0.94/netboot/i386_byteswap.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/i386_byteswap.h	2003-11-11 21:38:02.000000000 +0800
***************
*** 0 ****
--- 1,46 ----
+ #ifndef ETHERBOOT_BITS_BYTESWAP_H
+ #define ETHERBOOT_BITS_BYTESWAP_H
+ 
+ #include "types.h"
+ static inline uint16_t __i386_bswap_16(uint16_t x)
+ {
+ 	__asm__("xchgb %b0,%h0\n\t"
+ 		: "=q" (x)
+ 		: "0" (x));
+ 	return x;
+ }
+ 
+ static inline uint32_t __i386_bswap_32(uint32_t x)
+ {
+ 	__asm__("xchgb %b0,%h0\n\t"
+ 		"rorl $16,%0\n\t"
+ 		"xchgb %b0,%h0"
+ 		: "=q" (x)
+ 		: "0" (x));
+ 	return x;
+ }
+ 
+ 
+ #define __bswap_constant_16(x) \
+ 	((uint16_t)((((uint16_t)(x) & 0x00ff) << 8) | \
+ 		(((uint16_t)(x) & 0xff00) >> 8)))
+ 
+ #define __bswap_constant_32(x) \
+ 	((uint32_t)((((uint32_t)(x) & 0x000000ffU) << 24) | \
+ 		(((uint32_t)(x) & 0x0000ff00U) <<  8) | \
+ 		(((uint32_t)(x) & 0x00ff0000U) >>  8) | \
+ 		(((uint32_t)(x) & 0xff000000U) >> 24)))
+ 
+ #define __bswap_16(x) \
+ 	(__builtin_constant_p(x) ? \
+ 	__bswap_constant_16(x) : \
+ 	__i386_bswap_16(x))
+ 
+ 
+ #define __bswap_32(x) \
+ 	(__builtin_constant_p(x) ? \
+ 	__bswap_constant_32(x) : \
+ 	__i386_bswap_32(x))
+ 
+ 
+ #endif /* ETHERBOOT_BITS_BYTESWAP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/i386_elf.h GRUB/netboot/i386_elf.h
*** GRUB_0.94/netboot/i386_elf.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/i386_elf.h	2003-11-04 05:21:57.000000000 +0800
***************
*** 0 ****
--- 1,91 ----
+ #ifndef I386_BITS_ELF_H
+ #define I386_BITS_ELF_H
+ 
+ #include "cpu.h"
+ 
+ #ifdef CONFIG_X86_64
+ /* ELF Defines for the 64bit version of the current architecture */
+ #define EM_CURRENT_64	EM_X86_64
+ #define EM_CURRENT_64_PRESENT ( \
+ 	CPU_FEATURE_P(cpu_info.x86_capability, LM) && \
+ 	CPU_FEATURE_P(cpu_info.x86_capability, PAE) && \
+ 	CPU_FEATURE_P(cpu_info.x86_capability, PSE))
+ 			
+ #define ELF_CHECK_X86_64_ARCH(x) \
+ 	(EM_CURRENT_64_PRESENT && ((x).e_machine == EM_X86_64))
+ #define __unused_i386
+ #else
+ #define ELF_CHECK_X86_64_ARCH(x) 0
+ #define __unused_i386 __unused
+ #endif
+ 
+ 
+ /* ELF Defines for the current architecture */
+ #define	EM_CURRENT	EM_386
+ #define ELFDATA_CURRENT	ELFDATA2LSB
+ 
+ #define ELF_CHECK_I386_ARCH(x) \
+ 	(((x).e_machine == EM_386) || ((x).e_machine == EM_486))
+ 
+ #define ELF_CHECK_ARCH(x) \
+ 	((ELF_CHECK_I386_ARCH(x) || ELF_CHECK_X86_64_ARCH(x)) && \
+ 		((x).e_entry <= 0xffffffffUL))
+ 
+ #ifdef  IMAGE_FREEBSD
+ /*
+  * FreeBSD has this rather strange "feature" of its design.
+  * At some point in its evolution, FreeBSD started to rely
+  * externally on private/static/debug internal symbol information.
+  * That is, some of the interfaces that software uses to access
+  * and work with the FreeBSD kernel are made available not
+  * via the shared library symbol information (the .DYNAMIC section)
+  * but rather the debug symbols.  This means that any symbol, not
+  * just publicly defined symbols can be (and are) used by system
+  * tools to make the system work.  (such as top, swapinfo, swapon,
+  * etc)
+  *
+  * Even worse, however, is the fact that standard ELF loaders do
+  * not know how to load the symbols since they are not within
+  * an ELF PT_LOAD section.  The kernel needs these symbols to
+  * operate so the following changes/additions to the boot
+  * loading of EtherBoot have been made to get the kernel to load.
+  * All of the changes are within IMAGE_FREEBSD such that the
+  * extra/changed code only compiles when FREEBSD support is
+  * enabled.
+  */
+ 
+ /*
+  * Section header for FreeBSD (debug symbol kludge!) support
+  */
+ typedef struct {
+ 	Elf32_Word	sh_name;	/* Section name (index into the
+ 					   section header string table). */
+ 	Elf32_Word	sh_type;	/* Section type. */
+ 	Elf32_Word	sh_flags;	/* Section flags. */
+ 	Elf32_Addr	sh_addr;	/* Address in memory image. */
+ 	Elf32_Off	sh_offset;	/* Offset in file. */
+ 	Elf32_Size	sh_size;	/* Size in bytes. */
+ 	Elf32_Word	sh_link;	/* Index of a related section. */
+ 	Elf32_Word	sh_info;	/* Depends on section type. */
+ 	Elf32_Size	sh_addralign;	/* Alignment in bytes. */
+ 	Elf32_Size	sh_entsize;	/* Size of each entry in section. */
+ } Elf32_Shdr;
+ 
+ /* sh_type */
+ #define SHT_SYMTAB	2		/* symbol table section */
+ #define SHT_STRTAB	3		/* string table section */
+ 
+ /*
+  * Module information subtypes (for the metadata that we need to build)
+  */
+ #define MODINFO_END		0x0000		/* End of list */
+ #define MODINFO_NAME		0x0001		/* Name of module (string) */
+ #define MODINFO_TYPE		0x0002		/* Type of module (string) */
+ #define MODINFO_METADATA	0x8000		/* Module-specfic */
+ 
+ #define MODINFOMD_SSYM		0x0003		/* start of symbols */
+ #define MODINFOMD_ESYM		0x0004		/* end of symbols */
+ 
+ #endif	/* IMAGE_FREEBSD */
+ 
+ #endif /* I386_BITS_ELF_H */
diff -rc2P -x CVS GRUB_0.94/netboot/i386_endian.h GRUB/netboot/i386_endian.h
*** GRUB_0.94/netboot/i386_endian.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/i386_endian.h	2003-11-04 05:21:57.000000000 +0800
***************
*** 0 ****
--- 1,6 ----
+ #ifndef ETHERBOOT_BITS_ENDIAN_H
+ #define ETHERBOOT_BITS_ENDIAN_H
+ 
+ #define __BYTE_ORDER __LITTLE_ENDIAN
+ 
+ #endif /* ETHERBOOT_BITS_ENDIAN_H */
diff -rc2P -x CVS GRUB_0.94/netboot/i386_timer.c GRUB/netboot/i386_timer.c
*** GRUB_0.94/netboot/i386_timer.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/i386_timer.c	2003-11-17 10:51:59.000000000 +0800
***************
*** 0 ****
--- 1,192 ----
+ /* A couple of routines to implement a low-overhead timer for drivers */
+ 
+  /*
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2, or (at
+  * your option) any later version.
+  */
+ #include "grub.h"
+ #include "osdep.h"
+ #include "io.h"
+ #include "timer.h"
+ #include "latch.h"
+ 
+ void __load_timer2(unsigned int ticks)
+ {
+ 	/*
+ 	 * Now let's take care of PPC channel 2
+ 	 *
+ 	 * Set the Gate high, program PPC channel 2 for mode 0,
+ 	 * (interrupt on terminal count mode), binary count,
+ 	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.
+ 	 *
+ 	 * Note some implementations have a bug where the high bits byte
+ 	 * of channel 2 is ignored.
+ 	 */
+ 	/* Set up the timer gate, turn off the speaker */
+ 	/* Set the Gate high, disable speaker */
+ 	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
+ 	/* binary, mode 0, LSB/MSB, Ch 2 */
+ 	outb(TIMER2_SEL|WORD_ACCESS|MODE0|BINARY_COUNT, TIMER_MODE_PORT);
+ 	/* LSB of ticks */
+ 	outb(ticks & 0xFF, TIMER2_PORT);
+ 	/* MSB of ticks */
+ 	outb(ticks >> 8, TIMER2_PORT);
+ }
+ 
+ static int __timer2_running(void)
+ {
+ 	return ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
+ }
+ 
+ #if !defined(CONFIG_TSC_CURRTICKS)
+ void setup_timers(void)
+ {
+ 	return;
+ }
+ 
+ void load_timer2(unsigned int ticks)
+ {
+ 	return __load_timer2(ticks);
+ }
+ 
+ int timer2_running(void)
+ {
+ 	return __timer2_running();
+ }
+ 
+ void ndelay(unsigned int nsecs)
+ {
+ 	waiton_timer2((nsecs * CLOCK_TICK_RATE)/1000000000);
+ }
+ void udelay(unsigned int usecs)
+ {
+ 	waiton_timer2((usecs * TICKS_PER_MS)/1000);
+ }
+ #endif /* !defined(CONFIG_TSC_CURRTICKS) */
+ 
+ #if defined(CONFIG_TSC_CURRTICKS)
+ 
+ #define rdtsc(low,high) \
+      __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
+ 
+ #define rdtscll(val) \
+      __asm__ __volatile__ ("rdtsc" : "=A" (val))
+ 
+ 
+ /* Number of clock ticks to time with the rtc */
+ #define LATCH 0xFF
+ 
+ #define LATCHES_PER_SEC ((CLOCK_TICK_RATE + (LATCH/2))/LATCH)
+ #define TICKS_PER_LATCH ((LATCHES_PER_SEC + (TICKS_PER_SEC/2))/TICKS_PER_SEC)
+ 
+ static void sleep_latch(void)
+ {
+ 	__load_timer2(LATCH);
+ 	while(__timer2_running());
+ }
+ 
+ /* ------ Calibrate the TSC ------- 
+  * Time how long it takes to excute a loop that runs in known time.
+  * And find the convertion needed to get to CLOCK_TICK_RATE
+  */
+ 
+ 
+ static unsigned long long calibrate_tsc(void)
+ {
+ 	unsigned long startlow, starthigh;
+ 	unsigned long endlow, endhigh;
+ 	
+ 	rdtsc(startlow,starthigh);
+ 	sleep_latch();
+ 	rdtsc(endlow,endhigh);
+ 
+ 	/* 64-bit subtract - gcc just messes up with long longs */
+ 	__asm__("subl %2,%0\n\t"
+ 		"sbbl %3,%1"
+ 		:"=a" (endlow), "=d" (endhigh)
+ 		:"g" (startlow), "g" (starthigh),
+ 		"0" (endlow), "1" (endhigh));
+ 	
+ 	/* Error: ECPUTOOFAST */
+ 	if (endhigh)
+ 		goto bad_ctc;
+ 	
+ 	endlow *= TICKS_PER_LATCH;
+ 	return endlow;
+ 
+ 	/*
+ 	 * The CTC wasn't reliable: we got a hit on the very first read,
+ 	 * or the CPU was so fast/slow that the quotient wouldn't fit in
+ 	 * 32 bits..
+ 	 */
+ bad_ctc:
+ 	printf("bad_ctc\n");
+ 	return 0;
+ }
+ 
+ static unsigned long clocks_per_tick;
+ void setup_timers(void)
+ {
+ 	if (!clocks_per_tick) {
+ 		clocks_per_tick = calibrate_tsc();
+ 		/* Display the CPU Mhz to easily test if the calibration was bad */
+ 		printf("CPU %ld Mhz\n", (clocks_per_tick/1000 * TICKS_PER_SEC)/1000);
+ 	}
+ }
+ 
+ unsigned long currticks(void)
+ {
+ 	unsigned long clocks_high, clocks_low;
+ 	unsigned long currticks;
+ 	/* Read the Time Stamp Counter */
+ 	rdtsc(clocks_low, clocks_high);
+ 
+ 	/* currticks = clocks / clocks_per_tick; */
+ 	__asm__("divl %1"
+ 		:"=a" (currticks)
+ 		:"r" (clocks_per_tick), "0" (clocks_low), "d" (clocks_high));
+ 
+ 
+ 	return currticks;
+ }
+ 
+ static unsigned long long timer_timeout;
+ static int __timer_running(void)
+ {
+ 	unsigned long long now;
+ 	rdtscll(now);
+ 	return now < timer_timeout;
+ }
+ 
+ void udelay(unsigned int usecs)
+ {
+ 	unsigned long long now;
+ 	rdtscll(now);
+ 	timer_timeout = now + usecs * ((clocks_per_tick * TICKS_PER_SEC)/(1000*1000));
+ 	while(__timer_running());
+ }
+ void ndelay(unsigned int nsecs)
+ {
+ 	unsigned long long now;
+ 	rdtscll(now);
+ 	timer_timeout = now + nsecs * ((clocks_per_tick * TICKS_PER_SEC)/(1000*1000*1000));
+ 	while(__timer_running());
+ }
+ 
+ void load_timer2(unsigned int timer2_ticks)
+ {
+ 	unsigned long long now;
+ 	unsigned long clocks;
+ 	rdtscll(now);
+ 	clocks = timer2_ticks * ((clocks_per_tick * TICKS_PER_SEC)/CLOCK_TICK_RATE);
+ 	timer_timeout = now + clocks;
+ }
+ 
+ int timer2_running(void)
+ {
+ 	return __timer_running();
+ }
+ 
+ #endif /* RTC_CURRTICKS */
Only in GRUB_0.94/netboot: i82586.c
diff -rc2P -x CVS GRUB_0.94/netboot/if_arp.h GRUB/netboot/if_arp.h
*** GRUB_0.94/netboot/if_arp.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/if_arp.h	2003-11-11 20:43:02.000000000 +0800
***************
*** 0 ****
--- 1,29 ----
+ #ifndef	_IF_ARP_H
+ #define	_IF_ARP_H
+ 
+ #include "types.h"
+ 
+ #define ARP_REQUEST	1
+ #define ARP_REPLY	2
+ 
+ #ifndef	MAX_ARP_RETRIES
+ #define MAX_ARP_RETRIES		20
+ #endif
+ 
+ /*
+  * A pity sipaddr and tipaddr are not longword aligned or we could use
+  * in_addr. No, I don't want to use #pragma packed.
+  */
+ struct arprequest {
+ 	uint16_t hwtype;
+ 	uint16_t protocol;
+ 	uint8_t  hwlen;
+ 	uint8_t  protolen;
+ 	uint16_t opcode;
+ 	uint8_t  shwaddr[6];
+ 	uint8_t  sipaddr[4];
+ 	uint8_t  thwaddr[6];
+ 	uint8_t  tipaddr[4];
+ };
+ 
+ #endif	/* _IF_ARP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/if_ether.h GRUB/netboot/if_ether.h
*** GRUB_0.94/netboot/if_ether.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/if_ether.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,21 ----
+ #ifndef	_IF_ETHER_H
+ #define	_IF_ETHER_H
+ 
+ /*
+    I'm moving towards the defined names in linux/if_ether.h for clarity.
+    The confusion between 60/64 and 1514/1518 arose because the NS8390
+    counts the 4 byte frame checksum in the incoming packet, but not
+    in the outgoing packet. 60/1514 are the correct numbers for most
+    if not all of the other NIC controllers.
+ */
+ 
+ #define ETH_ALEN		6	/* Size of Ethernet address */
+ #define ETH_HLEN		14	/* Size of ethernet header */
+ #define	ETH_ZLEN		60	/* Minimum packet */
+ #define	ETH_FRAME_LEN		1514	/* Maximum packet */
+ #define ETH_DATA_ALIGN		2	/* Amount needed to align the data after an ethernet header */
+ #ifndef	ETH_MAX_MTU
+ #define	ETH_MAX_MTU		(ETH_FRAME_LEN-ETH_HLEN)
+ #endif
+ 
+ #endif	/* _IF_ETHER_H */
diff -rc2P -x CVS GRUB_0.94/netboot/igmp.h GRUB/netboot/igmp.h
*** GRUB_0.94/netboot/igmp.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/igmp.h	2003-11-11 20:43:02.000000000 +0800
***************
*** 0 ****
--- 1,27 ----
+ #ifndef	_IGMP_H
+ #define	_IGMP_H
+ 
+ /* Max interval between IGMP packets */
+ #define IGMP_INTERVAL			(10*TICKS_PER_SEC)
+ #define IGMPv1_ROUTER_PRESENT_TIMEOUT	(400*TICKS_PER_SEC)
+ 
+ #define IGMP_QUERY	0x11
+ #define IGMPv1_REPORT	0x12
+ #define IGMPv2_REPORT	0x16
+ #define IGMP_LEAVE	0x17
+ #define GROUP_ALL_HOSTS 0xe0000001 /* 224.0.0.1 Host byte order */
+ 
+ struct igmp {
+ 	uint8_t  type;
+ 	uint8_t  response_time;
+ 	uint16_t chksum;
+ 	in_addr group;
+ };
+ 
+ struct igmp_ip_t { /* Format of an igmp ip packet */
+ 	struct iphdr ip;
+ 	uint8_t router_alert[4]; /* Router alert option */
+ 	struct igmp igmp;
+ };
+ 
+ #endif	/* _IGMP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/in.h GRUB/netboot/in.h
*** GRUB_0.94/netboot/in.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/in.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,21 ----
+ #ifndef	_IN_H
+ #define	_IN_H
+ 
+ #include "types.h"
+ 
+ #define IP		0x0800
+ #define ARP		0x0806
+ #define	RARP		0x8035
+ 
+ #define IP_ICMP		1
+ #define IP_IGMP		2
+ #define IP_UDP		17
+ 
+ /* Same after going through htonl */
+ #define IP_BROADCAST	0xFFFFFFFF
+ 
+ typedef struct {
+ 	uint32_t	s_addr;
+ } in_addr;
+ 
+ #endif	/* _IN_H */
diff -rc2P -x CVS GRUB_0.94/netboot/io.h GRUB/netboot/io.h
*** GRUB_0.94/netboot/io.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/io.h	2003-11-03 05:55:18.000000000 +0800
***************
*** 0 ****
--- 1,246 ----
+ #ifndef	IO_H
+ #define IO_H
+ 
+ 
+ /* Amount of relocation etherboot is experiencing */
+ extern unsigned long virt_offset;
+ 
+ /* Don't require identity mapped physical memory,
+  * osloader.c is the only valid user at the moment.
+  */
+ static inline unsigned long virt_to_phys(volatile const void *virt_addr)
+ {
+ 	return ((unsigned long)virt_addr) + virt_offset;
+ }
+ 
+ static inline void *phys_to_virt(unsigned long phys_addr)
+ {
+ 	return (void *)(phys_addr - virt_offset);
+ }
+ 
+ /* virt_to_bus converts an addresss inside of etherboot [_start, _end]
+  * into a memory access cards can use.
+  */
+ #define virt_to_bus virt_to_phys
+ 
+ 
+ /* bus_to_virt reverses virt_to_bus, the address must be output
+  * from virt_to_bus to be valid.  This function does not work on
+  * all bus addresses.
+  */
+ #define bus_to_virt phys_to_virt
+ 
+ /* ioremap converts a random 32bit bus address into something
+  * etherboot can access.
+  */
+ static inline void *ioremap(unsigned long bus_addr, unsigned long length __unused)
+ {
+ 	return bus_to_virt(bus_addr);
+ }
+ 
+ /* iounmap cleans up anything ioremap had to setup */
+ static inline void iounmap(void *virt_addr __unused)
+ {
+ 	return;
+ }
+ 
+ /*
+  * This file contains the definitions for the x86 IO instructions
+  * inb/inw/inl/outb/outw/outl and the "string versions" of the same
+  * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
+  * versions of the single-IO instructions (inb_p/inw_p/..).
+  *
+  * This file is not meant to be obfuscating: it's just complicated
+  * to (a) handle it all in a way that makes gcc able to optimize it
+  * as well as possible and (b) trying to avoid writing the same thing
+  * over and over again with slight variations and possibly making a
+  * mistake somewhere.
+  */
+ 
+ /*
+  * Thanks to James van Artsdalen for a better timing-fix than
+  * the two short jumps: using outb's to a nonexistent port seems
+  * to guarantee better timings even on fast machines.
+  *
+  * On the other hand, I'd like to be sure of a non-existent port:
+  * I feel a bit unsafe about using 0x80 (should be safe, though)
+  *
+  *		Linus
+  */
+ 
+ #ifdef	SLOW_IO_BY_JUMPING
+ #define __SLOW_DOWN_IO __asm__ __volatile__("jmp 1f\n1:\tjmp 1f\n1:")
+ #else
+ #define __SLOW_DOWN_IO __asm__ __volatile__("outb %al,$0x80")
+ #endif
+ 
+ #ifdef	REALLY_SLOW_IO
+ #define SLOW_DOWN_IO { __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; }
+ #else
+ #define SLOW_DOWN_IO __SLOW_DOWN_IO
+ #endif
+ 
+ /*
+  * readX/writeX() are used to access memory mapped devices. On some
+  * architectures the memory mapped IO stuff needs to be accessed
+  * differently. On the x86 architecture, we just read/write the
+  * memory location directly.
+  */
+ #define readb(addr) (*(volatile unsigned char *) (addr))
+ #define readw(addr) (*(volatile unsigned short *) (addr))
+ #define readl(addr) (*(volatile unsigned int *) (addr))
+ 
+ #define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
+ #define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
+ #define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
+ 
+ #define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+ #define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+ 
+ /*
+  * Force strict CPU ordering.
+  * And yes, this is required on UP too when we're talking
+  * to devices.
+  *
+  * For now, "wmb()" doesn't actually do anything, as all
+  * Intel CPU's follow what Intel calls a *Processor Order*,
+  * in which all writes are seen in the program order even
+  * outside the CPU.
+  *
+  * I expect future Intel CPU's to have a weaker ordering,
+  * but I'd also expect them to finally get their act together
+  * and add some real memory barriers if so.
+  *
+  * Some non intel clones support out of order store. wmb() ceases to be a
+  * nop for these.
+  */
+  
+ #define mb() 	__asm__ __volatile__ ("lock; addl $0,0(%%esp)": : :"memory")
+ #define rmb()	mb()
+ #define wmb()	mb();
+ 
+ 
+ /*
+  * Talk about misusing macros..
+  */
+ 
+ #define __OUT1(s,x) \
+ extern void __out##s(unsigned x value, unsigned short port); \
+ extern inline void __out##s(unsigned x value, unsigned short port) {
+ 
+ #define __OUT2(s,s1,s2) \
+ __asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
+ 
+ #define __OUT(s,s1,x) \
+ __OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); } \
+ __OUT1(s##c,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); } \
+ __OUT1(s##_p,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); SLOW_DOWN_IO; } \
+ __OUT1(s##c_p,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); SLOW_DOWN_IO; }
+ 
+ #define __IN1(s,x) \
+ extern unsigned x __in##s(unsigned short port); \
+ extern inline unsigned x __in##s(unsigned short port) { unsigned x _v;
+ 
+ #define __IN2(s,s1,s2) \
+ __asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
+ 
+ #define __IN(s,s1,x,i...) \
+ __IN1(s,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); return _v; } \
+ __IN1(s##c,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); return _v; } \
+ __IN1(s##_p,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); SLOW_DOWN_IO; return _v; } \
+ __IN1(s##c_p,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); SLOW_DOWN_IO; return _v; }
+ 
+ #define __INS(s) \
+ extern void ins##s(unsigned short port, void * addr, unsigned long count); \
+ extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+ { __asm__ __volatile__ ("cld ; rep ; ins" #s \
+ : "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+ 
+ #define __OUTS(s) \
+ extern void outs##s(unsigned short port, const void * addr, unsigned long  count); \
+ extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+ { __asm__ __volatile__ ("cld ; rep ; outs" #s \
+ : "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+ 
+ __IN(b,"", char)
+ __IN(w,"",short)
+ __IN(l,"", long)
+ 
+ __OUT(b,"b",char)
+ __OUT(w,"w",short)
+ __OUT(l,,int)
+ 
+ __INS(b)
+ __INS(w)
+ __INS(l)
+ 
+ __OUTS(b)
+ __OUTS(w)
+ __OUTS(l)
+ 
+ /*
+  * Note that due to the way __builtin_constant_p() works, you
+  *  - can't use it inside a inline function (it will never be true)
+  *  - you don't have to worry about side effects within the __builtin..
+  */
+ #define outb(val,port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__outbc((val),(port)) : \
+ 	__outb((val),(port)))
+ 
+ #define inb(port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__inbc(port) : \
+ 	__inb(port))
+ 
+ #define outb_p(val,port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__outbc_p((val),(port)) : \
+ 	__outb_p((val),(port)))
+ 
+ #define inb_p(port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__inbc_p(port) : \
+ 	__inb_p(port))
+ 
+ #define outw(val,port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__outwc((val),(port)) : \
+ 	__outw((val),(port)))
+ 
+ #define inw(port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__inwc(port) : \
+ 	__inw(port))
+ 
+ #define outw_p(val,port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__outwc_p((val),(port)) : \
+ 	__outw_p((val),(port)))
+ 
+ #define inw_p(port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__inwc_p(port) : \
+ 	__inw_p(port))
+ 
+ #define outl(val,port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__outlc((val),(port)) : \
+ 	__outl((val),(port)))
+ 
+ #define inl(port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__inlc(port) : \
+ 	__inl(port))
+ 
+ #define outl_p(val,port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__outlc_p((val),(port)) : \
+ 	__outl_p((val),(port)))
+ 
+ #define inl_p(port) \
+ ((__builtin_constant_p((port)) && (port) < 256) ? \
+ 	__inlc_p(port) : \
+ 	__inl_p(port))
+ 
+ #endif /* ETHERBOOT_IO_H */
diff -rc2P -x CVS GRUB_0.94/netboot/ip.h GRUB/netboot/ip.h
*** GRUB_0.94/netboot/ip.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/ip.h	2003-11-07 22:35:16.000000000 +0800
***************
*** 0 ****
--- 1,36 ----
+ #ifndef	_IP_H
+ #define	_IP_H
+ 
+ /* We need 'uint16_t' */
+ #include "types.h"
+ /* We need 'in_addr' */
+ #include "in.h"
+ 
+ struct iphdr {
+ 	uint8_t  verhdrlen;
+ 	uint8_t  service;
+ 	uint16_t len;
+ 	uint16_t ident;
+ 	uint16_t frags;
+ 	uint8_t  ttl;
+ 	uint8_t  protocol;
+ 	uint16_t chksum;
+ 	in_addr src;
+ 	in_addr dest;
+ };
+ 
+ extern void build_ip_hdr(unsigned long __destip, int __ttl, int __protocol, 
+ 			 int __option_len, int __len, const void * __buf);
+ 
+ extern int ip_transmit(int __len, const void * __buf);
+ 
+ extern uint16_t ipchksum(const void * __data, unsigned long __length);
+ 
+ extern uint16_t add_ipchksums(unsigned long __offset, uint16_t __sum, 
+ 			      uint16_t __new);
+ 
+ 
+ 
+ 
+ 
+ #endif	/* _IP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/isa.h GRUB/netboot/isa.h
*** GRUB_0.94/netboot/isa.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/isa.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,27 ----
+ #if !defined(ISA_H) && defined(CONFIG_ISA)
+ #define ISA_H
+ 
+ struct dev;
+ 
+ #define ISAPNP_VENDOR(a,b,c)	(((((a)-'A'+1)&0x3f)<<2)|\
+ 				((((b)-'A'+1)&0x18)>>3)|((((b)-'A'+1)&7)<<13)|\
+ 				((((c)-'A'+1)&0x1f)<<8))
+ 
+ #define	GENERIC_ISAPNP_VENDOR	ISAPNP_VENDOR('P','N','P')
+ 
+ struct isa_driver
+ {
+ 	int type;
+ 	const char *name;
+ 	int (*probe)(struct dev *, unsigned short *);
+ 	unsigned short *ioaddrs;
+ };
+ 
+ #define __isa_driver	__attribute__ ((unused,__section__(".drivers.isa")))
+ extern const struct isa_driver isa_drivers[];
+ extern const struct isa_driver isa_drivers_end[];
+ 
+ #define ISA_ROM(IMAGE, DESCRIPTION)
+ 
+ #endif /* ISA_H */
+ 
Only in GRUB_0.94/netboot: lance.c
diff -rc2P -x CVS GRUB_0.94/netboot/latch.h GRUB/netboot/latch.h
*** GRUB_0.94/netboot/latch.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/latch.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,10 ----
+ #ifndef LATCH_H
+ #define LATCH_H
+ 
+ #define	TICKS_PER_SEC		18
+ 
+ /* For different calibrators of the TSC move the declaration of
+  * sleep_latch and the definitions of it's length here...
+  */
+ 
+ #endif /* LATCH_H */
Only in GRUB_0.94/netboot: linux-asm-io.h
Only in GRUB_0.94/netboot: linux-asm-string.h
diff -rc2P -x CVS GRUB_0.94/netboot/little_bswap.h GRUB/netboot/little_bswap.h
*** GRUB_0.94/netboot/little_bswap.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/little_bswap.h	2003-11-04 05:23:11.000000000 +0800
***************
*** 0 ****
--- 1,17 ----
+ #ifndef ETHERBOOT_LITTLE_BSWAP_H
+ #define ETHERBOOT_LITTLE_BSWAP_H
+ 
+ #define ntohl(x)	__bswap_32(x)
+ #define htonl(x) 	__bswap_32(x)
+ #define ntohs(x) 	__bswap_16(x)
+ #define htons(x) 	__bswap_16(x)
+ #define cpu_to_le32(x)	(x)
+ #define cpu_to_le16(x)	(x)
+ #define cpu_to_be32(x)	__bswap_32(x)
+ #define cpu_to_be16(x)	__bswap_16(x)
+ #define le32_to_cpu(x)	(x)
+ #define le16_to_cpu(x)	(x)
+ #define be32_to_cpu(x)	__bswap_32(x)
+ #define be16_to_cpu(x)	__bswap_16(x)
+ 
+ #endif /* ETHERBOOT_LITTLE_BSWAP_H */
Only in GRUB_0.94/netboot: main.c
diff -rc2P -x CVS GRUB_0.94/netboot/Makefile.am GRUB/netboot/Makefile.am
*** GRUB_0.94/netboot/Makefile.am	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/Makefile.am	2003-11-21 11:25:14.000000000 +0800
***************
*** 11,23 ****
  noinst_LIBRARIES = $(LIBDRIVERS)
  
! libdrivers_a_SOURCES = cards.h config.c etherboot.h \
! 	fsys_tftp.c linux-asm-io.h linux-asm-string.h \
! 	main.c misc.c nic.h osdep.h pci.c pci.h timer.c timer.h
! EXTRA_libdrivers_a_SOURCES = 3c509.c 3c509.h 3c595.c 3c595.h 3c90x.c \
! 	cs89x0.c cs89x0.h davicom.c depca.c eepro.c eepro100.c \
! 	epic100.c epic100.h fa311.c i82586.c lance.c natsemi.c \
! 	ni5010.c ns8390.c ns8390.h otulip.c otulip.h rtl8139.c \
! 	sis900.c sis900.h sk_g16.c sk_g16.h smc9000.c smc9000.h \
! 	tiara.c tlan.c tulip.c via-rhine.c w89c840.c
  libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	-DFSYS_TFTP=1 $(NET_CFLAGS) $(NET_EXTRAFLAGS)
--- 11,26 ----
  noinst_LIBRARIES = $(LIBDRIVERS)
  
! libdrivers_a_SOURCES = big_bswap.h bootp.h byteswap.h config.c cpu.h \
! 	dev.h elf.h endian.h etherboot.h fsys_tftp.c grub.h \
! 	i386_byteswap.h i386_elf.h i386_endian.h i386_timer.c \
! 	if_arp.h if_ether.h igmp.h in.h io.h ip.h isa.h latch.h \
! 	little_bswap.h misc.c nic.c nic.h osdep.h pci.c pci.h \
! 	pci_ids.h pci_io.c stdint.h tftp.h timer.c timer.h \
! 	types.h udp.h
! EXTRA_libdrivers_a_SOURCES = 3c595.c 3c595.h 3c90x.c davicom.c \
! 	e1000.c e1000_hw.h eepro100.c epic100.c epic100.h natsemi.c \
! 	ns8390.c ns8390.h pcnet32.c rtl8139.c sis900.c sis900.h \
! 	sundance.c tg3.c tg3.h tlan.c tlan.h tulip.c via-rhine.c \
! 	w89c840.c
  libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	-DFSYS_TFTP=1 $(NET_CFLAGS) $(NET_EXTRAFLAGS)
***************
*** 26,30 ****
  libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
  
! EXTRA_DIST = README.netboot 3c90x.txt cs89x0.txt sis900.txt tulip.txt
  
  # These below are several special rules for the device drivers.
--- 29,33 ----
  libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
  
! EXTRA_DIST = README.netboot 3c90x.txt sis900.txt tulip.txt skel.c
  
  # These below are several special rules for the device drivers.
***************
*** 32,57 ****
  
  # What objects are derived from a driver?
! 3c509_drivers = 3c509.o 3c529.o
  3c595_drivers = 3c595.o
  3c90x_drivers = 3c90x.o
! cs89x0_drivers = cs89x0.o
  davicom_drivers = davicom.o
! depca_drivers = depca.o
! eepro_drivers = eepro.o
  eepro100_drivers = eepro100.o
  epic100_drivers = epic100.o
  #fa311_drivers = fa311.o
! i82586_drivers = 3c507.o exos205.o ni5210.o
! lance_drivers = lance.o ne2100.o ni6510.o
  natsemi_drivers = natsemi.o
! ni5010_drivers = ni5010.o
  ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
! otulip_drivers = otulip.o
  rtl8139_drivers = rtl8139.o
  sis900_drivers = sis900.o
! sk_g16_drivers = sk_g16.o
! smc9000_drivers = smc9000.o
! tiara_drivers = tiara.o
! #tlan_drivers = tlan.o
  tulip_drivers = tulip.o
  via_rhine_drivers = via_rhine.o
--- 35,64 ----
  
  # What objects are derived from a driver?
! #3c509_drivers = 3c509.o 3c529.o
  3c595_drivers = 3c595.o
  3c90x_drivers = 3c90x.o
! #cs89x0_drivers = cs89x0.o
  davicom_drivers = davicom.o
! #depca_drivers = depca.o
! #eepro_drivers = eepro.o
! e1000_drivers = e1000.o
  eepro100_drivers = eepro100.o
  epic100_drivers = epic100.o
  #fa311_drivers = fa311.o
! #i82586_drivers = 3c507.o exos205.o ni5210.o
! #lance_drivers = lance.o ne2100.o ni6510.o
  natsemi_drivers = natsemi.o
! #ni5010_drivers = ni5010.o
  ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
! #otulip_drivers = otulip.o
! pcnet32_drivers = pcnet32.o
  rtl8139_drivers = rtl8139.o
  sis900_drivers = sis900.o
! #sk_g16_drivers = sk_g16.o
! sundance_driver = sundance.o
! #smc9000_drivers = smc9000.o
! tg3_drivers = tg3.o
! #tiara_drivers = tiara.o
! tlan_drivers = tlan.o
  tulip_drivers = tulip.o
  via_rhine_drivers = via_rhine.o
***************
*** 59,66 ****
  
  # Is it really necessary to specify dependecies explicitly?
! $(3c509_drivers): 3c509.c 3c509.h
! $(3c509_drivers): %.o: 3c509.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(3c595_drivers): 3c595.c 3c595.h
--- 66,73 ----
  
  # Is it really necessary to specify dependecies explicitly?
! #$(3c509_drivers): 3c509.c 3c509.h
! #$(3c509_drivers): %.o: 3c509.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(3c595_drivers): 3c595.c 3c595.h
***************
*** 74,81 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(cs89x0_drivers): cs89x0.c cs89x0.h
! $(cs89x0_drivers): %.o: cs89x0.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(davicom_drivers): davicom.c
--- 81,88 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(cs89x0_drivers): cs89x0.c cs89x0.h
! #$(cs89x0_drivers): %.o: cs89x0.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(davicom_drivers): davicom.c
***************
*** 84,94 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(depca_drivers): depca.c
! $(depca_drivers): %.o: depca.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(eepro_drivers): eepro.c
! $(eepro_drivers): %.o: eepro.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
--- 91,106 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(depca_drivers): depca.c
! #$(depca_drivers): %.o: depca.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
! 
! #$(eepro_drivers): eepro.c
! #$(eepro_drivers): %.o: eepro.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(e1000_drivers): e1000.c e1000_hw.h
! $(e1000_drivers): %.o: e1000.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
***************
*** 109,121 ****
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(i82586_drivers): i82586.c
! $(i82586_drivers): %.o: i82586.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(lance_drivers): lance.c
! $(lance_drivers): %.o: lance.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(natsemi_drivers): natsemi.c
--- 121,133 ----
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(i82586_drivers): i82586.c
! #$(i82586_drivers): %.o: i82586.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(lance_drivers): lance.c
! #$(lance_drivers): %.o: lance.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(natsemi_drivers): natsemi.c
***************
*** 124,131 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(ni5010_drivers): ni5010.c
! $(ni5010_drivers): %.o: ni5010.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(ns8390_drivers): ns8390.c ns8390.h
--- 136,143 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(ni5010_drivers): ni5010.c
! #$(ni5010_drivers): %.o: ni5010.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(ns8390_drivers): ns8390.c ns8390.h
***************
*** 134,139 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(otulip_drivers): otulip.c otulip.h
! $(otulip_drivers): %.o: otulip.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
--- 146,156 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(otulip_drivers): otulip.c otulip.h
! #$(otulip_drivers): %.o: otulip.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
! 
! $(pcnet32_drivers): pcnet32.c
! $(pcnet32_drivers): %.o: pcnet32.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
***************
*** 144,172 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sis900_drivers): sis900.c
! $(sis900_drivers): %.o: sis900.c sis900.h
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sk_g16_drivers): sk_g16.c sk_g16.h
! $(sk_g16_drivers): %.o: sk_g16.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(smc9000_drivers): smc9000.c smc9000.h
! $(smc9000_drivers): %.o: smc9000.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(tiara_drivers): tiara.c
! $(tiara_drivers): %.o: tiara.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(tlan_drivers): tlan.c
! #$(tlan_drivers): %.o: tlan.c
  #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(tulip_drivers): tulip.c
  $(tulip_drivers): %.o: tulip.c
--- 161,199 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sis900_drivers): sis900.c sis900.h
! $(sis900_drivers): %.o: sis900.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(sk_g16_drivers): sk_g16.c sk_g16.h
! #$(sk_g16_drivers): %.o: sk_g16.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
! 
! #$(smc9000_drivers): smc9000.c smc9000.h
! #$(smc9000_drivers): %.o: smc9000.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sundance_drivers): sundance.c
! $(sundance_drivers): %.o: sundance.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(tg3_drivers): tg3.c tg3.h
! $(tg3_drivers): %.o: tg3.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(tiara_drivers): tiara.c
! #$(tiara_drivers): %.o: tiara.c
  #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
+ $(tlan_drivers): tlan.c tlan.h
+ $(tlan_drivers): %.o: tlan.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
  $(tulip_drivers): tulip.c
  $(tulip_drivers): %.o: tulip.c
***************
*** 185,218 ****
  
  # Per-object flags.
! 3c509_o_CFLAGS = -DINCLUDE_3C509=1
! 3c529_o_CFLAGS = -DINCLUDE_3C529=1
  3c595_o_CFLAGS = -DINCLUDE_3C595=1
  3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
! cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
  davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
! depca_o_CFLAGS = -DINCLUDE_DEPCA=1
! eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
  eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
  epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
  #fa311_o_CFLAGS = -DINCLUDE_FA311=1
! 3c507_o_CFLAGS = -DINCLUDE_3C507=1
! exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
! ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
! lance_o_CFLAGS = -DINCLUDE_LANCE=1
! ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
! ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
  natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
! ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
! 3c503_o_CFLAGS = -DINCLUDE_3C503=1
! ne_o_CFLAGS = -DINCLUDE_NE=1
  ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
! wd_o_CFLAGS = -DINCLUDE_WD=1
! otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
  rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
  sis900_o_CFLAGS = -DINCLUDE_SIS900=1
! sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
! smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
! tiara_o_CFLAGS = -DINCLUDE_TIARA=1
! #tlan_o_CFLAGS = -DINCLUDE_TLAN=1
  tulip_o_CFLAGS = -DINCLUDE_TULIP=1
  via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
--- 212,249 ----
  
  # Per-object flags.
! #3c509_o_CFLAGS = -DINCLUDE_3C509=1
! #3c529_o_CFLAGS = -DINCLUDE_3C529=1
  3c595_o_CFLAGS = -DINCLUDE_3C595=1
  3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
! #cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
  davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
! #depca_o_CFLAGS = -DINCLUDE_DEPCA=1
! #eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
! e1000_o_CFLAGS = -DINCLUDE_E1000=1
  eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
  epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
  #fa311_o_CFLAGS = -DINCLUDE_FA311=1
! #3c507_o_CFLAGS = -DINCLUDE_3C507=1
! #exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
! #ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
! #lance_o_CFLAGS = -DINCLUDE_LANCE=1
! #ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
! #ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
  natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
! #ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
! #3c503_o_CFLAGS = -DINCLUDE_3C503=1
! #ne_o_CFLAGS = -DINCLUDE_NE=1
  ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
! #wd_o_CFLAGS = -DINCLUDE_WD=1
! #otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
! pcnet32_o_CFLAGS = -DINCLUDE_PCNET32=1
  rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
  sis900_o_CFLAGS = -DINCLUDE_SIS900=1
! #sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
! #smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
! sundance_o_CFLAGS = -DINCLUDE_SUNDANCE=1
! #tiara_o_CFLAGS = -DINCLUDE_TIARA=1
! tg3_o_CFLAGS = -DINCLUDE_TG3=1
! tlan_o_CFLAGS = -DINCLUDE_TLAN=1
  tulip_o_CFLAGS = -DINCLUDE_TULIP=1
  via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
diff -rc2P -x CVS GRUB_0.94/netboot/Makefile.am~ GRUB/netboot/Makefile.am~
*** GRUB_0.94/netboot/Makefile.am~	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/Makefile.am~	2003-11-20 11:44:56.000000000 +0800
***************
*** 0 ****
--- 1,222 ----
+ # For <shared.h> and <stage1.h>.
+ INCLUDES = -I$(top_srcdir)/stage2 -I$(top_srcdir)/stage1
+ 
+ # Don't build the netboot support by default.
+ if NETBOOT_SUPPORT
+ LIBDRIVERS = libdrivers.a
+ else
+ LIBDRIVERS =
+ endif
+ 
+ noinst_LIBRARIES = $(LIBDRIVERS)
+ 
+ libdrivers_a_SOURCES = big_bswap.h bootp.h byteswap.h config.c cpu.h \
+ 	dev.h elf.h endian.h etherboot.h fsys_tftp.c grub.h \
+ 	i386_byteswap.h i386_elf.h i386_endian.h i386_timer.c \
+ 	if_arp.h if_ether.h igmp.h in.h io.h ip.h isa.h latch.h \
+ 	little_bswap.h misc.c nfs.h nic.c nic.h osdep.h pci.c pci.h \
+ 	pci_ids.h pci_io.c rpc.c rpc.h stdint.h tftp.h timer.c timer.h \
+ 	types.h udp.h
+ EXTRA_libdrivers_a_SOURCES = 3c595.c 3c595.h 3c90x.c davicom.c \
+ 	e1000.c e1000_hw.h eepro100.c epic100.c epic100.h natsemi.c \
+ 	ns8390.c ns8390.h pcnet32.c rtl8139.c sis900.c sis900.h \
+ 	sundance.c tg3.c tg3.h tlan.c tlan.h tulip.c via-rhine.c \
+ 	w89c840.c
+ libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	-DFSYS_TFTP=1 $(NET_CFLAGS) $(NET_EXTRAFLAGS)
+ # Filled by configure.
+ libdrivers_a_LIBADD = @NETBOOT_DRIVERS@
+ libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
+ 
+ EXTRA_DIST = README.netboot 3c90x.txt sis900.txt tulip.txt skel.c
+ 
+ # These below are several special rules for the device drivers.
+ # We cannot use a simple rule for them...
+ 
+ # What objects are derived from a driver?
+ 3c509_drivers = 3c509.o 3c529.o
+ 3c595_drivers = 3c595.o
+ 3c90x_drivers = 3c90x.o
+ cs89x0_drivers = cs89x0.o
+ davicom_drivers = davicom.o
+ depca_drivers = depca.o
+ eepro_drivers = eepro.o
+ eepro100_drivers = eepro100.o
+ epic100_drivers = epic100.o
+ #fa311_drivers = fa311.o
+ i82586_drivers = 3c507.o exos205.o ni5210.o
+ lance_drivers = lance.o ne2100.o ni6510.o
+ natsemi_drivers = natsemi.o
+ ni5010_drivers = ni5010.o
+ ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
+ otulip_drivers = otulip.o
+ rtl8139_drivers = rtl8139.o
+ sis900_drivers = sis900.o
+ sk_g16_drivers = sk_g16.o
+ smc9000_drivers = smc9000.o
+ tiara_drivers = tiara.o
+ #tlan_drivers = tlan.o
+ tulip_drivers = tulip.o
+ via_rhine_drivers = via_rhine.o
+ w89c840_drivers = w89c840.o
+ 
+ # Is it really necessary to specify dependecies explicitly?
+ $(3c509_drivers): 3c509.c 3c509.h
+ $(3c509_drivers): %.o: 3c509.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(3c595_drivers): 3c595.c 3c595.h
+ $(3c595_drivers): %.o: 3c595.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(3c90x_drivers): 3c90x.c
+ $(3c90x_drivers): %.o: 3c90x.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(cs89x0_drivers): cs89x0.c cs89x0.h
+ $(cs89x0_drivers): %.o: cs89x0.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(davicom_drivers): davicom.c
+ $(davicom_drivers): %.o: davicom.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(depca_drivers): depca.c
+ $(depca_drivers): %.o: depca.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(eepro_drivers): eepro.c
+ $(eepro_drivers): %.o: eepro.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(eepro100_drivers): eepro100.c
+ $(eepro100_drivers): %.o: eepro100.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(epic100_drivers): epic100.c epic100.h
+ $(epic100_drivers): %.o: epic100.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ #$(fa311_drivers): fa311.c
+ #$(fa311_drivers): %.o: fa311.c
+ #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(i82586_drivers): i82586.c
+ $(i82586_drivers): %.o: i82586.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(lance_drivers): lance.c
+ $(lance_drivers): %.o: lance.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(natsemi_drivers): natsemi.c
+ $(natsemi_drivers): %.o: natsemi.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(ni5010_drivers): ni5010.c
+ $(ni5010_drivers): %.o: ni5010.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(ns8390_drivers): ns8390.c ns8390.h
+ $(ns8390_drivers): %.o: ns8390.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(otulip_drivers): otulip.c otulip.h
+ $(otulip_drivers): %.o: otulip.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(rtl8139_drivers): rtl8139.c
+ $(rtl8139_drivers): %.o: rtl8139.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(sis900_drivers): sis900.c
+ $(sis900_drivers): %.o: sis900.c sis900.h
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(sk_g16_drivers): sk_g16.c sk_g16.h
+ $(sk_g16_drivers): %.o: sk_g16.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(smc9000_drivers): smc9000.c smc9000.h
+ $(smc9000_drivers): %.o: smc9000.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(tiara_drivers): tiara.c
+ $(tiara_drivers): %.o: tiara.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ #$(tlan_drivers): tlan.c
+ #$(tlan_drivers): %.o: tlan.c
+ #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(tulip_drivers): tulip.c
+ $(tulip_drivers): %.o: tulip.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(via_rhine_drivers): via-rhine.c
+ $(via_rhine_drivers): %.o: via-rhine.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ $(w89c840_drivers): w89c840.c
+ $(w89c840_drivers): %.o: w89c840.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
+ # Per-object flags.
+ 3c509_o_CFLAGS = -DINCLUDE_3C509=1
+ 3c529_o_CFLAGS = -DINCLUDE_3C529=1
+ 3c595_o_CFLAGS = -DINCLUDE_3C595=1
+ 3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
+ cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
+ davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
+ depca_o_CFLAGS = -DINCLUDE_DEPCA=1
+ eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+ eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
+ epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
+ #fa311_o_CFLAGS = -DINCLUDE_FA311=1
+ 3c507_o_CFLAGS = -DINCLUDE_3C507=1
+ exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
+ ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
+ lance_o_CFLAGS = -DINCLUDE_LANCE=1
+ ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
+ ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
+ natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
+ ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
+ 3c503_o_CFLAGS = -DINCLUDE_3C503=1
+ ne_o_CFLAGS = -DINCLUDE_NE=1
+ ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
+ wd_o_CFLAGS = -DINCLUDE_WD=1
+ otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+ rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
+ sis900_o_CFLAGS = -DINCLUDE_SIS900=1
+ sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
+ smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
+ tiara_o_CFLAGS = -DINCLUDE_TIARA=1
+ #tlan_o_CFLAGS = -DINCLUDE_TLAN=1
+ tulip_o_CFLAGS = -DINCLUDE_TULIP=1
+ via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
+ w89c840_o_CFLAGS = -DINCLUDE_W89C840=1
diff -rc2P -x CVS GRUB_0.94/netboot/Makefile.in GRUB/netboot/Makefile.in
*** GRUB_0.94/netboot/Makefile.in	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/Makefile.in	2003-11-21 11:29:41.000000000 +0800
***************
*** 152,165 ****
  noinst_LIBRARIES = $(LIBDRIVERS)
  
! libdrivers_a_SOURCES = cards.h config.c etherboot.h \
! 	fsys_tftp.c linux-asm-io.h linux-asm-string.h \
! 	main.c misc.c nic.h osdep.h pci.c pci.h timer.c timer.h
! 
! EXTRA_libdrivers_a_SOURCES = 3c509.c 3c509.h 3c595.c 3c595.h 3c90x.c \
! 	cs89x0.c cs89x0.h davicom.c depca.c eepro.c eepro100.c \
! 	epic100.c epic100.h fa311.c i82586.c lance.c natsemi.c \
! 	ni5010.c ns8390.c ns8390.h otulip.c otulip.h rtl8139.c \
! 	sis900.c sis900.h sk_g16.c sk_g16.h smc9000.c smc9000.h \
! 	tiara.c tlan.c tulip.c via-rhine.c w89c840.c
  
  libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
--- 152,168 ----
  noinst_LIBRARIES = $(LIBDRIVERS)
  
! libdrivers_a_SOURCES = big_bswap.h bootp.h byteswap.h config.c cpu.h \
! 	dev.h elf.h endian.h etherboot.h fsys_tftp.c grub.h \
! 	i386_byteswap.h i386_elf.h i386_endian.h i386_timer.c \
! 	if_arp.h if_ether.h igmp.h in.h io.h ip.h isa.h latch.h \
! 	little_bswap.h misc.c nic.c nic.h osdep.h pci.c pci.h \
! 	pci_ids.h pci_io.c stdint.h tftp.h timer.c timer.h \
! 	types.h udp.h
! 
! EXTRA_libdrivers_a_SOURCES = 3c595.c 3c595.h 3c90x.c davicom.c \
! 	e1000.c e1000_hw.h eepro100.c epic100.c epic100.h natsemi.c \
! 	ns8390.c ns8390.h pcnet32.c rtl8139.c sis900.c sis900.h \
! 	sundance.c tg3.c tg3.h tlan.c tlan.h tulip.c via-rhine.c \
! 	w89c840.c
  
  libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
***************
*** 170,174 ****
  libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
  
! EXTRA_DIST = README.netboot 3c90x.txt cs89x0.txt sis900.txt tulip.txt
  
  # These below are several special rules for the device drivers.
--- 173,177 ----
  libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
  
! EXTRA_DIST = README.netboot 3c90x.txt sis900.txt tulip.txt skel.c
  
  # These below are several special rules for the device drivers.
***************
*** 176,201 ****
  
  # What objects are derived from a driver?
! 3c509_drivers = 3c509.o 3c529.o
  3c595_drivers = 3c595.o
  3c90x_drivers = 3c90x.o
! cs89x0_drivers = cs89x0.o
  davicom_drivers = davicom.o
! depca_drivers = depca.o
! eepro_drivers = eepro.o
  eepro100_drivers = eepro100.o
  epic100_drivers = epic100.o
  #fa311_drivers = fa311.o
! i82586_drivers = 3c507.o exos205.o ni5210.o
! lance_drivers = lance.o ne2100.o ni6510.o
  natsemi_drivers = natsemi.o
! ni5010_drivers = ni5010.o
  ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
! otulip_drivers = otulip.o
  rtl8139_drivers = rtl8139.o
  sis900_drivers = sis900.o
! sk_g16_drivers = sk_g16.o
! smc9000_drivers = smc9000.o
! tiara_drivers = tiara.o
! #tlan_drivers = tlan.o
  tulip_drivers = tulip.o
  via_rhine_drivers = via_rhine.o
--- 179,208 ----
  
  # What objects are derived from a driver?
! #3c509_drivers = 3c509.o 3c529.o
  3c595_drivers = 3c595.o
  3c90x_drivers = 3c90x.o
! #cs89x0_drivers = cs89x0.o
  davicom_drivers = davicom.o
! #depca_drivers = depca.o
! #eepro_drivers = eepro.o
! e1000_drivers = e1000.o
  eepro100_drivers = eepro100.o
  epic100_drivers = epic100.o
  #fa311_drivers = fa311.o
! #i82586_drivers = 3c507.o exos205.o ni5210.o
! #lance_drivers = lance.o ne2100.o ni6510.o
  natsemi_drivers = natsemi.o
! #ni5010_drivers = ni5010.o
  ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
! #otulip_drivers = otulip.o
! pcnet32_drivers = pcnet32.o
  rtl8139_drivers = rtl8139.o
  sis900_drivers = sis900.o
! #sk_g16_drivers = sk_g16.o
! sundance_driver = sundance.o
! #smc9000_drivers = smc9000.o
! tg3_drivers = tg3.o
! #tiara_drivers = tiara.o
! tlan_drivers = tlan.o
  tulip_drivers = tulip.o
  via_rhine_drivers = via_rhine.o
***************
*** 203,236 ****
  
  # Per-object flags.
! 3c509_o_CFLAGS = -DINCLUDE_3C509=1
! 3c529_o_CFLAGS = -DINCLUDE_3C529=1
  3c595_o_CFLAGS = -DINCLUDE_3C595=1
  3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
! cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
  davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
! depca_o_CFLAGS = -DINCLUDE_DEPCA=1
! eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
  eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
  epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
  #fa311_o_CFLAGS = -DINCLUDE_FA311=1
! 3c507_o_CFLAGS = -DINCLUDE_3C507=1
! exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
! ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
! lance_o_CFLAGS = -DINCLUDE_LANCE=1
! ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
! ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
  natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
! ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
! 3c503_o_CFLAGS = -DINCLUDE_3C503=1
! ne_o_CFLAGS = -DINCLUDE_NE=1
  ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
! wd_o_CFLAGS = -DINCLUDE_WD=1
! otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
  rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
  sis900_o_CFLAGS = -DINCLUDE_SIS900=1
! sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
! smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
! tiara_o_CFLAGS = -DINCLUDE_TIARA=1
! #tlan_o_CFLAGS = -DINCLUDE_TLAN=1
  tulip_o_CFLAGS = -DINCLUDE_TULIP=1
  via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
--- 210,247 ----
  
  # Per-object flags.
! #3c509_o_CFLAGS = -DINCLUDE_3C509=1
! #3c529_o_CFLAGS = -DINCLUDE_3C529=1
  3c595_o_CFLAGS = -DINCLUDE_3C595=1
  3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
! #cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
  davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
! #depca_o_CFLAGS = -DINCLUDE_DEPCA=1
! #eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
! e1000_o_CFLAGS = -DINCLUDE_E1000=1
  eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
  epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
  #fa311_o_CFLAGS = -DINCLUDE_FA311=1
! #3c507_o_CFLAGS = -DINCLUDE_3C507=1
! #exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
! #ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
! #lance_o_CFLAGS = -DINCLUDE_LANCE=1
! #ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
! #ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
  natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
! #ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
! #3c503_o_CFLAGS = -DINCLUDE_3C503=1
! #ne_o_CFLAGS = -DINCLUDE_NE=1
  ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
! #wd_o_CFLAGS = -DINCLUDE_WD=1
! #otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
! pcnet32_o_CFLAGS = -DINCLUDE_PCNET32=1
  rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
  sis900_o_CFLAGS = -DINCLUDE_SIS900=1
! #sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
! #smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
! sundance_o_CFLAGS = -DINCLUDE_SUNDANCE=1
! #tiara_o_CFLAGS = -DINCLUDE_TIARA=1
! tg3_o_CFLAGS = -DINCLUDE_TG3=1
! tlan_o_CFLAGS = -DINCLUDE_TLAN=1
  tulip_o_CFLAGS = -DINCLUDE_TULIP=1
  via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
***************
*** 244,250 ****
  libdrivers_a_AR = $(AR) cru
  am_libdrivers_a_OBJECTS = libdrivers_a-config.$(OBJEXT) \
! 	libdrivers_a-fsys_tftp.$(OBJEXT) libdrivers_a-main.$(OBJEXT) \
! 	libdrivers_a-misc.$(OBJEXT) libdrivers_a-pci.$(OBJEXT) \
! 	libdrivers_a-timer.$(OBJEXT)
  libdrivers_a_OBJECTS = $(am_libdrivers_a_OBJECTS)
  
--- 255,262 ----
  libdrivers_a_AR = $(AR) cru
  am_libdrivers_a_OBJECTS = libdrivers_a-config.$(OBJEXT) \
! 	libdrivers_a-fsys_tftp.$(OBJEXT) \
! 	libdrivers_a-i386_timer.$(OBJEXT) libdrivers_a-misc.$(OBJEXT) \
! 	libdrivers_a-nic.$(OBJEXT) libdrivers_a-pci.$(OBJEXT) \
! 	libdrivers_a-pci_io.$(OBJEXT) libdrivers_a-timer.$(OBJEXT)
  libdrivers_a_OBJECTS = $(am_libdrivers_a_OBJECTS)
  
***************
*** 252,281 ****
  depcomp = $(SHELL) $(top_srcdir)/depcomp
  am__depfiles_maybe = depfiles
! @AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/libdrivers_a-3c509.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-3c595.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-3c90x.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-config.Po \
- @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-cs89x0.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-davicom.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-depca.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-eepro.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-eepro100.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-epic100.Po \
- @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-fa311.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-fsys_tftp.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-i82586.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-lance.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-main.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-misc.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-natsemi.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-ni5010.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-ns8390.Po \
- @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-otulip.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pci.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-rtl8139.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-sis900.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-sk_g16.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-smc9000.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tiara.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-timer.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tlan.Po \
--- 264,287 ----
  depcomp = $(SHELL) $(top_srcdir)/depcomp
  am__depfiles_maybe = depfiles
! @AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/libdrivers_a-3c595.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-3c90x.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-config.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-davicom.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-e1000.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-eepro100.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-epic100.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-fsys_tftp.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-i386_timer.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-misc.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-natsemi.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-nic.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-ns8390.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pci.Po \
+ @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pci_io.Po \
+ @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-pcnet32.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-rtl8139.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-sis900.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-sundance.Po \
! @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tg3.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-timer.Po \
  @AMDEP_TRUE@	./$(DEPDIR)/libdrivers_a-tlan.Po \
***************
*** 316,345 ****
  	-rm -f *.tab.c
  
- @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c509.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c595.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c90x.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-config.Po@am__quote@
- @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-cs89x0.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-davicom.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-depca.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-eepro.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-eepro100.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-epic100.Po@am__quote@
- @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-fa311.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-fsys_tftp.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-i82586.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-lance.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-main.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-misc.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-natsemi.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-ni5010.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-ns8390.Po@am__quote@
- @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-otulip.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pci.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-rtl8139.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-sis900.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-sk_g16.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-smc9000.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tiara.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-timer.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tlan.Po@am__quote@
--- 322,345 ----
  	-rm -f *.tab.c
  
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c595.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-3c90x.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-config.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-davicom.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-e1000.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-eepro100.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-epic100.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-fsys_tftp.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-i386_timer.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-misc.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-natsemi.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-nic.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-ns8390.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pci.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pci_io.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-pcnet32.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-rtl8139.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-sis900.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-sundance.Po@am__quote@
! @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tg3.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-timer.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libdrivers_a-tlan.Po@am__quote@
***************
*** 417,441 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fsys_tftp.obj `if test -f 'fsys_tftp.c'; then $(CYGPATH_W) 'fsys_tftp.c'; else $(CYGPATH_W) '$(srcdir)/fsys_tftp.c'; fi`
  
! libdrivers_a-main.o: main.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-main.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-main.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-main.Tpo" "$(DEPDIR)/libdrivers_a-main.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-main.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='libdrivers_a-main.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-main.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-main.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-main.o `test -f 'main.c' || echo '$(srcdir)/'`main.c
! 
! libdrivers_a-main.obj: main.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-main.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-main.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-main.Tpo" "$(DEPDIR)/libdrivers_a-main.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-main.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='main.c' object='libdrivers_a-main.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-main.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-main.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-main.obj `if test -f 'main.c'; then $(CYGPATH_W) 'main.c'; else $(CYGPATH_W) '$(srcdir)/main.c'; fi`
  
  libdrivers_a-misc.o: misc.c
--- 417,441 ----
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fsys_tftp.obj `if test -f 'fsys_tftp.c'; then $(CYGPATH_W) 'fsys_tftp.c'; else $(CYGPATH_W) '$(srcdir)/fsys_tftp.c'; fi`
  
! libdrivers_a-i386_timer.o: i386_timer.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i386_timer.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-i386_timer.o `test -f 'i386_timer.c' || echo '$(srcdir)/'`i386_timer.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" "$(DEPDIR)/libdrivers_a-i386_timer.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-i386_timer.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i386_timer.c' object='libdrivers_a-i386_timer.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-i386_timer.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-i386_timer.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i386_timer.o `test -f 'i386_timer.c' || echo '$(srcdir)/'`i386_timer.c
! 
! libdrivers_a-i386_timer.obj: i386_timer.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i386_timer.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-i386_timer.obj `if test -f 'i386_timer.c'; then $(CYGPATH_W) 'i386_timer.c'; else $(CYGPATH_W) '$(srcdir)/i386_timer.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-i386_timer.Tpo" "$(DEPDIR)/libdrivers_a-i386_timer.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-i386_timer.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i386_timer.c' object='libdrivers_a-i386_timer.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-i386_timer.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-i386_timer.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i386_timer.obj `if test -f 'i386_timer.c'; then $(CYGPATH_W) 'i386_timer.c'; else $(CYGPATH_W) '$(srcdir)/i386_timer.c'; fi`
  
  libdrivers_a-misc.o: misc.c
***************
*** 461,464 ****
--- 461,486 ----
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-misc.obj `if test -f 'misc.c'; then $(CYGPATH_W) 'misc.c'; else $(CYGPATH_W) '$(srcdir)/misc.c'; fi`
  
+ libdrivers_a-nic.o: nic.c
+ @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-nic.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-nic.Tpo" \
+ @am__fastdepCC_TRUE@	  -c -o libdrivers_a-nic.o `test -f 'nic.c' || echo '$(srcdir)/'`nic.c; \
+ @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-nic.Tpo" "$(DEPDIR)/libdrivers_a-nic.Po"; \
+ @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-nic.Tpo"; exit 1; \
+ @am__fastdepCC_TRUE@	fi
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='nic.c' object='libdrivers_a-nic.o' libtool=no @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-nic.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-nic.TPo' @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-nic.o `test -f 'nic.c' || echo '$(srcdir)/'`nic.c
+ 
+ libdrivers_a-nic.obj: nic.c
+ @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-nic.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-nic.Tpo" \
+ @am__fastdepCC_TRUE@	  -c -o libdrivers_a-nic.obj `if test -f 'nic.c'; then $(CYGPATH_W) 'nic.c'; else $(CYGPATH_W) '$(srcdir)/nic.c'; fi`; \
+ @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-nic.Tpo" "$(DEPDIR)/libdrivers_a-nic.Po"; \
+ @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-nic.Tpo"; exit 1; \
+ @am__fastdepCC_TRUE@	fi
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='nic.c' object='libdrivers_a-nic.obj' libtool=no @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-nic.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-nic.TPo' @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-nic.obj `if test -f 'nic.c'; then $(CYGPATH_W) 'nic.c'; else $(CYGPATH_W) '$(srcdir)/nic.c'; fi`
+ 
  libdrivers_a-pci.o: pci.c
  @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci.Tpo" \
***************
*** 483,486 ****
--- 505,530 ----
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci.obj `if test -f 'pci.c'; then $(CYGPATH_W) 'pci.c'; else $(CYGPATH_W) '$(srcdir)/pci.c'; fi`
  
+ libdrivers_a-pci_io.o: pci_io.c
+ @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci_io.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci_io.Tpo" \
+ @am__fastdepCC_TRUE@	  -c -o libdrivers_a-pci_io.o `test -f 'pci_io.c' || echo '$(srcdir)/'`pci_io.c; \
+ @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-pci_io.Tpo" "$(DEPDIR)/libdrivers_a-pci_io.Po"; \
+ @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-pci_io.Tpo"; exit 1; \
+ @am__fastdepCC_TRUE@	fi
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pci_io.c' object='libdrivers_a-pci_io.o' libtool=no @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pci_io.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pci_io.TPo' @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci_io.o `test -f 'pci_io.c' || echo '$(srcdir)/'`pci_io.c
+ 
+ libdrivers_a-pci_io.obj: pci_io.c
+ @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pci_io.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pci_io.Tpo" \
+ @am__fastdepCC_TRUE@	  -c -o libdrivers_a-pci_io.obj `if test -f 'pci_io.c'; then $(CYGPATH_W) 'pci_io.c'; else $(CYGPATH_W) '$(srcdir)/pci_io.c'; fi`; \
+ @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-pci_io.Tpo" "$(DEPDIR)/libdrivers_a-pci_io.Po"; \
+ @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-pci_io.Tpo"; exit 1; \
+ @am__fastdepCC_TRUE@	fi
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pci_io.c' object='libdrivers_a-pci_io.obj' libtool=no @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pci_io.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pci_io.TPo' @AMDEPBACKSLASH@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pci_io.obj `if test -f 'pci_io.c'; then $(CYGPATH_W) 'pci_io.c'; else $(CYGPATH_W) '$(srcdir)/pci_io.c'; fi`
+ 
  libdrivers_a-timer.o: timer.c
  @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-timer.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-timer.Tpo" \
***************
*** 505,530 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-timer.obj `if test -f 'timer.c'; then $(CYGPATH_W) 'timer.c'; else $(CYGPATH_W) '$(srcdir)/timer.c'; fi`
  
- libdrivers_a-3c509.o: 3c509.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c509.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c509.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-3c509.o `test -f '3c509.c' || echo '$(srcdir)/'`3c509.c; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-3c509.Tpo" "$(DEPDIR)/libdrivers_a-3c509.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-3c509.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c509.c' object='libdrivers_a-3c509.o' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-3c509.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-3c509.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c509.o `test -f '3c509.c' || echo '$(srcdir)/'`3c509.c
- 
- libdrivers_a-3c509.obj: 3c509.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c509.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c509.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-3c509.obj `if test -f '3c509.c'; then $(CYGPATH_W) '3c509.c'; else $(CYGPATH_W) '$(srcdir)/3c509.c'; fi`; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-3c509.Tpo" "$(DEPDIR)/libdrivers_a-3c509.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-3c509.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='3c509.c' object='libdrivers_a-3c509.obj' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-3c509.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-3c509.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c509.obj `if test -f '3c509.c'; then $(CYGPATH_W) '3c509.c'; else $(CYGPATH_W) '$(srcdir)/3c509.c'; fi`
- 
  libdrivers_a-3c595.o: 3c595.c
  @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-3c595.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-3c595.Tpo" \
--- 549,552 ----
***************
*** 571,596 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-3c90x.obj `if test -f '3c90x.c'; then $(CYGPATH_W) '3c90x.c'; else $(CYGPATH_W) '$(srcdir)/3c90x.c'; fi`
  
- libdrivers_a-cs89x0.o: cs89x0.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-cs89x0.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-cs89x0.o `test -f 'cs89x0.c' || echo '$(srcdir)/'`cs89x0.c; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" "$(DEPDIR)/libdrivers_a-cs89x0.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-cs89x0.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cs89x0.c' object='libdrivers_a-cs89x0.o' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-cs89x0.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-cs89x0.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-cs89x0.o `test -f 'cs89x0.c' || echo '$(srcdir)/'`cs89x0.c
- 
- libdrivers_a-cs89x0.obj: cs89x0.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-cs89x0.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-cs89x0.obj `if test -f 'cs89x0.c'; then $(CYGPATH_W) 'cs89x0.c'; else $(CYGPATH_W) '$(srcdir)/cs89x0.c'; fi`; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-cs89x0.Tpo" "$(DEPDIR)/libdrivers_a-cs89x0.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-cs89x0.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cs89x0.c' object='libdrivers_a-cs89x0.obj' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-cs89x0.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-cs89x0.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-cs89x0.obj `if test -f 'cs89x0.c'; then $(CYGPATH_W) 'cs89x0.c'; else $(CYGPATH_W) '$(srcdir)/cs89x0.c'; fi`
- 
  libdrivers_a-davicom.o: davicom.c
  @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-davicom.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-davicom.Tpo" \
--- 593,596 ----
***************
*** 615,661 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-davicom.obj `if test -f 'davicom.c'; then $(CYGPATH_W) 'davicom.c'; else $(CYGPATH_W) '$(srcdir)/davicom.c'; fi`
  
! libdrivers_a-depca.o: depca.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-depca.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-depca.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-depca.o `test -f 'depca.c' || echo '$(srcdir)/'`depca.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-depca.Tpo" "$(DEPDIR)/libdrivers_a-depca.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-depca.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='depca.c' object='libdrivers_a-depca.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-depca.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-depca.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-depca.o `test -f 'depca.c' || echo '$(srcdir)/'`depca.c
! 
! libdrivers_a-depca.obj: depca.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-depca.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-depca.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-depca.obj `if test -f 'depca.c'; then $(CYGPATH_W) 'depca.c'; else $(CYGPATH_W) '$(srcdir)/depca.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-depca.Tpo" "$(DEPDIR)/libdrivers_a-depca.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-depca.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='depca.c' object='libdrivers_a-depca.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-depca.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-depca.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-depca.obj `if test -f 'depca.c'; then $(CYGPATH_W) 'depca.c'; else $(CYGPATH_W) '$(srcdir)/depca.c'; fi`
! 
! libdrivers_a-eepro.o: eepro.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-eepro.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-eepro.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-eepro.o `test -f 'eepro.c' || echo '$(srcdir)/'`eepro.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-eepro.Tpo" "$(DEPDIR)/libdrivers_a-eepro.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-eepro.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eepro.c' object='libdrivers_a-eepro.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-eepro.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-eepro.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-eepro.o `test -f 'eepro.c' || echo '$(srcdir)/'`eepro.c
! 
! libdrivers_a-eepro.obj: eepro.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-eepro.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-eepro.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-eepro.obj `if test -f 'eepro.c'; then $(CYGPATH_W) 'eepro.c'; else $(CYGPATH_W) '$(srcdir)/eepro.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-eepro.Tpo" "$(DEPDIR)/libdrivers_a-eepro.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-eepro.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eepro.c' object='libdrivers_a-eepro.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-eepro.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-eepro.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-eepro.obj `if test -f 'eepro.c'; then $(CYGPATH_W) 'eepro.c'; else $(CYGPATH_W) '$(srcdir)/eepro.c'; fi`
  
  libdrivers_a-eepro100.o: eepro100.c
--- 615,639 ----
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-davicom.obj `if test -f 'davicom.c'; then $(CYGPATH_W) 'davicom.c'; else $(CYGPATH_W) '$(srcdir)/davicom.c'; fi`
  
! libdrivers_a-e1000.o: e1000.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-e1000.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-e1000.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-e1000.o `test -f 'e1000.c' || echo '$(srcdir)/'`e1000.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-e1000.Tpo" "$(DEPDIR)/libdrivers_a-e1000.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-e1000.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='e1000.c' object='libdrivers_a-e1000.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-e1000.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-e1000.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-e1000.o `test -f 'e1000.c' || echo '$(srcdir)/'`e1000.c
! 
! libdrivers_a-e1000.obj: e1000.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-e1000.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-e1000.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-e1000.obj `if test -f 'e1000.c'; then $(CYGPATH_W) 'e1000.c'; else $(CYGPATH_W) '$(srcdir)/e1000.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-e1000.Tpo" "$(DEPDIR)/libdrivers_a-e1000.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-e1000.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='e1000.c' object='libdrivers_a-e1000.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-e1000.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-e1000.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-e1000.obj `if test -f 'e1000.c'; then $(CYGPATH_W) 'e1000.c'; else $(CYGPATH_W) '$(srcdir)/e1000.c'; fi`
  
  libdrivers_a-eepro100.o: eepro100.c
***************
*** 703,772 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-epic100.obj `if test -f 'epic100.c'; then $(CYGPATH_W) 'epic100.c'; else $(CYGPATH_W) '$(srcdir)/epic100.c'; fi`
  
- libdrivers_a-fa311.o: fa311.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-fa311.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-fa311.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-fa311.o `test -f 'fa311.c' || echo '$(srcdir)/'`fa311.c; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-fa311.Tpo" "$(DEPDIR)/libdrivers_a-fa311.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-fa311.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='fa311.c' object='libdrivers_a-fa311.o' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-fa311.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-fa311.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fa311.o `test -f 'fa311.c' || echo '$(srcdir)/'`fa311.c
- 
- libdrivers_a-fa311.obj: fa311.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-fa311.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-fa311.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-fa311.obj `if test -f 'fa311.c'; then $(CYGPATH_W) 'fa311.c'; else $(CYGPATH_W) '$(srcdir)/fa311.c'; fi`; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-fa311.Tpo" "$(DEPDIR)/libdrivers_a-fa311.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-fa311.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='fa311.c' object='libdrivers_a-fa311.obj' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-fa311.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-fa311.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-fa311.obj `if test -f 'fa311.c'; then $(CYGPATH_W) 'fa311.c'; else $(CYGPATH_W) '$(srcdir)/fa311.c'; fi`
- 
- libdrivers_a-i82586.o: i82586.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i82586.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-i82586.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-i82586.o `test -f 'i82586.c' || echo '$(srcdir)/'`i82586.c; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-i82586.Tpo" "$(DEPDIR)/libdrivers_a-i82586.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-i82586.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i82586.c' object='libdrivers_a-i82586.o' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-i82586.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-i82586.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i82586.o `test -f 'i82586.c' || echo '$(srcdir)/'`i82586.c
- 
- libdrivers_a-i82586.obj: i82586.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-i82586.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-i82586.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-i82586.obj `if test -f 'i82586.c'; then $(CYGPATH_W) 'i82586.c'; else $(CYGPATH_W) '$(srcdir)/i82586.c'; fi`; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-i82586.Tpo" "$(DEPDIR)/libdrivers_a-i82586.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-i82586.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='i82586.c' object='libdrivers_a-i82586.obj' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-i82586.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-i82586.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-i82586.obj `if test -f 'i82586.c'; then $(CYGPATH_W) 'i82586.c'; else $(CYGPATH_W) '$(srcdir)/i82586.c'; fi`
- 
- libdrivers_a-lance.o: lance.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-lance.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-lance.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-lance.o `test -f 'lance.c' || echo '$(srcdir)/'`lance.c; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-lance.Tpo" "$(DEPDIR)/libdrivers_a-lance.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-lance.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='lance.c' object='libdrivers_a-lance.o' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-lance.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-lance.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-lance.o `test -f 'lance.c' || echo '$(srcdir)/'`lance.c
- 
- libdrivers_a-lance.obj: lance.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-lance.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-lance.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-lance.obj `if test -f 'lance.c'; then $(CYGPATH_W) 'lance.c'; else $(CYGPATH_W) '$(srcdir)/lance.c'; fi`; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-lance.Tpo" "$(DEPDIR)/libdrivers_a-lance.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-lance.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='lance.c' object='libdrivers_a-lance.obj' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-lance.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-lance.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-lance.obj `if test -f 'lance.c'; then $(CYGPATH_W) 'lance.c'; else $(CYGPATH_W) '$(srcdir)/lance.c'; fi`
- 
  libdrivers_a-natsemi.o: natsemi.c
  @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-natsemi.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-natsemi.Tpo" \
--- 681,684 ----
***************
*** 791,816 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-natsemi.obj `if test -f 'natsemi.c'; then $(CYGPATH_W) 'natsemi.c'; else $(CYGPATH_W) '$(srcdir)/natsemi.c'; fi`
  
- libdrivers_a-ni5010.o: ni5010.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ni5010.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-ni5010.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-ni5010.o `test -f 'ni5010.c' || echo '$(srcdir)/'`ni5010.c; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-ni5010.Tpo" "$(DEPDIR)/libdrivers_a-ni5010.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-ni5010.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ni5010.c' object='libdrivers_a-ni5010.o' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-ni5010.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-ni5010.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ni5010.o `test -f 'ni5010.c' || echo '$(srcdir)/'`ni5010.c
- 
- libdrivers_a-ni5010.obj: ni5010.c
- @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ni5010.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-ni5010.Tpo" \
- @am__fastdepCC_TRUE@	  -c -o libdrivers_a-ni5010.obj `if test -f 'ni5010.c'; then $(CYGPATH_W) 'ni5010.c'; else $(CYGPATH_W) '$(srcdir)/ni5010.c'; fi`; \
- @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-ni5010.Tpo" "$(DEPDIR)/libdrivers_a-ni5010.Po"; \
- @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-ni5010.Tpo"; exit 1; \
- @am__fastdepCC_TRUE@	fi
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ni5010.c' object='libdrivers_a-ni5010.obj' libtool=no @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-ni5010.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-ni5010.TPo' @AMDEPBACKSLASH@
- @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ni5010.obj `if test -f 'ni5010.c'; then $(CYGPATH_W) 'ni5010.c'; else $(CYGPATH_W) '$(srcdir)/ni5010.c'; fi`
- 
  libdrivers_a-ns8390.o: ns8390.c
  @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-ns8390.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-ns8390.Tpo" \
--- 703,706 ----
***************
*** 835,859 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ns8390.obj `if test -f 'ns8390.c'; then $(CYGPATH_W) 'ns8390.c'; else $(CYGPATH_W) '$(srcdir)/ns8390.c'; fi`
  
! libdrivers_a-otulip.o: otulip.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-otulip.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-otulip.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-otulip.o `test -f 'otulip.c' || echo '$(srcdir)/'`otulip.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-otulip.Tpo" "$(DEPDIR)/libdrivers_a-otulip.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-otulip.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='otulip.c' object='libdrivers_a-otulip.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-otulip.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-otulip.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-otulip.o `test -f 'otulip.c' || echo '$(srcdir)/'`otulip.c
! 
! libdrivers_a-otulip.obj: otulip.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-otulip.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-otulip.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-otulip.obj `if test -f 'otulip.c'; then $(CYGPATH_W) 'otulip.c'; else $(CYGPATH_W) '$(srcdir)/otulip.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-otulip.Tpo" "$(DEPDIR)/libdrivers_a-otulip.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-otulip.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='otulip.c' object='libdrivers_a-otulip.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-otulip.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-otulip.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-otulip.obj `if test -f 'otulip.c'; then $(CYGPATH_W) 'otulip.c'; else $(CYGPATH_W) '$(srcdir)/otulip.c'; fi`
  
  libdrivers_a-rtl8139.o: rtl8139.c
--- 725,749 ----
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-ns8390.obj `if test -f 'ns8390.c'; then $(CYGPATH_W) 'ns8390.c'; else $(CYGPATH_W) '$(srcdir)/ns8390.c'; fi`
  
! libdrivers_a-pcnet32.o: pcnet32.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pcnet32.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-pcnet32.o `test -f 'pcnet32.c' || echo '$(srcdir)/'`pcnet32.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" "$(DEPDIR)/libdrivers_a-pcnet32.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-pcnet32.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pcnet32.c' object='libdrivers_a-pcnet32.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pcnet32.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pcnet32.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pcnet32.o `test -f 'pcnet32.c' || echo '$(srcdir)/'`pcnet32.c
! 
! libdrivers_a-pcnet32.obj: pcnet32.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-pcnet32.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-pcnet32.obj `if test -f 'pcnet32.c'; then $(CYGPATH_W) 'pcnet32.c'; else $(CYGPATH_W) '$(srcdir)/pcnet32.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-pcnet32.Tpo" "$(DEPDIR)/libdrivers_a-pcnet32.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-pcnet32.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='pcnet32.c' object='libdrivers_a-pcnet32.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-pcnet32.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-pcnet32.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-pcnet32.obj `if test -f 'pcnet32.c'; then $(CYGPATH_W) 'pcnet32.c'; else $(CYGPATH_W) '$(srcdir)/pcnet32.c'; fi`
  
  libdrivers_a-rtl8139.o: rtl8139.c
***************
*** 901,969 ****
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sis900.obj `if test -f 'sis900.c'; then $(CYGPATH_W) 'sis900.c'; else $(CYGPATH_W) '$(srcdir)/sis900.c'; fi`
  
! libdrivers_a-sk_g16.o: sk_g16.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sk_g16.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-sk_g16.o `test -f 'sk_g16.c' || echo '$(srcdir)/'`sk_g16.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" "$(DEPDIR)/libdrivers_a-sk_g16.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-sk_g16.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sk_g16.c' object='libdrivers_a-sk_g16.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-sk_g16.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-sk_g16.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sk_g16.o `test -f 'sk_g16.c' || echo '$(srcdir)/'`sk_g16.c
! 
! libdrivers_a-sk_g16.obj: sk_g16.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sk_g16.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-sk_g16.obj `if test -f 'sk_g16.c'; then $(CYGPATH_W) 'sk_g16.c'; else $(CYGPATH_W) '$(srcdir)/sk_g16.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-sk_g16.Tpo" "$(DEPDIR)/libdrivers_a-sk_g16.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-sk_g16.Tpo"; exit 1; \
! @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sk_g16.c' object='libdrivers_a-sk_g16.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-sk_g16.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-sk_g16.TPo' @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sk_g16.obj `if test -f 'sk_g16.c'; then $(CYGPATH_W) 'sk_g16.c'; else $(CYGPATH_W) '$(srcdir)/sk_g16.c'; fi`
! 
! libdrivers_a-smc9000.o: smc9000.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-smc9000.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-smc9000.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-smc9000.o `test -f 'smc9000.c' || echo '$(srcdir)/'`smc9000.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-smc9000.Tpo" "$(DEPDIR)/libdrivers_a-smc9000.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-smc9000.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='smc9000.c' object='libdrivers_a-smc9000.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-smc9000.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-smc9000.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-smc9000.o `test -f 'smc9000.c' || echo '$(srcdir)/'`smc9000.c
  
! libdrivers_a-smc9000.obj: smc9000.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-smc9000.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-smc9000.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-smc9000.obj `if test -f 'smc9000.c'; then $(CYGPATH_W) 'smc9000.c'; else $(CYGPATH_W) '$(srcdir)/smc9000.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-smc9000.Tpo" "$(DEPDIR)/libdrivers_a-smc9000.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-smc9000.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='smc9000.c' object='libdrivers_a-smc9000.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-smc9000.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-smc9000.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-smc9000.obj `if test -f 'smc9000.c'; then $(CYGPATH_W) 'smc9000.c'; else $(CYGPATH_W) '$(srcdir)/smc9000.c'; fi`
  
! libdrivers_a-tiara.o: tiara.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tiara.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-tiara.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-tiara.o `test -f 'tiara.c' || echo '$(srcdir)/'`tiara.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-tiara.Tpo" "$(DEPDIR)/libdrivers_a-tiara.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-tiara.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tiara.c' object='libdrivers_a-tiara.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tiara.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tiara.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tiara.o `test -f 'tiara.c' || echo '$(srcdir)/'`tiara.c
  
! libdrivers_a-tiara.obj: tiara.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tiara.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-tiara.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-tiara.obj `if test -f 'tiara.c'; then $(CYGPATH_W) 'tiara.c'; else $(CYGPATH_W) '$(srcdir)/tiara.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-tiara.Tpo" "$(DEPDIR)/libdrivers_a-tiara.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-tiara.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tiara.c' object='libdrivers_a-tiara.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tiara.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tiara.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tiara.obj `if test -f 'tiara.c'; then $(CYGPATH_W) 'tiara.c'; else $(CYGPATH_W) '$(srcdir)/tiara.c'; fi`
  
  libdrivers_a-tlan.o: tlan.c
--- 791,837 ----
  @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sis900.obj `if test -f 'sis900.c'; then $(CYGPATH_W) 'sis900.c'; else $(CYGPATH_W) '$(srcdir)/sis900.c'; fi`
  
! libdrivers_a-sundance.o: sundance.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sundance.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-sundance.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-sundance.o `test -f 'sundance.c' || echo '$(srcdir)/'`sundance.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-sundance.Tpo" "$(DEPDIR)/libdrivers_a-sundance.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-sundance.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sundance.c' object='libdrivers_a-sundance.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-sundance.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-sundance.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sundance.o `test -f 'sundance.c' || echo '$(srcdir)/'`sundance.c
  
! libdrivers_a-sundance.obj: sundance.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-sundance.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-sundance.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-sundance.obj `if test -f 'sundance.c'; then $(CYGPATH_W) 'sundance.c'; else $(CYGPATH_W) '$(srcdir)/sundance.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-sundance.Tpo" "$(DEPDIR)/libdrivers_a-sundance.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-sundance.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sundance.c' object='libdrivers_a-sundance.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-sundance.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-sundance.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-sundance.obj `if test -f 'sundance.c'; then $(CYGPATH_W) 'sundance.c'; else $(CYGPATH_W) '$(srcdir)/sundance.c'; fi`
  
! libdrivers_a-tg3.o: tg3.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tg3.o -MD -MP -MF "$(DEPDIR)/libdrivers_a-tg3.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-tg3.o `test -f 'tg3.c' || echo '$(srcdir)/'`tg3.c; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-tg3.Tpo" "$(DEPDIR)/libdrivers_a-tg3.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-tg3.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tg3.c' object='libdrivers_a-tg3.o' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tg3.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tg3.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tg3.o `test -f 'tg3.c' || echo '$(srcdir)/'`tg3.c
  
! libdrivers_a-tg3.obj: tg3.c
! @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -MT libdrivers_a-tg3.obj -MD -MP -MF "$(DEPDIR)/libdrivers_a-tg3.Tpo" \
! @am__fastdepCC_TRUE@	  -c -o libdrivers_a-tg3.obj `if test -f 'tg3.c'; then $(CYGPATH_W) 'tg3.c'; else $(CYGPATH_W) '$(srcdir)/tg3.c'; fi`; \
! @am__fastdepCC_TRUE@	then mv "$(DEPDIR)/libdrivers_a-tg3.Tpo" "$(DEPDIR)/libdrivers_a-tg3.Po"; \
! @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/libdrivers_a-tg3.Tpo"; exit 1; \
  @am__fastdepCC_TRUE@	fi
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='tg3.c' object='libdrivers_a-tg3.obj' libtool=no @AMDEPBACKSLASH@
! @AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/libdrivers_a-tg3.Po' tmpdepfile='$(DEPDIR)/libdrivers_a-tg3.TPo' @AMDEPBACKSLASH@
  @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
! @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libdrivers_a_CFLAGS) $(CFLAGS) -c -o libdrivers_a-tg3.obj `if test -f 'tg3.c'; then $(CYGPATH_W) 'tg3.c'; else $(CYGPATH_W) '$(srcdir)/tg3.c'; fi`
  
  libdrivers_a-tlan.o: tlan.c
***************
*** 1229,1236 ****
  
  # Is it really necessary to specify dependecies explicitly?
! $(3c509_drivers): 3c509.c 3c509.h
! $(3c509_drivers): %.o: 3c509.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(3c595_drivers): 3c595.c 3c595.h
--- 1097,1104 ----
  
  # Is it really necessary to specify dependecies explicitly?
! #$(3c509_drivers): 3c509.c 3c509.h
! #$(3c509_drivers): %.o: 3c509.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(3c595_drivers): 3c595.c 3c595.h
***************
*** 1244,1251 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(cs89x0_drivers): cs89x0.c cs89x0.h
! $(cs89x0_drivers): %.o: cs89x0.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(davicom_drivers): davicom.c
--- 1112,1119 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(cs89x0_drivers): cs89x0.c cs89x0.h
! #$(cs89x0_drivers): %.o: cs89x0.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(davicom_drivers): davicom.c
***************
*** 1254,1264 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(depca_drivers): depca.c
! $(depca_drivers): %.o: depca.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(eepro_drivers): eepro.c
! $(eepro_drivers): %.o: eepro.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
--- 1122,1137 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(depca_drivers): depca.c
! #$(depca_drivers): %.o: depca.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(eepro_drivers): eepro.c
! #$(eepro_drivers): %.o: eepro.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
! 
! $(e1000_drivers): e1000.c e1000_hw.h
! $(e1000_drivers): %.o: e1000.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
***************
*** 1279,1291 ****
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(i82586_drivers): i82586.c
! $(i82586_drivers): %.o: i82586.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(lance_drivers): lance.c
! $(lance_drivers): %.o: lance.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(natsemi_drivers): natsemi.c
--- 1152,1164 ----
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(i82586_drivers): i82586.c
! #$(i82586_drivers): %.o: i82586.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(lance_drivers): lance.c
! #$(lance_drivers): %.o: lance.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(natsemi_drivers): natsemi.c
***************
*** 1294,1301 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(ni5010_drivers): ni5010.c
! $(ni5010_drivers): %.o: ni5010.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(ns8390_drivers): ns8390.c ns8390.h
--- 1167,1174 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(ni5010_drivers): ni5010.c
! #$(ni5010_drivers): %.o: ni5010.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(ns8390_drivers): ns8390.c ns8390.h
***************
*** 1304,1309 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(otulip_drivers): otulip.c otulip.h
! $(otulip_drivers): %.o: otulip.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
--- 1177,1187 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(otulip_drivers): otulip.c otulip.h
! #$(otulip_drivers): %.o: otulip.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
! 
! $(pcnet32_drivers): pcnet32.c
! $(pcnet32_drivers): %.o: pcnet32.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
***************
*** 1314,1342 ****
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sis900_drivers): sis900.c
! $(sis900_drivers): %.o: sis900.c sis900.h
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sk_g16_drivers): sk_g16.c sk_g16.h
! $(sk_g16_drivers): %.o: sk_g16.c
! 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(smc9000_drivers): smc9000.c smc9000.h
! $(smc9000_drivers): %.o: smc9000.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(tiara_drivers): tiara.c
! $(tiara_drivers): %.o: tiara.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(tlan_drivers): tlan.c
! #$(tlan_drivers): %.o: tlan.c
  #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
  $(tulip_drivers): tulip.c
  $(tulip_drivers): %.o: tulip.c
--- 1192,1230 ----
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(sis900_drivers): sis900.c sis900.h
! $(sis900_drivers): %.o: sis900.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(sk_g16_drivers): sk_g16.c sk_g16.h
! #$(sk_g16_drivers): %.o: sk_g16.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(smc9000_drivers): smc9000.c smc9000.h
! #$(smc9000_drivers): %.o: smc9000.c
! #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
! #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
! 
! $(sundance_drivers): sundance.c
! $(sundance_drivers): %.o: sundance.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! $(tg3_drivers): tg3.c tg3.h
! $(tg3_drivers): %.o: tg3.c
  	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
! #$(tiara_drivers): tiara.c
! #$(tiara_drivers): %.o: tiara.c
  #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
  #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
  
+ $(tlan_drivers): tlan.c tlan.h
+ $(tlan_drivers): %.o: tlan.c
+ 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+ 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+ 
  $(tulip_drivers): tulip.c
  $(tulip_drivers): %.o: tulip.c
diff -rc2P -x CVS GRUB_0.94/netboot/misc.c GRUB/netboot/misc.c
*** GRUB_0.94/netboot/misc.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/misc.c	2003-11-11 20:43:02.000000000 +0800
***************
*** 20,54 ****
  /* Based on "src/misc.c" in etherboot-5.0.5.  */
  
! #define GRUB	1
! #include <etherboot.h>
  
! void
! sleep (int secs)
  {
!   unsigned long tmo = currticks () + secs;
  
!   while (currticks () < tmo)
!     ;
  }
  
! void
! twiddle (void)
  {
!   static unsigned long lastticks = 0;
!   static int count = 0;
!   static const char tiddles[]="-\\|/";
!   unsigned long ticks;
  
!   if (debug)
!     {
!       if ((ticks = currticks ()) == lastticks)
! 	return;
!       
!       lastticks = ticks;
!       grub_putchar (tiddles[(count++) & 3]);
!       grub_putchar ('\b');
!     }
  }
  
  /* Because Etherboot uses its own formats for the printf family,
     define separate definitions from GRUB.  */
--- 20,107 ----
  /* Based on "src/misc.c" in etherboot-5.0.5.  */
  
! #include "grub.h"
! #include "timer.h"
  
! #include "nic.h"
! 
! /**************************************************************************
! RANDOM - compute a random number between 0 and 2147483647L or 2147483562?
! **************************************************************************/
! int32_t random(void)
  {
! 	static int32_t seed = 0;
! 	int32_t q;
! 	if (!seed) /* Initialize linear congruential generator */
! 		seed = currticks() + *(int32_t *)&arptable[ARP_CLIENT].node
! 		       + ((int16_t *)arptable[ARP_CLIENT].node)[2];
! 	/* simplified version of the LCG given in Bruce Schneier's
! 	   "Applied Cryptography" */
! 	q = seed/53668;
! 	if ((seed = 40014*(seed-53668*q) - 12211*q) < 0) seed += 2147483563L;
! 	return seed;
! }
  
! /**************************************************************************
! POLL INTERRUPTIONS
! **************************************************************************/
! void poll_interruptions(void)
! {
! 	if (checkkey() != -1 && ASCII_CHAR(getkey()) == K_INTR) {
! 		user_abort = 1;
! 	}
  }
  
! /**************************************************************************
! SLEEP
! **************************************************************************/
! void sleep(int secs)
  {
! 	unsigned long tmo;
  
! 	for (tmo = currticks()+secs*TICKS_PER_SEC; currticks() < tmo; ) {
! 		poll_interruptions();
! 	}
! }
! 
! /**************************************************************************
! INTERRUPTIBLE SLEEP
! **************************************************************************/
! void interruptible_sleep(int secs)
! {
! 	printf("<sleep>\n");
! 	return sleep(secs);
! }
! 
! /**************************************************************************
! TWIDDLE
! **************************************************************************/
! void twiddle(void)
! {
! #ifdef BAR_PROGRESS
! 	static int count=0;
! 	static const char tiddles[]="-\\|/";
! 	static unsigned long lastticks = 0;
! 	unsigned long ticks;
! #endif
! #ifdef FREEBSD_PXEEMU
! 	extern char pxeemu_nbp_active;
! 	if(pxeemu_nbp_active != 0)
! 		return;
! #endif
! #ifdef	BAR_PROGRESS
! 	/* Limit the maximum rate at which characters are printed */
! 	ticks = currticks();
! 	if ((lastticks + (TICKS_PER_SEC/18)) > ticks)
! 		return;
! 	lastticks = ticks;
! 
! 	putchar(tiddles[(count++)&3]);
! 	putchar('\b');
! #else
! 	//putchar('.');
! #endif	/* BAR_PROGRESS */
  }
  
+ 
  /* Because Etherboot uses its own formats for the printf family,
     define separate definitions from GRUB.  */
***************
*** 265,266 ****
--- 318,321 ----
    return ret;
  }
+ 
+ 
diff -rc2P -x CVS GRUB_0.94/netboot/natsemi.c GRUB/netboot/natsemi.c
*** GRUB_0.94/netboot/natsemi.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/natsemi.c	2003-11-08 22:47:31.000000000 +0800
***************
*** 1,2 ****
--- 1,5 ----
+ #ifdef ALLMULTI
+ #error multicast support is not yet implemented
+ #endif
  /* -*- Mode:C; c-basic-offset:4; -*- */
  
***************
*** 56,60 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  
  /* defines */
--- 59,62 ----
***************
*** 72,90 ****
  #define NUM_RX_DESC    4              /* Number of Rx descriptor registers. */
  
! typedef unsigned char  u8;
! typedef   signed char  s8;
! typedef unsigned short u16;
! typedef   signed short s16;
! typedef unsigned int   u32;
! typedef   signed int   s32;
  
  /* helpful macroes if on a big_endian machine for changing byte order.
     not strictly needed on Intel */
- #define le16_to_cpu(val) (val)
- #define cpu_to_le32(val) (val)
  #define get_unaligned(ptr) (*(ptr))
  #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
  #define get_u16(ptr) (*(u16 *)(ptr))
- #define virt_to_bus(x) ((unsigned long)x)
  #define virt_to_le32desc(addr)  virt_to_bus(addr)
  
--- 74,89 ----
  #define NUM_RX_DESC    4              /* Number of Rx descriptor registers. */
  
! typedef uint8_t    u8;
! typedef int8_t     s8;
! typedef uint16_t   u16;
! typedef int16_t    s16;
! typedef uint32_t   u32;
! typedef int32_t    s32;
  
  /* helpful macroes if on a big_endian machine for changing byte order.
     not strictly needed on Intel */
  #define get_unaligned(ptr) (*(ptr))
  #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
  #define get_u16(ptr) (*(u16 *)(ptr))
  #define virt_to_le32desc(addr)  virt_to_bus(addr)
  
***************
*** 208,222 ****
  static BufferDesc rxd[NUM_RX_DESC] __attribute__ ((aligned(4)));
  
- #ifdef USE_LOWMEM_BUFFER
- #define txb ((char *)0x10000 - TX_BUF_SIZE)
- #define rxb ((char *)0x10000 - NUM_RX_DESC*RX_BUF_SIZE - TX_BUF_SIZE)
- #else
  static unsigned char txb[TX_BUF_SIZE] __attribute__ ((aligned(4)));
  static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE] __attribute__ ((aligned(4)));
- #endif
  
  /* Function Prototypes */
  
! struct nic *natsemi_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci);
  static int eeprom_read(long addr, int location);
  static int mdio_read(int phy_id, int location);
--- 207,216 ----
  static BufferDesc rxd[NUM_RX_DESC] __attribute__ ((aligned(4)));
  
  static unsigned char txb[TX_BUF_SIZE] __attribute__ ((aligned(4)));
  static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE] __attribute__ ((aligned(4)));
  
  /* Function Prototypes */
  
! static int natsemi_probe(struct dev *dev, struct pci_device *pci);
  static int eeprom_read(long addr, int location);
  static int mdio_read(int phy_id, int location);
***************
*** 230,234 ****
  static void natsemi_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p);
  static int  natsemi_poll(struct nic *nic);
! static void natsemi_disable(struct nic *nic);
  
  /* 
--- 224,228 ----
  static void natsemi_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p);
  static int  natsemi_poll(struct nic *nic);
! static void natsemi_disable(struct dev *dev);
  
  /* 
***************
*** 246,262 ****
   */
  
! struct nic *
! natsemi_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
  {
      int i;
      int prev_eedata;
      u32 tmp;
  
!     if (io_addrs == 0 || *io_addrs == 0)
!         return NULL;
  
      /* initialize some commonly used globals */
  	
!     ioaddr     = *io_addrs & ~3;
      vendor     = pci->vendor;
      dev_id     = pci->dev_id;
--- 240,257 ----
   */
  
! static int
! natsemi_probe(struct dev *dev, struct pci_device *pci)
  {
+     struct nic *nic = (struct nic *)dev;
      int i;
      int prev_eedata;
      u32 tmp;
  
!     if (pci->ioaddr == 0)
!         return 0;
  
      /* initialize some commonly used globals */
  	
!     ioaddr     = pci->ioaddr & ~3;
      vendor     = pci->vendor;
      dev_id     = pci->dev_id;
***************
*** 318,327 ****
      natsemi_init(nic);
  
!     nic->reset    = natsemi_init;
      nic->poll     = natsemi_poll;
      nic->transmit = natsemi_transmit;
-     nic->disable  = natsemi_disable;
  
!     return nic;
  }
  
--- 313,321 ----
      natsemi_init(nic);
  
!     dev->disable  = natsemi_disable;
      nic->poll     = natsemi_poll;
      nic->transmit = natsemi_transmit;
  
!     return 1;
  }
  
***************
*** 453,457 ****
   */
  static void 
! natsemi_reset(struct nic *nic)
  {
      outl(ChipReset, ioaddr + ChipCmd);
--- 447,451 ----
   */
  static void 
! natsemi_reset(struct nic *nic __unused)
  {
      outl(ChipReset, ioaddr + ChipCmd);
***************
*** 505,516 ****
  
  static void
! natsemi_init_txd(struct nic *nic)
  {
      txd.link   = (u32) 0;
      txd.cmdsts = (u32) 0;
!     txd.bufptr = (u32) &txb[0];
  
      /* load Transmit Descriptor Register */
!     outl((u32) &txd, ioaddr + TxRingPtr); 
      if (natsemi_debug > 1)
          printf("natsemi_init_txd: TX descriptor register loaded with: %X\n", 
--- 499,510 ----
  
  static void
! natsemi_init_txd(struct nic *nic __unused)
  {
      txd.link   = (u32) 0;
      txd.cmdsts = (u32) 0;
!     txd.bufptr = virt_to_bus(&txb[0]);
  
      /* load Transmit Descriptor Register */
!     outl(virt_to_bus(&txd), ioaddr + TxRingPtr); 
      if (natsemi_debug > 1)
          printf("natsemi_init_txd: TX descriptor register loaded with: %X\n", 
***************
*** 528,532 ****
   
  static void 
! natsemi_init_rxd(struct nic *nic) 
  { 
      int i;
--- 522,526 ----
   
  static void 
! natsemi_init_rxd(struct nic *nic __unused) 
  { 
      int i;
***************
*** 536,542 ****
      /* init RX descriptor */
      for (i = 0; i < NUM_RX_DESC; i++) {
!         rxd[i].link   = (i+1 < NUM_RX_DESC) ? (u32) &rxd[i+1] : (u32) &rxd[0];
          rxd[i].cmdsts = (u32) RX_BUF_SIZE;
!         rxd[i].bufptr = (u32) &rxb[i*RX_BUF_SIZE];
          if (natsemi_debug > 1)
              printf("natsemi_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
--- 530,536 ----
      /* init RX descriptor */
      for (i = 0; i < NUM_RX_DESC; i++) {
!         rxd[i].link   = virt_to_bus((i+1 < NUM_RX_DESC) ? &rxd[i+1] : &rxd[0]);
          rxd[i].cmdsts = (u32) RX_BUF_SIZE;
!         rxd[i].bufptr = virt_to_bus(&rxb[i*RX_BUF_SIZE]);
          if (natsemi_debug > 1)
              printf("natsemi_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
***************
*** 545,549 ****
  
      /* load Receive Descriptor Register */
!     outl((u32) &rxd[0], ioaddr + RxRingPtr);
  
      if (natsemi_debug > 1)
--- 539,543 ----
  
      /* load Receive Descriptor Register */
!     outl(virt_to_bus(&rxd[0]), ioaddr + RxRingPtr);
  
      if (natsemi_debug > 1)
***************
*** 563,567 ****
   */
  
! static void natsemi_set_rx_mode(struct nic *nic)
  {
      u32 rx_mode = AcceptBroadcast | AcceptMyPhys;
--- 557,561 ----
   */
  
! static void natsemi_set_rx_mode(struct nic *nic __unused)
  {
      u32 rx_mode = AcceptBroadcast | AcceptMyPhys;
***************
*** 570,574 ****
  }
  
! static void natsemi_check_duplex(struct nic *nic)
  {
      int duplex = inl(ioaddr + ChipConfig) & 0x20000000 ? 1 : 0;
--- 564,568 ----
  }
  
! static void natsemi_check_duplex(struct nic *nic __unused)
  {
      int duplex = inl(ioaddr + ChipConfig) & 0x20000000 ? 1 : 0;
***************
*** 608,612 ****
  		 const char  *p)     /* Packet */
  {
!     u32 status, to, nstype;
      u32 tx_status;
      
--- 602,606 ----
  		 const char  *p)     /* Packet */
  {
!     u32 to, nstype;
      u32 tx_status;
      
***************
*** 615,619 ****
  
      /* load Transmit Descriptor Register */
!     outl((u32) &txd, ioaddr + TxRingPtr);
      if (natsemi_debug > 1)
          printf("natsemi_transmit: TX descriptor register loaded with: %X\n", 
--- 609,613 ----
  
      /* load Transmit Descriptor Register */
!     outl(virt_to_bus(&txd), ioaddr + TxRingPtr);
      if (natsemi_debug > 1)
          printf("natsemi_transmit: TX descriptor register loaded with: %X\n", 
***************
*** 637,641 ****
  
      /* set the transmit buffer descriptor and enable Transmit State Machine */
!     txd.bufptr = (u32) &txb[0];
      txd.cmdsts = (u32) OWN | s;
  
--- 631,635 ----
  
      /* set the transmit buffer descriptor and enable Transmit State Machine */
!     txd.bufptr = virt_to_bus(&txb[0]);
      txd.cmdsts = (u32) OWN | s;
  
***************
*** 705,709 ****
      /* return the descriptor and buffer to receive ring */
      rxd[cur_rx].cmdsts = RX_BUF_SIZE;
!     rxd[cur_rx].bufptr = (u32) &rxb[cur_rx*RX_BUF_SIZE];
          
      if (++cur_rx == NUM_RX_DESC)
--- 699,703 ----
      /* return the descriptor and buffer to receive ring */
      rxd[cur_rx].cmdsts = RX_BUF_SIZE;
!     rxd[cur_rx].bufptr = virt_to_bus(&rxb[cur_rx*RX_BUF_SIZE]);
          
      if (++cur_rx == NUM_RX_DESC)
***************
*** 726,731 ****
  
  static void
! natsemi_disable(struct nic *nic)
  {
      /* Disable interrupts using the mask. */
      outl(0, ioaddr + IntrMask);
--- 720,729 ----
  
  static void
! natsemi_disable(struct dev *dev)
  {
+     struct nic *nic = (struct nic *)dev;
+     /* merge reset and disable */
+     natsemi_init(nic);
+ 
      /* Disable interrupts using the mask. */
      outl(0, ioaddr + IntrMask);
***************
*** 738,739 ****
--- 736,750 ----
      outl(SavedClkRun, ioaddr + ClkRun);
  }
+ 
+ static struct pci_id natsemi_nics[] = {
+ PCI_ROM(0x100b, 0x0020, "dp83815", "DP83815"),
+ };
+ 
+ struct pci_driver natsemi_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "NATSEMI",
+ 	.probe    = natsemi_probe,
+ 	.ids      = natsemi_nics,
+ 	.id_count = sizeof(natsemi_nics)/sizeof(natsemi_nics[0]),
+ 	.class    = 0,
+ };
Only in GRUB_0.94/netboot: ni5010.c
diff -rc2P -x CVS GRUB_0.94/netboot/nic.c GRUB/netboot/nic.c
*** GRUB_0.94/netboot/nic.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/nic.c	2003-11-17 10:51:59.000000000 +0800
***************
*** 0 ****
--- 1,1177 ----
+ /**************************************************************************
+ Etherboot -  Network Bootstrap Program
+ 
+ Literature dealing with the network protocols:
+ 	ARP - RFC826
+ 	RARP - RFC903
+         IP - RFC791
+ 	UDP - RFC768
+ 	BOOTP - RFC951, RFC2132 (vendor extensions)
+ 	DHCP - RFC2131, RFC2132 (options)
+ 	TFTP - RFC1350, RFC2347 (options), RFC2348 (blocksize), RFC2349 (tsize)
+ 	RPC - RFC1831, RFC1832 (XDR), RFC1833 (rpcbind/portmapper)
+ 	NFS - RFC1094, RFC1813 (v3, useful for clarifications, not implemented)
+ 	IGMP - RFC1112, RFC2113, RFC2365, RFC2236, RFC3171
+ 
+ **************************************************************************/
+ 
+ #include "grub.h"
+ #include "nic.h"
+ #include "elf.h" /* FOR EM_CURRENT */
+ #include "bootp.h"
+ #include "if_arp.h"
+ #include "tftp.h"
+ #include "timer.h"
+ #include "ip.h"
+ #include "udp.h"
+ 
+ /* Currently no other module uses rom, but it is available */
+ struct rom_info		rom;
+ struct arptable_t	arptable[MAX_ARP];
+ #if MULTICAST_LEVEL2
+ unsigned long last_igmpv1 = 0;
+ struct igmptable_t	igmptable[MAX_IGMP];
+ #endif
+ static unsigned long	netmask;
+ /* Used by nfs.c */
+ char *hostname = "";
+ int hostnamelen = 0;
+ static uint32_t xid;
+ static unsigned char *end_of_rfc1533 = NULL;
+ static const unsigned char broadcast[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+ static const in_addr zeroIP = { 0L };
+ static char rfc1533_venddata[MAX_RFC1533_VENDLEN];
+ static unsigned char rfc1533_cookie[4] = { RFC1533_COOKIE };
+ static unsigned char rfc1533_cookie_bootp[5] = { RFC1533_COOKIE, RFC1533_END };
+ static unsigned char rfc1533_cookie_dhcp[] = { RFC1533_COOKIE };
+ static int dhcp_reply;
+ static in_addr dhcp_server = { 0L };
+ static in_addr dhcp_addr = { 0L };
+ 
+ static const unsigned char dhcpdiscover[] = {
+ 	RFC2132_MSG_TYPE, 1, DHCPDISCOVER,
+ 	RFC2132_MAX_SIZE, 2,	/* request as much as we can */
+ 	ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
+ 	RFC2132_PARAM_LIST, 4, RFC1533_NETMASK, RFC1533_GATEWAY,
+ 	RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH, RFC1533_END
+ };
+ static const unsigned char dhcprequest [] = {
+ 	RFC2132_MSG_TYPE,1,DHCPREQUEST,
+ 	RFC2132_SRV_ID,4,0,0,0,0,
+ 	RFC2132_REQ_ADDR,4,0,0,0,0,
+ 	RFC2132_MAX_SIZE,2,	/* request as much as we can */
+ 	ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
+ 	RFC2132_PARAM_LIST,
+ 	/* 5 standard + 6 vendortags + 8 motd + 16 menu items */
+ 	4 + 2,
+ 	/* Standard parameters */
+ 	RFC1533_NETMASK, RFC1533_GATEWAY,
+ 	RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH,
+ 	/* Etherboot vendortags */
+ 	RFC1533_VENDOR_MAGIC,
+ 	RFC1533_VENDOR_CONFIGFILE,
+ 	RFC1533_END
+ };
+ 
+ /* See nic.h */
+ int user_abort = 0;
+ int network_ready = 0;
+ 
+ #ifdef	REQUIRE_VCI_ETHERBOOT
+ int	vci_etherboot;
+ #endif
+ 
+ static int dummy(void *unused __unused)
+ {
+ 	return (0);
+ }
+ 
+ /* Careful.  We need an aligned buffer to avoid problems on machines
+  * that care about alignment.  To trivally align the ethernet data
+  * (the ip hdr and arp requests) we offset the packet by 2 bytes.
+  * leaving the ethernet data 16 byte aligned.  Beyond this
+  * we use memmove but this makes the common cast simple and fast.
+  */
+ static char	packet[ETH_FRAME_LEN + ETH_DATA_ALIGN] __aligned;
+ 
+ struct nic	nic =
+ {
+ 	{
+ 		0,				/* dev.disable */
+ 		{
+ 			0,
+ 			0,
+ 			PCI_BUS_TYPE,
+ 		},				/* dev.devid */
+ 		0,				/* index */
+ 		0,				/* type */
+ 		PROBE_FIRST,			/* how_pobe */
+ 		PROBE_NONE,			/* to_probe */
+ 		0,				/* failsafe */
+ 		0,				/* type_index */
+ 		{},				/* state */
+ 	},
+ 	(int (*)(struct nic *))dummy,		/* poll */
+ 	(void (*)(struct nic *, const char *,
+ 		unsigned int, unsigned int,
+ 		const char *))dummy,		/* transmit */
+ 	0,					/* flags */
+ 	&rom,					/* rom_info */
+ 	arptable[ARP_CLIENT].node,		/* node_addr */
+ 	packet + ETH_DATA_ALIGN,		/* packet */
+ 	0,					/* packetlen */
+ 	0,					/* priv_data */
+ };
+ 
+ int eth_probe(void)
+ {
+ 	static int probed = 0;
+ 	struct dev *dev;
+ 
+ 	EnterFunction("eth_probe");
+ 
+ 	if (probed)
+ 		return 1;
+ 
+ 	network_ready = 0;
+ 	grub_memset((char *)arptable, 0, MAX_ARP * sizeof(struct arptable_t));
+ 	dev = &nic.dev;
+ 	dev->how_probe = -1;
+ 	dev->type = NIC_DRIVER;
+ 	dev->failsafe = 1;
+ 	rom = *((struct rom_info *)ROM_INFO_LOCATION);
+ 
+ 	probed = (probe(dev) == PROBE_WORKED);
+ 
+ 	LeaveFunction("eth_probe");
+ 	return probed;
+ }
+ 
+ int eth_poll(void)
+ {
+ 	return ((*nic.poll)(&nic));
+ }
+ 
+ void eth_transmit(const char *d, unsigned int t, unsigned int s, const void *p)
+ {
+ 	(*nic.transmit)(&nic, d, t, s, p);
+ 	if (t == IP) twiddle();
+ }
+ 
+ void eth_disable(void)
+ {
+ #ifdef MULTICAST_LEVEL2
+ 	int i;
+ 	for(i = 0; i < MAX_IGMP; i++) {
+ 		leave_group(i);
+ 	}
+ #endif
+ 	disable(&nic.dev);
+ }
+ 
+ /**************************************************************************
+ IPCHKSUM - Checksum IP Header
+ **************************************************************************/
+ uint16_t ipchksum(const void *data, unsigned long length)
+ {
+ 	unsigned long sum;
+ 	unsigned long i;
+ 	const uint8_t *ptr;
+ 
+ 	/* In the most straight forward way possible,
+ 	 * compute an ip style checksum.
+ 	 */
+ 	sum = 0;
+ 	ptr = data;
+ 	for(i = 0; i < length; i++) {
+ 		unsigned long value;
+ 		value = ptr[i];
+ 		if (i & 1) {
+ 			value <<= 8;
+ 		}
+ 		/* Add the new value */
+ 		sum += value;
+ 		/* Wrap around the carry */
+ 		if (sum > 0xFFFF) {
+ 			sum = (sum + (sum >> 16)) & 0xFFFF;
+ 		}
+ 	}
+ 	return (~cpu_to_le16(sum)) & 0xFFFF;
+ }
+ 
+ uint16_t add_ipchksums(unsigned long offset, uint16_t sum, uint16_t new)
+ {
+ 	unsigned long checksum;
+ 	sum = ~sum & 0xFFFF;
+ 	new = ~new & 0xFFFF;
+ 	if (offset & 1) {
+ 		/* byte swap the sum if it came from an odd offset 
+ 		 * since the computation is endian independant this
+ 		 * works.
+ 		 */
+ 		new = bswap_16(new);
+ 	}
+ 	checksum = sum + new;
+ 	if (checksum > 0xFFFF) {
+ 		checksum -= 0xFFFF;
+ 	}
+ 	return (~checksum) & 0xFFFF;
+ }
+ 
+ /**************************************************************************
+ DEFAULT_NETMASK - Return default netmask for IP address
+ **************************************************************************/
+ static inline unsigned long default_netmask(void)
+ {
+ 	int net = ntohl(arptable[ARP_CLIENT].ipaddr.s_addr) >> 24;
+ 	if (net <= 127)
+ 		return(htonl(0xff000000));
+ 	else if (net < 192)
+ 		return(htonl(0xffff0000));
+ 	else
+ 		return(htonl(0xffffff00));
+ }
+ 
+ /**************************************************************************
+ IP_TRANSMIT - Send an IP datagram
+ **************************************************************************/
+ static int await_arp(int ival, void *ptr,
+ 	unsigned short ptype, struct iphdr *ip __unused, struct udphdr *udp __unused)
+ {
+ 	struct	arprequest *arpreply;
+ 	if (ptype != ARP)
+ 		return 0;
+ 	if (nic.packetlen < ETH_HLEN + sizeof(struct arprequest))
+ 		return 0;
+ 	arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+ 
+ 	if (arpreply->opcode != htons(ARP_REPLY)) 
+ 		return 0;
+ 	if (memcmp(arpreply->sipaddr, ptr, sizeof(in_addr)) != 0)
+ 		return 0;
+ 	memcpy(arptable[ival].node, arpreply->shwaddr, ETH_ALEN);
+ 	return 1;
+ }
+ 
+ int ip_transmit(int len, const void *buf)
+ {
+ 	unsigned long destip;
+ 	struct iphdr *ip;
+ 	struct arprequest arpreq;
+ 	int arpentry, i;
+ 	int retry;
+ 
+ 	ip = (struct iphdr *)buf;
+ 	destip = ip->dest.s_addr;
+ 	if (destip == IP_BROADCAST) {
+ 		eth_transmit(broadcast, IP, len, buf);
+ #ifdef MULTICAST_LEVEL1 
+ 	} else if ((destip & htonl(MULTICAST_MASK)) == htonl(MULTICAST_NETWORK)) {
+ 		unsigned char multicast[6];
+ 		unsigned long hdestip;
+ 		hdestip = ntohl(destip);
+ 		multicast[0] = 0x01;
+ 		multicast[1] = 0x00;
+ 		multicast[2] = 0x5e;
+ 		multicast[3] = (hdestip >> 16) & 0x7;
+ 		multicast[4] = (hdestip >> 8) & 0xff;
+ 		multicast[5] = hdestip & 0xff;
+ 		eth_transmit(multicast, IP, len, buf);
+ #endif
+ 	} else {
+ 		if (((destip & netmask) !=
+ 		     (arptable[ARP_CLIENT].ipaddr.s_addr & netmask)) &&
+ 		    arptable[ARP_GATEWAY].ipaddr.s_addr)
+ 			destip = arptable[ARP_GATEWAY].ipaddr.s_addr;
+ 		for(arpentry = 0; arpentry<MAX_ARP; arpentry++)
+ 			if (arptable[arpentry].ipaddr.s_addr == destip) break;
+ 		if (arpentry == MAX_ARP) {
+ 			printf("%@ is not in my arp table!\n", destip);
+ 			return(0);
+ 		}
+ 		for (i = 0; i < ETH_ALEN; i++)
+ 			if (arptable[arpentry].node[i])
+ 				break;
+ 		if (i == ETH_ALEN) {	/* Need to do arp request */
+ 			arpreq.hwtype = htons(1);
+ 			arpreq.protocol = htons(IP);
+ 			arpreq.hwlen = ETH_ALEN;
+ 			arpreq.protolen = 4;
+ 			arpreq.opcode = htons(ARP_REQUEST);
+ 			memcpy(arpreq.shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+ 			memcpy(arpreq.sipaddr, &arptable[ARP_CLIENT].ipaddr, sizeof(in_addr));
+ 			memset(arpreq.thwaddr, 0, ETH_ALEN);
+ 			memcpy(arpreq.tipaddr, &destip, sizeof(in_addr));
+ 			for (retry = 1; retry <= MAX_ARP_RETRIES; retry++) {
+ 				long timeout;
+ 				eth_transmit(broadcast, ARP, sizeof(arpreq),
+ 					&arpreq);
+ 				timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+ 				if (await_reply(await_arp, arpentry,
+ 					arpreq.tipaddr, timeout)) goto xmit;
+ 			}
+ 			return(0);
+ 		}
+ xmit:
+ 		eth_transmit(arptable[arpentry].node, IP, len, buf);
+ 	}
+ 	return 1;
+ }
+ 
+ void build_ip_hdr(unsigned long destip, int ttl, int protocol, int option_len,
+ 	int len, const void *buf)
+ {
+ 	struct iphdr *ip;
+ 	ip = (struct iphdr *)buf;
+ 	ip->verhdrlen = 0x45;
+ 	ip->verhdrlen += (option_len/4);
+ 	ip->service = 0;
+ 	ip->len = htons(len);
+ 	ip->ident = 0;
+ 	ip->frags = 0; /* Should we set don't fragment? */
+ 	ip->ttl = ttl;
+ 	ip->protocol = protocol;
+ 	ip->chksum = 0;
+ 	ip->src.s_addr = arptable[ARP_CLIENT].ipaddr.s_addr;
+ 	ip->dest.s_addr = destip;
+ 	ip->chksum = ipchksum(buf, sizeof(struct iphdr) + option_len);
+ }
+ 
+ static uint16_t udpchksum(struct iphdr *ip, struct udphdr *udp)
+ {
+ 	struct udp_pseudo_hdr pseudo;
+ 	uint16_t checksum;
+ 
+ 	/* Compute the pseudo header */
+ 	pseudo.src.s_addr  = ip->src.s_addr;
+ 	pseudo.dest.s_addr = ip->dest.s_addr;
+ 	pseudo.unused      = 0;
+ 	pseudo.protocol    = IP_UDP;
+ 	pseudo.len         = udp->len;
+ 
+ 	/* Sum the pseudo header */
+ 	checksum = ipchksum(&pseudo, 12);
+ 
+ 	/* Sum the rest of the udp packet */
+ 	checksum = add_ipchksums(12, checksum, ipchksum(udp, ntohs(udp->len)));
+ 	return checksum;
+ }
+ 
+ 
+ void build_udp_hdr(unsigned long destip, 
+ 	unsigned int srcsock, unsigned int destsock, int ttl,
+ 	int len, const void *buf)
+ {
+ 	struct iphdr *ip;
+ 	struct udphdr *udp;
+ 	ip = (struct iphdr *)buf;
+ 	build_ip_hdr(destip, ttl, IP_UDP, 0, len, buf);
+ 	udp = (struct udphdr *)((char *)buf + sizeof(struct iphdr));
+ 	udp->src = htons(srcsock);
+ 	udp->dest = htons(destsock);
+ 	udp->len = htons(len - sizeof(struct iphdr));
+ 	udp->chksum = 0;
+ 	if ((udp->chksum = udpchksum(ip, udp)) == 0)
+ 		udp->chksum = 0xffff;
+ }
+ 
+ 
+ /**************************************************************************
+ UDP_TRANSMIT - Send an UDP datagram
+ **************************************************************************/
+ int udp_transmit(unsigned long destip, unsigned int srcsock,
+ 	unsigned int destsock, int len, const void *buf)
+ {
+ 	build_udp_hdr(destip, srcsock, destsock, 60, len, buf);
+ 	return ip_transmit(len, buf);
+ }
+ 
+ /**************************************************************************
+ QDRAIN - clear the nic's receive queue
+ **************************************************************************/
+ static int await_qdrain(int ival __unused, void *ptr __unused,
+ 	unsigned short ptype __unused, 
+ 	struct iphdr *ip __unused, struct udphdr *udp __unused)
+ {
+ 	return 0;
+ }
+ 
+ void rx_qdrain(void)
+ {
+ 	/* Clear out the Rx queue first.  It contains nothing of interest,
+ 	 * except possibly ARP requests from the DHCP/TFTP server.  We use
+ 	 * polling throughout Etherboot, so some time may have passed since we
+ 	 * last polled the receive queue, which may now be filled with
+ 	 * broadcast packets.  This will cause the reply to the packets we are
+ 	 * about to send to be lost immediately.  Not very clever.  */
+ 	await_reply(await_qdrain, 0, NULL, 0);
+ }
+ 
+ /**
+  * rarp
+  *
+  * Get IP address by rarp. Just copy from etherboot
+  **/
+ static int await_rarp(int ival, void *ptr, unsigned short ptype, 
+ 		      struct iphdr *ip, struct udphdr *udp)
+ {
+ 	struct arprequest *arpreply;
+ 	if (ptype != RARP)
+ 		return 0;
+ 	if (nic.packetlen < ETH_HLEN + sizeof(struct arprequest))
+ 		return 0;
+ 	arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+ 	if (arpreply->opcode != htons(RARP_REPLY))
+ 		return 0;
+ 	if (memcmp(arpreply->thwaddr, ptr, ETH_ALEN) == 0){
+ 		memcpy(arptable[ARP_SERVER].node, arpreply->shwaddr, ETH_ALEN);
+ 		memcpy(&arptable[ARP_SERVER].ipaddr, arpreply->sipaddr, sizeof(in_addr));
+ 		memcpy(&arptable[ARP_CLIENT].ipaddr, arpreply->tipaddr, sizeof(in_addr));
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ int rarp(void)
+ {
+ 	int retry;
+ 
+ 	/* arp and rarp requests share the same packet structure. */
+ 	struct arprequest rarpreq;
+ 
+ 	if(!eth_probe())
+ 		return 0;
+ 	network_ready = 0;
+ 
+ 	memset(&rarpreq, 0, sizeof(rarpreq));
+ 
+ 	rarpreq.hwtype = htons(1);
+ 	rarpreq.protocol = htons(IP);
+ 	rarpreq.hwlen = ETH_ALEN;
+ 	rarpreq.protolen = 4;
+ 	rarpreq.opcode = htons(RARP_REQUEST);
+ 	memcpy(&rarpreq.shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+ 	/* sipaddr is already zeroed out */
+ 	memcpy(&rarpreq.thwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+ 	/* tipaddr is already zeroed out */
+ 
+ 	for (retry = 0; retry < MAX_ARP_RETRIES; ++retry) {
+ 		long timeout;
+ 		eth_transmit(broadcast, RARP, sizeof(rarpreq), &rarpreq);
+ 
+ 		timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+ 		if (await_reply(await_rarp, 0, rarpreq.shwaddr, timeout))
+ 			break;
+ 		if (user_abort)
+ 			return 0;
+ 	}
+ 
+ 	if (retry < MAX_ARP_RETRIES) {
+ 		network_ready = 1;
+ 		return (1);
+ 	}
+ 	return (0);
+ }
+ 
+ /**
+  * bootp
+  *
+  * Get IP address by bootp, segregate from bootp in etherboot.
+  **/
+ static int await_bootp(int ival __unused, void *ptr __unused,
+ 	unsigned short ptype __unused, struct iphdr *ip __unused, 
+ 	struct udphdr *udp)
+ {
+ 	struct	bootp_t *bootpreply;
+ 	int len;
+ 
+ 	if (!udp) {
+ 		return 0;
+ 	}
+ 	bootpreply = (struct bootp_t *)
+ 		&nic.packet[ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr)];
+ 	len = nic.packetlen - (ETH_HLEN + sizeof(struct iphdr) + 
+ 		sizeof(struct udphdr) + sizeof(struct bootp_t));
+ 	if (len < 0) {
+ 		return 0;
+ 	}
+ 	if (udp->dest != htons(BOOTP_CLIENT))
+ 		return 0;
+ 	if (bootpreply->bp_op != BOOTP_REPLY)
+ 		return 0;
+ 	if (bootpreply->bp_xid != xid)
+ 		return 0;
+ 	if (memcmp((char *)&bootpreply->bp_siaddr, (char *)&zeroIP, sizeof(in_addr)) == 0)
+ 		return 0;
+ 	if ((memcmp(broadcast, bootpreply->bp_hwaddr, ETH_ALEN) != 0) &&
+ 	    (memcmp(arptable[ARP_CLIENT].node, bootpreply->bp_hwaddr, ETH_ALEN) != 0)) {
+ 		return 0;
+ 	}
+ 	arptable[ARP_CLIENT].ipaddr.s_addr = bootpreply->bp_yiaddr.s_addr;
+ 	netmask = default_netmask();
+ 	arptable[ARP_SERVER].ipaddr.s_addr = bootpreply->bp_siaddr.s_addr;
+ 	memset(arptable[ARP_SERVER].node, 0, ETH_ALEN);  /* Kill arp */
+ 	arptable[ARP_GATEWAY].ipaddr.s_addr = bootpreply->bp_giaddr.s_addr;
+ 	memset(arptable[ARP_GATEWAY].node, 0, ETH_ALEN);  /* Kill arp */
+ 	/* We don't care bootpreply->bp_file, it must be 'pxegrub':-) */
+ 	memcpy((char *)rfc1533_venddata, (char *)(bootpreply->bp_vend), len);
+ 	decode_rfc1533(rfc1533_venddata, 0, len, 1);
+ 	return(1);
+ }
+ 
+ int bootp(void)
+ {
+ 	int retry;
+ 	struct bootpip_t ip;
+ 	unsigned long  starttime;
+ 	
+ 	EnterFunction("bootp");
+ 
+ 	if(!eth_probe())
+ 		return 0;
+ 	network_ready = 0;
+ 
+ 	memset(&ip, 0, sizeof(struct bootpip_t));
+ 	ip.bp.bp_op = BOOTP_REQUEST;
+ 	ip.bp.bp_htype = 1;
+ 	ip.bp.bp_hlen = ETH_ALEN;
+ 	starttime = currticks();
+ 	/* Use lower 32 bits of node address, more likely to be
+ 	   distinct than the time since booting */
+ 	memcpy(&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
+ 	ip.bp.bp_xid = xid += htonl(starttime);
+ 	/* TODO: check bp_secs */
+ 	memcpy(ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+ 	memcpy(ip.bp.bp_vend, rfc1533_cookie_bootp, sizeof(rfc1533_cookie_bootp)); /* request RFC-style options */
+ 
+ 	for (retry = 0; retry < MAX_BOOTP_RETRIES; ) {
+ 		long timeout;
+ 
+ 		rx_qdrain();
+ 
+ 		udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+ 			sizeof(struct bootpip_t), &ip);
+ 		timeout = rfc2131_sleep_interval(TIMEOUT, retry++);
+ 		if (await_reply(await_bootp, 0, NULL, timeout)){
+ 			network_ready = 1;
+ 			return(1);
+ 		}
+ 		if (user_abort)
+ 			return 0;
+ 		ip.bp.bp_secs = htons((currticks()-starttime)/TICKS_PER_SEC);
+ 	}
+ 	return(0);
+ }
+ 
+ /**
+  * dhcp
+  *
+  * Get IP address by dhcp, segregate from bootp in etherboot.
+  **/
+ static int await_dhcp(int ival __unused, void *ptr __unused,
+ 	unsigned short ptype __unused, struct iphdr *ip __unused, 
+ 	struct udphdr *udp)
+ {
+ 	struct	dhcp_t *dhcpreply;
+ 	int len;
+ 
+ 	if (!udp) {
+ 		return 0;
+ 	}
+ 	dhcpreply = (struct dhcp_t *)
+ 		&nic.packet[ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr)];
+ 	len = nic.packetlen - (ETH_HLEN + sizeof(struct iphdr) + 
+ 		sizeof(struct udphdr) + sizeof(struct dhcp_t) - DHCP_OPT_LEN);
+ 	if (len < 0){
+ 		return 0;
+ 	}
+ 	if (udp->dest != htons(BOOTP_CLIENT))
+ 		return 0;
+ 	if (dhcpreply->bp_op != BOOTP_REPLY)
+ 		return 0;
+ 	if (dhcpreply->bp_xid != xid)
+ 		return 0;
+ 	if (memcmp((char *)&dhcpreply->bp_siaddr, (char *)&zeroIP, sizeof(in_addr)) == 0)
+ 		return 0;
+ 	if ((memcmp(broadcast, dhcpreply->bp_hwaddr, ETH_ALEN) != 0) &&
+ 	    (memcmp(arptable[ARP_CLIENT].node, dhcpreply->bp_hwaddr, ETH_ALEN) != 0)) {
+ 		return 0;
+ 	}
+ 	arptable[ARP_CLIENT].ipaddr.s_addr = dhcpreply->bp_yiaddr.s_addr;
+ 	dhcp_addr.s_addr = dhcpreply->bp_yiaddr.s_addr;
+ 	netmask = default_netmask();
+ 	arptable[ARP_SERVER].ipaddr.s_addr = dhcpreply->bp_siaddr.s_addr;
+ 	memset(arptable[ARP_SERVER].node, 0, ETH_ALEN);  /* Kill arp */
+ 	arptable[ARP_GATEWAY].ipaddr.s_addr = dhcpreply->bp_giaddr.s_addr;
+ 	memset(arptable[ARP_GATEWAY].node, 0, ETH_ALEN);  /* Kill arp */
+ 	/* We don't care bootpreply->bp_file. It must be 'pxegrub' */
+ 	memcpy((char *)rfc1533_venddata, (char *)(dhcpreply->bp_vend), len);
+ 	decode_rfc1533(rfc1533_venddata, 0, len, 1);
+ 	return(1);
+ }
+ 
+ int dhcp(void)
+ {
+ 	int retry;
+ 	int reqretry;
+ 	struct dhcpip_t ip;
+ 	unsigned long  starttime;
+ 
+ 	if(!eth_probe())
+ 		return 0;
+ 
+ 	network_ready = 0;
+ 
+ 	memset(&ip, 0, sizeof(struct dhcpip_t));
+ 	ip.bp.bp_op = BOOTP_REQUEST;
+ 	ip.bp.bp_htype = 1;
+ 	ip.bp.bp_hlen = ETH_ALEN;
+ 	starttime = currticks();
+ 	/* Use lower 32 bits of node address, more likely to be
+ 	   distinct than the time since booting */
+ 	memcpy(&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
+ 	ip.bp.bp_xid = xid += htonl(starttime);
+ 	memcpy(ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+ 	memcpy(ip.bp.bp_vend, rfc1533_cookie_dhcp, sizeof rfc1533_cookie_dhcp); /* request RFC-style options */
+ 	memcpy(ip.bp.bp_vend + sizeof rfc1533_cookie_dhcp, dhcpdiscover, sizeof dhcpdiscover);
+ 
+ 	for (retry = 0; retry < MAX_BOOTP_RETRIES; ) {
+ 		long timeout;
+ 
+ 		rx_qdrain();
+ 
+ 		udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+ 			     sizeof(struct bootpip_t), &ip);
+ 		timeout = rfc2131_sleep_interval(TIMEOUT, retry++);
+ 		if (await_reply(await_dhcp, 0, NULL, timeout)) {
+ 			/* If not a DHCPOFFER then must be just a BOOTP reply,
+ 			   be backward compatible with BOOTP then */
+ 			if (dhcp_reply != DHCPOFFER){
+ 				network_ready = 1;
+ 				return(1);
+ 			}
+ 			dhcp_reply = 0;
+ 			memcpy(ip.bp.bp_vend, rfc1533_cookie_dhcp, sizeof rfc1533_cookie_dhcp);
+ 			memcpy(ip.bp.bp_vend + sizeof rfc1533_cookie_dhcp, dhcprequest, sizeof dhcprequest);
+ 			/* Beware: the magic numbers 9 and 15 depend on
+ 			   the layout of dhcprequest */
+ 			memcpy(&ip.bp.bp_vend[9], &dhcp_server, sizeof(in_addr));
+ 			memcpy(&ip.bp.bp_vend[15], &dhcp_addr, sizeof(in_addr));
+ 			for (reqretry = 0; reqretry < MAX_BOOTP_RETRIES; ) {
+ 				udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+ 					     sizeof(struct bootpip_t), &ip);
+ 				dhcp_reply=0;
+ 				timeout = rfc2131_sleep_interval(TIMEOUT, reqretry++);
+ 				if (await_reply(await_dhcp, 0, NULL, timeout))
+ 					if (dhcp_reply == DHCPACK){
+ 						network_ready = 1;
+ 						return(1);
+ 					}
+ 				if (user_abort)
+ 					return 0;
+ 			}
+ 		}
+ 		if (user_abort)
+ 			return 0;
+ 		ip.bp.bp_secs = htons((currticks()-starttime)/TICKS_PER_SEC);
+ 	}
+ 	return(0);
+ }
+ 
+ #ifdef MULTICAST_LEVEL2
+ static void send_igmp_reports(unsigned long now)
+ {
+ 	int i;
+ 	for(i = 0; i < MAX_IGMP; i++) {
+ 		if (igmptable[i].time && (now >= igmptable[i].time)) {
+ 			struct igmp_ip_t igmp;
+ 			igmp.router_alert[0] = 0x94;
+ 			igmp.router_alert[1] = 0x04;
+ 			igmp.router_alert[2] = 0;
+ 			igmp.router_alert[3] = 0;
+ 			build_ip_hdr(igmptable[i].group.s_addr, 
+ 				1, IP_IGMP, sizeof(igmp.router_alert), sizeof(igmp), &igmp);
+ 			igmp.igmp.type = IGMPv2_REPORT;
+ 			if (last_igmpv1 && 
+ 				(now < last_igmpv1 + IGMPv1_ROUTER_PRESENT_TIMEOUT)) {
+ 				igmp.igmp.type = IGMPv1_REPORT;
+ 			}
+ 			igmp.igmp.response_time = 0;
+ 			igmp.igmp.chksum = 0;
+ 			igmp.igmp.group.s_addr = igmptable[i].group.s_addr;
+ 			igmp.igmp.chksum = ipchksum(&igmp.igmp, sizeof(igmp.igmp));
+ 			ip_transmit(sizeof(igmp), &igmp);
+ #ifdef	MDEBUG
+ 			printf("Sent IGMP report to: %@\n", igmp.igmp.group.s_addr);
+ #endif
+ 			/* Don't send another igmp report until asked */
+ 			igmptable[i].time = 0;
+ 		}
+ 	}
+ }
+ 
+ static void process_igmp(struct iphdr *ip, unsigned long now)
+ {
+ 	struct igmp *igmp;
+ 	int i;
+ 	unsigned iplen = 0;
+ 	if (!ip || (ip->protocol == IP_IGMP) ||
+ 		(nic.packetlen < sizeof(struct iphdr) + sizeof(struct igmp))) {
+ 		return;
+ 	}
+ 	iplen = (ip->verhdrlen & 0xf)*4;
+ 	igmp = (struct igmp *)&nic.packet[sizeof(struct iphdr)];
+ 	if (ipchksum(igmp, ntohs(ip->len) - iplen) != 0)
+ 		return;
+ 	if ((igmp->type == IGMP_QUERY) && 
+ 		(ip->dest.s_addr == htonl(GROUP_ALL_HOSTS))) {
+ 		unsigned long interval = IGMP_INTERVAL;
+ 		if (igmp->response_time == 0) {
+ 			last_igmpv1 = now;
+ 		} else {
+ 			interval = (igmp->response_time * TICKS_PER_SEC)/10;
+ 		}
+ 		
+ #ifdef	MDEBUG
+ 		printf("Received IGMP query for: %@\n", igmp->group.s_addr);
+ #endif			       
+ 		for(i = 0; i < MAX_IGMP; i++) {
+ 			uint32_t group = igmptable[i].group.s_addr;
+ 			if ((group == 0) || (group == igmp->group.s_addr)) {
+ 				unsigned long time;
+ 				time = currticks() + rfc1112_sleep_interval(interval, 0);
+ 				if (time < igmptable[i].time) {
+ 					igmptable[i].time = time;
+ 				}
+ 			}
+ 		}
+ 	}
+ 	if (((igmp->type == IGMPv1_REPORT) || (igmp->type == IGMPv2_REPORT)) &&
+ 		(ip->dest.s_addr == igmp->group.s_addr)) {
+ #ifdef	MDEBUG
+ 		printf("Received IGMP report for: %@\n", igmp->group.s_addr);
+ #endif			       
+ 		for(i = 0; i < MAX_IGMP; i++) {
+ 			if ((igmptable[i].group.s_addr == igmp->group.s_addr) &&
+ 				igmptable[i].time != 0) {
+ 				igmptable[i].time = 0;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void leave_group(int slot)
+ {
+ 	/* Be very stupid and always send a leave group message if 
+ 	 * I have subscribed.  Imperfect but it is standards
+ 	 * compliant, easy and reliable to implement.
+ 	 *
+ 	 * The optimal group leave method is to only send leave when,
+ 	 * we were the last host to respond to a query on this group,
+ 	 * and igmpv1 compatibility is not enabled.
+ 	 */
+ 	if (igmptable[slot].group.s_addr) {
+ 		struct igmp_ip_t igmp;
+ 		igmp.router_alert[0] = 0x94;
+ 		igmp.router_alert[1] = 0x04;
+ 		igmp.router_alert[2] = 0;
+ 		igmp.router_alert[3] = 0;
+ 		build_ip_hdr(htonl(GROUP_ALL_HOSTS),
+ 			1, IP_IGMP, sizeof(igmp.router_alert), sizeof(igmp), &igmp);
+ 		igmp.igmp.type = IGMP_LEAVE;
+ 		igmp.igmp.response_time = 0;
+ 		igmp.igmp.chksum = 0;
+ 		igmp.igmp.group.s_addr = igmptable[slot].group.s_addr;
+ 		igmp.igmp.chksum = ipchksum(&igmp.igmp, sizeof(igmp));
+ 		ip_transmit(sizeof(igmp), &igmp);
+ #ifdef	MDEBUG
+ 		printf("Sent IGMP leave for: %@\n", igmp.igmp.group.s_addr);
+ #endif	
+ 	}
+ 	memset(&igmptable[slot], 0, sizeof(igmptable[0]));
+ }
+ 
+ void join_group(int slot, unsigned long group)
+ {
+ 	/* I have already joined */
+ 	if (igmptable[slot].group.s_addr == group)
+ 		return;
+ 	if (igmptable[slot].group.s_addr) {
+ 		leave_group(slot);
+ 	}
+ 	/* Only join a group if we are given a multicast ip, this way
+ 	 * code can be given a non-multicast (broadcast or unicast ip)
+ 	 * and still work... 
+ 	 */
+ 	if ((group & htonl(MULTICAST_MASK)) == htonl(MULTICAST_NETWORK)) {
+ 		igmptable[slot].group.s_addr = group;
+ 		igmptable[slot].time = currticks();
+ 	}
+ }
+ #else
+ #define send_igmp_reports(now);
+ #define process_igmp(ip, now)
+ #endif
+ 
+ /**************************************************************************
+ AWAIT_REPLY - Wait until we get a response for our request
+ ************f**************************************************************/
+ int await_reply(reply_t reply, int ival, void *ptr, long timeout)
+ {
+ 	unsigned long time, now;
+ 	struct	iphdr *ip;
+ 	unsigned iplen = 0;
+ 	struct	udphdr *udp;
+ 	unsigned short ptype;
+ 	int result;
+ 
+ 	user_abort = 0;
+ 
+ 	time = timeout + currticks();
+ 	/* The timeout check is done below.  The timeout is only checked if
+ 	 * there is no packet in the Rx queue.  This assumes that eth_poll()
+ 	 * needs a negligible amount of time.  
+ 	 */
+ 	for (;;) {
+ 		now = currticks();
+ 		send_igmp_reports(now);
+ 		result = eth_poll();
+ 		if (result == 0) {
+ 			/* We don't have anything */
+ 		
+ 			/* Check for abort key only if the Rx queue is empty -
+ 			 * as long as we have something to process, don't
+ 			 * assume that something failed.  It is unlikely that
+ 			 * we have no processing time left between packets.  */
+ 			poll_interruptions();
+ 			/* Do the timeout after at least a full queue walk.  */
+ 			if ((timeout == 0) || (currticks() > time)) {
+ 				break;
+ 			}
+ 			continue;
+ 		}
+ 	
+ 		/* We have something! */
+ 
+ 		/* Find the Ethernet packet type */
+ 		if (nic.packetlen >= ETH_HLEN) {
+ 			ptype = ((unsigned short) nic.packet[12]) << 8
+ 				| ((unsigned short) nic.packet[13]);
+ 		} else continue; /* what else could we do with it? */
+ 		/* Verify an IP header */
+ 		ip = 0;
+ 		if ((ptype == IP) && (nic.packetlen >= ETH_HLEN + sizeof(struct iphdr))) {
+ 			unsigned ipoptlen;
+ 			ip = (struct iphdr *)&nic.packet[ETH_HLEN];
+ 			if ((ip->verhdrlen < 0x45) || (ip->verhdrlen > 0x4F)) 
+ 				continue;
+ 			iplen = (ip->verhdrlen & 0xf) * 4;
+ 			if (ipchksum(ip, iplen) != 0)
+ 				continue;
+ 			if (ip->frags & htons(0x3FFF)) {
+ 				static int warned_fragmentation = 0;
+ 				if (!warned_fragmentation) {
+ 					printf("ALERT: got a fragmented packet - reconfigure your server\n");
+ 					warned_fragmentation = 1;
+ 				}
+ 				continue;
+ 			}
+ 			if (ntohs(ip->len) > ETH_MAX_MTU)
+ 				continue;
+ 
+ 			ipoptlen = iplen - sizeof(struct iphdr);
+ 			if (ipoptlen) {
+ 				/* Delete the ip options, to guarantee
+ 				 * good alignment, and make etherboot simpler.
+ 				 */
+ 				memmove(&nic.packet[ETH_HLEN + sizeof(struct iphdr)], 
+ 					&nic.packet[ETH_HLEN + iplen],
+ 					nic.packetlen - ipoptlen);
+ 				nic.packetlen -= ipoptlen;
+ 			}
+ 		}
+ 		udp = 0;
+ 		if (ip && (ip->protocol == IP_UDP) && 
+ 		    (nic.packetlen >= ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr))) {
+ 			udp = (struct udphdr *)&nic.packet[ETH_HLEN + sizeof(struct iphdr)];
+ 			
+ 			/* Make certain we have a reasonable packet length */
+ 			if (ntohs(udp->len) > (ntohs(ip->len) - iplen))
+ 				continue;
+ 
+ 			if (udp->chksum && udpchksum(ip, udp)) {
+ 				printf("UDP checksum error\n");
+ 				continue;
+ 			}
+ 		}
+ 		result = reply(ival, ptr, ptype, ip, udp);
+ 		if (result > 0) {
+ 			return result;
+ 		}
+ 		
+ 		/* If it isn't a packet the upper layer wants see if there is a default
+ 		 * action.  This allows us reply to arp and igmp queryies.
+ 		 */
+ 		if ((ptype == ARP) &&
+ 		    (nic.packetlen >= ETH_HLEN + sizeof(struct arprequest))) {
+ 			struct	arprequest *arpreply;
+ 			unsigned long tmp;
+ 			
+ 			arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+ 			memcpy(&tmp, arpreply->tipaddr, sizeof(in_addr));
+ 			if ((arpreply->opcode == htons(ARP_REQUEST)) &&
+ 			    (tmp == arptable[ARP_CLIENT].ipaddr.s_addr)) {
+ 				arpreply->opcode = htons(ARP_REPLY);
+ 				memcpy(arpreply->tipaddr, arpreply->sipaddr, sizeof(in_addr));
+ 				memcpy(arpreply->thwaddr, arpreply->shwaddr, ETH_ALEN);
+ 				memcpy(arpreply->sipaddr, &arptable[ARP_CLIENT].ipaddr, sizeof(in_addr));
+ 				memcpy(arpreply->shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+ 				eth_transmit(arpreply->thwaddr, ARP,
+ 					     sizeof(struct  arprequest),
+ 					     arpreply);
+ #ifdef	MDEBUG
+ 				memcpy(&tmp, arpreply->tipaddr, sizeof(in_addr));
+ 				printf("Sent ARP reply to: %@\n",tmp);
+ #endif	/* MDEBUG */
+ 			}
+ 		}
+ 		process_igmp(ip, now);
+ 	}
+ 	return(0);
+ }
+ 
+ #ifdef	REQUIRE_VCI_ETHERBOOT
+ /**************************************************************************
+ FIND_VCI_ETHERBOOT - Looks for "Etherboot" in Vendor Encapsulated Identifiers
+ On entry p points to byte count of VCI options
+ **************************************************************************/
+ static int find_vci_etherboot(unsigned char *p)
+ {
+ 	unsigned char	*end = p + 1 + *p;
+ 
+ 	for (p++; p < end; ) {
+ 		if (*p == RFC2132_VENDOR_CLASS_ID) {
+ 			if (strncmp("Etherboot", p + 2, sizeof("Etherboot") - 1) == 0)
+ 				return (1);
+ 		} else if (*p == RFC1533_END)
+ 			return (0);
+ 		p += TAG_LEN(p) + 2;
+ 	}
+ 	return (0);
+ }
+ #endif	/* REQUIRE_VCI_ETHERBOOT */
+ 
+ /**
+  * decode_rfc1533
+  *
+  * Decodes RFC1533 header
+  **/
+ int decode_rfc1533(unsigned char *p, unsigned int block, unsigned int len, int eof)
+ {
+ 	static unsigned char *extdata = NULL, *extend = NULL;
+ 	unsigned char        *extpath = NULL;
+ 	unsigned char        *endp;
+ 
+ 	if (block == 0) {
+ 		end_of_rfc1533 = NULL;
+ 		if (memcmp(p, rfc1533_cookie, sizeof(rfc1533_cookie)))
+ 			return(0); /* no RFC 1533 header found */
+ 		p += 4;
+ 		endp = p + len;
+ 	} else {
+ 		if (block == 1) {
+ 			if (memcmp(p, rfc1533_cookie, sizeof(rfc1533_cookie)))
+ 				return(0); /* no RFC 1533 header found */
+ 			p += 4;
+ 			len -= 4; }
+ 		if (extend + len <= (unsigned char *)
+ 		    rfc1533_venddata + sizeof(rfc1533_venddata)) {
+ 			memcpy(extend, p, len);
+ 			extend += len;
+ 		} else {
+ 			printf("Overflow in vendor data buffer! Aborting...\n");
+ 			*extdata = RFC1533_END;
+ 			return(0);
+ 		}
+ 		p = extdata; endp = extend;
+ 	}
+ 	if (!eof)
+ 		return 1;
+ 	while (p < endp) {
+ 		unsigned char c = *p;
+ 		if (c == RFC1533_PAD) {
+ 			p++;
+ 			continue;
+ 		}
+ 		else if (c == RFC1533_END) {
+ 			end_of_rfc1533 = endp = p;
+ 			continue;
+ 		}
+ 		else if (c == RFC1533_NETMASK)
+ 			memcpy(&netmask, p+2, sizeof(in_addr));
+ 		else if (c == RFC1533_GATEWAY) {
+ 			/* This is a little simplistic, but it will
+ 			   usually be sufficient.
+ 			   Take only the first entry */
+ 			if (TAG_LEN(p) >= sizeof(in_addr))
+ 				memcpy(&arptable[ARP_GATEWAY].ipaddr, p+2, sizeof(in_addr));
+ 		}
+ 		else if (c == RFC1533_EXTENSIONPATH)
+ 			extpath = p;
+ 		else if (c == RFC2132_MSG_TYPE)
+ 			dhcp_reply=*(p+2);
+ 		else if (c == RFC2132_SRV_ID)
+ 			memcpy(&dhcp_server, p+2, sizeof(in_addr));
+ 		else if (c == RFC1533_HOSTNAME) {
+ 			hostname = p + 2;
+ 			hostnamelen = *(p + 1);
+ 		}
+ 		else if (c == RFC1533_VENDOR_CONFIGFILE){
+ 			int l = TAG_LEN (p);
+ 	  
+ 			/* Eliminate the trailing NULs according to RFC 2132.  */
+ 			while (*(p + 2 + l - 1) == '\000' && l > 0)
+ 				l--;
+ 	  
+ 			/* XXX: Should check if LEN is less than the maximum length
+ 			   of CONFIG_FILE. This kind of robustness will be a goal
+ 			   in GRUB 1.0.  */
+ 			memcpy (config_file, p + 2, l);
+ 			config_file[l] = 0;
+ 		}
+ 		else {
+ 			;
+ 		}
+ 		p += TAG_LEN(p) + 2;
+ 	}
+ 	extdata = extend = endp;
+ 	if (block <= 0 && extpath != NULL) {
+ 		char fname[64];
+ 		if (TAG_LEN(extpath) >= sizeof(fname)){
+ 			printf("Overflow in vendor data buffer! Aborting...\n");
+ 			*extdata = RFC1533_END;
+ 			return(0);
+ 		}
+ 		memcpy(fname, extpath+2, TAG_LEN(extpath));
+ 		fname[(int)TAG_LEN(extpath)] = '\0';
+ 		printf("Loading BOOTP-extension file: %s\n",fname);
+ 		tftp_file_read(fname, decode_rfc1533);
+ 	}
+ 	return 1;	/* proceed with next block */
+ }
+ 
+ 
+ /* FIXME double check TWO_SECOND_DIVISOR */
+ #define TWO_SECOND_DIVISOR (RAND_MAX/TICKS_PER_SEC)
+ /**************************************************************************
+ RFC2131_SLEEP_INTERVAL - sleep for expotentially longer times (base << exp) +- 1 sec)
+ **************************************************************************/
+ long rfc2131_sleep_interval(long base, int exp)
+ {
+ 	unsigned long tmo;
+ #ifdef BACKOFF_LIMIT
+ 	if (exp > BACKOFF_LIMIT)
+ 		exp = BACKOFF_LIMIT;
+ #endif
+ 	tmo = (base << exp) + (TICKS_PER_SEC - (random()/TWO_SECOND_DIVISOR));
+ 	return tmo;
+ }
+ 
+ #ifdef MULTICAST_LEVEL2
+ /**************************************************************************
+ RFC1112_SLEEP_INTERVAL - sleep for expotentially longer times, up to (base << exp)
+ **************************************************************************/
+ long rfc1112_sleep_interval(long base, int exp)
+ {
+ 	unsigned long divisor, tmo;
+ #ifdef BACKOFF_LIMIT
+ 	if (exp > BACKOFF_LIMIT)
+ 		exp = BACKOFF_LIMIT;
+ #endif
+ 	divisor = RAND_MAX/(base << exp);
+ 	tmo = random()/divisor;
+ 	return tmo;
+ }
+ #endif /* MULTICAST_LEVEL_2 */
+ /* ifconfig - configure network interface.  */
+ int
+ ifconfig (char *ip, char *sm, char *gw, char *svr)
+ {
+   in_addr tmp;
+   
+   if (sm) 
+     {
+       if (! inet_aton (sm, &tmp))
+ 	return 0;
+       
+       netmask = tmp.s_addr;
+     }
+   
+   if (ip) 
+     {
+       if (! inet_aton (ip, &arptable[ARP_CLIENT].ipaddr)) 
+ 	return 0;
+       
+       if (! netmask && ! sm) 
+ 	netmask = default_netmask ();
+     }
+   
+   if (gw && ! inet_aton (gw, &arptable[ARP_GATEWAY].ipaddr)) 
+     return 0;
+ 
+   /* Clear out the ARP entry.  */
+   grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
+   
+   if (svr && ! inet_aton (svr, &arptable[ARP_SERVER].ipaddr)) 
+     return 0;
+ 
+   /* Likewise.  */
+   grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
+   
+   if (ip || sm)
+     {
+       if (IP_BROADCAST == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
+ 	  || netmask == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
+ 	  || ! netmask)
+ 	network_ready = 0;
+       else
+ 	network_ready = 1;
+     }
+   
+   return 1;
+ }
+ 
+ /*
+  * print_network_configuration
+  *
+  * Output the network configuration. It may broke the graphic console now.:-(
+  */
+ void print_network_configuration (void)
+ {
+ 	EnterFunction("print_network_configuration");
+ 	if (! eth_probe ())
+ 		grub_printf ("No ethernet card found.\n");
+ 	else if (! network_ready)
+ 		grub_printf ("Not initialized yet.\n");
+ 	else {
+ 		etherboot_printf ("Address: %@\n", arptable[ARP_CLIENT].ipaddr.s_addr);
+ 		etherboot_printf ("Netmask: %@\n", netmask);
+ 		etherboot_printf ("Server: %@\n", arptable[ARP_SERVER].ipaddr.s_addr);
+ 		etherboot_printf ("Gateway: %@\n", arptable[ARP_GATEWAY].ipaddr.s_addr);
+ 	}
+ 	LeaveFunction("print_network_configuration");
+ }
+ 
+ /**
+  * cleanup_net
+  *
+  * Mark network unusable, and disable NICs
+  */
+ void cleanup_net (void)
+ {
+ 	if (network_ready){
+ 		/* Stop receiving packets.  */
+ 		eth_disable ();
+ 		network_ready = 0;
+ 	}
+ }
diff -rc2P -x CVS GRUB_0.94/netboot/nic.h GRUB/netboot/nic.h
*** GRUB_0.94/netboot/nic.h	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/nic.h	2003-11-11 20:43:02.000000000 +0800
***************
*** 9,31 ****
  #define NIC_H
  
  /*
   *	Structure returned from eth_probe and passed to other driver
   *	functions.
   */
- 
  struct nic
  {
! 	void		(*reset)P((struct nic *));
  	int		(*poll)P((struct nic *));
  	void		(*transmit)P((struct nic *, const char *d,
  				unsigned int t, unsigned int s, const char *p));
- 	void		(*disable)P((struct nic *));
  	int		flags;	/* driver specific flags */
  	struct rom_info	*rom_info;	/* -> rom_info from main */
  	unsigned char	*node_addr;
! 	char		*packet;
  	unsigned int	packetlen;
  	void		*priv_data;	/* driver can hang private data here */
  };
  
  #endif	/* NIC_H */
--- 9,71 ----
  #define NIC_H
  
+ #include "dev.h"
+ 
+ /* The 'rom_info' maybe arch depended. It must be moved to some other
+  * place */
+ struct rom_info {
+ 	unsigned short	rom_segment;
+ 	unsigned short	rom_length;
+ };
+ 
  /*
   *	Structure returned from eth_probe and passed to other driver
   *	functions.
   */
  struct nic
  {
! 	struct dev	dev;  /* This must come first */
  	int		(*poll)P((struct nic *));
  	void		(*transmit)P((struct nic *, const char *d,
  				unsigned int t, unsigned int s, const char *p));
  	int		flags;	/* driver specific flags */
  	struct rom_info	*rom_info;	/* -> rom_info from main */
  	unsigned char	*node_addr;
! 	unsigned char	*packet;
  	unsigned int	packetlen;
  	void		*priv_data;	/* driver can hang private data here */
  };
  
+ extern char *hostname;
+ 
+ extern int hostnamelen;
+ 
+ /* Current Network Interface Card */
+ extern struct nic nic;
+ 
+ /* Whether network is ready */
+ extern int network_ready;
+ 
+ /* User aborted in await_reply if not zero */
+ extern int user_abort;
+ 
+ /** 
+  * Some network functions.
+  **/
+ extern int  eth_probe(void);
+ 
+ extern int  eth_poll(void);
+ 
+ extern void eth_transmit(const char * __d, unsigned int __t, 
+ 			 unsigned int __s, const void * __p);
+ 
+ extern void eth_disable(void);
+ 
+ 
+ 
+ extern int rarp(void);
+ 
+ extern int bootp(void);
+ 
+ extern int dhcp(void);
+ 
  #endif	/* NIC_H */
diff -rc2P -x CVS GRUB_0.94/netboot/ns8390.c GRUB/netboot/ns8390.c
*** GRUB_0.94/netboot/ns8390.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/ns8390.c	2003-11-08 22:47:31.000000000 +0800
***************
*** 14,17 ****
--- 14,19 ----
    responsibility for damages incurred with its use.
  
+ Multicast support added by Timothy Legge (timlegge@users.sourceforge.net) 09/28/2003
+ Relocation support added by Ken Yap (ken_yap@users.sourceforge.net) 28/12/02
  3c503 support added by Bill Paul (wpaul@ctr.columbia.edu) on 11/15/94
  SMC8416 support added by Bill Paul (wpaul@ctr.columbia.edu) on 12/25/94
***************
*** 19,22 ****
--- 21,26 ----
  RX overrun by Klaus Espenlaub (espenlaub@informatik.uni-ulm.de) on 3/10/99
    parts taken from the Linux 8390 driver (by Donald Becker and Paul Gortmaker)
+ SMC8416 PIO support added by Andrew Bettison (andrewb@zip.com.au) on 4/3/02
+   based on the Linux 8390 driver (by Donald Becker and Paul Gortmaker)
  
  **************************************************************************/
***************
*** 27,34 ****
  #ifdef	INCLUDE_NS8390
  #include "pci.h"
  #endif
- #include "cards.h"
  
! static unsigned char	eth_vendor, eth_flags, eth_laar;
  static unsigned short	eth_nic_base, eth_asic_base;
  static unsigned char	eth_memsize, eth_rx_start, eth_tx_start;
--- 31,42 ----
  #ifdef	INCLUDE_NS8390
  #include "pci.h"
+ #else
+ #include "isa.h"
  #endif
  
! static unsigned char	eth_vendor, eth_flags;
! #ifdef	INCLUDE_WD
! static unsigned char	eth_laar;
! #endif
  static unsigned short	eth_nic_base, eth_asic_base;
  static unsigned char	eth_memsize, eth_rx_start, eth_tx_start;
***************
*** 67,70 ****
--- 75,79 ----
  
  #if	defined(INCLUDE_WD)
+ #define	ASIC_PIO	WD_IAR
  #define	eth_probe	wd_probe
  #if	defined(INCLUDE_3C503) || defined(INCLUDE_NE) || defined(INCLUDE_NS8390)
***************
*** 102,106 ****
  #endif
  
! #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM))
  /**************************************************************************
  ETH_PIO_READ - Read a frame via Programmed I/O
--- 111,115 ----
  #endif
  
! #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM)) || (defined(INCLUDE_WD) && defined(WD_790_PIO))
  /**************************************************************************
  ETH_PIO_READ - Read a frame via Programmed I/O
***************
*** 108,112 ****
  static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt)
  {
! 	if (eth_flags & FLAG_16BIT) { ++cnt; cnt &= ~1; }
  	outb(D8390_COMMAND_RD2 |
  		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
--- 117,124 ----
  static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt)
  {
! #ifdef	INCLUDE_WD
! 	outb(src & 0xff, eth_asic_base + WD_GP2);
! 	outb(src >> 8, eth_asic_base + WD_GP2);
! #else
  	outb(D8390_COMMAND_RD2 |
  		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
***************
*** 123,129 ****
  	outb(t503_output | _3COM_CR_START, eth_asic_base + _3COM_CR);
  #endif
  
  	if (eth_flags & FLAG_16BIT)
! 		cnt >>= 1;
  
  	while(cnt--) {
--- 135,142 ----
  	outb(t503_output | _3COM_CR_START, eth_asic_base + _3COM_CR);
  #endif
+ #endif
  
  	if (eth_flags & FLAG_16BIT)
! 		cnt = (cnt + 1) >> 1;
  
  	while(cnt--) {
***************
*** 154,158 ****
  	unsigned int x;
  #endif	/* COMPEX_RL2000_FIX */
! 	if (eth_flags & FLAG_16BIT) { ++cnt; cnt &= ~1; }
  	outb(D8390_COMMAND_RD2 |
  		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
--- 167,174 ----
  	unsigned int x;
  #endif	/* COMPEX_RL2000_FIX */
! #ifdef	INCLUDE_WD
! 	outb(dst & 0xff, eth_asic_base + WD_GP2);
! 	outb(dst >> 8, eth_asic_base + WD_GP2);
! #else
  	outb(D8390_COMMAND_RD2 |
  		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
***************
*** 171,177 ****
  	outb(t503_output | _3COM_CR_DDIR | _3COM_CR_START, eth_asic_base + _3COM_CR);
  #endif
  
  	if (eth_flags & FLAG_16BIT)
! 		cnt >>= 1;
  
  	while(cnt--)
--- 187,194 ----
  	outb(t503_output | _3COM_CR_DDIR | _3COM_CR_START, eth_asic_base + _3COM_CR);
  #endif
+ #endif
  
  	if (eth_flags & FLAG_16BIT)
! 		cnt = (cnt + 1) >> 1;
  
  	while(cnt--)
***************
*** 202,208 ****
--- 219,227 ----
  		printf("Warning: Compex RL2000 aborted wait!\n");
  #endif	/* COMPEX_RL2000_FIX */
+ #ifndef	INCLUDE_WD
  	while((inb(eth_nic_base + D8390_P0_ISR) & D8390_ISR_RDC)
  		!= D8390_ISR_RDC);
  #endif
+ #endif
  }
  #else
***************
*** 210,216 ****
  ETH_PIO_READ - Dummy routine when NE2000 not compiled in
  **************************************************************************/
! static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt) {}
  #endif
  
  /**************************************************************************
  NS8390_RESET - Reset adapter
--- 229,256 ----
  ETH_PIO_READ - Dummy routine when NE2000 not compiled in
  **************************************************************************/
! static void eth_pio_read(unsigned int src __unused, unsigned char *dst  __unused, unsigned int cnt __unused) {}
  #endif
  
+ 
+ /**************************************************************************
+ enable_multycast - Enable Multicast
+ **************************************************************************/
+ static void enable_multicast(unsigned short eth_nic_base) 
+ {
+ 	unsigned char mcfilter[8];
+ 	int i;
+ 	memset(mcfilter, 0xFF, 8);
+ 	outb(4, eth_nic_base+D8390_P0_RCR);	
+ 	outb(D8390_COMMAND_RD2 + D8390_COMMAND_PS1, eth_nic_base + D8390_P0_COMMAND);
+ 	for(i=0;i<8;i++)
+ 	{
+ 		outb(mcfilter[i], eth_nic_base + 8 + i);
+ 		if(inb(eth_nic_base + 8 + i)!=mcfilter[i])
+ 			printf("Error SMC 83C690 Multicast filter read/write mishap %d\n",i);
+ 	}
+ 	outb(D8390_COMMAND_RD2 + D8390_COMMAND_PS0, eth_nic_base + D8390_P0_COMMAND);
+ 	outb(4 | 0x08, eth_nic_base+D8390_P0_RCR);
+ }
+ 
  /**************************************************************************
  NS8390_RESET - Reset adapter
***************
*** 239,243 ****
  	outb(eth_rx_start, eth_nic_base+D8390_P0_PSTART);
  #ifdef	INCLUDE_WD
! 	if (eth_flags & FLAG_790) outb(0, eth_nic_base + 0x09);
  #endif
  	outb(eth_memsize, eth_nic_base+D8390_P0_PSTOP);
--- 279,290 ----
  	outb(eth_rx_start, eth_nic_base+D8390_P0_PSTART);
  #ifdef	INCLUDE_WD
! 	if (eth_flags & FLAG_790) {
! #ifdef	WD_790_PIO
! 		outb(0x10, eth_asic_base + 0x06); /* disable interrupts, enable PIO */
! 		outb(0x01, eth_nic_base + 0x09); /* enable ring read auto-wrap */
! #else
! 		outb(0, eth_nic_base + 0x09);
! #endif
! 	}
  #endif
  	outb(eth_memsize, eth_nic_base+D8390_P0_PSTOP);
***************
*** 267,272 ****
  			D8390_COMMAND_RD2 | D8390_COMMAND_STA, eth_nic_base+D8390_P0_COMMAND);
  	outb(0xFF, eth_nic_base+D8390_P0_ISR);
! 	outb(0, eth_nic_base+D8390_P0_TCR);
! 	outb(4, eth_nic_base+D8390_P0_RCR);	/* allow broadcast frames */
  
  #ifdef	INCLUDE_3C503
--- 314,321 ----
  			D8390_COMMAND_RD2 | D8390_COMMAND_STA, eth_nic_base+D8390_P0_COMMAND);
  	outb(0xFF, eth_nic_base+D8390_P0_ISR);
! 	outb(0, eth_nic_base+D8390_P0_TCR);	/* transmitter on */
! 	outb(4, eth_nic_base+D8390_P0_RCR);	/* allow rx broadcast frames */
! 
! 	enable_multicast(eth_nic_base);
  
  #ifdef	INCLUDE_3C503
***************
*** 345,366 ****
  	const char *p)			/* Packet */
  {
  #ifdef	INCLUDE_3C503
          if (!(eth_flags & FLAG_PIO)) {
!                 memcpy((char *)eth_bmem, d, ETH_ALEN);	/* dst */
!                 memcpy((char *)eth_bmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
!                 *((char *)eth_bmem+12) = t>>8;		/* type */
!                 *((char *)eth_bmem+13) = t;
!                 memcpy((char *)eth_bmem+ETH_HLEN, p, s);
                  s += ETH_HLEN;
!                 while (s < ETH_ZLEN) *((char *)eth_bmem+(s++)) = 0;
          }
  #endif
  
  #ifdef	INCLUDE_WD
- 	/* Memory interface */
  	if (eth_flags & FLAG_16BIT) {
  		outb(eth_laar | WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
  		inb(0x84);
  	}
  	if (eth_flags & FLAG_790) {
  		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
--- 394,417 ----
  	const char *p)			/* Packet */
  {
+ 	Address		eth_vmem = bus_to_virt(eth_bmem);
  #ifdef	INCLUDE_3C503
          if (!(eth_flags & FLAG_PIO)) {
!                 memcpy((char *)eth_vmem, d, ETH_ALEN);	/* dst */
!                 memcpy((char *)eth_vmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
!                 *((char *)eth_vmem+12) = t>>8;		/* type */
!                 *((char *)eth_vmem+13) = t;
!                 memcpy((char *)eth_vmem+ETH_HLEN, p, s);
                  s += ETH_HLEN;
!                 while (s < ETH_ZLEN) *((char *)eth_vmem+(s++)) = 0;
          }
  #endif
  
  #ifdef	INCLUDE_WD
  	if (eth_flags & FLAG_16BIT) {
  		outb(eth_laar | WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
  		inb(0x84);
  	}
+ #ifndef	WD_790_PIO
+ 	/* Memory interface */
  	if (eth_flags & FLAG_790) {
  		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
***************
*** 368,392 ****
  	}
  	inb(0x84);
! 	memcpy((char *)eth_bmem, d, ETH_ALEN);	/* dst */
! 	memcpy((char *)eth_bmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
! 	*((char *)eth_bmem+12) = t>>8;		/* type */
! 	*((char *)eth_bmem+13) = t;
! 	memcpy((char *)eth_bmem+ETH_HLEN, p, s);
  	s += ETH_HLEN;
! 	while (s < ETH_ZLEN) *((char *)eth_bmem+(s++)) = 0;
  	if (eth_flags & FLAG_790) {
  		outb(0, eth_asic_base + WD_MSR);
  		inb(0x84);
  	}
! 	if (eth_flags & FLAG_16BIT) {
! 		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
! 		inb(0x84);
! 	}
  #endif
  
  #if	defined(INCLUDE_3C503)
! 	if (eth_flags & FLAG_PIO) {
  #endif
! #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM))
  		/* Programmed I/O */
  		unsigned short type;
--- 419,443 ----
  	}
  	inb(0x84);
! 	memcpy((char *)eth_vmem, d, ETH_ALEN);	/* dst */
! 	memcpy((char *)eth_vmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
! 	*((char *)eth_vmem+12) = t>>8;		/* type */
! 	*((char *)eth_vmem+13) = t;
! 	memcpy((char *)eth_vmem+ETH_HLEN, p, s);
  	s += ETH_HLEN;
! 	while (s < ETH_ZLEN) *((char *)eth_vmem+(s++)) = 0;
  	if (eth_flags & FLAG_790) {
  		outb(0, eth_asic_base + WD_MSR);
  		inb(0x84);
  	}
! #else
! 	inb(0x84);
! #endif
  #endif
  
  #if	defined(INCLUDE_3C503)
! 	if (eth_flags & FLAG_PIO)
  #endif
! #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM)) || (defined(INCLUDE_WD) && defined(WD_790_PIO))
! 	{
  		/* Programmed I/O */
  		unsigned short type;
***************
*** 399,408 ****
  		s += ETH_HLEN;
  		if (s < ETH_ZLEN) s = ETH_ZLEN;
  #endif
  #if	defined(INCLUDE_3C503)
- 	}
  #endif
  
  #ifdef	INCLUDE_WD
  	if (eth_flags & FLAG_790)
  		outb(D8390_COMMAND_PS0 |
--- 450,463 ----
  		s += ETH_HLEN;
  		if (s < ETH_ZLEN) s = ETH_ZLEN;
+ 	}
  #endif
  #if	defined(INCLUDE_3C503)
  #endif
  
  #ifdef	INCLUDE_WD
+ 	if (eth_flags & FLAG_16BIT) {
+ 		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
+ 		inb(0x84);
+ 	}
  	if (eth_flags & FLAG_790)
  		outb(D8390_COMMAND_PS0 |
***************
*** 459,466 ****
--- 514,523 ----
  		inb(0x84);
  	}
+ #ifndef	WD_790_PIO
  	if (eth_flags & FLAG_790) {
  		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
  		inb(0x84);
  	}
+ #endif
  	inb(0x84);
  #endif
***************
*** 469,473 ****
  		eth_pio_read(pktoff, (char *)&pkthdr, 4);
  	else
! 		memcpy(&pkthdr, (char *)eth_rmem + pktoff, 4);
  	pktoff += sizeof(pkthdr);
  	/* incoming length includes FCS so must sub 4 */
--- 526,530 ----
  		eth_pio_read(pktoff, (char *)&pkthdr, 4);
  	else
! 		memcpy(&pkthdr, bus_to_virt(eth_rmem + pktoff), 4);
  	pktoff += sizeof(pkthdr);
  	/* incoming length includes FCS so must sub 4 */
***************
*** 487,491 ****
  				eth_pio_read(pktoff, p, frag);
  			else
! 				memcpy(p, (char *)eth_rmem + pktoff, frag);
  			pktoff = eth_rx_start << 8;
  			p += frag;
--- 544,548 ----
  				eth_pio_read(pktoff, p, frag);
  			else
! 				memcpy(p, bus_to_virt(eth_rmem + pktoff), frag);
  			pktoff = eth_rx_start << 8;
  			p += frag;
***************
*** 496,507 ****
  			eth_pio_read(pktoff, p, len);
  		else
! 			memcpy(p, (char *)eth_rmem + pktoff, len);
  		ret = 1;
  	}
  #ifdef	INCLUDE_WD
  	if (eth_flags & FLAG_790) {
  		outb(0, eth_asic_base + WD_MSR);
  		inb(0x84);
  	}
  	if (eth_flags & FLAG_16BIT) {
  		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
--- 553,566 ----
  			eth_pio_read(pktoff, p, len);
  		else
! 			memcpy(p, bus_to_virt(eth_rmem + pktoff), len);
  		ret = 1;
  	}
  #ifdef	INCLUDE_WD
+ #ifndef	WD_790_PIO
  	if (eth_flags & FLAG_790) {
  		outb(0, eth_asic_base + WD_MSR);
  		inb(0x84);
  	}
+ #endif
  	if (eth_flags & FLAG_16BIT) {
  		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
***************
*** 520,525 ****
  NS8390_DISABLE - Turn off adapter
  **************************************************************************/
! static void ns8390_disable(struct nic *nic)
  {
  }
  
--- 579,587 ----
  NS8390_DISABLE - Turn off adapter
  **************************************************************************/
! static void ns8390_disable(struct dev *dev)
  {
+ 	struct nic *nic = (struct nic *)dev;
+ 	/* reset and disable merge */
+ 	ns8390_reset(nic);
  }
  
***************
*** 528,548 ****
  **************************************************************************/
  #ifdef	INCLUDE_NS8390
! struct nic *eth_probe(struct nic *nic, unsigned short *probe_addrs,
! 		      struct pci_device *pci)
  #else
! struct nic *eth_probe(struct nic *nic, unsigned short *probe_addrs)
  #endif
  {
  	int i;
! 	struct wd_board *brd;
! 	unsigned short chksum;
! 	unsigned char c;
  	eth_vendor = VENDOR_NONE;
  	eth_drain_receiver = 0;
  
  #ifdef	INCLUDE_WD
  	/******************************************************************
  	Search for WD/SMC cards
  	******************************************************************/
  	for (eth_asic_base = WD_LOW_BASE; eth_asic_base <= WD_HIGH_BASE;
  		eth_asic_base += 0x20) {
--- 590,615 ----
  **************************************************************************/
  #ifdef	INCLUDE_NS8390
! static int eth_probe (struct dev *dev, struct pci_device *pci)
  #else
! static int eth_probe (struct dev *dev, unsigned short *probe_addrs __unused)
  #endif
  {
+ 	struct nic *nic = (struct nic *)dev;
  	int i;
! #ifdef INCLUDE_NS8390
! 	unsigned short pci_probe_addrs[] = { pci->ioaddr, 0 };
! 	unsigned short *probe_addrs = pci_probe_addrs;
! #endif
  	eth_vendor = VENDOR_NONE;
  	eth_drain_receiver = 0;
  
  #ifdef	INCLUDE_WD
+ {
  	/******************************************************************
  	Search for WD/SMC cards
  	******************************************************************/
+ 	struct wd_board *brd;
+ 	unsigned short chksum;
+ 	unsigned char c;
  	for (eth_asic_base = WD_LOW_BASE; eth_asic_base <= WD_HIGH_BASE;
  		eth_asic_base += 0x20) {
***************
*** 583,588 ****
  		eth_bmem = WD_DEFAULT_MEM;
  	if (brd->id == TYPE_SMC8216T || brd->id == TYPE_SMC8216C) {
! 		*((unsigned int *)(eth_bmem + 8192)) = (unsigned int)0;
! 		if (*((unsigned int *)(eth_bmem + 8192))) {
  			brd += 2;
  			eth_memsize = brd->memsize;
--- 650,656 ----
  		eth_bmem = WD_DEFAULT_MEM;
  	if (brd->id == TYPE_SMC8216T || brd->id == TYPE_SMC8216C) {
! 		/* from Linux driver, 8416BT detects as 8216 sometimes */
! 		unsigned int addr = inb(eth_asic_base + 0xb);
! 		if (((addr >> 4) & 3) == 0) {
  			brd += 2;
  			eth_memsize = brd->memsize;
***************
*** 593,609 ****
  		nic->node_addr[i] = inb(i+eth_asic_base+WD_LAR);
  	}
! 	printf("\n%s base %#hx, memory %#hx, addr %!\n",
! 		brd->name, eth_asic_base, eth_bmem, nic->node_addr);
  	if (eth_flags & FLAG_790) {
  		outb(WD_MSR_MENB, eth_asic_base+WD_MSR);
  		outb((inb(eth_asic_base+0x04) |
  			0x80), eth_asic_base+0x04);
! 		outb((((unsigned)eth_bmem >> 13) & 0x0F) |
! 			(((unsigned)eth_bmem >> 11) & 0x40) |
  			(inb(eth_asic_base+0x0B) & 0xB0), eth_asic_base+0x0B);
  		outb((inb(eth_asic_base+0x04) &
  			~0x80), eth_asic_base+0x04);
  	} else {
! 		outb((((unsigned)eth_bmem >> 13) & 0x3F) | 0x40, eth_asic_base+WD_MSR);
  	}
  	if (eth_flags & FLAG_16BIT) {
--- 661,685 ----
  		nic->node_addr[i] = inb(i+eth_asic_base+WD_LAR);
  	}
! 	printf("\n%s base %#hx", brd->name, eth_asic_base);
  	if (eth_flags & FLAG_790) {
+ #ifdef	WD_790_PIO
+ 		printf(", PIO mode, addr %!\n", nic->node_addr);
+ 		eth_bmem = 0;
+ 		eth_flags |= FLAG_PIO;		/* force PIO mode */
+ 		outb(0, eth_asic_base+WD_MSR);
+ #else
+ 		printf(", memory %#x, addr %!\n", eth_bmem, nic->node_addr);
  		outb(WD_MSR_MENB, eth_asic_base+WD_MSR);
  		outb((inb(eth_asic_base+0x04) |
  			0x80), eth_asic_base+0x04);
! 		outb(((unsigned)(eth_bmem >> 13) & 0x0F) |
! 			((unsigned)(eth_bmem >> 11) & 0x40) |
  			(inb(eth_asic_base+0x0B) & 0xB0), eth_asic_base+0x0B);
  		outb((inb(eth_asic_base+0x04) &
  			~0x80), eth_asic_base+0x04);
+ #endif
  	} else {
! 		printf(", memory %#x, addr %!\n", eth_bmem, nic->node_addr);
! 		outb(((unsigned)(eth_bmem >> 13) & 0x3F) | 0x40, eth_asic_base+WD_MSR);
  	}
  	if (eth_flags & FLAG_16BIT) {
***************
*** 625,630 ****
--- 701,712 ----
  		inb(0x84);
  	}
+ }
  #endif
  #ifdef	INCLUDE_3C503
+ #ifdef	T503_AUI
+ 	nic->flags = 1;		/* aui */
+ #else
+ 	nic->flags = 0;		/* no aui */
+ #endif
          /******************************************************************
          Search for 3Com 3c503 if no WD/SMC cards
***************
*** 713,717 ****
  			printf("PIO mode");
                  else
! 			printf("memory %#hx", eth_bmem);
                  for (i=0; i<ETH_ALEN; i++) {
                          nic->node_addr[i] = inb(eth_nic_base+i);
--- 795,799 ----
  			printf("PIO mode");
                  else
! 			printf("memory %#x", eth_bmem);
                  for (i=0; i<ETH_ALEN; i++) {
                          nic->node_addr[i] = inb(eth_nic_base+i);
***************
*** 735,741 ****
  
  		if (!(eth_flags & FLAG_PIO)) {
! 			memset((char *)eth_bmem, 0, 0x2000);
  			for(i = 0; i < 0x2000; ++i)
! 				if (*(((char *)eth_bmem)+i)) {
  					printf ("Failed to clear 3c503 shared mem.\n");
  					return (0);
--- 817,823 ----
  
  		if (!(eth_flags & FLAG_PIO)) {
! 			memset(bus_to_virt(eth_bmem), 0, 0x2000);
  			for(i = 0; i < 0x2000; ++i)
! 				if (*((char *)(bus_to_virt(eth_bmem+i)))) {
  					printf ("Failed to clear 3c503 shared mem.\n");
  					return (0);
***************
*** 750,756 ****
--- 832,840 ----
  #endif
  #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390)
+ {
  	/******************************************************************
  	Search for NE1000/2000 if no WD/SMC or 3com cards
  	******************************************************************/
+ 	unsigned char c;
  	if (eth_vendor == VENDOR_NONE) {
  		char romdata[16], testbuf[32];
***************
*** 815,818 ****
--- 899,903 ----
  			nic->node_addr);
  	}
+ }
  #endif
  	if (eth_vendor == VENDOR_NONE)
***************
*** 821,831 ****
  		eth_rmem = eth_bmem;
  	ns8390_reset(nic);
! 	nic->reset = ns8390_reset;
! 	nic->poll = ns8390_poll;
  	nic->transmit = ns8390_transmit;
! 	nic->disable = ns8390_disable;
! 	return(nic);
  }
  
  /*
   * Local variables:
--- 906,984 ----
  		eth_rmem = eth_bmem;
  	ns8390_reset(nic);
! 
! 	dev->disable  = ns8390_disable; 
! 	nic->poll     = ns8390_poll;
  	nic->transmit = ns8390_transmit;
! 
!         /* Based on PnP ISA map */
! #ifdef	INCLUDE_WD
!         dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
!         dev->devid.device_id = htons(0x812a);
! #endif
! #ifdef	INCLUDE_3C503
!         dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
!         dev->devid.device_id = htons(0x80f3);
! #endif
! #ifdef	INCLUDE_NE
!         dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
!         dev->devid.device_id = htons(0x80d6);
! #endif
! 	return 1;
  }
  
+ #ifdef	INCLUDE_WD
+ static struct isa_driver wd_driver __isa_driver = {
+ 	.type    = NIC_DRIVER,
+ 	.name    = "WD",
+ 	.probe   = wd_probe,
+ 	.ioaddrs = 0, 
+ };
+ #endif
+ 
+ #ifdef	INCLUDE_3c503
+ static struct isa_driver t503_driver __isa_driver = {
+ 	.type    = NIC_DRIVER,
+ 	.name    = "3C503",
+ 	.probe   = t503_probe,
+ 	.ioaddrs = 0, 
+ };
+ #endif
+ 
+ #ifdef	INCLUDE_NE
+ static struct isa_driver ne_driver __isa_driver = {
+ 	.type    = NIC_DRIVER,
+ 	.name    = "NE*000",
+ 	.probe   = ne_probe,
+ 	.ioaddrs = 0, 
+ };
+ #endif
+ 
+ #ifdef	INCLUDE_NS8390
+ static struct pci_id nepci_nics[] = {
+ /* A few NE2000 PCI clones, list not exhaustive */
+ PCI_ROM(0x10ec, 0x8029, "rtl8029",      "Realtek 8029"),
+ PCI_ROM(0x1186, 0x0300, "dlink-528",    "D-Link DE-528"),
+ PCI_ROM(0x1050, 0x0940, "winbond940",   "Winbond NE2000-PCI"),		/* Winbond 86C940 / 89C940 */
+ PCI_ROM(0x1050, 0x5a5a, "winbond940f",  "Winbond W89c940F"),		/* Winbond 89C940F */
+ PCI_ROM(0x11f6, 0x1401, "compexrl2000", "Compex ReadyLink 2000"),
+ PCI_ROM(0x8e2e, 0x3000, "ktiet32p2",    "KTI ET32P2"),
+ PCI_ROM(0x4a14, 0x5000, "nv5000sc",     "NetVin NV5000SC"),
+ PCI_ROM(0x12c3, 0x0058, "holtek80232",  "Holtek HT80232"),
+ PCI_ROM(0x12c3, 0x5598, "holtek80229",  "Holtek HT80229"),
+ PCI_ROM(0x10bd, 0x0e34, "surecom-ne34", "Surecom NE34"),
+ PCI_ROM(0x1106, 0x0926, "via86c926",    "Via 86c926"),
+ };
+ 
+ struct pci_driver nepci_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "NE2000/PCI",
+ 	.probe    = nepci_probe,
+ 	.ids      = nepci_nics,
+ 	.id_count = sizeof(nepci_nics)/sizeof(nepci_nics[0]),
+ 	.class    = 0,
+ };
+ 
+ #endif /* INCLUDE_NS8390 */
+ 
  /*
   * Local variables:
diff -rc2P -x CVS GRUB_0.94/netboot/osdep.h GRUB/netboot/osdep.h
*** GRUB_0.94/netboot/osdep.h	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/osdep.h	2003-11-11 21:38:02.000000000 +0800
***************
*** 1,94 ****
! #ifndef	__OSDEP_H__
! #define __OSDEP_H__
  
! /*
!  * This program is free software; you can redistribute it and/or
!  * modify it under the terms of the GNU General Public License as
!  * published by the Free Software Foundation; either version 2, or (at
!  * your option) any later version.
!  */
! 
! #define	__LITTLE_ENDIAN		/* x86 */
! 
! /* Taken from /usr/include/linux/hfs_sysdep.h */
! #if defined(__BIG_ENDIAN)
! #	if !defined(__constant_htonl)
! #		define __constant_htonl(x) (x)
! #	endif
! #	if !defined(__constant_htons)
! #		define __constant_htons(x) (x)
! #	endif
! #elif defined(__LITTLE_ENDIAN)
! #	if !defined(__constant_htonl)
! #		define __constant_htonl(x) \
!         ((unsigned long int)((((unsigned long int)(x) & 0x000000ffU) << 24) | \
!                              (((unsigned long int)(x) & 0x0000ff00U) <<  8) | \
!                              (((unsigned long int)(x) & 0x00ff0000U) >>  8) | \
!                              (((unsigned long int)(x) & 0xff000000U) >> 24)))
! #	endif
! #	if !defined(__constant_htons)
! #		define __constant_htons(x) \
!         ((unsigned short int)((((unsigned short int)(x) & 0x00ff) << 8) | \
!                               (((unsigned short int)(x) & 0xff00) >> 8)))
! #	endif
! #else
! #	error "Don't know if bytes are big- or little-endian!"
! #endif
! 
! #define ntohl(x) \
! (__builtin_constant_p(x) ? \
!  __constant_htonl((x)) : \
!  __swap32(x))
! #define htonl(x) \
! (__builtin_constant_p(x) ? \
!  __constant_htonl((x)) : \
!  __swap32(x))
! #define ntohs(x) \
! (__builtin_constant_p(x) ? \
!  __constant_htons((x)) : \
!  __swap16(x))
! #define htons(x) \
! (__builtin_constant_p(x) ? \
!  __constant_htons((x)) : \
!  __swap16(x))
! 
! static inline unsigned long int __swap32(unsigned long int x)
! {
! 	__asm__("xchgb %b0,%h0\n\t"
! 		"rorl $16,%0\n\t"
! 		"xchgb %b0,%h0"
! 		: "=q" (x)
! 		: "0" (x));
! 	return x;
! }
! 
! static inline unsigned short int __swap16(unsigned short int x)
! {
! 	__asm__("xchgb %b0,%h0"
! 		: "=q" (x)
! 		: "0" (x));
! 	return x;
! }
! 
! /* Make routines available to all */
! #define	swap32(x)	__swap32(x)
! #define	swap16(x)	__swap16(x)
! 
! #include "linux-asm-io.h"
! 
! typedef	unsigned long Address;
  
  /* ANSI prototyping macro */
  #ifdef	__STDC__
! #define	P(x)	x
  #else
! #define	P(x)	()
  #endif
  
  #endif
- 
- /*
-  * Local variables:
-  *  c-basic-offset: 8
-  * End:
-  */
--- 1,14 ----
! #ifndef	_OSDEP_H
! #define _OSDEP_H
  
! #define __unused __attribute__((unused))
! #define __aligned __attribute__((aligned(16)))
  
  /* ANSI prototyping macro */
  #ifdef	__STDC__
! #  define	P(x)	x
  #else
! #  define	P(x)	()
  #endif
  
  #endif
Only in GRUB_0.94/netboot: otulip.c
Only in GRUB_0.94/netboot: otulip.h
diff -rc2P -x CVS GRUB_0.94/netboot/pci.c GRUB/netboot/pci.c
*** GRUB_0.94/netboot/pci.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/pci.c	2003-11-12 21:03:29.000000000 +0800
***************
*** 1,14 ****
- /*
- ** Support for NE2000 PCI clones added David Monro June 1997
- ** Generalised to other NICs by Ken Yap July 1997
- **
- ** Most of this is taken from:
- **
- ** /usr/src/linux/drivers/pci/pci.c
- ** /usr/src/linux/include/linux/pci.h
- ** /usr/src/linux/arch/i386/bios32.c
- ** /usr/src/linux/include/linux/bios32.h
- ** /usr/src/linux/drivers/net/ne.c
- */
  
  /*
--- 1,2 ----
***************
*** 19,418 ****
   */
  
! #include "etherboot.h"
  #include "pci.h"
  
! /*#define	DEBUG	1*/
! #define DEBUG	0
! 
! #ifdef	CONFIG_PCI_DIRECT
! #define  PCIBIOS_SUCCESSFUL                0x00
! 
! /*
!  * Functions for accessing PCI configuration space with type 1 accesses
!  */
! 
! #define CONFIG_CMD(bus, device_fn, where)   (0x80000000 | (bus << 16) | (device_fn << 8) | (where & ~3))
! 
! int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn,
! 			       unsigned int where, unsigned char *value)
! {
!     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
!     *value = inb(0xCFC + (where&3));
!     return PCIBIOS_SUCCESSFUL;
! }
! 
! int pcibios_read_config_word (unsigned int bus,
!     unsigned int device_fn, unsigned int where, unsigned short *value)
! {
!     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
!     *value = inw(0xCFC + (where&2));
!     return PCIBIOS_SUCCESSFUL;
! }
! 
! int pcibios_read_config_dword (unsigned int bus, unsigned int device_fn,
! 				 unsigned int where, unsigned int *value)
! {
!     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
!     *value = inl(0xCFC);
!     return PCIBIOS_SUCCESSFUL;
! }
! 
! int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn,
! 				 unsigned int where, unsigned char value)
! {
!     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
!     outb(value, 0xCFC + (where&3));
!     return PCIBIOS_SUCCESSFUL;
! }
! 
! int pcibios_write_config_word (unsigned int bus, unsigned int device_fn,
! 				 unsigned int where, unsigned short value)
! {
!     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
!     outw(value, 0xCFC + (where&2));
!     return PCIBIOS_SUCCESSFUL;
! }
! 
! int pcibios_write_config_dword (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int value)
! {
!     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
!     outl(value, 0xCFC);
!     return PCIBIOS_SUCCESSFUL;
! }
! 
! #undef CONFIG_CMD
! 
! #else	 /* CONFIG_PCI_DIRECT  not defined */
! 
! static struct {
! 	unsigned long address;
! 	unsigned short segment;
! } bios32_indirect = { 0, KERN_CODE_SEG };
! 
! static long pcibios_entry;
! static struct {
! 	unsigned long address;
! 	unsigned short segment;
! } pci_indirect = { 0, KERN_CODE_SEG };
! 
! static unsigned long bios32_service(unsigned long service)
! {
! 	unsigned char return_code;	/* %al */
! 	unsigned long address;		/* %ebx */
! 	unsigned long length;		/* %ecx */
! 	unsigned long entry;		/* %edx */
! 	unsigned long flags;
! 
! 	save_flags(flags);
! 	__asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%edi)"
! #else
! 		"lcall *(%%edi)"
! #endif
! 		: "=a" (return_code),
! 		  "=b" (address),
! 		  "=c" (length),
! 		  "=d" (entry)
! 		: "0" (service),
! 		  "1" (0),
! 		  "D" (&bios32_indirect));
! 	restore_flags(flags);
! 
! 	switch (return_code) {
! 		case 0:
! 			return address + entry;
! 		case 0x80:	/* Not present */
! 			printf("bios32_service(%d) : not present\n", service);
! 			return 0;
! 		default: /* Shouldn't happen */
! 			printf("bios32_service(%d) : returned %#X, mail drew@colorado.edu\n",
! 				service, return_code);
! 			return 0;
! 	}
! }
! 
! int pcibios_read_config_byte(unsigned int bus,
!         unsigned int device_fn, unsigned int where, unsigned char *value)
! {
!         unsigned long ret;
!         unsigned long bx = (bus << 8) | device_fn;
!         unsigned long flags;
! 
!         save_flags(flags);
!         __asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%esi)\n\t"
! #else
! 		"lcall *(%%esi)\n\t"
! #endif
!                 "jc 1f\n\t"
!                 "xor %%ah, %%ah\n"
!                 "1:"
!                 : "=c" (*value),
!                   "=a" (ret)
!                 : "1" (PCIBIOS_READ_CONFIG_BYTE),
!                   "b" (bx),
!                   "D" ((long) where),
!                   "S" (&pci_indirect));
!         restore_flags(flags);
!         return (int) (ret & 0xff00) >> 8;
! }
! 
! int pcibios_read_config_word(unsigned int bus,
!         unsigned int device_fn, unsigned int where, unsigned short *value)
! {
!         unsigned long ret;
!         unsigned long bx = (bus << 8) | device_fn;
!         unsigned long flags;
! 
!         save_flags(flags);
!         __asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%esi)\n\t"
! #else
! 		"lcall *(%%esi)\n\t"
! #endif
!                 "jc 1f\n\t"
!                 "xor %%ah, %%ah\n"
!                 "1:"
!                 : "=c" (*value),
!                   "=a" (ret)
!                 : "1" (PCIBIOS_READ_CONFIG_WORD),
!                   "b" (bx),
!                   "D" ((long) where),
!                   "S" (&pci_indirect));
!         restore_flags(flags);
!         return (int) (ret & 0xff00) >> 8;
! }
! 
! int pcibios_read_config_dword(unsigned int bus,
!         unsigned int device_fn, unsigned int where, unsigned int *value)
! {
!         unsigned long ret;
!         unsigned long bx = (bus << 8) | device_fn;
!         unsigned long flags;
! 
!         save_flags(flags);
!         __asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%esi)\n\t"
! #else
! 		"lcall *(%%esi)\n\t"
! #endif
!                 "jc 1f\n\t"
!                 "xor %%ah, %%ah\n"
!                 "1:"
!                 : "=c" (*value),
!                   "=a" (ret)
!                 : "1" (PCIBIOS_READ_CONFIG_DWORD),
!                   "b" (bx),
!                   "D" ((long) where),
!                   "S" (&pci_indirect));
!         restore_flags(flags);
!         return (int) (ret & 0xff00) >> 8;
! }
! 
! int pcibios_write_config_byte (unsigned int bus,
! 	unsigned int device_fn, unsigned int where, unsigned char value)
! {
! 	unsigned long ret;
! 	unsigned long bx = (bus << 8) | device_fn;
! 	unsigned long flags;
! 
! 	save_flags(flags); cli();
! 	__asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%esi)\n\t"
! #else
! 		"lcall *(%%esi)\n\t"
! #endif
! 		"jc 1f\n\t"
! 		"xor %%ah, %%ah\n"
! 		"1:"
! 		: "=a" (ret)
! 		: "0" (PCIBIOS_WRITE_CONFIG_BYTE),
! 		  "c" (value),
! 		  "b" (bx),
! 		  "D" ((long) where),
! 		  "S" (&pci_indirect));
! 	restore_flags(flags);
! 	return (int) (ret & 0xff00) >> 8;
! }
! 
! int pcibios_write_config_word (unsigned int bus,
! 	unsigned int device_fn, unsigned int where, unsigned short value)
! {
! 	unsigned long ret;
! 	unsigned long bx = (bus << 8) | device_fn;
! 	unsigned long flags;
! 
! 	save_flags(flags); cli();
! 	__asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%esi)\n\t"
! #else
! 		"lcall *(%%esi)\n\t"
! #endif
! 		"jc 1f\n\t"
! 		"xor %%ah, %%ah\n"
! 		"1:"
! 		: "=a" (ret)
! 		: "0" (PCIBIOS_WRITE_CONFIG_WORD),
! 		  "c" (value),
! 		  "b" (bx),
! 		  "D" ((long) where),
! 		  "S" (&pci_indirect));
! 	restore_flags(flags);
! 	return (int) (ret & 0xff00) >> 8;
! }
! 
! int pcibios_write_config_dword (unsigned int bus,
! 	unsigned int device_fn, unsigned int where, unsigned int value)
! {
! 	unsigned long ret;
! 	unsigned long bx = (bus << 8) | device_fn;
! 	unsigned long flags;
! 
! 	save_flags(flags); cli();
! 	__asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 		"lcall (%%esi)\n\t"
! #else
! 		"lcall *(%%esi)\n\t"
! #endif
! 		"jc 1f\n\t"
! 		"xor %%ah, %%ah\n"
! 		"1:"
! 		: "=a" (ret)
! 		: "0" (PCIBIOS_WRITE_CONFIG_DWORD),
! 		  "c" (value),
! 		  "b" (bx),
! 		  "D" ((long) where),
! 		  "S" (&pci_indirect));
! 	restore_flags(flags);
! 	return (int) (ret & 0xff00) >> 8;
! }
! 
! static void check_pcibios(void)
! {
! 	unsigned long signature;
! 	unsigned char present_status;
! 	unsigned char major_revision;
! 	unsigned char minor_revision;
! 	unsigned long flags;
! 	int pack;
! 
! 	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
! 		pci_indirect.address = pcibios_entry;
! 
! 		save_flags(flags);
! 		__asm__(
! #ifdef ABSOLUTE_WITHOUT_ASTERISK
! 			"lcall (%%edi)\n\t"
! #else
! 			"lcall *(%%edi)\n\t"
! #endif
! 			"jc 1f\n\t"
! 			"xor %%ah, %%ah\n"
! 			"1:\tshl $8, %%eax\n\t"
! 			"movw %%bx, %%ax"
! 			: "=d" (signature),
! 			  "=a" (pack)
! 			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
! 			  "D" (&pci_indirect)
! 			: "bx", "cx");
! 		restore_flags(flags);
! 
! 		present_status = (pack >> 16) & 0xff;
! 		major_revision = (pack >> 8) & 0xff;
! 		minor_revision = pack & 0xff;
! 		if (present_status || (signature != PCI_SIGNATURE)) {
! 			printf("ERROR: BIOS32 says PCI BIOS, but no PCI "
! 				"BIOS????\n");
! 			pcibios_entry = 0;
  		}
! #if	DEBUG
! 		if (pcibios_entry) {
! 			printf ("pcibios_init : PCI BIOS revision %hhX.%hhX"
! 				" entry at %#X\n", major_revision,
! 				minor_revision, pcibios_entry);
  		}
- #endif
  	}
! }
! 
! static void pcibios_init(void)
! {
! 	union bios32 *check;
! 	unsigned char sum;
! 	int i, length;
! 	unsigned long bios32_entry = 0;
! 
! 	/*
! 	 * Follow the standard procedure for locating the BIOS32 Service
! 	 * directory by scanning the permissible address range from
! 	 * 0xe0000 through 0xfffff for a valid BIOS32 structure.
! 	 *
! 	 */
! 
! 	for (check = (union bios32 *) 0xe0000; check <= (union bios32 *) 0xffff0; ++check) {
! 		if (check->fields.signature != BIOS32_SIGNATURE)
! 			continue;
! 		length = check->fields.length * 16;
! 		if (!length)
! 			continue;
! 		sum = 0;
! 		for (i = 0; i < length ; ++i)
! 			sum += check->chars[i];
! 		if (sum != 0)
  			continue;
! 		if (check->fields.revision != 0) {
! 			printf("pcibios_init : unsupported revision %d at %#X, mail drew@colorado.edu\n",
! 				check->fields.revision, check);
  			continue;
  		}
! #if	DEBUG
! 		printf("pcibios_init : BIOS32 Service Directory "
! 			"structure at %#X\n", check);
! #endif
! 		if (!bios32_entry) {
! 			if (check->fields.entry >= 0x100000) {
! 				printf("pcibios_init: entry in high "
! 					"memory, giving up\n");
! 				return;
! 			} else {
! 				bios32_entry = check->fields.entry;
! #if	DEBUG
! 				printf("pcibios_init : BIOS32 Service Directory"
! 					" entry at %#X\n", bios32_entry);
! #endif
! 				bios32_indirect.address = bios32_entry;
! 			}
  		}
  	}
! 	if (bios32_entry)
! 		check_pcibios();
  }
- #endif	/* CONFIG_PCI_DIRECT not defined*/
  
! static void scan_bus(struct pci_device *pcidev)
  {
! 	unsigned int devfn, l, bus, buses;
  	unsigned char hdr_type = 0;
! 	unsigned short vendor, device;
! 	unsigned int membase, ioaddr, romaddr;
! 	int i, reg;
! 	unsigned int pci_ioaddr = 0;
! 
  	/* Scan all PCI buses, until we find our card.
! 	 * We could be smart only scan the required busses but that
  	 * is error prone, and tricky.
! 	 * By scanning all possible pci busses in order we should find
  	 * our card eventually. 
  	 */
  	buses=256;
! 	for (bus = 0; bus < buses; ++bus) {
! 		for (devfn = 0; devfn < 0xff; ++devfn) {
  			if (PCI_FUNC (devfn) == 0)
  				pcibios_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);
--- 7,243 ----
   */
  
! #include "grub.h"
  #include "pci.h"
  
! #ifdef INCLUDE_3C595
! extern struct pci_driver t595_driver;
! #endif /* INCLUDE_3C595 */
! 
! #ifdef INCLUDE_3C90X
! extern struct pci_driver a3c90x_driver;
! #endif /* INCLUDE_3C90X */
! 
! #ifdef INCLUDE_DAVICOM
! extern struct pci_driver davicom_driver;
! #endif /* INCLUDE_DAVICOM */
! 
! #ifdef INCLUDE_E1000
! extern struct pci_driver e1000_driver;
! #endif /* INCLUDE_E1000 */
! 
! #ifdef INCLUDE_EEPRO100
! extern struct pci_driver eepro100_driver;
! #endif /* INCLUDE_EEPRO100 */
! 
! #ifdef INCLUDE_EPIC100
! extern struct pci_driver epic100_driver;
! #endif /* INCLUDE_EPIC100 */
! 
! #ifdef INCLUDE_NATSEMI
! extern struct pci_driver natsemi_driver;
! #endif /* INCLUDE_NATSEMI */
! 
! #ifdef INCLUDE_NS8390
! extern struct pci_driver nepci_driver;
! #endif /* INCLUDE_NS8390 */
! 
! #ifdef INCLUDE_PCNET32
! extern struct pci_driver pcnet32_driver;
! #endif /* INCLUDE_PCNET32 */
! 
! #ifdef INCLUDE_RTL8139
! extern struct pci_driver rtl8139_driver;
! #endif /* INCLUDE_RTL8139 */
! 
! #ifdef INCLUDE_SIS900
! extern struct pci_driver sis900_driver;
! #endif /* INCLUDE_SIS900 */
! 
! #ifdef INCLUDE_TG3
! extern struct pci_driver  tg3_driver;
! #endif /* INCLUDE_TG3 */
! 
! #ifdef INCLUDE_TLAN
! extern struct pci_driver tlan_driver;
! #endif /* INCLUDE_TLAN */
! 
! #ifdef INCLUDE_TULIP
! extern struct pci_driver tulip_driver;
! #endif /* INCLUDE_TULIP */
! 
! #ifdef INCLUDE_VIA_RHINE
! extern struct pci_driver rhine_driver;
! #endif/* INCLUDE_VIA_RHINE */
! 
! #ifdef INCLUDE_W89C840
! extern struct pci_driver w89c840_driver;
! #endif /* INCLUDE_W89C840 */
! 
! #ifdef INCLUDE_SUNDANCE
! extern struct pci_dirver sundance_driver;
! #endif
! 
! static const struct pci_driver *pci_drivers[] = {
! 
! #ifdef INCLUDE_3C595
! 	&t595_driver,
! #endif /* INCLUDE_3C595 */
! 
! #ifdef INCLUDE_3C90X
! 	&a3c90x_driver,
! #endif /* INCLUDE_3C90X */
! 
! #ifdef INCLUDE_DAVICOM
! 	&davicom_driver,
! #endif /* INCLUDE_DAVICOM */
! 
! #ifdef INCLUDE_E1000
! 	&e1000_driver,
! #endif /* INCLUDE_E1000 */
! 
! #ifdef INCLUDE_EEPRO100
! 	&eepro100_driver,
! #endif /* INCLUDE_EEPRO100 */
! 
! #ifdef INCLUDE_EPIC100
! 	&epic100_driver,
! #endif /* INCLUDE_EPIC100 */
! 
! #ifdef INCLUDE_NATSEMI
! 	&natsemi_driver,
! #endif /* INCLUDE_NATSEMI */
! 
! #ifdef INCLUDE_NS8390
! 	&nepci_driver,
! #endif /* INCLUDE_NS8390 */
! 
! #ifdef INCLUDE_PCNET32
! 	&pcnet32_driver,
! #endif /* INCLUDE_PCNET32 */
! 
! #ifdef INCLUDE_RTL8139
! 	&rtl8139_driver,
! #endif /* INCLUDE_RTL8139 */
! 
! #ifdef INCLUDE_SIS900
! 	&sis900_driver,
! #endif /* INCLUDE_SIS900 */
! 
! #ifdef INCLUDE_SUNDANCE
! 	&sundance_driver,
! #endif
! 
! #ifdef INCLUDE_TG3
! 	& tg3_driver,
! #endif /* INCLUDE_TG3 */
! 
! #ifdef INCLUDE_TLAN
! 	&tlan_driver,
! #endif /* INCLUDE_TLAN */
! 
! #ifdef INCLUDE_TULIP
! 	& tulip_driver,
! #endif /* INCLUDE_TULIP */
! 
! #ifdef INCLUDE_VIA_RHINE
! 	&rhine_driver,
! #endif/* INCLUDE_VIA_RHINE */
! 
! #ifdef INCLUDE_W89C840
! 	&w89c840_driver,
! #endif /* INCLUDE_W89C840 */
! 	0
! };
! 
! static void scan_drivers(
! 	int type, 
! 	uint32_t class, uint16_t vendor, uint16_t device,
! 	const struct pci_driver *last_driver, struct pci_device *dev)
! {
! 	const struct pci_driver *skip_driver = last_driver;
! 	/* Assume there is only one match of the correct type */
! 	const struct pci_driver *driver;
! 	int i, j;
! 	
! 	for(j = 0; pci_drivers[j] != 0; j++){
! 		driver = pci_drivers[j];
! 		if (driver->type != type)
! 			continue;
! 		if (skip_driver) {
! 			if (skip_driver == driver) 
! 				skip_driver = 0;
! 			continue;
  		}
! 		for(i = 0; i < driver->id_count; i++) {
! 			if ((vendor == driver->ids[i].vendor) &&
! 			    (device == driver->ids[i].dev_id)) {
! 				
! 				dev->driver = driver;
! 				dev->name   = driver->ids[i].name;
! 
! 				goto out;
! 			}
  		}
  	}
! 	if (!class) {
! 		goto out;
! 	}
! 	for(j = 0; pci_drivers[j] != 0; j++){
! 		driver = pci_drivers[j];
! 		if (driver->type != type)
  			continue;
! 		if (skip_driver) {
! 			if (skip_driver == driver)
! 				skip_driver = 0;
  			continue;
  		}
! 		if (last_driver == driver)
! 			continue;
! 		if ((class >> 8) == driver->class) {
! 			dev->driver = driver;
! 			dev->name   = driver->name;
! 			goto out;
  		}
  	}
!  out:
! 	return;
  }
  
! void scan_pci_bus(int type, struct pci_device *dev)
  {
! 	unsigned int first_bus, first_devfn;
! 	const struct pci_driver *first_driver;
! 	unsigned int devfn, bus, buses;
  	unsigned char hdr_type = 0;
! 	uint32_t class;
! 	uint16_t vendor, device;
! 	uint32_t l, membase, ioaddr, romaddr;
! 	int reg;
! 
! 	EnterFunction("scan_pci_bus");
! 	first_bus    = 0;
! 	first_devfn  = 0;
! 	first_driver = 0;
! 	if (dev->driver) {
! 		first_driver = dev->driver;
! 		first_bus    = dev->bus;
! 		first_devfn  = dev->devfn;
! 		/* Re read the header type on a restart */
! 		pcibios_read_config_byte(first_bus, first_devfn & ~0x7, 
! 			PCI_HEADER_TYPE, &hdr_type);
! 		dev->driver  = 0;
! 		dev->bus     = 0;
! 		dev->devfn   = 0;
! 	}
! 		
  	/* Scan all PCI buses, until we find our card.
! 	 * We could be smart only scan the required buses but that
  	 * is error prone, and tricky.
! 	 * By scanning all possible pci buses in order we should find
  	 * our card eventually. 
  	 */
  	buses=256;
! 	for (bus = first_bus; bus < buses; ++bus) {
! 		for (devfn = first_devfn; devfn < 0xff; ++devfn, first_driver = 0) {
  			if (PCI_FUNC (devfn) == 0)
  				pcibios_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);
***************
*** 422,426 ****
  			/* some broken boards return 0 if a slot is empty: */
  			if (l == 0xffffffff || l == 0x00000000) {
- 				hdr_type = 0;
  				continue;
  			}
--- 247,250 ----
***************
*** 428,480 ****
  			device = (l >> 16) & 0xffff;
  
  #if	DEBUG
! 			printf("bus %hhX, function %hhX, vendor %hX, device %hX\n",
! 				bus, devfn, vendor, device);
  #endif
! 			for (i = 0; pcidev[i].vendor != 0; i++) {
! 				if (vendor != pcidev[i].vendor
! 				    || device != pcidev[i].dev_id)
  					continue;
! 				pcidev[i].devfn = devfn;
! 				pcidev[i].bus = bus;
! 				for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
! 					pcibios_read_config_dword(bus, devfn, reg, &ioaddr);
! 
! 					if ((ioaddr & PCI_BASE_ADDRESS_IO_MASK) == 0 || (ioaddr & PCI_BASE_ADDRESS_SPACE_IO) == 0)
! 						continue;
! 					/* Strip the I/O address out of the returned value */
! 					ioaddr &= PCI_BASE_ADDRESS_IO_MASK;
! 					/* Get the memory base address */
! 					pcibios_read_config_dword(bus, devfn,
! 						PCI_BASE_ADDRESS_1, &membase);
! 					/* Get the ROM base address */
! 					pcibios_read_config_dword(bus, devfn, PCI_ROM_ADDRESS, &romaddr);
! 					romaddr >>= 10;
! 					printf("Found %s at %#hx, ROM address %#hx\n",
! 						pcidev[i].name, ioaddr, romaddr);
! 					/* Take the first one or the one that matches in boot ROM address */
! 					if (pci_ioaddr == 0 || romaddr == ((unsigned long) rom.rom_segment << 4)) {
! 						pcidev[i].membase = membase;
! 						pcidev[i].ioaddr = ioaddr;
! 						return;
! 					}
! 				}
  			}
  		}
  	}
  }
  
! void eth_pci_init(struct pci_device *pcidev)
! {
! #ifndef	CONFIG_PCI_DIRECT
! 	pcibios_init();
! 	if (!pcibios_entry) {
! 		printf("pci_init: no BIOS32 detected\n");
! 		return;
! 	}
! #endif
! 	scan_bus(pcidev);
! 	/* return values are in pcidev structures */
! }
  
  /*
--- 252,334 ----
  			device = (l >> 16) & 0xffff;
  
+ 			pcibios_read_config_dword(bus, devfn, PCI_REVISION, &l);
+ 			class = (l >> 8) & 0xffffff;
  #if	DEBUG
! 		{
! 			int i;
! 			printf("%hhx:%hhx.%hhx [%hX/%hX] ---- ",
! 				bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
! 				vendor, device);
! #if	DEBUG > 1
! 			for(i = 0; i < 256; i++) {
! 				unsigned char byte;
! 				if ((i & 0xf) == 0) {
! 					printf("%hhx: ", i);
! 				}
! 				pcibios_read_config_byte(bus, devfn, i, &byte);
! 				printf("%hhx ", byte);
! 				if ((i & 0xf) == 0xf) {
! 					printf("\n");
! 				}
! 			}
! #endif
! 
! 		}
! #endif
! 			scan_drivers(type, class, vendor, device, first_driver, dev);
! 			if (!dev->driver){
! #if DEBUG
! 				printf("No driver fit.\n");
! #endif
! 				continue;
! 			}
! #if DEBUG
! 			printf("Get Driver:\n");
  #endif
! 			dev->devfn = devfn;
! 			dev->bus = bus;
! 			dev->class = class;
! 			dev->vendor = vendor;
! 			dev->dev_id = device;
! 			
! 			
! 			/* Get the ROM base address */
! 			pcibios_read_config_dword(bus, devfn, 
! 				PCI_ROM_ADDRESS, &romaddr);
! 			romaddr >>= 10;
! 			dev->romaddr = romaddr;
! 			
! 			/* Get the ``membase'' */
! 			pcibios_read_config_dword(bus, devfn,
! 				PCI_BASE_ADDRESS_1, &membase);
! 			dev->membase = membase;
! 				
! 			/* Get the ``ioaddr'' */
! 			for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
! 				pcibios_read_config_dword(bus, devfn, reg, &ioaddr);
! 				if ((ioaddr & PCI_BASE_ADDRESS_IO_MASK) == 0 || (ioaddr & PCI_BASE_ADDRESS_SPACE_IO) == 0)
  					continue;
! 				
! 				
! 				/* Strip the I/O address out of the returned value */
! 				ioaddr &= PCI_BASE_ADDRESS_IO_MASK;
! 				
! 				/* Take the first one or the one that matches in boot ROM address */
! 				dev->ioaddr = ioaddr;
  			}
+ #if DEBUG > 2
+ 			printf("Found %s ROM address %#hx\n",
+ 				dev->name, romaddr);
+ #endif
+ 			LeaveFunction("scan_pci_bus");
+ 			return;
  		}
+ 		first_devfn = 0;
  	}
+ 	first_bus = 0;
+ 	LeaveFunction("scan_pci_bus");
  }
  
! 
  
  /*
***************
*** 490,501 ****
  	new_command = pci_command | PCI_COMMAND_MASTER|PCI_COMMAND_IO;
  	if (pci_command != new_command) {
! 		printf("The PCI BIOS has not enabled this device!\nUpdating PCI command %hX->%hX. pci_bus %hhX pci_device_fn %hhX\n",
  			   pci_command, new_command, p->bus, p->devfn);
  		pcibios_write_config_word(p->bus, p->devfn, PCI_COMMAND, new_command);
  	}
  	pcibios_read_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, &pci_latency);
  	if (pci_latency < 32) {
! 		printf("PCI latency timer (CFLT) is unreasonably low at %d. Setting to 32 clocks.\n", pci_latency);
  		pcibios_write_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, 32);
  	}
  }
--- 344,476 ----
  	new_command = pci_command | PCI_COMMAND_MASTER|PCI_COMMAND_IO;
  	if (pci_command != new_command) {
! #if DEBUG > 0
! 		printf(
! 			"The PCI BIOS has not enabled this device!\n"
! 			"Updating PCI command %hX->%hX. pci_bus %hhX pci_device_fn %hhX\n",
  			   pci_command, new_command, p->bus, p->devfn);
+ #endif
  		pcibios_write_config_word(p->bus, p->devfn, PCI_COMMAND, new_command);
  	}
  	pcibios_read_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, &pci_latency);
  	if (pci_latency < 32) {
! #if DEBUG > 0
! 		printf("PCI latency timer (CFLT) is unreasonably low at %d. Setting to 32 clocks.\n", 
! 			pci_latency);
! #endif
  		pcibios_write_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, 32);
  	}
  }
+ 
+ /*
+  * Find the start of a pci resource.
+  */
+ unsigned long pci_bar_start(struct pci_device *dev, unsigned int index)
+ {
+ 	uint32_t lo, hi;
+ 	unsigned long bar;
+ 	pci_read_config_dword(dev, index, &lo);
+ 	if (lo & PCI_BASE_ADDRESS_SPACE_IO) {
+ 		bar = lo & PCI_BASE_ADDRESS_IO_MASK;
+ 	} else {
+ 		bar = 0;
+ 		if ((lo & PCI_BASE_ADDRESS_MEM_TYPE_MASK) == PCI_BASE_ADDRESS_MEM_TYPE_64) {
+ 			pci_read_config_dword(dev, index + 4, &hi);
+ 			if (hi) {
+ 				if (sizeof(unsigned long) > sizeof(uint32_t)) {
+ 					bar = hi;
+ 					/* It's REALLY interesting:-) */
+ 					bar <<=32;
+ 				}
+ 				else {
+ 					printf("Unhandled 64bit BAR\n");
+ 					return -1UL;
+ 				}
+ 			}
+ 		}
+ 		bar |= lo & PCI_BASE_ADDRESS_MEM_MASK;
+ 	}
+ 	return bar + pcibios_bus_base(dev->bus);
+ }
+ 
+ /*
+  * Find the size of a pci resource.
+  */
+ unsigned long pci_bar_size(struct pci_device *dev, unsigned int bar)
+ {
+ 	uint32_t start, size;
+ 	/* Save the original bar */
+ 	pci_read_config_dword(dev, bar, &start);
+ 	/* Compute which bits can be set */
+ 	pci_write_config_dword(dev, bar, ~0);
+ 	pci_read_config_dword(dev, bar, &size);
+ 	/* Restore the original size */
+ 	pci_write_config_dword(dev, bar, start);
+ 	/* Find the significant bits */
+ 	if (start & PCI_BASE_ADDRESS_SPACE_IO) {
+ 		size &= PCI_BASE_ADDRESS_IO_MASK;
+ 	} else {
+ 		size &= PCI_BASE_ADDRESS_MEM_MASK;
+ 	}
+ 	/* Find the lowest bit set */
+ 	size = size & ~(size - 1);
+ 	return size;
+ }
+ 
+ /**
+  * pci_find_capability - query for devices' capabilities 
+  * @dev: PCI device to query
+  * @cap: capability code
+  *
+  * Tell if a device supports a given PCI capability.
+  * Returns the address of the requested capability structure within the
+  * device's PCI configuration space or 0 in case the device does not
+  * support it.  Possible values for @cap:
+  *
+  *  %PCI_CAP_ID_PM           Power Management 
+  *
+  *  %PCI_CAP_ID_AGP          Accelerated Graphics Port 
+  *
+  *  %PCI_CAP_ID_VPD          Vital Product Data 
+  *
+  *  %PCI_CAP_ID_SLOTID       Slot Identification 
+  *
+  *  %PCI_CAP_ID_MSI          Message Signalled Interrupts
+  *
+  *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap 
+  */
+ int pci_find_capability(struct pci_device *dev, int cap)
+ {
+ 	uint16_t status;
+ 	uint8_t pos, id;
+ 	uint8_t hdr_type;
+ 	int ttl = 48;
+ 
+ 	pci_read_config_word(dev, PCI_STATUS, &status);
+ 	if (!(status & PCI_STATUS_CAP_LIST))
+ 		return 0;
+ 	pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type);
+ 	switch (hdr_type & 0x7F) {
+ 	case PCI_HEADER_TYPE_NORMAL:
+ 	case PCI_HEADER_TYPE_BRIDGE:
+ 	default:
+ 		pci_read_config_byte(dev, PCI_CAPABILITY_LIST, &pos);
+ 		break;
+ 	case PCI_HEADER_TYPE_CARDBUS:
+ 		pci_read_config_byte(dev, PCI_CB_CAPABILITY_LIST, &pos);
+ 		break;
+ 	}
+ 	while (ttl-- && pos >= 0x40) {
+ 		pos &= ~3;
+ 		pci_read_config_byte(dev, pos + PCI_CAP_LIST_ID, &id);
+ #if	DEBUG > 0
+ 		printf("Capability: %d\n", id);
+ #endif
+ 		if (id == 0xff)
+ 			break;
+ 		if (id == cap)
+ 			return pos;
+ 		pci_read_config_byte(dev, pos + PCI_CAP_LIST_NEXT, &pos);
+ 	}
+ 	return 0;
+ }
+ 
diff -rc2P -x CVS GRUB_0.94/netboot/pci.h GRUB/netboot/pci.h
*** GRUB_0.94/netboot/pci.h	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/pci.h	2003-11-11 20:43:02.000000000 +0800
***************
*** 1,3 ****
! #ifndef	PCI_H
  #define PCI_H
  
--- 1,3 ----
! #if !defined(PCI_H) && defined(CONFIG_PCI)
  #define PCI_H
  
***************
*** 22,29 ****
--- 22,39 ----
   */
  
+ #include "pci_ids.h"
+ #include "types.h"
+ 
  #define PCI_COMMAND_IO			0x1	/* Enable response in I/O space */
  #define PCI_COMMAND_MEM			0x2	/* Enable response in mem space */
  #define PCI_COMMAND_MASTER		0x4	/* Enable bus mastering */
  #define PCI_LATENCY_TIMER		0x0d	/* 8 bits */
+ #define PCI_COMMAND_SPECIAL		0x8	/* Enable response to special cycles */
+ #define PCI_COMMAND_INVALIDATE		0x10	/* Use memory write and invalidate */
+ #define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
+ #define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+ #define  PCI_COMMAND_WAIT 	0x80	/* Enable address/data stepping */
+ #define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+ #define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
  
  #define PCIBIOS_PCI_FUNCTION_ID         0xb1XX
***************
*** 43,50 ****
--- 53,87 ----
  #define PCI_COMMAND             0x04    /* 16 bits */
  
+ #define PCI_STATUS		0x06	/* 16 bits */
+ #define  PCI_STATUS_CAP_LIST	0x10	/* Support Capability List */
+ #define  PCI_STATUS_66MHZ	0x20	/* Support 66 Mhz PCI 2.1 bus */
+ #define  PCI_STATUS_UDF		0x40	/* Support User Definable Features [obsolete] */
+ #define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
+ #define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+ #define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
+ #define  PCI_STATUS_DEVSEL_FAST	0x000	
+ #define  PCI_STATUS_DEVSEL_MEDIUM 0x200
+ #define  PCI_STATUS_DEVSEL_SLOW 0x400
+ #define  PCI_STATUS_SIG_TARGET_ABORT 0x800 /* Set on target abort */
+ #define  PCI_STATUS_REC_TARGET_ABORT 0x1000 /* Master ack of " */
+ #define  PCI_STATUS_REC_MASTER_ABORT 0x2000 /* Set on master abort */
+ #define  PCI_STATUS_SIG_SYSTEM_ERROR 0x4000 /* Set when we drive SERR */
+ #define  PCI_STATUS_DETECTED_PARITY 0x8000 /* Set on parity error */
+ 
  #define PCI_REVISION            0x08    /* 8 bits  */
+ #define PCI_REVISION_ID         0x08    /* 8 bits  */
+ #define PCI_CLASS_REVISION      0x08    /* 32 bits  */
  #define PCI_CLASS_CODE          0x0b    /* 8 bits */
  #define PCI_SUBCLASS_CODE       0x0a    /* 8 bits */
  #define PCI_HEADER_TYPE         0x0e    /* 8 bits */
+ #define  PCI_HEADER_TYPE_NORMAL	0
+ #define  PCI_HEADER_TYPE_BRIDGE 1
+ #define  PCI_HEADER_TYPE_CARDBUS 2
+ 
+ 
+ /* Header type 0 (normal devices) */
+ #define PCI_CARDBUS_CIS		0x28
+ #define PCI_SUBSYSTEM_VENDOR_ID	0x2c
+ #define PCI_SUBSYSTEM_ID	0x2e  
  
  #define PCI_BASE_ADDRESS_0      0x10    /* 32 bits */
***************
*** 55,61 ****
--- 92,106 ----
  #define PCI_BASE_ADDRESS_5      0x24    /* 32 bits */
  
+ #define PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
+ #define PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
+ #define PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
+ #define PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
+ 
  #ifndef	PCI_BASE_ADDRESS_IO_MASK
  #define	PCI_BASE_ADDRESS_IO_MASK       (~0x03)
  #endif
+ #ifndef	PCI_BASE_ADDRESS_MEM_MASK
+ #define	PCI_BASE_ADDRESS_MEM_MASK       (~0x0f)
+ #endif
  #define	PCI_BASE_ADDRESS_SPACE_IO	0x01
  #define	PCI_ROM_ADDRESS		0x30	/* 32 bits */
***************
*** 64,67 ****
--- 109,241 ----
  					   10..2 are reserved */
  
+ #define PCI_CAPABILITY_LIST	0x34	/* Offset of first capability list entry */
+ 
+ /* Header type 1 (PCI-to-PCI bridges) */
+ #define PCI_PRIMARY_BUS		0x18	/* Primary bus number */
+ #define PCI_SECONDARY_BUS	0x19	/* Secondary bus number */
+ #define PCI_SUBORDINATE_BUS	0x1a	/* Highest bus number behind the bridge */
+ #define PCI_SEC_LATENCY_TIMER	0x1b	/* Latency timer for secondary interface */
+ #define PCI_IO_BASE		0x1c	/* I/O range behind the bridge */
+ #define PCI_IO_LIMIT		0x1d
+ #define  PCI_IO_RANGE_TYPE_MASK	0x0f	/* I/O bridging type */
+ #define  PCI_IO_RANGE_TYPE_16	0x00
+ #define  PCI_IO_RANGE_TYPE_32	0x01
+ #define  PCI_IO_RANGE_MASK	~0x0f
+ #define PCI_SEC_STATUS		0x1e	/* Secondary status register, only bit 14 used */
+ #define PCI_MEMORY_BASE		0x20	/* Memory range behind */
+ #define PCI_MEMORY_LIMIT	0x22
+ #define  PCI_MEMORY_RANGE_TYPE_MASK 0x0f
+ #define  PCI_MEMORY_RANGE_MASK	~0x0f
+ #define PCI_PREF_MEMORY_BASE	0x24	/* Prefetchable memory range behind */
+ #define PCI_PREF_MEMORY_LIMIT	0x26
+ #define  PCI_PREF_RANGE_TYPE_MASK 0x0f
+ #define  PCI_PREF_RANGE_TYPE_32	0x00
+ #define  PCI_PREF_RANGE_TYPE_64	0x01
+ #define  PCI_PREF_RANGE_MASK	~0x0f
+ #define PCI_PREF_BASE_UPPER32	0x28	/* Upper half of prefetchable memory range */
+ #define PCI_PREF_LIMIT_UPPER32	0x2c
+ #define PCI_IO_BASE_UPPER16	0x30	/* Upper half of I/O addresses */
+ #define PCI_IO_LIMIT_UPPER16	0x32
+ /* 0x34 same as for htype 0 */
+ /* 0x35-0x3b is reserved */
+ #define PCI_ROM_ADDRESS1	0x38	/* Same as PCI_ROM_ADDRESS, but for htype 1 */
+ /* 0x3c-0x3d are same as for htype 0 */
+ #define PCI_BRIDGE_CONTROL	0x3e
+ #define  PCI_BRIDGE_CTL_PARITY	0x01	/* Enable parity detection on secondary interface */
+ #define  PCI_BRIDGE_CTL_SERR	0x02	/* The same for SERR forwarding */
+ #define  PCI_BRIDGE_CTL_NO_ISA	0x04	/* Disable bridging of ISA ports */
+ #define  PCI_BRIDGE_CTL_VGA	0x08	/* Forward VGA addresses */
+ #define  PCI_BRIDGE_CTL_MASTER_ABORT 0x20  /* Report master aborts */
+ #define  PCI_BRIDGE_CTL_BUS_RESET 0x40	/* Secondary bus reset */
+ #define  PCI_BRIDGE_CTL_FAST_BACK 0x80	/* Fast Back2Back enabled on secondary interface */
+ 
+ #define PCI_CB_CAPABILITY_LIST	0x14
+ 
+ /* Capability lists */
+ 
+ #define PCI_CAP_LIST_ID		0	/* Capability ID */
+ #define  PCI_CAP_ID_PM		0x01	/* Power Management */
+ #define  PCI_CAP_ID_AGP		0x02	/* Accelerated Graphics Port */
+ #define  PCI_CAP_ID_VPD		0x03	/* Vital Product Data */
+ #define  PCI_CAP_ID_SLOTID	0x04	/* Slot Identification */
+ #define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
+ #define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
+ #define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
+ #define PCI_CAP_FLAGS		2	/* Capability defined flags (16 bits) */
+ #define PCI_CAP_SIZEOF		4
+ 
+ /* Power Management Registers */
+ 
+ #define PCI_PM_PMC              2       /* PM Capabilities Register */
+ #define  PCI_PM_CAP_VER_MASK	0x0007	/* Version */
+ #define  PCI_PM_CAP_PME_CLOCK	0x0008	/* PME clock required */
+ #define  PCI_PM_CAP_RESERVED    0x0010  /* Reserved field */
+ #define  PCI_PM_CAP_DSI		0x0020	/* Device specific initialization */
+ #define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxilliary power support mask */
+ #define  PCI_PM_CAP_D1		0x0200	/* D1 power state support */
+ #define  PCI_PM_CAP_D2		0x0400	/* D2 power state support */
+ #define  PCI_PM_CAP_PME		0x0800	/* PME pin supported */
+ #define  PCI_PM_CAP_PME_MASK    0xF800  /* PME Mask of all supported states */
+ #define  PCI_PM_CAP_PME_D0      0x0800  /* PME# from D0 */
+ #define  PCI_PM_CAP_PME_D1      0x1000  /* PME# from D1 */
+ #define  PCI_PM_CAP_PME_D2      0x2000  /* PME# from D2 */
+ #define  PCI_PM_CAP_PME_D3      0x4000  /* PME# from D3 (hot) */
+ #define  PCI_PM_CAP_PME_D3cold  0x8000  /* PME# from D3 (cold) */
+ #define PCI_PM_CTRL		4	/* PM control and status register */
+ #define  PCI_PM_CTRL_STATE_MASK	0x0003	/* Current power state (D0 to D3) */
+ #define  PCI_PM_CTRL_PME_ENABLE	0x0100	/* PME pin enable */
+ #define  PCI_PM_CTRL_DATA_SEL_MASK	0x1e00	/* Data select (??) */
+ #define  PCI_PM_CTRL_DATA_SCALE_MASK	0x6000	/* Data scale (??) */
+ #define  PCI_PM_CTRL_PME_STATUS	0x8000	/* PME pin status */
+ #define PCI_PM_PPB_EXTENSIONS	6	/* PPB support extensions (??) */
+ #define  PCI_PM_PPB_B2_B3	0x40	/* Stop clock when in D3hot (??) */
+ #define  PCI_PM_BPCC_ENABLE	0x80	/* Bus power/clock control enable (??) */
+ #define PCI_PM_DATA_REGISTER	7	/* (??) */
+ #define PCI_PM_SIZEOF		8
+ 
+ /* AGP registers */
+ 
+ #define PCI_AGP_VERSION		2	/* BCD version number */
+ #define PCI_AGP_RFU		3	/* Rest of capability flags */
+ #define PCI_AGP_STATUS		4	/* Status register */
+ #define  PCI_AGP_STATUS_RQ_MASK	0xff000000	/* Maximum number of requests - 1 */
+ #define  PCI_AGP_STATUS_SBA	0x0200	/* Sideband addressing supported */
+ #define  PCI_AGP_STATUS_64BIT	0x0020	/* 64-bit addressing supported */
+ #define  PCI_AGP_STATUS_FW	0x0010	/* FW transfers supported */
+ #define  PCI_AGP_STATUS_RATE4	0x0004	/* 4x transfer rate supported */
+ #define  PCI_AGP_STATUS_RATE2	0x0002	/* 2x transfer rate supported */
+ #define  PCI_AGP_STATUS_RATE1	0x0001	/* 1x transfer rate supported */
+ #define PCI_AGP_COMMAND		8	/* Control register */
+ #define  PCI_AGP_COMMAND_RQ_MASK 0xff000000  /* Master: Maximum number of requests */
+ #define  PCI_AGP_COMMAND_SBA	0x0200	/* Sideband addressing enabled */
+ #define  PCI_AGP_COMMAND_AGP	0x0100	/* Allow processing of AGP transactions */
+ #define  PCI_AGP_COMMAND_64BIT	0x0020 	/* Allow processing of 64-bit addresses */
+ #define  PCI_AGP_COMMAND_FW	0x0010 	/* Force FW transfers */
+ #define  PCI_AGP_COMMAND_RATE4	0x0004	/* Use 4x rate */
+ #define  PCI_AGP_COMMAND_RATE2	0x0002	/* Use 2x rate */
+ #define  PCI_AGP_COMMAND_RATE1	0x0001	/* Use 1x rate */
+ #define PCI_AGP_SIZEOF		12
+ 
+ /* Slot Identification */
+ 
+ #define PCI_SID_ESR		2	/* Expansion Slot Register */
+ #define  PCI_SID_ESR_NSLOTS	0x1f	/* Number of expansion slots available */
+ #define  PCI_SID_ESR_FIC	0x20	/* First In Chassis Flag */
+ #define PCI_SID_CHASSIS_NR	3	/* Chassis Number */
+ 
+ /* Message Signalled Interrupts registers */
+ 
+ #define PCI_MSI_FLAGS		2	/* Various flags */
+ #define  PCI_MSI_FLAGS_64BIT	0x80	/* 64-bit addresses allowed */
+ #define  PCI_MSI_FLAGS_QSIZE	0x70	/* Message queue size configured */
+ #define  PCI_MSI_FLAGS_QMASK	0x0e	/* Maximum queue size available */
+ #define  PCI_MSI_FLAGS_ENABLE	0x01	/* MSI feature enabled */
+ #define PCI_MSI_RFU		3	/* Rest of capability flags */
+ #define PCI_MSI_ADDRESS_LO	4	/* Lower 32 bits */
+ #define PCI_MSI_ADDRESS_HI	8	/* Upper 32 bits (if PCI_MSI_FLAGS_64BIT set) */
+ #define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
+ #define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
+ 
+ #define PCI_SLOT(devfn)		  ((devfn) >> 3)
  #define PCI_FUNC(devfn)           ((devfn) & 0x07)
  
***************
*** 74,77 ****
--- 248,252 ----
  #define PCI_SERVICE             (('$' << 0) + ('P' << 8) + ('C' << 16) + ('I' << 24))
  
+ /* The following is from old Grub :-( */
  union bios32 {
  	struct {
***************
*** 86,192 ****
  };
  
! #define KERN_CODE_SEG	0x8	/* This _MUST_ match start.S */
! 
! /* Stuff for asm */
! #define save_flags(x) \
! __asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
! 
! #define cli() __asm__ __volatile__ ("cli": : :"memory")
! 
! #define restore_flags(x) \
! __asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
! 
! #define PCI_VENDOR_ID_ADMTEK            0x1317
! #define PCI_DEVICE_ID_ADMTEK_0985       0x0985
! #define PCI_VENDOR_ID_REALTEK           0x10ec
! #define PCI_DEVICE_ID_REALTEK_8029      0x8029
! #define PCI_DEVICE_ID_REALTEK_8139      0x8139
! #define PCI_VENDOR_ID_WINBOND2          0x1050
! #define PCI_DEVICE_ID_WINBOND2_89C940   0x0940
! #define PCI_DEVICE_ID_WINBOND2_89C840   0x0840
! #define PCI_VENDOR_ID_COMPEX            0x11f6
! #define PCI_DEVICE_ID_COMPEX_RL2000     0x1401
! #define PCI_DEVICE_ID_COMPEX_RL100ATX   0x2011
! #define PCI_VENDOR_ID_KTI               0x8e2e
! #define PCI_DEVICE_ID_KTI_ET32P2        0x3000
! #define PCI_VENDOR_ID_NETVIN            0x4a14
! #define PCI_DEVICE_ID_NETVIN_NV5000SC   0x5000
! #define	PCI_VENDOR_ID_HOLTEK		0x12c3
! #define	PCI_DEVICE_ID_HOLTEK_HT80232	0x0058
! #define PCI_VENDOR_ID_3COM		0x10b7
! #define PCI_DEVICE_ID_3COM_3C590	0x5900
! #define PCI_DEVICE_ID_3COM_3C595	0x5950
! #define PCI_DEVICE_ID_3COM_3C595_1	0x5951
! #define PCI_DEVICE_ID_3COM_3C595_2	0x5952
! #define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
! #define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
! #define PCI_DEVICE_ID_3COM_3C905TX	0x9050
! #define PCI_DEVICE_ID_3COM_3C905T4	0x9051
! #define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
! #define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
! #define PCI_VENDOR_ID_INTEL		0x8086
! #define PCI_DEVICE_ID_INTEL_82557	0x1229
! #define PCI_DEVICE_ID_INTEL_82559ER	0x1209
! #define PCI_DEVICE_ID_INTEL_ID1029	0x1029
! #define PCI_DEVICE_ID_INTEL_ID1030	0x1030
! #define PCI_DEVICE_ID_INTEL_82562	0x2449
! #define PCI_VENDOR_ID_AMD		0x1022
! #define PCI_DEVICE_ID_AMD_LANCE		0x2000
! #define PCI_VENDOR_ID_AMD_HOMEPNA	0x1022
! #define PCI_DEVICE_ID_AMD_HOMEPNA	0x2001
! #define PCI_VENDOR_ID_SMC_1211          0x1113
! #define PCI_DEVICE_ID_SMC_1211          0x1211
! #define PCI_VENDOR_ID_DEC		0x1011
! #define PCI_DEVICE_ID_DEC_TULIP		0x0002
! #define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
! #define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
! #define PCI_DEVICE_ID_DEC_21142		0x0019
! #define PCI_VENDOR_ID_SMC		0x10B8
! #ifndef	PCI_DEVICE_ID_SMC_EPIC100
! # define PCI_DEVICE_ID_SMC_EPIC100	0x0005
! #endif
! #define PCI_VENDOR_ID_MACRONIX		0x10d9
! #define PCI_DEVICE_ID_MX987x5		0x0531
! #define PCI_VENDOR_ID_LINKSYS		0x11AD
! #define PCI_DEVICE_ID_LC82C115		0xC115
! #define PCI_VENDOR_ID_VIATEC		0x1106
! #define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
! #define PCI_DEVICE_ID_VIA_VT6102	0x3065
! #define PCI_DEVICE_ID_VIA_86C100A	0x6100
! #define PCI_VENDOR_ID_DAVICOM		0x1282
! #define	PCI_DEVICE_ID_DM9009		0x9009
! #define PCI_DEVICE_ID_DM9102		0x9102
! #define PCI_VENDOR_ID_SIS         	0x1039
! #define PCI_DEVICE_ID_SIS900     	0x0900   
! #define PCI_DEVICE_ID_SIS7016    	0x7016  
! #define	PCI_VENDOR_ID_DLINK		0x1186
! #define	PCI_DEVICE_ID_DFE530TXP		0x1300
! #define	PCI_VENDOR_ID_NS		0x100B
! #define	PCI_DEVICE_ID_DP83815		0x0020
! #define PCI_VENDOR_ID_OLICOM		0x108d
! #define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
! #define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
! #define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
! #define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
! #define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
! #define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
  
  struct pci_device {
! 	unsigned short	vendor, dev_id;
! 	const char	*name;
! 	unsigned int	membase;
! 	unsigned short	ioaddr;
! 	unsigned char	devfn;
! 	unsigned char	bus;
  };
  
! extern void	eth_pci_init(struct pci_device *);
  
- extern int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned char *value);
- extern int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned char value);
- extern int pcibios_read_config_word(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned short *value);
- extern int pcibios_write_config_word (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned short value);
- extern int pcibios_read_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int *value);
- extern int pcibios_write_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int value);
- void adjust_pci_device(struct pci_device *p);
  #endif	/* PCI_H */
--- 261,355 ----
  };
  
! struct pci_device;
! struct dev;
! typedef int (*pci_probe_t)(struct dev *, struct pci_device *);
  
  struct pci_device {
! 	uint32_t		class;
! 	uint16_t		vendor, dev_id;
! 	const char		*name;
! 	/* membase and ioaddr are silly and depricated */
! 	unsigned int		membase;
! 	unsigned int		ioaddr;
! 	unsigned int		romaddr;
! 	unsigned char		devfn;
! 	unsigned char		bus;
! 	const struct pci_driver	*driver;
! };
! 
! extern void scan_pci_bus(int type, struct pci_device *dev);
! extern void find_pci(int type, struct pci_device *dev);
! 
! extern int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn, unsigned int where, uint8_t *value);
! extern int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn, unsigned int where, uint8_t value);
! extern int pcibios_read_config_word(unsigned int bus, unsigned int device_fn, unsigned int where, uint16_t *value);
! extern int pcibios_write_config_word (unsigned int bus, unsigned int device_fn, unsigned int where, uint16_t value);
! extern int pcibios_read_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t *value);
! extern int pcibios_write_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t value);
! extern unsigned long pcibios_bus_base(unsigned int bus);
! extern void adjust_pci_device(struct pci_device *p);
! 
! 
! static inline int 
! pci_read_config_byte(struct pci_device *dev, unsigned int where, uint8_t *value)
! {
! 	return pcibios_read_config_byte(dev->bus, dev->devfn, where, value);
! }
! static inline int 
! pci_write_config_byte(struct pci_device *dev, unsigned int where, uint8_t value)
! {
! 	return pcibios_write_config_byte(dev->bus, dev->devfn, where, value);
! }
! static inline int 
! pci_read_config_word(struct pci_device *dev, unsigned int where, uint16_t *value)
! {
! 	return pcibios_read_config_word(dev->bus, dev->devfn, where, value);
! }
! static inline int 
! pci_write_config_word(struct pci_device *dev, unsigned int where, uint16_t value)
! {
! 	return pcibios_write_config_word(dev->bus, dev->devfn, where, value);
! }
! static inline int 
! pci_read_config_dword(struct pci_device *dev, unsigned int where, uint32_t *value)
! {
! 	return pcibios_read_config_dword(dev->bus, dev->devfn, where, value);
! }
! static inline int 
! pci_write_config_dword(struct pci_device *dev, unsigned int where, uint32_t value)
! {
! 	return pcibios_write_config_dword(dev->bus, dev->devfn, where, value);
! }
! 
! /* Helper functions to find the size of a pci bar */
! extern unsigned long pci_bar_start(struct pci_device *dev, unsigned int bar);
! extern unsigned long pci_bar_size(struct pci_device *dev, unsigned int bar);
! /* Helper function to find pci capabilities */
! extern int pci_find_capability(struct pci_device *dev, int cap);
! struct pci_id {
! 	unsigned short vendor, dev_id;
! 	const char *name;
  };
  
! struct dev;
! /* Most pci drivers will use this */
! struct pci_driver {
! 	int type;
! 	const char *name;
! 	pci_probe_t probe;
! 	struct pci_id *ids;
! 	int id_count;
! 
! /* On a few occasions the hardware is standardized enough that
!  * we only need to know the class of the device and not the exact
!  * type to drive the device correctly.  If this is the case
!  * set a class value other than 0.
!  */
! 	unsigned short class;
! };
! 
! 
! #define PCI_ROM(VENDOR_ID, DEVICE_ID, IMAGE, DESCRIPTION) \
! 	{ VENDOR_ID, DEVICE_ID, IMAGE, }
  
  #endif	/* PCI_H */
diff -rc2P -x CVS GRUB_0.94/netboot/pci_ids.h GRUB/netboot/pci_ids.h
*** GRUB_0.94/netboot/pci_ids.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/pci_ids.h	2003-11-04 05:21:57.000000000 +0800
***************
*** 0 ****
--- 1,1809 ----
+ /*
+  *	PCI Class, Vendor and Device IDs
+  *
+  *	Please keep sorted.
+  */
+ 
+ /* Device classes and subclasses */
+ 
+ #define PCI_CLASS_NOT_DEFINED		0x0000
+ #define PCI_CLASS_NOT_DEFINED_VGA	0x0001
+ 
+ #define PCI_BASE_CLASS_STORAGE		0x01
+ #define PCI_CLASS_STORAGE_SCSI		0x0100
+ #define PCI_CLASS_STORAGE_IDE		0x0101
+ #define PCI_CLASS_STORAGE_FLOPPY	0x0102
+ #define PCI_CLASS_STORAGE_IPI		0x0103
+ #define PCI_CLASS_STORAGE_RAID		0x0104
+ #define PCI_CLASS_STORAGE_OTHER		0x0180
+ 
+ #define PCI_BASE_CLASS_NETWORK		0x02
+ #define PCI_CLASS_NETWORK_ETHERNET	0x0200
+ #define PCI_CLASS_NETWORK_TOKEN_RING	0x0201
+ #define PCI_CLASS_NETWORK_FDDI		0x0202
+ #define PCI_CLASS_NETWORK_ATM		0x0203
+ #define PCI_CLASS_NETWORK_OTHER		0x0280
+ 
+ #define PCI_BASE_CLASS_DISPLAY		0x03
+ #define PCI_CLASS_DISPLAY_VGA		0x0300
+ #define PCI_CLASS_DISPLAY_XGA		0x0301
+ #define PCI_CLASS_DISPLAY_3D		0x0302
+ #define PCI_CLASS_DISPLAY_OTHER		0x0380
+ 
+ #define PCI_BASE_CLASS_MULTIMEDIA	0x04
+ #define PCI_CLASS_MULTIMEDIA_VIDEO	0x0400
+ #define PCI_CLASS_MULTIMEDIA_AUDIO	0x0401
+ #define PCI_CLASS_MULTIMEDIA_PHONE	0x0402
+ #define PCI_CLASS_MULTIMEDIA_OTHER	0x0480
+ 
+ #define PCI_BASE_CLASS_MEMORY		0x05
+ #define PCI_CLASS_MEMORY_RAM		0x0500
+ #define PCI_CLASS_MEMORY_FLASH		0x0501
+ #define PCI_CLASS_MEMORY_OTHER		0x0580
+ 
+ #define PCI_BASE_CLASS_BRIDGE		0x06
+ #define PCI_CLASS_BRIDGE_HOST		0x0600
+ #define PCI_CLASS_BRIDGE_ISA		0x0601
+ #define PCI_CLASS_BRIDGE_EISA		0x0602
+ #define PCI_CLASS_BRIDGE_MC		0x0603
+ #define PCI_CLASS_BRIDGE_PCI		0x0604
+ #define PCI_CLASS_BRIDGE_PCMCIA		0x0605
+ #define PCI_CLASS_BRIDGE_NUBUS		0x0606
+ #define PCI_CLASS_BRIDGE_CARDBUS	0x0607
+ #define PCI_CLASS_BRIDGE_RACEWAY	0x0608
+ #define PCI_CLASS_BRIDGE_OTHER		0x0680
+ 
+ #define PCI_BASE_CLASS_COMMUNICATION	0x07
+ #define PCI_CLASS_COMMUNICATION_SERIAL	0x0700
+ #define PCI_CLASS_COMMUNICATION_PARALLEL 0x0701
+ #define PCI_CLASS_COMMUNICATION_MULTISERIAL 0x0702
+ #define PCI_CLASS_COMMUNICATION_MODEM	0x0703
+ #define PCI_CLASS_COMMUNICATION_OTHER	0x0780
+ 
+ #define PCI_BASE_CLASS_SYSTEM		0x08
+ #define PCI_CLASS_SYSTEM_PIC		0x0800
+ #define PCI_CLASS_SYSTEM_DMA		0x0801
+ #define PCI_CLASS_SYSTEM_TIMER		0x0802
+ #define PCI_CLASS_SYSTEM_RTC		0x0803
+ #define PCI_CLASS_SYSTEM_PCI_HOTPLUG	0x0804
+ #define PCI_CLASS_SYSTEM_OTHER		0x0880
+ 
+ #define PCI_BASE_CLASS_INPUT		0x09
+ #define PCI_CLASS_INPUT_KEYBOARD	0x0900
+ #define PCI_CLASS_INPUT_PEN		0x0901
+ #define PCI_CLASS_INPUT_MOUSE		0x0902
+ #define PCI_CLASS_INPUT_SCANNER		0x0903
+ #define PCI_CLASS_INPUT_GAMEPORT	0x0904
+ #define PCI_CLASS_INPUT_OTHER		0x0980
+ 
+ #define PCI_BASE_CLASS_DOCKING		0x0a
+ #define PCI_CLASS_DOCKING_GENERIC	0x0a00
+ #define PCI_CLASS_DOCKING_OTHER		0x0a80
+ 
+ #define PCI_BASE_CLASS_PROCESSOR	0x0b
+ #define PCI_CLASS_PROCESSOR_386		0x0b00
+ #define PCI_CLASS_PROCESSOR_486		0x0b01
+ #define PCI_CLASS_PROCESSOR_PENTIUM	0x0b02
+ #define PCI_CLASS_PROCESSOR_ALPHA	0x0b10
+ #define PCI_CLASS_PROCESSOR_POWERPC	0x0b20
+ #define PCI_CLASS_PROCESSOR_MIPS	0x0b30
+ #define PCI_CLASS_PROCESSOR_CO		0x0b40
+ 
+ #define PCI_BASE_CLASS_SERIAL		0x0c
+ #define PCI_CLASS_SERIAL_FIREWIRE	0x0c00
+ #define PCI_CLASS_SERIAL_ACCESS		0x0c01
+ #define PCI_CLASS_SERIAL_SSA		0x0c02
+ #define PCI_CLASS_SERIAL_USB		0x0c03
+ #define PCI_CLASS_SERIAL_FIBER		0x0c04
+ #define PCI_CLASS_SERIAL_SMBUS		0x0c05
+ 
+ #define PCI_BASE_CLASS_INTELLIGENT	0x0e
+ #define PCI_CLASS_INTELLIGENT_I2O	0x0e00
+ 
+ #define PCI_BASE_CLASS_SATELLITE	0x0f
+ #define PCI_CLASS_SATELLITE_TV		0x0f00
+ #define PCI_CLASS_SATELLITE_AUDIO	0x0f01
+ #define PCI_CLASS_SATELLITE_VOICE	0x0f03
+ #define PCI_CLASS_SATELLITE_DATA	0x0f04
+ 
+ #define PCI_BASE_CLASS_CRYPT		0x10
+ #define PCI_CLASS_CRYPT_NETWORK		0x1000
+ #define PCI_CLASS_CRYPT_ENTERTAINMENT	0x1001
+ #define PCI_CLASS_CRYPT_OTHER		0x1080
+ 
+ #define PCI_BASE_CLASS_SIGNAL_PROCESSING 0x11
+ #define PCI_CLASS_SP_DPIO		0x1100
+ #define PCI_CLASS_SP_OTHER		0x1180
+ 
+ #define PCI_CLASS_OTHERS		0xff
+ 
+ /* Vendors and devices.  Sort key: vendor first, device next. */
+ 
+ #define PCI_VENDOR_ID_DYNALINK		0x0675
+ #define PCI_DEVICE_ID_DYNALINK_IS64PH	0x1702
+ 
+ #define PCI_VENDOR_ID_BERKOM			0x0871
+ #define PCI_DEVICE_ID_BERKOM_A1T		0xffa1
+ #define PCI_DEVICE_ID_BERKOM_T_CONCEPT		0xffa2
+ #define PCI_DEVICE_ID_BERKOM_A4T		0xffa4
+ #define PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO	0xffa8
+ 
+ #define PCI_VENDOR_ID_COMPAQ		0x0e11
+ #define PCI_DEVICE_ID_COMPAQ_TOKENRING	0x0508
+ #define PCI_DEVICE_ID_COMPAQ_1280	0x3033
+ #define PCI_DEVICE_ID_COMPAQ_TRIFLEX	0x4000
+ #define PCI_DEVICE_ID_COMPAQ_6010	0x6010
+ #define PCI_DEVICE_ID_COMPAQ_SMART2P	0xae10
+ #define PCI_DEVICE_ID_COMPAQ_NETEL100	0xae32
+ #define PCI_DEVICE_ID_COMPAQ_NETEL10	0xae34
+ #define PCI_DEVICE_ID_COMPAQ_NETFLEX3I	0xae35
+ #define PCI_DEVICE_ID_COMPAQ_NETEL100D	0xae40
+ #define PCI_DEVICE_ID_COMPAQ_NETEL100PI	0xae43
+ #define PCI_DEVICE_ID_COMPAQ_NETEL100I	0xb011
+ #define PCI_DEVICE_ID_COMPAQ_CISS	0xb060
+ #define PCI_DEVICE_ID_COMPAQ_CISSB	0xb178
+ #define PCI_DEVICE_ID_COMPAQ_THUNDER	0xf130
+ #define PCI_DEVICE_ID_COMPAQ_NETFLEX3B	0xf150
+ 
+ #define PCI_VENDOR_ID_NCR		0x1000
+ #define PCI_VENDOR_ID_LSI_LOGIC		0x1000
+ #define PCI_DEVICE_ID_NCR_53C810	0x0001
+ #define PCI_DEVICE_ID_NCR_53C820	0x0002
+ #define PCI_DEVICE_ID_NCR_53C825	0x0003
+ #define PCI_DEVICE_ID_NCR_53C815	0x0004
+ #define PCI_DEVICE_ID_LSI_53C810AP	0x0005
+ #define PCI_DEVICE_ID_NCR_53C860	0x0006
+ #define PCI_DEVICE_ID_LSI_53C1510	0x000a
+ #define PCI_DEVICE_ID_NCR_53C896	0x000b
+ #define PCI_DEVICE_ID_NCR_53C895	0x000c
+ #define PCI_DEVICE_ID_NCR_53C885	0x000d
+ #define PCI_DEVICE_ID_NCR_53C875	0x000f
+ #define PCI_DEVICE_ID_NCR_53C1510	0x0010
+ #define PCI_DEVICE_ID_LSI_53C895A	0x0012
+ #define PCI_DEVICE_ID_LSI_53C875A	0x0013
+ #define PCI_DEVICE_ID_LSI_53C1010_33	0x0020
+ #define PCI_DEVICE_ID_LSI_53C1010_66	0x0021
+ #define PCI_DEVICE_ID_LSI_53C1030	0x0030
+ #define PCI_DEVICE_ID_LSI_53C1035	0x0040
+ #define PCI_DEVICE_ID_NCR_53C875J	0x008f
+ #define PCI_DEVICE_ID_LSI_FC909		0x0621
+ #define PCI_DEVICE_ID_LSI_FC929		0x0622
+ #define PCI_DEVICE_ID_LSI_FC929_LAN	0x0623
+ #define PCI_DEVICE_ID_LSI_FC919		0x0624
+ #define PCI_DEVICE_ID_LSI_FC919_LAN	0x0625
+ #define PCI_DEVICE_ID_NCR_YELLOWFIN	0x0701
+ #define PCI_DEVICE_ID_LSI_61C102	0x0901
+ #define PCI_DEVICE_ID_LSI_63C815	0x1000
+ 
+ #define PCI_VENDOR_ID_ATI		0x1002
+ /* Mach64 */
+ #define PCI_DEVICE_ID_ATI_68800		0x4158
+ #define PCI_DEVICE_ID_ATI_215CT222	0x4354
+ #define PCI_DEVICE_ID_ATI_210888CX	0x4358
+ #define PCI_DEVICE_ID_ATI_215ET222	0x4554
+ /* Mach64 / Rage */
+ #define PCI_DEVICE_ID_ATI_215GB		0x4742
+ #define PCI_DEVICE_ID_ATI_215GD		0x4744
+ #define PCI_DEVICE_ID_ATI_215GI		0x4749
+ #define PCI_DEVICE_ID_ATI_215GP		0x4750
+ #define PCI_DEVICE_ID_ATI_215GQ		0x4751
+ #define PCI_DEVICE_ID_ATI_215XL		0x4752
+ #define PCI_DEVICE_ID_ATI_215GT		0x4754
+ #define PCI_DEVICE_ID_ATI_215GTB	0x4755
+ #define PCI_DEVICE_ID_ATI_215_IV	0x4756
+ #define PCI_DEVICE_ID_ATI_215_IW	0x4757
+ #define PCI_DEVICE_ID_ATI_215_IZ	0x475A
+ #define PCI_DEVICE_ID_ATI_210888GX	0x4758
+ #define PCI_DEVICE_ID_ATI_215_LB	0x4c42
+ #define PCI_DEVICE_ID_ATI_215_LD	0x4c44
+ #define PCI_DEVICE_ID_ATI_215_LG	0x4c47
+ #define PCI_DEVICE_ID_ATI_215_LI	0x4c49
+ #define PCI_DEVICE_ID_ATI_215_LM	0x4c4D
+ #define PCI_DEVICE_ID_ATI_215_LN	0x4c4E
+ #define PCI_DEVICE_ID_ATI_215_LR	0x4c52
+ #define PCI_DEVICE_ID_ATI_215_LS	0x4c53
+ #define PCI_DEVICE_ID_ATI_264_LT	0x4c54
+ /* Mach64 VT */
+ #define PCI_DEVICE_ID_ATI_264VT		0x5654
+ #define PCI_DEVICE_ID_ATI_264VU		0x5655
+ #define PCI_DEVICE_ID_ATI_264VV		0x5656
+ /* Rage128 Pro GL */
+ #define PCI_DEVICE_ID_ATI_Rage128_PA	0x5041
+ #define PCI_DEVICE_ID_ATI_Rage128_PB	0x5042
+ #define PCI_DEVICE_ID_ATI_Rage128_PC	0x5043
+ #define PCI_DEVICE_ID_ATI_Rage128_PD	0x5044
+ #define PCI_DEVICE_ID_ATI_Rage128_PE	0x5045
+ #define PCI_DEVICE_ID_ATI_RAGE128_PF	0x5046
+ /* Rage128 Pro VR */
+ #define PCI_DEVICE_ID_ATI_RAGE128_PG	0x5047
+ #define PCI_DEVICE_ID_ATI_RAGE128_PH	0x5048
+ #define PCI_DEVICE_ID_ATI_RAGE128_PI	0x5049
+ #define PCI_DEVICE_ID_ATI_RAGE128_PJ	0x504A
+ #define PCI_DEVICE_ID_ATI_RAGE128_PK	0x504B
+ #define PCI_DEVICE_ID_ATI_RAGE128_PL	0x504C
+ #define PCI_DEVICE_ID_ATI_RAGE128_PM	0x504D
+ #define PCI_DEVICE_ID_ATI_RAGE128_PN	0x504E
+ #define PCI_DEVICE_ID_ATI_RAGE128_PO	0x504F
+ #define PCI_DEVICE_ID_ATI_RAGE128_PP	0x5050
+ #define PCI_DEVICE_ID_ATI_RAGE128_PQ	0x5051
+ #define PCI_DEVICE_ID_ATI_RAGE128_PR	0x5052
+ #define PCI_DEVICE_ID_ATI_RAGE128_TR	0x5452
+ #define PCI_DEVICE_ID_ATI_RAGE128_PS	0x5053
+ #define PCI_DEVICE_ID_ATI_RAGE128_PT	0x5054
+ #define PCI_DEVICE_ID_ATI_RAGE128_PU	0x5055
+ #define PCI_DEVICE_ID_ATI_RAGE128_PV	0x5056
+ #define PCI_DEVICE_ID_ATI_RAGE128_PW	0x5057
+ #define PCI_DEVICE_ID_ATI_RAGE128_PX	0x5058
+ /* Rage128 GL */
+ #define PCI_DEVICE_ID_ATI_RAGE128_RE	0x5245
+ #define PCI_DEVICE_ID_ATI_RAGE128_RF	0x5246
+ #define PCI_DEVICE_ID_ATI_RAGE128_RG	0x534b
+ #define PCI_DEVICE_ID_ATI_RAGE128_RH	0x534c
+ #define PCI_DEVICE_ID_ATI_RAGE128_RI	0x534d
+ /* Rage128 VR */
+ #define PCI_DEVICE_ID_ATI_RAGE128_RK	0x524b
+ #define PCI_DEVICE_ID_ATI_RAGE128_RL	0x524c
+ #define PCI_DEVICE_ID_ATI_RAGE128_RM	0x5345
+ #define PCI_DEVICE_ID_ATI_RAGE128_RN	0x5346
+ #define PCI_DEVICE_ID_ATI_RAGE128_RO	0x5347
+ /* Rage128 M3 */
+ #define PCI_DEVICE_ID_ATI_RAGE128_LE	0x4c45
+ #define PCI_DEVICE_ID_ATI_RAGE128_LF	0x4c46
+ /* Rage128 Pro Ultra */
+ #define PCI_DEVICE_ID_ATI_RAGE128_U1	0x5446
+ #define PCI_DEVICE_ID_ATI_RAGE128_U2	0x544C
+ #define PCI_DEVICE_ID_ATI_RAGE128_U3	0x5452
+ /* Radeon M4 */
+ #define PCI_DEVICE_ID_ATI_RADEON_LE	0x4d45
+ #define PCI_DEVICE_ID_ATI_RADEON_LF	0x4d46
+ /* Radeon NV-100 */
+ #define PCI_DEVICE_ID_ATI_RADEON_N1	0x5159
+ #define PCI_DEVICE_ID_ATI_RADEON_N2	0x515a
+ /* Radeon */
+ #define PCI_DEVICE_ID_ATI_RADEON_RA	0x5144
+ #define PCI_DEVICE_ID_ATI_RADEON_RB	0x5145
+ #define PCI_DEVICE_ID_ATI_RADEON_RC	0x5146
+ #define PCI_DEVICE_ID_ATI_RADEON_RD	0x5147
+ 
+ #define PCI_VENDOR_ID_VLSI		0x1004
+ #define PCI_DEVICE_ID_VLSI_82C592	0x0005
+ #define PCI_DEVICE_ID_VLSI_82C593	0x0006
+ #define PCI_DEVICE_ID_VLSI_82C594	0x0007
+ #define PCI_DEVICE_ID_VLSI_82C597	0x0009
+ #define PCI_DEVICE_ID_VLSI_82C541	0x000c
+ #define PCI_DEVICE_ID_VLSI_82C543	0x000d
+ #define PCI_DEVICE_ID_VLSI_82C532	0x0101
+ #define PCI_DEVICE_ID_VLSI_82C534	0x0102
+ #define PCI_DEVICE_ID_VLSI_82C535	0x0104
+ #define PCI_DEVICE_ID_VLSI_82C147	0x0105
+ #define PCI_DEVICE_ID_VLSI_VAS96011	0x0702
+ 
+ #define PCI_VENDOR_ID_ADL		0x1005
+ #define PCI_DEVICE_ID_ADL_2301		0x2301
+ 
+ #define PCI_VENDOR_ID_NS		0x100b
+ #define PCI_DEVICE_ID_NS_87415		0x0002
+ #define PCI_DEVICE_ID_NS_87560_LIO	0x000e
+ #define PCI_DEVICE_ID_NS_87560_USB	0x0012
+ #define PCI_DEVICE_ID_NS_83815		0x0020
+ #define	PCI_DEVICE_ID_DP83815		0x0020
+ #define PCI_DEVICE_ID_NS_83820		0x0022
+ #define PCI_DEVICE_ID_NS_87410		0xd001
+ 
+ #define PCI_VENDOR_ID_TSENG		0x100c
+ #define PCI_DEVICE_ID_TSENG_W32P_2	0x3202
+ #define PCI_DEVICE_ID_TSENG_W32P_b	0x3205
+ #define PCI_DEVICE_ID_TSENG_W32P_c	0x3206
+ #define PCI_DEVICE_ID_TSENG_W32P_d	0x3207
+ #define PCI_DEVICE_ID_TSENG_ET6000	0x3208
+ 
+ #define PCI_VENDOR_ID_WEITEK		0x100e
+ #define PCI_DEVICE_ID_WEITEK_P9000	0x9001
+ #define PCI_DEVICE_ID_WEITEK_P9100	0x9100
+ 
+ #define PCI_VENDOR_ID_DEC		0x1011
+ #define PCI_DEVICE_ID_DEC_BRD		0x0001
+ #define PCI_DEVICE_ID_DEC_TULIP		0x0002
+ #define PCI_DEVICE_ID_DEC_TGA		0x0004
+ #define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
+ #define PCI_DEVICE_ID_DEC_TGA2		0x000D
+ #define PCI_DEVICE_ID_DEC_FDDI		0x000F
+ #define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
+ #define PCI_DEVICE_ID_DEC_21142		0x0019
+ #define PCI_DEVICE_ID_DEC_21052		0x0021
+ #define PCI_DEVICE_ID_DEC_21150		0x0022
+ #define PCI_DEVICE_ID_DEC_21152		0x0024
+ #define PCI_DEVICE_ID_DEC_21153		0x0025
+ #define PCI_DEVICE_ID_DEC_21154		0x0026
+ #define PCI_DEVICE_ID_DEC_21285		0x1065
+ #define PCI_DEVICE_ID_COMPAQ_42XX	0x0046
+ 
+ #define PCI_VENDOR_ID_CIRRUS		0x1013
+ #define PCI_DEVICE_ID_CIRRUS_7548	0x0038
+ #define PCI_DEVICE_ID_CIRRUS_5430	0x00a0
+ #define PCI_DEVICE_ID_CIRRUS_5434_4	0x00a4
+ #define PCI_DEVICE_ID_CIRRUS_5434_8	0x00a8
+ #define PCI_DEVICE_ID_CIRRUS_5436	0x00ac
+ #define PCI_DEVICE_ID_CIRRUS_5446	0x00b8
+ #define PCI_DEVICE_ID_CIRRUS_5480	0x00bc
+ #define PCI_DEVICE_ID_CIRRUS_5462	0x00d0
+ #define PCI_DEVICE_ID_CIRRUS_5464	0x00d4
+ #define PCI_DEVICE_ID_CIRRUS_5465	0x00d6
+ #define PCI_DEVICE_ID_CIRRUS_6729	0x1100
+ #define PCI_DEVICE_ID_CIRRUS_6832	0x1110
+ #define PCI_DEVICE_ID_CIRRUS_7542	0x1200
+ #define PCI_DEVICE_ID_CIRRUS_7543	0x1202
+ #define PCI_DEVICE_ID_CIRRUS_7541	0x1204
+ 
+ #define PCI_VENDOR_ID_IBM		0x1014
+ #define PCI_DEVICE_ID_IBM_FIRE_CORAL	0x000a
+ #define PCI_DEVICE_ID_IBM_TR		0x0018
+ #define PCI_DEVICE_ID_IBM_82G2675	0x001d
+ #define PCI_DEVICE_ID_IBM_MCA		0x0020
+ #define PCI_DEVICE_ID_IBM_82351		0x0022
+ #define PCI_DEVICE_ID_IBM_PYTHON	0x002d
+ #define PCI_DEVICE_ID_IBM_SERVERAID	0x002e
+ #define PCI_DEVICE_ID_IBM_TR_WAKE	0x003e
+ #define PCI_DEVICE_ID_IBM_MPIC		0x0046
+ #define PCI_DEVICE_ID_IBM_3780IDSP	0x007d
+ #define PCI_DEVICE_ID_IBM_CHUKAR	0x0096
+ #define	PCI_DEVICE_ID_IBM_405GP		0x0156
+ #define PCI_DEVICE_ID_IBM_SERVERAIDI960	0x01bd
+ #define PCI_DEVICE_ID_IBM_MPIC_2	0xffff
+ 
+ #define PCI_VENDOR_ID_COMPEX2		0x101a // pci.ids says "AT&T GIS (NCR)"
+ #define PCI_DEVICE_ID_COMPEX2_100VG	0x0005
+ 
+ #define PCI_VENDOR_ID_WD		0x101c
+ #define PCI_DEVICE_ID_WD_7197		0x3296
+ 
+ #define PCI_VENDOR_ID_AMI		0x101e
+ #define PCI_DEVICE_ID_AMI_MEGARAID3	0x1960
+ #define PCI_DEVICE_ID_AMI_MEGARAID	0x9010
+ #define PCI_DEVICE_ID_AMI_MEGARAID2	0x9060
+ 
+ #define PCI_VENDOR_ID_AMD		0x1022
+ 
+ #define PCI_DEVICE_ID_AMD_LANCE		0x2000
+ #define PCI_DEVICE_ID_AMD_LANCE_HOME	0x2001
+ #define PCI_DEVICE_ID_AMD_HOMEPNA	0x2001
+ #define PCI_DEVICE_ID_AMD_SCSI		0x2020
+ #define PCI_DEVICE_ID_AMD_FE_GATE_7006	0x7006
+ #define PCI_DEVICE_ID_AMD_FE_GATE_7007	0x7007
+ #define PCI_DEVICE_ID_AMD_FE_GATE_700C	0x700C
+ #define PCI_DEVIDE_ID_AMD_FE_GATE_700D	0x700D
+ #define PCI_DEVICE_ID_AMD_FE_GATE_700E	0x700E
+ #define PCI_DEVICE_ID_AMD_FE_GATE_700F	0x700F
+ #define PCI_DEVICE_ID_AMD_COBRA_7400	0x7400
+ #define PCI_DEVICE_ID_AMD_COBRA_7401	0x7401
+ #define PCI_DEVICE_ID_AMD_COBRA_7403	0x7403
+ #define PCI_DEVICE_ID_AMD_COBRA_7404	0x7404
+ #define PCI_DEVICE_ID_AMD_VIPER_7408	0x7408
+ #define PCI_DEVICE_ID_AMD_VIPER_7409	0x7409
+ #define PCI_DEVICE_ID_AMD_VIPER_740B	0x740B
+ #define PCI_DEVICE_ID_AMD_VIPER_740C	0x740C
+ #define PCI_DEVICE_ID_AMD_VIPER_7410	0x7410
+ #define PCI_DEVICE_ID_AMD_VIPER_7411	0x7411
+ #define PCI_DEVICE_ID_AMD_VIPER_7413	0x7413
+ #define PCI_DEVICE_ID_AMD_VIPER_7414	0x7414
+ #define PCI_DEVICE_ID_AMD_VIPER_7440	0x7440
+ #define PCI_DEVICE_ID_AMD_VIPER_7441	0x7441
+ #define PCI_DEVICE_ID_AMD_VIPER_7443	0x7443
+ #define PCI_DEVICE_ID_AMD_VIPER_7448	0x7448
+ #define PCI_DEVICE_ID_AMD_VIPER_7449	0x7449
+ 
+ #define PCI_VENDOR_ID_TRIDENT		0x1023
+ #define PCI_DEVICE_ID_TRIDENT_4DWAVE_DX	0x2000
+ #define PCI_DEVICE_ID_TRIDENT_4DWAVE_NX	0x2001
+ #define PCI_DEVICE_ID_TRIDENT_9320	0x9320
+ #define PCI_DEVICE_ID_TRIDENT_9388	0x9388
+ #define PCI_DEVICE_ID_TRIDENT_9397	0x9397
+ #define PCI_DEVICE_ID_TRIDENT_939A	0x939A
+ #define PCI_DEVICE_ID_TRIDENT_9520	0x9520
+ #define PCI_DEVICE_ID_TRIDENT_9525	0x9525
+ #define PCI_DEVICE_ID_TRIDENT_9420	0x9420
+ #define PCI_DEVICE_ID_TRIDENT_9440	0x9440
+ #define PCI_DEVICE_ID_TRIDENT_9660	0x9660
+ #define PCI_DEVICE_ID_TRIDENT_9750	0x9750
+ #define PCI_DEVICE_ID_TRIDENT_9850	0x9850
+ #define PCI_DEVICE_ID_TRIDENT_9880	0x9880
+ #define PCI_DEVICE_ID_TRIDENT_8400	0x8400
+ #define PCI_DEVICE_ID_TRIDENT_8420	0x8420
+ #define PCI_DEVICE_ID_TRIDENT_8500	0x8500
+ 
+ #define PCI_VENDOR_ID_AI		0x1025
+ #define PCI_DEVICE_ID_AI_M1435		0x1435
+ 
+ #define PCI_VENDOR_ID_DELL              0x1028
+ 
+ #define PCI_VENDOR_ID_MATROX		0x102B
+ #define PCI_DEVICE_ID_MATROX_MGA_2	0x0518
+ #define PCI_DEVICE_ID_MATROX_MIL	0x0519
+ #define PCI_DEVICE_ID_MATROX_MYS	0x051A
+ #define PCI_DEVICE_ID_MATROX_MIL_2	0x051b
+ #define PCI_DEVICE_ID_MATROX_MIL_2_AGP	0x051f
+ #define PCI_DEVICE_ID_MATROX_MGA_IMP	0x0d10
+ #define PCI_DEVICE_ID_MATROX_G100_MM	0x1000
+ #define PCI_DEVICE_ID_MATROX_G100_AGP	0x1001
+ #define PCI_DEVICE_ID_MATROX_G200_PCI	0x0520
+ #define PCI_DEVICE_ID_MATROX_G200_AGP	0x0521
+ #define	PCI_DEVICE_ID_MATROX_G400	0x0525
+ #define PCI_DEVICE_ID_MATROX_G550	0x2527
+ #define PCI_DEVICE_ID_MATROX_VIA	0x4536
+ 
+ #define PCI_VENDOR_ID_CT		0x102c
+ #define PCI_DEVICE_ID_CT_65545		0x00d8
+ #define PCI_DEVICE_ID_CT_65548		0x00dc
+ #define PCI_DEVICE_ID_CT_65550		0x00e0
+ #define PCI_DEVICE_ID_CT_65554		0x00e4
+ #define PCI_DEVICE_ID_CT_65555		0x00e5
+ 
+ #define PCI_VENDOR_ID_MIRO		0x1031
+ #define PCI_DEVICE_ID_MIRO_36050	0x5601
+ 
+ #define PCI_VENDOR_ID_NEC		0x1033
+ #define PCI_DEVICE_ID_NEC_PCX2		0x0046
+ #define PCI_DEVICE_ID_NEC_NILE4		0x005a
+ #define PCI_DEVICE_ID_NEC_VRC5476       0x009b
+ 
+ #define PCI_VENDOR_ID_FD		0x1036
+ #define PCI_DEVICE_ID_FD_36C70		0x0000
+ 
+ #define PCI_VENDOR_ID_SIS         	0x1039
+ #define PCI_VENDOR_ID_SI		0x1039
+ #define PCI_DEVICE_ID_SI_5591_AGP	0x0001
+ #define PCI_DEVICE_ID_SI_6202		0x0002
+ #define PCI_DEVICE_ID_SI_503		0x0008
+ #define PCI_DEVICE_ID_SI_ACPI		0x0009
+ #define PCI_DEVICE_ID_SI_5597_VGA	0x0200
+ #define PCI_DEVICE_ID_SI_6205		0x0205
+ #define PCI_DEVICE_ID_SI_501		0x0406
+ #define PCI_DEVICE_ID_SI_496		0x0496
+ #define PCI_DEVICE_ID_SI_300		0x0300
+ #define PCI_DEVICE_ID_SI_315H		0x0310
+ #define PCI_DEVICE_ID_SI_315		0x0315
+ #define PCI_DEVICE_ID_SI_315PRO		0x0325
+ #define PCI_DEVICE_ID_SI_530		0x0530
+ #define PCI_DEVICE_ID_SI_540		0x0540
+ #define PCI_DEVICE_ID_SI_550		0x0550
+ #define PCI_DEVICE_ID_SI_601		0x0601
+ #define PCI_DEVICE_ID_SI_620		0x0620
+ #define PCI_DEVICE_ID_SI_630		0x0630
+ #define PCI_DEVICE_ID_SI_635		0x0635
+ #define PCI_DEVICE_ID_SI_640		0x0640
+ #define PCI_DEVICE_ID_SI_645		0x0645
+ #define PCI_DEVICE_ID_SI_650		0x0650
+ #define PCI_DEVICE_ID_SI_730		0x0730
+ #define PCI_DEVICE_ID_SI_735		0x0735
+ #define PCI_DEVICE_ID_SI_740		0x0740
+ #define PCI_DEVICE_ID_SI_745		0x0745
+ #define PCI_DEVICE_ID_SI_750		0x0750
+ #define PCI_DEVICE_ID_SI_900		0x0900
+ #define PCI_DEVICE_ID_SIS900		0x0900
+ #define PCI_DEVICE_ID_SI_5107		0x5107
+ #define PCI_DEVICE_ID_SI_5300		0x5300
+ #define PCI_DEVICE_ID_SI_540_VGA	0x5300
+ #define PCI_DEVICE_ID_SI_550_VGA	0x5315
+ #define PCI_DEVICE_ID_SI_5511		0x5511
+ #define PCI_DEVICE_ID_SI_5513		0x5513
+ #define PCI_DEVICE_ID_SI_5571		0x5571
+ #define PCI_DEVICE_ID_SI_5591		0x5591
+ #define PCI_DEVICE_ID_SI_5597		0x5597
+ #define PCI_DEVICE_ID_SI_5598		0x5598
+ #define PCI_DEVICE_ID_SI_5600		0x5600
+ #define PCI_DEVICE_ID_SI_6300		0x6300
+ #define PCI_DEVICE_ID_SI_630_VGA	0x6300
+ #define PCI_DEVICE_ID_SI_6306		0x6306
+ #define PCI_DEVICE_ID_SI_6326		0x6326
+ #define PCI_DEVICE_ID_SI_7001		0x7001
+ #define PCI_DEVICE_ID_SI_7016		0x7016
+ #define PCI_DEVICE_ID_SIS7016    	0x7016  
+ #define PCI_DEVICE_ID_SI_730_VGA	0x7300
+ 
+ #define PCI_VENDOR_ID_HP		0x103c
+ #define PCI_DEVICE_ID_HP_DONNER_GFX	0x1008
+ #define PCI_DEVICE_ID_HP_TACHYON	0x1028
+ #define PCI_DEVICE_ID_HP_TACHLITE	0x1029
+ #define PCI_DEVICE_ID_HP_J2585A		0x1030
+ #define PCI_DEVICE_ID_HP_J2585B		0x1031
+ #define PCI_DEVICE_ID_HP_SAS		0x1048
+ #define PCI_DEVICE_ID_HP_DIVA1		0x1049
+ #define PCI_DEVICE_ID_HP_DIVA2		0x104A
+ #define PCI_DEVICE_ID_HP_SP2_0		0x104B
+ 
+ #define PCI_VENDOR_ID_PCTECH		0x1042
+ #define PCI_DEVICE_ID_PCTECH_RZ1000	0x1000
+ #define PCI_DEVICE_ID_PCTECH_RZ1001	0x1001
+ #define PCI_DEVICE_ID_PCTECH_SAMURAI_0	0x3000
+ #define PCI_DEVICE_ID_PCTECH_SAMURAI_1	0x3010
+ #define PCI_DEVICE_ID_PCTECH_SAMURAI_IDE 0x3020
+ 
+ #define PCI_VENDOR_ID_ASUSTEK		0x1043
+ #define PCI_DEVICE_ID_ASUSTEK_0675	0x0675
+ 
+ #define PCI_VENDOR_ID_DPT		0x1044
+ #define PCI_DEVICE_ID_DPT		0xa400
+ 
+ #define PCI_VENDOR_ID_OPTI		0x1045
+ #define PCI_DEVICE_ID_OPTI_92C178	0xc178
+ #define PCI_DEVICE_ID_OPTI_82C557	0xc557
+ #define PCI_DEVICE_ID_OPTI_82C558	0xc558
+ #define PCI_DEVICE_ID_OPTI_82C621	0xc621
+ #define PCI_DEVICE_ID_OPTI_82C700	0xc700
+ #define PCI_DEVICE_ID_OPTI_82C701	0xc701
+ #define PCI_DEVICE_ID_OPTI_82C814	0xc814
+ #define PCI_DEVICE_ID_OPTI_82C822	0xc822
+ #define PCI_DEVICE_ID_OPTI_82C861	0xc861
+ #define PCI_DEVICE_ID_OPTI_82C825	0xd568
+ 
+ #define PCI_VENDOR_ID_ELSA		0x1048
+ #define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+ #define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+ 
+ #define PCI_VENDOR_ID_ELSA		0x1048
+ #define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+ #define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+ 
+ #define PCI_VENDOR_ID_SGS		0x104a
+ #define PCI_DEVICE_ID_SGS_2000		0x0008
+ #define PCI_DEVICE_ID_SGS_1764		0x0009
+ 
+ #define PCI_VENDOR_ID_BUSLOGIC		      0x104B
+ #define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC 0x0140
+ #define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER    0x1040
+ #define PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT     0x8130
+ 
+ #define PCI_VENDOR_ID_TI		0x104c
+ #define PCI_DEVICE_ID_TI_TVP4010	0x3d04
+ #define PCI_DEVICE_ID_TI_TVP4020	0x3d07
+ #define PCI_DEVICE_ID_TI_1130		0xac12
+ #define PCI_DEVICE_ID_TI_1031		0xac13
+ #define PCI_DEVICE_ID_TI_1131		0xac15
+ #define PCI_DEVICE_ID_TI_1250		0xac16
+ #define PCI_DEVICE_ID_TI_1220		0xac17
+ #define PCI_DEVICE_ID_TI_1221		0xac19
+ #define PCI_DEVICE_ID_TI_1210		0xac1a
+ #define PCI_DEVICE_ID_TI_1410		0xac50
+ #define PCI_DEVICE_ID_TI_1450		0xac1b
+ #define PCI_DEVICE_ID_TI_1225		0xac1c
+ #define PCI_DEVICE_ID_TI_1251A		0xac1d
+ #define PCI_DEVICE_ID_TI_1211		0xac1e
+ #define PCI_DEVICE_ID_TI_1251B		0xac1f
+ #define PCI_DEVICE_ID_TI_4410		0xac41
+ #define PCI_DEVICE_ID_TI_4451		0xac42
+ #define PCI_DEVICE_ID_TI_1420		0xac51
+ 
+ #define PCI_VENDOR_ID_SONY		0x104d
+ #define PCI_DEVICE_ID_SONY_CXD3222	0x8039
+ 
+ #define PCI_VENDOR_ID_OAK		0x104e
+ #define PCI_DEVICE_ID_OAK_OTI107	0x0107
+ 
+ /* Winbond have two vendor IDs! See 0x10ad as well */
+ #define PCI_VENDOR_ID_WINBOND2		0x1050
+ #define PCI_DEVICE_ID_WINBOND2_89C840   0x0840
+ #define PCI_DEVICE_ID_WINBOND2_89C940	0x0940
+ #define PCI_DEVICE_ID_WINBOND2_89C940F	0x5a5a
+ #define PCI_DEVICE_ID_WINBOND2_6692	0x6692
+ 
+ #define PCI_VENDOR_ID_ANIGMA		0x1051
+ #define PCI_DEVICE_ID_ANIGMA_MC145575	0x0100
+   
+ #define PCI_VENDOR_ID_EFAR		0x1055
+ #define PCI_DEVICE_ID_EFAR_SLC90E66_1	0x9130
+ #define PCI_DEVICE_ID_EFAR_SLC90E66_0	0x9460
+ #define PCI_DEVICE_ID_EFAR_SLC90E66_2	0x9462
+ #define PCI_DEVICE_ID_EFAR_SLC90E66_3	0x9463
+ 
+ #define PCI_VENDOR_ID_MOTOROLA		0x1057
+ #define PCI_VENDOR_ID_MOTOROLA_OOPS	0x1507
+ #define PCI_DEVICE_ID_MOTOROLA_MPC105	0x0001
+ #define PCI_DEVICE_ID_MOTOROLA_MPC106	0x0002
+ #define PCI_DEVICE_ID_MOTOROLA_RAVEN	0x4801
+ #define PCI_DEVICE_ID_MOTOROLA_FALCON	0x4802
+ #define PCI_DEVICE_ID_MOTOROLA_CPX8216	0x4806
+ 
+ #define PCI_VENDOR_ID_PROMISE		0x105a
+ #define PCI_DEVICE_ID_PROMISE_20265	0x0d30
+ #define PCI_DEVICE_ID_PROMISE_20267	0x4d30
+ #define PCI_DEVICE_ID_PROMISE_20246	0x4d33
+ #define PCI_DEVICE_ID_PROMISE_20262	0x4d38
+ #define PCI_DEVICE_ID_PROMISE_20268	0x4d68
+ #define PCI_DEVICE_ID_PROMISE_20268R	0x6268
+ #define PCI_DEVICE_ID_PROMISE_20269	0x4d69
+ #define PCI_DEVICE_ID_PROMISE_20275	0x1275
+ #define PCI_DEVICE_ID_PROMISE_5300	0x5300
+ 
+ #define PCI_VENDOR_ID_N9		0x105d
+ #define PCI_DEVICE_ID_N9_I128		0x2309
+ #define PCI_DEVICE_ID_N9_I128_2		0x2339
+ #define PCI_DEVICE_ID_N9_I128_T2R	0x493d
+ 
+ #define PCI_VENDOR_ID_UMC		0x1060
+ #define PCI_DEVICE_ID_UMC_UM8673F	0x0101
+ #define PCI_DEVICE_ID_UMC_UM8891A	0x0891
+ #define PCI_DEVICE_ID_UMC_UM8886BF	0x673a
+ #define PCI_DEVICE_ID_UMC_UM8886A	0x886a
+ #define PCI_DEVICE_ID_UMC_UM8881F	0x8881
+ #define PCI_DEVICE_ID_UMC_UM8886F	0x8886
+ #define PCI_DEVICE_ID_UMC_UM9017F	0x9017
+ #define PCI_DEVICE_ID_UMC_UM8886N	0xe886
+ #define PCI_DEVICE_ID_UMC_UM8891N	0xe891
+ 
+ #define PCI_VENDOR_ID_X			0x1061
+ #define PCI_DEVICE_ID_X_AGX016		0x0001
+ 
+ #define PCI_VENDOR_ID_MYLEX		0x1069
+ #define PCI_DEVICE_ID_MYLEX_DAC960_P	0x0001
+ #define PCI_DEVICE_ID_MYLEX_DAC960_PD	0x0002
+ #define PCI_DEVICE_ID_MYLEX_DAC960_PG	0x0010
+ #define PCI_DEVICE_ID_MYLEX_DAC960_LA	0x0020
+ #define PCI_DEVICE_ID_MYLEX_DAC960_LP	0x0050
+ #define PCI_DEVICE_ID_MYLEX_DAC960_BA	0xBA56
+ 
+ #define PCI_VENDOR_ID_PICOP		0x1066
+ #define PCI_DEVICE_ID_PICOP_PT86C52X	0x0001
+ #define PCI_DEVICE_ID_PICOP_PT80C524	0x8002
+ 
+ #define PCI_VENDOR_ID_APPLE		0x106b
+ #define PCI_DEVICE_ID_APPLE_BANDIT	0x0001
+ #define PCI_DEVICE_ID_APPLE_GC		0x0002
+ #define PCI_DEVICE_ID_APPLE_HYDRA	0x000e
+ #define PCI_DEVICE_ID_APPLE_UNI_N_FW	0x0018
+ #define PCI_DEVICE_ID_APPLE_KL_USB	0x0019
+ #define PCI_DEVICE_ID_APPLE_UNI_N_AGP	0x0020
+ #define PCI_DEVICE_ID_APPLE_UNI_N_GMAC	0x0021
+ #define PCI_DEVICE_ID_APPLE_UNI_N_FW2	0x0030
+ 
+ #define PCI_VENDOR_ID_YAMAHA		0x1073
+ #define PCI_DEVICE_ID_YAMAHA_724	0x0004
+ #define PCI_DEVICE_ID_YAMAHA_724F	0x000d
+ #define PCI_DEVICE_ID_YAMAHA_740	0x000a
+ #define PCI_DEVICE_ID_YAMAHA_740C	0x000c
+ #define PCI_DEVICE_ID_YAMAHA_744	0x0010
+ #define PCI_DEVICE_ID_YAMAHA_754	0x0012
+ 
+ #define PCI_VENDOR_ID_NEXGEN		0x1074
+ #define PCI_DEVICE_ID_NEXGEN_82C501	0x4e78
+ 
+ #define PCI_VENDOR_ID_QLOGIC		0x1077
+ #define PCI_DEVICE_ID_QLOGIC_ISP1020	0x1020
+ #define PCI_DEVICE_ID_QLOGIC_ISP1022	0x1022
+ #define PCI_DEVICE_ID_QLOGIC_ISP2100	0x2100
+ #define PCI_DEVICE_ID_QLOGIC_ISP2200	0x2200
+ 
+ #define PCI_VENDOR_ID_CYRIX		0x1078
+ #define PCI_DEVICE_ID_CYRIX_5510	0x0000
+ #define PCI_DEVICE_ID_CYRIX_PCI_MASTER	0x0001
+ #define PCI_DEVICE_ID_CYRIX_5520	0x0002
+ #define PCI_DEVICE_ID_CYRIX_5530_LEGACY	0x0100
+ #define PCI_DEVICE_ID_CYRIX_5530_SMI	0x0101
+ #define PCI_DEVICE_ID_CYRIX_5530_IDE	0x0102
+ #define PCI_DEVICE_ID_CYRIX_5530_AUDIO	0x0103
+ #define PCI_DEVICE_ID_CYRIX_5530_VIDEO	0x0104
+ 
+ #define PCI_VENDOR_ID_LEADTEK		0x107d
+ #define PCI_DEVICE_ID_LEADTEK_805	0x0000
+ 
+ #define PCI_VENDOR_ID_INTERPHASE	0x107e
+ #define PCI_DEVICE_ID_INTERPHASE_5526	0x0004
+ #define PCI_DEVICE_ID_INTERPHASE_55x6	0x0005
+ #define PCI_DEVICE_ID_INTERPHASE_5575	0x0008
+ 
+ #define PCI_VENDOR_ID_CONTAQ		0x1080
+ #define PCI_DEVICE_ID_CONTAQ_82C599	0x0600
+ #define PCI_DEVICE_ID_CONTAQ_82C693	0xc693
+ 
+ #define PCI_VENDOR_ID_FOREX		0x1083
+ 
+ #define PCI_VENDOR_ID_OLICOM		0x108d
+ #define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
+ #define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
+ #define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
+ #define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
+ #define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
+ #define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
+ 
+ #define PCI_VENDOR_ID_SUN		0x108e
+ #define PCI_DEVICE_ID_SUN_EBUS		0x1000
+ #define PCI_DEVICE_ID_SUN_HAPPYMEAL	0x1001
+ #define PCI_DEVICE_ID_SUN_RIO_EBUS	0x1100
+ #define PCI_DEVICE_ID_SUN_RIO_GEM	0x1101
+ #define PCI_DEVICE_ID_SUN_RIO_1394	0x1102
+ #define PCI_DEVICE_ID_SUN_RIO_USB	0x1103
+ #define PCI_DEVICE_ID_SUN_GEM		0x2bad
+ #define PCI_DEVICE_ID_SUN_SIMBA		0x5000
+ #define PCI_DEVICE_ID_SUN_PBM		0x8000
+ #define PCI_DEVICE_ID_SUN_SCHIZO	0x8001
+ #define PCI_DEVICE_ID_SUN_SABRE		0xa000
+ #define PCI_DEVICE_ID_SUN_HUMMINGBIRD	0xa001
+ 
+ #define PCI_VENDOR_ID_CMD		0x1095
+ #define PCI_DEVICE_ID_CMD_640		0x0640
+ #define PCI_DEVICE_ID_CMD_643		0x0643
+ #define PCI_DEVICE_ID_CMD_646		0x0646
+ #define PCI_DEVICE_ID_CMD_647		0x0647
+ #define PCI_DEVICE_ID_CMD_648		0x0648
+ #define PCI_DEVICE_ID_CMD_649		0x0649
+ #define PCI_DEVICE_ID_CMD_670		0x0670
+ #define PCI_DEVICE_ID_CMD_680		0x0680
+ 
+ #define PCI_VENDOR_ID_VISION		0x1098
+ #define PCI_DEVICE_ID_VISION_QD8500	0x0001
+ #define PCI_DEVICE_ID_VISION_QD8580	0x0002
+ 
+ #define PCI_VENDOR_ID_BROOKTREE		0x109e
+ #define PCI_DEVICE_ID_BROOKTREE_848	0x0350
+ #define PCI_DEVICE_ID_BROOKTREE_849A	0x0351
+ #define PCI_DEVICE_ID_BROOKTREE_878_1	0x036e
+ #define PCI_DEVICE_ID_BROOKTREE_878	0x0878
+ #define PCI_DEVICE_ID_BROOKTREE_8474	0x8474
+ 
+ #define PCI_VENDOR_ID_SIERRA		0x10a8
+ #define PCI_DEVICE_ID_SIERRA_STB	0x0000
+ 
+ #define PCI_VENDOR_ID_SGI		0x10a9
+ #define PCI_DEVICE_ID_SGI_IOC3		0x0003
+ 
+ #define PCI_VENDOR_ID_ACC		0x10aa
+ #define PCI_DEVICE_ID_ACC_2056		0x0000
+ 
+ #define PCI_VENDOR_ID_WINBOND		0x10ad
+ #define PCI_DEVICE_ID_WINBOND_83769	0x0001
+ #define PCI_DEVICE_ID_WINBOND_82C105	0x0105
+ #define PCI_DEVICE_ID_WINBOND_83C553	0x0565
+ 
+ #define PCI_VENDOR_ID_DATABOOK		0x10b3
+ #define PCI_DEVICE_ID_DATABOOK_87144	0xb106
+ 
+ #define PCI_VENDOR_ID_PLX		0x10b5
+ #define PCI_DEVICE_ID_PLX_R685		0x1030
+ #define PCI_DEVICE_ID_PLX_ROMULUS	0x106a
+ #define PCI_DEVICE_ID_PLX_SPCOM800	0x1076
+ #define PCI_DEVICE_ID_PLX_1077		0x1077
+ #define PCI_DEVICE_ID_PLX_SPCOM200	0x1103
+ #define PCI_DEVICE_ID_PLX_DJINN_ITOO	0x1151
+ #define PCI_DEVICE_ID_PLX_R753		0x1152
+ #define PCI_DEVICE_ID_PLX_9050		0x9050
+ #define PCI_DEVICE_ID_PLX_9060		0x9060
+ #define PCI_DEVICE_ID_PLX_9060ES	0x906E
+ #define PCI_DEVICE_ID_PLX_9060SD	0x906D
+ #define PCI_DEVICE_ID_PLX_9080		0x9080
+ #define PCI_DEVICE_ID_PLX_GTEK_SERIAL2	0xa001
+ 
+ #define PCI_VENDOR_ID_MADGE		0x10b6
+ #define PCI_DEVICE_ID_MADGE_MK2		0x0002
+ #define PCI_DEVICE_ID_MADGE_C155S	0x1001
+ 
+ #define PCI_VENDOR_ID_3COM		0x10b7
+ #define PCI_DEVICE_ID_3COM_3C985	0x0001
+ #define PCI_DEVICE_ID_3COM_3C339	0x3390
+ #define PCI_DEVICE_ID_3COM_3C590	0x5900
+ #define PCI_DEVICE_ID_3COM_3C595	0x5950
+ #define PCI_DEVICE_ID_3COM_3C595TX	0x5950
+ #define PCI_DEVICE_ID_3COM_3C595_1	0x5951
+ #define PCI_DEVICE_ID_3COM_3C595T4	0x5951
+ #define PCI_DEVICE_ID_3COM_3C595_2	0x5952
+ #define PCI_DEVICE_ID_3COM_3C595MII	0x5952
+ #define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
+ #define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
+ #define PCI_DEVICE_ID_3COM_3C905TX	0x9050
+ #define PCI_DEVICE_ID_3COM_3C905T4	0x9051
+ #define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
+ #define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
+ 
+ #define PCI_VENDOR_ID_SMC		0x10b8
+ #define PCI_DEVICE_ID_SMC_EPIC100	0x0005
+ 
+ #define PCI_VENDOR_ID_SUNDANCE		0x13F0
+ #define PCI_DEVICE_ID_SUNDANCE_ALTA	0x0201
+ 
+ #define PCI_VENDOR_ID_AL		0x10b9
+ #define PCI_DEVICE_ID_AL_M1445		0x1445
+ #define PCI_DEVICE_ID_AL_M1449		0x1449
+ #define PCI_DEVICE_ID_AL_M1451		0x1451
+ #define PCI_DEVICE_ID_AL_M1461		0x1461
+ #define PCI_DEVICE_ID_AL_M1489		0x1489
+ #define PCI_DEVICE_ID_AL_M1511		0x1511
+ #define PCI_DEVICE_ID_AL_M1513		0x1513
+ #define PCI_DEVICE_ID_AL_M1521		0x1521
+ #define PCI_DEVICE_ID_AL_M1523		0x1523
+ #define PCI_DEVICE_ID_AL_M1531		0x1531
+ #define PCI_DEVICE_ID_AL_M1533		0x1533
+ #define PCI_DEVICE_ID_AL_M1541		0x1541
+ #define PCI_DEVICE_ID_AL_M1621          0x1621
+ #define PCI_DEVICE_ID_AL_M1631          0x1631
+ #define PCI_DEVICE_ID_AL_M1641          0x1641
+ #define PCI_DEVICE_ID_AL_M1647          0x1647
+ #define PCI_DEVICE_ID_AL_M1651          0x1651
+ #define PCI_DEVICE_ID_AL_M1543		0x1543
+ #define PCI_DEVICE_ID_AL_M3307		0x3307
+ #define PCI_DEVICE_ID_AL_M4803		0x5215
+ #define PCI_DEVICE_ID_AL_M5219		0x5219
+ #define PCI_DEVICE_ID_AL_M5229		0x5229
+ #define PCI_DEVICE_ID_AL_M5237		0x5237
+ #define PCI_DEVICE_ID_AL_M5243		0x5243
+ #define PCI_DEVICE_ID_AL_M5451		0x5451
+ #define PCI_DEVICE_ID_AL_M7101		0x7101
+ 
+ #define PCI_VENDOR_ID_MITSUBISHI	0x10ba
+ 
+ #define PCI_VENDOR_ID_SURECOM		0x10bd
+ #define PCI_DEVICE_ID_SURECOM_NE34	0x0e34
+ 
+ #define PCI_VENDOR_ID_NEOMAGIC		0x10c8
+ #define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2070 0x0001
+ #define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128V 0x0002
+ #define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZV 0x0003
+ #define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2160 0x0004
+ #define PCI_DEVICE_ID_NEOMAGIC_MAGICMEDIA_256AV       0x0005
+ #define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZVPLUS   0x0083
+ 
+ #define PCI_VENDOR_ID_ASP		0x10cd
+ #define PCI_DEVICE_ID_ASP_ABP940	0x1200
+ #define PCI_DEVICE_ID_ASP_ABP940U	0x1300
+ #define PCI_DEVICE_ID_ASP_ABP940UW	0x2300
+ 
+ #define PCI_VENDOR_ID_MACRONIX		0x10d9
+ #define PCI_DEVICE_ID_MACRONIX_MX98713	0x0512
+ #define PCI_DEVICE_ID_MX987x3		0x0512
+ #define PCI_DEVICE_ID_MACRONIX_MX987x5	0x0531
+ #define PCI_DEVICE_ID_MX987x5		0x0531
+ 
+ #define PCI_VENDOR_ID_TCONRAD		0x10da
+ #define PCI_DEVICE_ID_TCONRAD_TOKENRING	0x0508
+ 
+ #define PCI_VENDOR_ID_CERN		0x10dc
+ #define PCI_DEVICE_ID_CERN_SPSB_PMC	0x0001
+ #define PCI_DEVICE_ID_CERN_SPSB_PCI	0x0002
+ #define PCI_DEVICE_ID_CERN_HIPPI_DST	0x0021
+ #define PCI_DEVICE_ID_CERN_HIPPI_SRC	0x0022
+ 
+ #define PCI_VENDOR_ID_NVIDIA			0x10de
+ #define PCI_DEVICE_ID_NVIDIA_TNT		0x0020
+ #define PCI_DEVICE_ID_NVIDIA_TNT2		0x0028
+ #define PCI_DEVICE_ID_NVIDIA_UTNT2		0x0029
+ #define PCI_DEVICE_ID_NVIDIA_VTNT2		0x002C
+ #define PCI_DEVICE_ID_NVIDIA_UVTNT2		0x002D
+ #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR	0x0100
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR	0x0101
+ #define PCI_DEVICE_ID_NVIDIA_QUADRO		0x0103
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX	0x0110
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2	0x0111
+ #define PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR	0x0113
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS	0x0150
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2	0x0151
+ #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA	0x0152
+ #define PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO	0x0153
+ 
+ #define PCI_VENDOR_ID_IMS		0x10e0
+ #define PCI_DEVICE_ID_IMS_8849		0x8849
+ #define PCI_DEVICE_ID_IMS_TT128		0x9128
+ #define PCI_DEVICE_ID_IMS_TT3D		0x9135
+ 
+ #define PCI_VENDOR_ID_TEKRAM2		0x10e1
+ #define PCI_DEVICE_ID_TEKRAM2_690c	0x690c
+ 
+ #define PCI_VENDOR_ID_TUNDRA		0x10e3
+ #define PCI_DEVICE_ID_TUNDRA_CA91C042	0x0000
+ 
+ #define PCI_VENDOR_ID_AMCC		0x10e8
+ #define PCI_DEVICE_ID_AMCC_MYRINET	0x8043
+ #define PCI_DEVICE_ID_AMCC_PARASTATION	0x8062
+ #define PCI_DEVICE_ID_AMCC_S5933	0x807d
+ #define PCI_DEVICE_ID_AMCC_S5933_HEPC3	0x809c
+ 
+ #define PCI_VENDOR_ID_INTERG		0x10ea
+ #define PCI_DEVICE_ID_INTERG_1680	0x1680
+ #define PCI_DEVICE_ID_INTERG_1682	0x1682
+ #define PCI_DEVICE_ID_INTERG_2000	0x2000
+ #define PCI_DEVICE_ID_INTERG_2010	0x2010
+ #define PCI_DEVICE_ID_INTERG_5000	0x5000
+ #define PCI_DEVICE_ID_INTERG_5050	0x5050
+ 
+ #define PCI_VENDOR_ID_REALTEK		0x10ec
+ #define PCI_DEVICE_ID_REALTEK_8029	0x8029
+ #define PCI_DEVICE_ID_REALTEK_8129	0x8129
+ #define PCI_DEVICE_ID_REALTEK_8139	0x8139
+ 
+ #define PCI_VENDOR_ID_XILINX		0x10ee
+ #define PCI_DEVICE_ID_TURBOPAM		0x4020
+ 
+ #define PCI_VENDOR_ID_TRUEVISION	0x10fa
+ #define PCI_DEVICE_ID_TRUEVISION_T1000	0x000c
+ 
+ #define PCI_VENDOR_ID_INIT		0x1101
+ #define PCI_DEVICE_ID_INIT_320P		0x9100
+ #define PCI_DEVICE_ID_INIT_360P		0x9500
+ 
+ #define PCI_VENDOR_ID_CREATIVE		0x1102 // duplicate: ECTIVA
+ #define PCI_DEVICE_ID_CREATIVE_EMU10K1	0x0002
+ 
+ #define PCI_VENDOR_ID_ECTIVA		0x1102 // duplicate: CREATIVE
+ #define PCI_DEVICE_ID_ECTIVA_EV1938	0x8938
+ 
+ #define PCI_VENDOR_ID_TTI		0x1103
+ #define PCI_DEVICE_ID_TTI_HPT343	0x0003
+ #define PCI_DEVICE_ID_TTI_HPT366	0x0004
+ 
+ #define PCI_VENDOR_ID_VIA		0x1106
+ #define PCI_VENDOR_ID_VIATEC		0x1106
+ #define PCI_DEVICE_ID_VIA_8363_0	0x0305
+ #define PCI_DEVICE_ID_VIA_8371_0	0x0391
+ #define PCI_DEVICE_ID_VIA_8501_0	0x0501
+ #define PCI_DEVICE_ID_VIA_82C505	0x0505
+ #define PCI_DEVICE_ID_VIA_82C561	0x0561
+ #define PCI_DEVICE_ID_VIA_82C586_1	0x0571
+ #define PCI_DEVICE_ID_VIA_82C576	0x0576
+ #define PCI_DEVICE_ID_VIA_82C585	0x0585
+ #define PCI_DEVICE_ID_VIA_82C586_0	0x0586
+ #define PCI_DEVICE_ID_VIA_82C595	0x0595
+ #define PCI_DEVICE_ID_VIA_82C596	0x0596
+ #define PCI_DEVICE_ID_VIA_82C597_0	0x0597
+ #define PCI_DEVICE_ID_VIA_82C598_0	0x0598
+ #define PCI_DEVICE_ID_VIA_8601_0	0x0601
+ #define PCI_DEVICE_ID_VIA_8605_0	0x0605
+ #define PCI_DEVICE_ID_VIA_82C680	0x0680
+ #define PCI_DEVICE_ID_VIA_82C686	0x0686
+ #define PCI_DEVICE_ID_VIA_82C691	0x0691
+ #define PCI_DEVICE_ID_VIA_82C693	0x0693
+ #define PCI_DEVICE_ID_VIA_82C693_1	0x0698
+ #define PCI_DEVICE_ID_VIA_82C926	0x0926
+ #define PCI_DEVICE_ID_VIA_82C576_1	0x1571
+ #define PCI_DEVICE_ID_VIA_82C595_97	0x1595
+ #define PCI_DEVICE_ID_VIA_82C586_2	0x3038
+ #define PCI_DEVICE_ID_VIA_82C586_3	0x3040
+ #define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
+ #define PCI_DEVICE_ID_VIA_6305		0x3044
+ #define PCI_DEVICE_ID_VIA_82C596_3	0x3050
+ #define PCI_DEVICE_ID_VIA_82C596B_3	0x3051
+ #define PCI_DEVICE_ID_VIA_82C686_4	0x3057
+ #define PCI_DEVICE_ID_VIA_82C686_5	0x3058
+ #define PCI_DEVICE_ID_VIA_8233_5	0x3059
+ #define PCI_DEVICE_ID_VIA_8233_7	0x3065
+ #define PCI_DEVICE_ID_VIA_VT6102	0x3065
+ #define PCI_DEVICE_ID_VIA_82C686_6	0x3068
+ #define PCI_DEVICE_ID_VIA_8233_0	0x3074
+ #define PCI_DEVICE_ID_VIA_VT6105	0x3106
+ #define PCI_DEVICE_ID_VIA_8233C_0	0x3109
+ #define PCI_DEVICE_ID_VIA_8633_0	0x3091
+ #define PCI_DEVICE_ID_VIA_8367_0	0x3099
+ #define PCI_DEVICE_ID_VIA_86C100A	0x6100
+ #define PCI_DEVICE_ID_VIA_8231		0x8231
+ #define PCI_DEVICE_ID_VIA_8231_4	0x8235
+ #define PCI_DEVICE_ID_VIA_8365_1	0x8305
+ #define PCI_DEVICE_ID_VIA_8371_1	0x8391
+ #define PCI_DEVICE_ID_VIA_8501_1	0x8501
+ #define PCI_DEVICE_ID_VIA_82C597_1	0x8597
+ #define PCI_DEVICE_ID_VIA_82C598_1	0x8598
+ #define PCI_DEVICE_ID_VIA_8601_1	0x8601
+ #define PCI_DEVICE_ID_VIA_8505_1	0X8605
+ #define PCI_DEVICE_ID_VIA_8633_1	0xB091
+ #define PCI_DEVICE_ID_VIA_8367_1	0xB099
+ 
+ #define PCI_VENDOR_ID_SIEMENS           0x110A
+ #define PCI_DEVICE_ID_SIEMENS_DSCC4     0x2102
+ 
+ #define PCI_VENDOR_ID_SMC2		0x1113
+ #define PCI_DEVICE_ID_SMC2_1211TX	0x1211
+ #define PCI_DEVICE_ID_SMC2_1211         0x1211
+ #define PCI_DEVICE_ID_SMC2_1216         0x1216
+ 
+ #define PCI_VENDOR_ID_VORTEX		0x1119
+ #define PCI_DEVICE_ID_VORTEX_GDT60x0	0x0000
+ #define PCI_DEVICE_ID_VORTEX_GDT6000B	0x0001
+ #define PCI_DEVICE_ID_VORTEX_GDT6x10	0x0002
+ #define PCI_DEVICE_ID_VORTEX_GDT6x20	0x0003
+ #define PCI_DEVICE_ID_VORTEX_GDT6530	0x0004
+ #define PCI_DEVICE_ID_VORTEX_GDT6550	0x0005
+ #define PCI_DEVICE_ID_VORTEX_GDT6x17	0x0006
+ #define PCI_DEVICE_ID_VORTEX_GDT6x27	0x0007
+ #define PCI_DEVICE_ID_VORTEX_GDT6537	0x0008
+ #define PCI_DEVICE_ID_VORTEX_GDT6557	0x0009
+ #define PCI_DEVICE_ID_VORTEX_GDT6x15	0x000a
+ #define PCI_DEVICE_ID_VORTEX_GDT6x25	0x000b
+ #define PCI_DEVICE_ID_VORTEX_GDT6535	0x000c
+ #define PCI_DEVICE_ID_VORTEX_GDT6555	0x000d
+ #define PCI_DEVICE_ID_VORTEX_GDT6x17RP	0x0100
+ #define PCI_DEVICE_ID_VORTEX_GDT6x27RP	0x0101
+ #define PCI_DEVICE_ID_VORTEX_GDT6537RP	0x0102
+ #define PCI_DEVICE_ID_VORTEX_GDT6557RP	0x0103
+ #define PCI_DEVICE_ID_VORTEX_GDT6x11RP	0x0104
+ #define PCI_DEVICE_ID_VORTEX_GDT6x21RP	0x0105
+ #define PCI_DEVICE_ID_VORTEX_GDT6x17RP1	0x0110
+ #define PCI_DEVICE_ID_VORTEX_GDT6x27RP1	0x0111
+ #define PCI_DEVICE_ID_VORTEX_GDT6537RP1	0x0112
+ #define PCI_DEVICE_ID_VORTEX_GDT6557RP1	0x0113
+ #define PCI_DEVICE_ID_VORTEX_GDT6x11RP1	0x0114
+ #define PCI_DEVICE_ID_VORTEX_GDT6x21RP1	0x0115
+ #define PCI_DEVICE_ID_VORTEX_GDT6x17RP2	0x0120
+ #define PCI_DEVICE_ID_VORTEX_GDT6x27RP2	0x0121
+ #define PCI_DEVICE_ID_VORTEX_GDT6537RP2	0x0122
+ #define PCI_DEVICE_ID_VORTEX_GDT6557RP2	0x0123
+ #define PCI_DEVICE_ID_VORTEX_GDT6x11RP2	0x0124
+ #define PCI_DEVICE_ID_VORTEX_GDT6x21RP2	0x0125
+ 
+ #define PCI_VENDOR_ID_EF		0x111a
+ #define PCI_DEVICE_ID_EF_ATM_FPGA	0x0000
+ #define PCI_DEVICE_ID_EF_ATM_ASIC	0x0002
+ 
+ #define PCI_VENDOR_ID_IDT		0x111d
+ #define PCI_DEVICE_ID_IDT_IDT77201	0x0001
+ 
+ #define PCI_VENDOR_ID_FORE		0x1127
+ #define PCI_DEVICE_ID_FORE_PCA200PC	0x0210
+ #define PCI_DEVICE_ID_FORE_PCA200E	0x0300
+ 
+ #define PCI_VENDOR_ID_IMAGINGTECH	0x112f
+ #define PCI_DEVICE_ID_IMAGINGTECH_ICPCI	0x0000
+ 
+ #define PCI_VENDOR_ID_PHILIPS		0x1131
+ #define PCI_DEVICE_ID_PHILIPS_SAA7145	0x7145
+ #define PCI_DEVICE_ID_PHILIPS_SAA7146	0x7146
+ #define PCI_DEVICE_ID_PHILIPS_SAA9730	0x9730
+ 
+ #define PCI_VENDOR_ID_EICON		0x1133
+ #define PCI_DEVICE_ID_EICON_DIVA20PRO	0xe001
+ #define PCI_DEVICE_ID_EICON_DIVA20	0xe002
+ #define PCI_DEVICE_ID_EICON_DIVA20PRO_U	0xe003
+ #define PCI_DEVICE_ID_EICON_DIVA20_U	0xe004
+ #define PCI_DEVICE_ID_EICON_DIVA201	0xe005
+ #define PCI_DEVICE_ID_EICON_MAESTRA	0xe010
+ #define PCI_DEVICE_ID_EICON_MAESTRAQ	0xe012
+ #define PCI_DEVICE_ID_EICON_MAESTRAQ_U	0xe013
+ #define PCI_DEVICE_ID_EICON_MAESTRAP	0xe014
+  
+ #define PCI_VENDOR_ID_CYCLONE		0x113c
+ #define PCI_DEVICE_ID_CYCLONE_SDK	0x0001
+ 
+ #define PCI_VENDOR_ID_ALLIANCE		0x1142
+ #define PCI_DEVICE_ID_ALLIANCE_PROMOTIO	0x3210
+ #define PCI_DEVICE_ID_ALLIANCE_PROVIDEO	0x6422
+ #define PCI_DEVICE_ID_ALLIANCE_AT24	0x6424
+ #define PCI_DEVICE_ID_ALLIANCE_AT3D	0x643d
+ 
+ #define PCI_VENDOR_ID_SYSKONNECT	0x1148
+ #define PCI_DEVICE_ID_SYSKONNECT_FP	0x4000
+ #define PCI_DEVICE_ID_SYSKONNECT_TR	0x4200
+ #define PCI_DEVICE_ID_SYSKONNECT_GE	0x4300
+ 
+ #define PCI_VENDOR_ID_VMIC		0x114a
+ #define PCI_DEVICE_ID_VMIC_VME		0x7587
+ 
+ #define PCI_VENDOR_ID_DIGI		0x114f
+ #define PCI_DEVICE_ID_DIGI_EPC		0x0002
+ #define PCI_DEVICE_ID_DIGI_RIGHTSWITCH	0x0003
+ #define PCI_DEVICE_ID_DIGI_XEM		0x0004
+ #define PCI_DEVICE_ID_DIGI_XR		0x0005
+ #define PCI_DEVICE_ID_DIGI_CX		0x0006
+ #define PCI_DEVICE_ID_DIGI_XRJ		0x0009
+ #define PCI_DEVICE_ID_DIGI_EPCJ		0x000a
+ #define PCI_DEVICE_ID_DIGI_XR_920	0x0027
+ #define PCI_DEVICE_ID_DIGI_DF_M_IOM2_E	0x0070
+ #define PCI_DEVICE_ID_DIGI_DF_M_E	0x0071
+ #define PCI_DEVICE_ID_DIGI_DF_M_IOM2_A	0x0072
+ #define PCI_DEVICE_ID_DIGI_DF_M_A	0x0073
+ 
+ #define PCI_VENDOR_ID_MUTECH		0x1159
+ #define PCI_DEVICE_ID_MUTECH_MV1000	0x0001
+ 
+ #define PCI_VENDOR_ID_XIRCOM		0x115d
+ #define PCI_DEVICE_ID_XIRCOM_X3201_ETH	0x0003
+ #define PCI_DEVICE_ID_XIRCOM_X3201_MDM	0x0103
+ 
+ #define PCI_VENDOR_ID_RENDITION		0x1163
+ #define PCI_DEVICE_ID_RENDITION_VERITE	0x0001
+ #define PCI_DEVICE_ID_RENDITION_VERITE2100 0x2000
+ 
+ #define PCI_VENDOR_ID_SERVERWORKS	  0x1166
+ #define PCI_DEVICE_ID_SERVERWORKS_HE	  0x0008
+ #define PCI_DEVICE_ID_SERVERWORKS_LE	  0x0009
+ #define PCI_DEVICE_ID_SERVERWORKS_CIOB30  0x0010
+ #define PCI_DEVICE_ID_SERVERWORKS_CMIC_HE 0x0011
+ #define PCI_DEVICE_ID_SERVERWORKS_OSB4	  0x0200
+ #define PCI_DEVICE_ID_SERVERWORKS_CSB5	  0x0201
+ #define PCI_DEVICE_ID_SERVERWORKS_OSB4IDE 0x0211
+ #define PCI_DEVICE_ID_SERVERWORKS_CSB5IDE 0x0212
+ #define PCI_DEVICE_ID_SERVERWORKS_OSB4USB 0x0220
+ #define PCI_DEVICE_ID_SERVERWORKS_CSB5USB PCI_DEVICE_ID_SERVERWORKS_OSB4USB
+ #define PCI_DEVICE_ID_SERVERWORKS_CSB5ISA 0x0230
+ 
+ #define PCI_VENDOR_ID_SBE		0x1176
+ #define PCI_DEVICE_ID_SBE_WANXL100	0x0301
+ #define PCI_DEVICE_ID_SBE_WANXL200	0x0302
+ #define PCI_DEVICE_ID_SBE_WANXL400	0x0104
+ 
+ #define PCI_VENDOR_ID_TOSHIBA		0x1179
+ #define PCI_DEVICE_ID_TOSHIBA_601	0x0601
+ #define PCI_DEVICE_ID_TOSHIBA_TOPIC95	0x060a
+ #define PCI_DEVICE_ID_TOSHIBA_TOPIC97	0x060f
+ 
+ #define PCI_VENDOR_ID_RICOH		0x1180
+ #define PCI_DEVICE_ID_RICOH_RL5C465	0x0465
+ #define PCI_DEVICE_ID_RICOH_RL5C466	0x0466
+ #define PCI_DEVICE_ID_RICOH_RL5C475	0x0475
+ #define PCI_DEVICE_ID_RICOH_RL5C476	0x0476
+ #define PCI_DEVICE_ID_RICOH_RL5C478	0x0478
+ 
+ #define	PCI_VENDOR_ID_DLINK		0x1186
+ #define	PCI_DEVICE_ID_DFE530TXP		0x1300
+ #define PCI_DEVICE_ID_DFE530TXS		0x1002
+ 
+ #define PCI_VENDOR_ID_ARTOP		0x1191
+ #define PCI_DEVICE_ID_ARTOP_ATP8400	0x0004
+ #define PCI_DEVICE_ID_ARTOP_ATP850UF	0x0005
+ #define PCI_DEVICE_ID_ARTOP_ATP860	0x0006
+ #define PCI_DEVICE_ID_ARTOP_ATP860R	0x0007
+ #define PCI_DEVICE_ID_ARTOP_AEC7610	0x8002
+ #define PCI_DEVICE_ID_ARTOP_AEC7612UW	0x8010
+ #define PCI_DEVICE_ID_ARTOP_AEC7612U	0x8020
+ #define PCI_DEVICE_ID_ARTOP_AEC7612S	0x8030
+ #define PCI_DEVICE_ID_ARTOP_AEC7612D	0x8040
+ #define PCI_DEVICE_ID_ARTOP_AEC7612SUW	0x8050
+ #define PCI_DEVICE_ID_ARTOP_8060	0x8060
+ 
+ #define PCI_VENDOR_ID_ZEITNET		0x1193
+ #define PCI_DEVICE_ID_ZEITNET_1221	0x0001
+ #define PCI_DEVICE_ID_ZEITNET_1225	0x0002
+ 
+ #define PCI_VENDOR_ID_OMEGA		0x119b
+ #define PCI_DEVICE_ID_OMEGA_82C092G	0x1221
+ 
+ #define PCI_VENDOR_ID_FUJITSU_ME	0x119e
+ #define PCI_DEVICE_ID_FUJITSU_FS155	0x0001
+ #define PCI_DEVICE_ID_FUJITSU_FS50	0x0003
+ 
+ #define PCI_SUBVENDOR_ID_KEYSPAN	0x11a9
+ #define PCI_SUBDEVICE_ID_KEYSPAN_SX2	0x5334
+ 
+ #define PCI_VENDOR_ID_GALILEO		0x11ab
+ #define PCI_DEVICE_ID_GALILEO_GT64011	0x4146
+ #define PCI_DEVICE_ID_GALILEO_GT64111	0x4146
+ #define PCI_DEVICE_ID_GALILEO_GT96100	0x9652
+ #define PCI_DEVICE_ID_GALILEO_GT96100A	0x9653
+ 
+ #define PCI_VENDOR_ID_LINKSYS		0x11ad
+ #define PCI_VENDOR_ID_LITEON		0x11ad
+ #define PCI_DEVICE_ID_LITEON_LNE100TX	0x0002
+ #define PCI_DEVICE_ID_LC82C115		0xC115
+ 
+ #define PCI_VENDOR_ID_V3		0x11b0
+ #define PCI_DEVICE_ID_V3_V960		0x0001
+ #define PCI_DEVICE_ID_V3_V350		0x0001
+ #define PCI_DEVICE_ID_V3_V961		0x0002
+ #define PCI_DEVICE_ID_V3_V351		0x0002
+ 
+ #define PCI_VENDOR_ID_NP		0x11bc
+ #define PCI_DEVICE_ID_NP_PCI_FDDI	0x0001
+ 
+ #define PCI_VENDOR_ID_ATT		0x11c1
+ #define PCI_DEVICE_ID_ATT_L56XMF	0x0440
+ #define PCI_DEVICE_ID_ATT_VENUS_MODEM	0x480
+ 
+ #define PCI_VENDOR_ID_SPECIALIX		0x11cb
+ #define PCI_DEVICE_ID_SPECIALIX_IO8	0x2000
+ #define PCI_DEVICE_ID_SPECIALIX_XIO	0x4000
+ #define PCI_DEVICE_ID_SPECIALIX_RIO	0x8000
+ #define PCI_SUBDEVICE_ID_SPECIALIX_SPEED4 0xa004
+ 
+ #define PCI_VENDOR_ID_AURAVISION	0x11d1
+ #define PCI_DEVICE_ID_AURAVISION_VXP524	0x01f7
+ 
+ #define PCI_VENDOR_ID_ANALOG_DEVICES	0x11d4
+ #define PCI_DEVICE_ID_AD1889JS		0x1889
+ 
+ #define PCI_VENDOR_ID_IKON		0x11d5
+ #define PCI_DEVICE_ID_IKON_10115	0x0115
+ #define PCI_DEVICE_ID_IKON_10117	0x0117
+ 
+ #define PCI_VENDOR_ID_ZORAN		0x11de
+ #define PCI_DEVICE_ID_ZORAN_36057	0x6057
+ #define PCI_DEVICE_ID_ZORAN_36120	0x6120
+ 
+ #define PCI_VENDOR_ID_KINETIC		0x11f4
+ #define PCI_DEVICE_ID_KINETIC_2915	0x2915
+ 
+ #define PCI_VENDOR_ID_COMPEX		0x11f6
+ #define PCI_DEVICE_ID_COMPEX_ENET100VG4	0x0112
+ #define PCI_DEVICE_ID_COMPEX_RL2000	0x1401
+ #define PCI_DEVICE_ID_COMPEX_RL100ATX   0x2011
+ 
+ #define PCI_VENDOR_ID_RP		0x11fe
+ #define PCI_DEVICE_ID_RP32INTF		0x0001
+ #define PCI_DEVICE_ID_RP8INTF		0x0002
+ #define PCI_DEVICE_ID_RP16INTF		0x0003
+ #define PCI_DEVICE_ID_RP4QUAD		0x0004
+ #define PCI_DEVICE_ID_RP8OCTA		0x0005
+ #define PCI_DEVICE_ID_RP8J		0x0006
+ #define PCI_DEVICE_ID_RPP4		0x000A
+ #define PCI_DEVICE_ID_RPP8		0x000B
+ #define PCI_DEVICE_ID_RP8M		0x000C
+ 
+ #define PCI_VENDOR_ID_CYCLADES		0x120e
+ #define PCI_DEVICE_ID_CYCLOM_Y_Lo	0x0100
+ #define PCI_DEVICE_ID_CYCLOM_Y_Hi	0x0101
+ #define PCI_DEVICE_ID_CYCLOM_4Y_Lo	0x0102
+ #define PCI_DEVICE_ID_CYCLOM_4Y_Hi	0x0103
+ #define PCI_DEVICE_ID_CYCLOM_8Y_Lo	0x0104
+ #define PCI_DEVICE_ID_CYCLOM_8Y_Hi	0x0105
+ #define PCI_DEVICE_ID_CYCLOM_Z_Lo	0x0200
+ #define PCI_DEVICE_ID_CYCLOM_Z_Hi	0x0201
+ #define PCI_DEVICE_ID_PC300_RX_2	0x0300
+ #define PCI_DEVICE_ID_PC300_RX_1	0x0301
+ #define PCI_DEVICE_ID_PC300_TE_2	0x0310
+ #define PCI_DEVICE_ID_PC300_TE_1	0x0311
+ 
+ #define PCI_VENDOR_ID_ESSENTIAL		0x120f
+ #define PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER	0x0001
+ 
+ #define PCI_VENDOR_ID_O2		0x1217
+ #define PCI_DEVICE_ID_O2_6729		0x6729
+ #define PCI_DEVICE_ID_O2_6730		0x673a
+ #define PCI_DEVICE_ID_O2_6832		0x6832
+ #define PCI_DEVICE_ID_O2_6836		0x6836
+ 
+ #define PCI_VENDOR_ID_3DFX		0x121a
+ #define PCI_DEVICE_ID_3DFX_VOODOO	0x0001
+ #define PCI_DEVICE_ID_3DFX_VOODOO2	0x0002
+ #define PCI_DEVICE_ID_3DFX_BANSHEE	0x0003
+ #define PCI_DEVICE_ID_3DFX_VOODOO3	0x0005
+ 
+ #define PCI_VENDOR_ID_SIGMADES		0x1236
+ #define PCI_DEVICE_ID_SIGMADES_6425	0x6401
+ 
+ #define PCI_VENDOR_ID_CCUBE		0x123f
+ 
+ #define PCI_VENDOR_ID_AVM		0x1244
+ #define PCI_DEVICE_ID_AVM_B1		0x0700
+ #define PCI_DEVICE_ID_AVM_C4		0x0800
+ #define PCI_DEVICE_ID_AVM_A1		0x0a00
+ #define PCI_DEVICE_ID_AVM_A1_V2		0x0e00
+ #define PCI_DEVICE_ID_AVM_C2		0x1100
+ #define PCI_DEVICE_ID_AVM_T1		0x1200
+ 
+ #define PCI_VENDOR_ID_DIPIX		0x1246
+ 
+ #define PCI_VENDOR_ID_STALLION		0x124d
+ #define PCI_DEVICE_ID_STALLION_ECHPCI832 0x0000
+ #define PCI_DEVICE_ID_STALLION_ECHPCI864 0x0002
+ #define PCI_DEVICE_ID_STALLION_EIOPCI	0x0003
+ 
+ #define PCI_VENDOR_ID_OPTIBASE		0x1255
+ #define PCI_DEVICE_ID_OPTIBASE_FORGE	0x1110
+ #define PCI_DEVICE_ID_OPTIBASE_FUSION	0x1210
+ #define PCI_DEVICE_ID_OPTIBASE_VPLEX	0x2110
+ #define PCI_DEVICE_ID_OPTIBASE_VPLEXCC	0x2120
+ #define PCI_DEVICE_ID_OPTIBASE_VQUEST	0x2130
+ 
+ #define PCI_VENDOR_ID_ESS		0x125d
+ #define PCI_DEVICE_ID_ESS_ESS1968	0x1968
+ #define PCI_DEVICE_ID_ESS_AUDIOPCI	0x1969
+ #define PCI_DEVICE_ID_ESS_ESS1978	0x1978
+ 
+ #define PCI_VENDOR_ID_HARRIS        	0x1260
+ #define PCI_DEVICE_ID_HARRIS_PRISM2	0x3873
+ 
+ #define PCI_VENDOR_ID_SATSAGEM		0x1267
+ #define PCI_DEVICE_ID_SATSAGEM_NICCY	0x1016
+ #define PCI_DEVICE_ID_SATSAGEM_PCR2101	0x5352
+ #define PCI_DEVICE_ID_SATSAGEM_TELSATTURBO 0x5a4b
+ 
+ #define PCI_VENDOR_ID_HUGHES		0x1273
+ #define PCI_DEVICE_ID_HUGHES_DIRECPC	0x0002
+ 
+ #define PCI_VENDOR_ID_ENSONIQ		0x1274
+ #define PCI_DEVICE_ID_ENSONIQ_CT5880	0x5880
+ #define PCI_DEVICE_ID_ENSONIQ_ES1370	0x5000
+ #define PCI_DEVICE_ID_ENSONIQ_ES1371	0x1371
+ 
+ #define PCI_VENDOR_ID_ROCKWELL		0x127A
+ 
+ #define PCI_VENDOR_ID_DAVICOM		0x1282
+ #define	PCI_DEVICE_ID_DM9009		0x9009
+ #define PCI_DEVICE_ID_DM9102		0x9102
+ 
+ #define PCI_VENDOR_ID_ITE		0x1283
+ #define PCI_DEVICE_ID_ITE_IT8172G_AUDIO 0x0801
+ #define PCI_DEVICE_ID_ITE_IT8172G	0x8172
+ #define PCI_DEVICE_ID_ITE_8872		0x8872
+ 
+ 
+ /* formerly Platform Tech */
+ #define PCI_VENDOR_ID_ESS_OLD		0x1285
+ #define PCI_DEVICE_ID_ESS_ESS0100	0x0100
+ 
+ #define PCI_VENDOR_ID_ALTEON		0x12ae
+ #define PCI_DEVICE_ID_ALTEON_ACENIC	0x0001
+ 
+ #define PCI_VENDOR_ID_USR		0x12B9
+ 
+ #define	PCI_VENDOR_ID_HOLTEK		0x12c3
+ #define	PCI_DEVICE_ID_HOLTEK_HT80232	0x0058
+ 
+ #define PCI_SUBVENDOR_ID_CONNECT_TECH			0x12c4
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_232		0x0001
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_232		0x0002
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_232		0x0003
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485		0x0004
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_4_4	0x0005
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485		0x0006
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485_2_2	0x0007
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_485		0x0008
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_2_6	0x0009
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH081101V1	0x000A
+ #define PCI_SUBDEVICE_ID_CONNECT_TECH_BH041101V1	0x000B
+ 
+ #define PCI_VENDOR_ID_PICTUREL		0x12c5
+ #define PCI_DEVICE_ID_PICTUREL_PCIVST	0x0081
+ 
+ #define PCI_VENDOR_ID_NVIDIA_SGS	0x12d2
+ #define PCI_DEVICE_ID_NVIDIA_SGS_RIVA128 0x0018
+ 
+ #define PCI_SUBVENDOR_ID_CHASE_PCIFAST		0x12E0
+ #define PCI_SUBDEVICE_ID_CHASE_PCIFAST4		0x0031
+ #define PCI_SUBDEVICE_ID_CHASE_PCIFAST8		0x0021
+ #define PCI_SUBDEVICE_ID_CHASE_PCIFAST16	0x0011
+ #define PCI_SUBDEVICE_ID_CHASE_PCIFAST16FMC	0x0041
+ #define PCI_SUBVENDOR_ID_CHASE_PCIRAS		0x124D
+ #define PCI_SUBDEVICE_ID_CHASE_PCIRAS4		0xF001
+ #define PCI_SUBDEVICE_ID_CHASE_PCIRAS8		0xF010
+ 
+ #define PCI_VENDOR_ID_AUREAL		0x12eb
+ #define PCI_DEVICE_ID_AUREAL_VORTEX_1	0x0001
+ #define PCI_DEVICE_ID_AUREAL_VORTEX_2	0x0002
+ 
+ #define PCI_VENDOR_ID_CBOARDS		0x1307
+ #define PCI_DEVICE_ID_CBOARDS_DAS1602_16 0x0001
+ 
+ #define PCI_VENDOR_ID_SIIG		0x131f
+ #define PCI_DEVICE_ID_SIIG_1S_10x_550	0x1000
+ #define PCI_DEVICE_ID_SIIG_1S_10x_650	0x1001
+ #define PCI_DEVICE_ID_SIIG_1S_10x_850	0x1002
+ #define PCI_DEVICE_ID_SIIG_1S1P_10x_550	0x1010
+ #define PCI_DEVICE_ID_SIIG_1S1P_10x_650	0x1011
+ #define PCI_DEVICE_ID_SIIG_1S1P_10x_850	0x1012
+ #define PCI_DEVICE_ID_SIIG_1P_10x	0x1020
+ #define PCI_DEVICE_ID_SIIG_2P_10x	0x1021
+ #define PCI_DEVICE_ID_SIIG_2S_10x_550	0x1030
+ #define PCI_DEVICE_ID_SIIG_2S_10x_650	0x1031
+ #define PCI_DEVICE_ID_SIIG_2S_10x_850	0x1032
+ #define PCI_DEVICE_ID_SIIG_2S1P_10x_550	0x1034
+ #define PCI_DEVICE_ID_SIIG_2S1P_10x_650	0x1035
+ #define PCI_DEVICE_ID_SIIG_2S1P_10x_850	0x1036
+ #define PCI_DEVICE_ID_SIIG_4S_10x_550	0x1050
+ #define PCI_DEVICE_ID_SIIG_4S_10x_650	0x1051
+ #define PCI_DEVICE_ID_SIIG_4S_10x_850	0x1052
+ #define PCI_DEVICE_ID_SIIG_1S_20x_550	0x2000
+ #define PCI_DEVICE_ID_SIIG_1S_20x_650	0x2001
+ #define PCI_DEVICE_ID_SIIG_1S_20x_850	0x2002
+ #define PCI_DEVICE_ID_SIIG_1P_20x	0x2020
+ #define PCI_DEVICE_ID_SIIG_2P_20x	0x2021
+ #define PCI_DEVICE_ID_SIIG_2S_20x_550	0x2030
+ #define PCI_DEVICE_ID_SIIG_2S_20x_650	0x2031
+ #define PCI_DEVICE_ID_SIIG_2S_20x_850	0x2032
+ #define PCI_DEVICE_ID_SIIG_2P1S_20x_550	0x2040
+ #define PCI_DEVICE_ID_SIIG_2P1S_20x_650	0x2041
+ #define PCI_DEVICE_ID_SIIG_2P1S_20x_850	0x2042
+ #define PCI_DEVICE_ID_SIIG_1S1P_20x_550	0x2010
+ #define PCI_DEVICE_ID_SIIG_1S1P_20x_650	0x2011
+ #define PCI_DEVICE_ID_SIIG_1S1P_20x_850	0x2012
+ #define PCI_DEVICE_ID_SIIG_4S_20x_550	0x2050
+ #define PCI_DEVICE_ID_SIIG_4S_20x_650	0x2051
+ #define PCI_DEVICE_ID_SIIG_4S_20x_850	0x2052
+ #define PCI_DEVICE_ID_SIIG_2S1P_20x_550	0x2060
+ #define PCI_DEVICE_ID_SIIG_2S1P_20x_650	0x2061
+ #define PCI_DEVICE_ID_SIIG_2S1P_20x_850	0x2062
+ 
+ #define PCI_VENDOR_ID_ADMTEK            0x1317
+ #define PCI_DEVICE_ID_ADMTEK_0985       0x0985
+ 
+ #define PCI_VENDOR_ID_DOMEX		0x134a
+ #define PCI_DEVICE_ID_DOMEX_DMX3191D	0x0001
+ 
+ #define PCI_VENDOR_ID_QUATECH		0x135C
+ #define PCI_DEVICE_ID_QUATECH_QSC100	0x0010
+ #define PCI_DEVICE_ID_QUATECH_DSC100	0x0020
+ #define PCI_DEVICE_ID_QUATECH_DSC200	0x0030
+ #define PCI_DEVICE_ID_QUATECH_QSC200	0x0040
+ #define PCI_DEVICE_ID_QUATECH_ESC100D	0x0050
+ #define PCI_DEVICE_ID_QUATECH_ESC100M	0x0060
+ 
+ #define PCI_VENDOR_ID_SEALEVEL		0x135e
+ #define PCI_DEVICE_ID_SEALEVEL_U530	0x7101
+ #define PCI_DEVICE_ID_SEALEVEL_UCOMM2	0x7201
+ #define PCI_DEVICE_ID_SEALEVEL_UCOMM422	0x7402
+ #define PCI_DEVICE_ID_SEALEVEL_UCOMM232	0x7202
+ #define PCI_DEVICE_ID_SEALEVEL_COMM4	0x7401
+ #define PCI_DEVICE_ID_SEALEVEL_COMM8	0x7801
+ 
+ #define PCI_VENDOR_ID_HYPERCOPE		0x1365
+ #define PCI_DEVICE_ID_HYPERCOPE_PLX	0x9050
+ #define PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO	0x0104
+ #define PCI_SUBDEVICE_ID_HYPERCOPE_ERGO		0x0106
+ #define PCI_SUBDEVICE_ID_HYPERCOPE_METRO	0x0107
+ #define PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2	0x0108
+ #define PCI_SUBDEVICE_ID_HYPERCOPE_PLEXUS	0x0109
+ 
+ #define PCI_VENDOR_ID_KAWASAKI		0x136b
+ #define PCI_DEVICE_ID_MCHIP_KL5A72002	0xff01
+ 
+ #define PCI_VENDOR_ID_LMC		0x1376
+ #define PCI_DEVICE_ID_LMC_HSSI		0x0003
+ #define PCI_DEVICE_ID_LMC_DS3		0x0004
+ #define PCI_DEVICE_ID_LMC_SSI		0x0005
+ #define PCI_DEVICE_ID_LMC_T1		0x0006
+ 
+ #define PCI_VENDOR_ID_NETGEAR		0x1385
+ #define PCI_DEVICE_ID_NETGEAR_MA301	0x4100
+ #define PCI_DEVICE_ID_NETGEAR_GA620	0x620a
+ #define PCI_DEVICE_ID_NETGEAR_GA622	0x622a
+ 
+ #define PCI_VENDOR_ID_APPLICOM		0x1389
+ #define PCI_DEVICE_ID_APPLICOM_PCIGENERIC 0x0001
+ #define PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN 0x0002
+ #define PCI_DEVICE_ID_APPLICOM_PCI2000PFB 0x0003
+ 
+ #define PCI_VENDOR_ID_MOXA		0x1393
+ #define PCI_DEVICE_ID_MOXA_C104		0x1040
+ #define PCI_DEVICE_ID_MOXA_C168		0x1680
+ #define PCI_DEVICE_ID_MOXA_CP204J	0x2040
+ #define PCI_DEVICE_ID_MOXA_C218		0x2180
+ #define PCI_DEVICE_ID_MOXA_C320		0x3200
+ 
+ #define PCI_VENDOR_ID_CCD		0x1397
+ #define PCI_DEVICE_ID_CCD_2BD0		0x2bd0
+ #define PCI_DEVICE_ID_CCD_B000		0xb000
+ #define PCI_DEVICE_ID_CCD_B006		0xb006
+ #define PCI_DEVICE_ID_CCD_B007		0xb007
+ #define PCI_DEVICE_ID_CCD_B008		0xb008
+ #define PCI_DEVICE_ID_CCD_B009		0xb009
+ #define PCI_DEVICE_ID_CCD_B00A		0xb00a
+ #define PCI_DEVICE_ID_CCD_B00B		0xb00b
+ #define PCI_DEVICE_ID_CCD_B00C		0xb00c
+ #define PCI_DEVICE_ID_CCD_B100		0xb100
+ 
+ #define PCI_VENDOR_ID_MICROGATE		0x13c0
+ #define PCI_DEVICE_ID_MICROGATE_USC	0x0010
+ #define PCI_DEVICE_ID_MICROGATE_SCC	0x0020
+ #define PCI_DEVICE_ID_MICROGATE_SCA	0x0030
+ 
+ #define PCI_VENDOR_ID_3WARE		0x13C1
+ #define PCI_DEVICE_ID_3WARE_1000	0x1000
+ 
+ #define PCI_VENDOR_ID_ABOCOM		0x13D1
+ #define PCI_DEVICE_ID_ABOCOM_2BD1       0x2BD1
+ 
+ #define PCI_VENDOR_ID_CMEDIA		0x13f6
+ #define PCI_DEVICE_ID_CMEDIA_CM8338A	0x0100
+ #define PCI_DEVICE_ID_CMEDIA_CM8338B	0x0101
+ #define PCI_DEVICE_ID_CMEDIA_CM8738	0x0111
+ #define PCI_DEVICE_ID_CMEDIA_CM8738B	0x0112
+ 
+ #define PCI_VENDOR_ID_LAVA		0x1407
+ #define PCI_DEVICE_ID_LAVA_DSERIAL	0x0100 /* 2x 16550 */
+ #define PCI_DEVICE_ID_LAVA_QUATRO_A	0x0101 /* 2x 16550, half of 4 port */
+ #define PCI_DEVICE_ID_LAVA_QUATRO_B	0x0102 /* 2x 16550, half of 4 port */
+ #define PCI_DEVICE_ID_LAVA_PORT_PLUS	0x0200 /* 2x 16650 */
+ #define PCI_DEVICE_ID_LAVA_QUAD_A	0x0201 /* 2x 16650, half of 4 port */
+ #define PCI_DEVICE_ID_LAVA_QUAD_B	0x0202 /* 2x 16650, half of 4 port */
+ #define PCI_DEVICE_ID_LAVA_SSERIAL	0x0500 /* 1x 16550 */
+ #define PCI_DEVICE_ID_LAVA_PORT_650	0x0600 /* 1x 16650 */
+ #define PCI_DEVICE_ID_LAVA_PARALLEL	0x8000
+ #define PCI_DEVICE_ID_LAVA_DUAL_PAR_A	0x8002 /* The Lava Dual Parallel is */
+ #define PCI_DEVICE_ID_LAVA_DUAL_PAR_B	0x8003 /* two PCI devices on a card */
+ #define PCI_DEVICE_ID_LAVA_BOCA_IOPPAR	0x8800
+ 
+ #define PCI_VENDOR_ID_TIMEDIA		0x1409
+ #define PCI_DEVICE_ID_TIMEDIA_1889	0x7168
+ 
+ #define PCI_VENDOR_ID_OXSEMI		0x1415
+ #define PCI_DEVICE_ID_OXSEMI_12PCI840	0x8403
+ #define PCI_DEVICE_ID_OXSEMI_16PCI954	0x9501
+ #define PCI_DEVICE_ID_OXSEMI_16PCI952	0x950A
+ #define PCI_DEVICE_ID_OXSEMI_16PCI95N	0x9511
+ #define PCI_DEVICE_ID_OXSEMI_16PCI954PP	0x9513
+ 
+ #define PCI_VENDOR_ID_AIRONET		0x14b9
+ #define PCI_DEVICE_ID_AIRONET_4800_1	0x0001
+ #define PCI_DEVICE_ID_AIRONET_4800	0x4500 // values switched?  see
+ #define PCI_DEVICE_ID_AIRONET_4500	0x4800 // drivers/net/aironet4500_card.c
+ 
+ #define PCI_VENDOR_ID_TITAN		0x14D2
+ #define PCI_DEVICE_ID_TITAN_010L	0x8001
+ #define PCI_DEVICE_ID_TITAN_100L	0x8010
+ #define PCI_DEVICE_ID_TITAN_110L	0x8011
+ #define PCI_DEVICE_ID_TITAN_200L	0x8020
+ #define PCI_DEVICE_ID_TITAN_210L	0x8021
+ #define PCI_DEVICE_ID_TITAN_400L	0x8040
+ #define PCI_DEVICE_ID_TITAN_800L	0x8080
+ #define PCI_DEVICE_ID_TITAN_100		0xA001
+ #define PCI_DEVICE_ID_TITAN_200		0xA005
+ #define PCI_DEVICE_ID_TITAN_400		0xA003
+ #define PCI_DEVICE_ID_TITAN_800B	0xA004
+ 
+ #define PCI_VENDOR_ID_PANACOM		0x14d4
+ #define PCI_DEVICE_ID_PANACOM_QUADMODEM	0x0400
+ #define PCI_DEVICE_ID_PANACOM_DUALMODEM	0x0402
+ 
+ #define PCI_VENDOR_ID_BROADCOM		0x14e4
+ #define PCI_DEVICE_ID_TIGON3_5700	0x1644
+ #define PCI_DEVICE_ID_TIGON3_5701	0x1645
+ #define PCI_DEVICE_ID_TIGON3_5702	0x1646
+ #define PCI_DEVICE_ID_TIGON3_5703	0x1647
+ #define PCI_DEVICE_ID_TIGON3_5704	0x1648
+ #define PCI_DEVICE_ID_TIGON3_5702FE	0x164d
+ #define PCI_DEVICE_ID_TIGON3_5705	0x1653
+ #define PCI_DEVICE_ID_TIGON3_5705_2	0x1654
+ #define PCI_DEVICE_ID_TIGON3_5705M	0x165d
+ #define PCI_DEVICE_ID_TIGON3_5705M_2	0x165e
+ #define PCI_DEVICE_ID_TIGON3_5782	0x1696
+ #define PCI_DEVICE_ID_TIGON3_5788	0x169c
+ #define PCI_DEVICE_ID_TIGON3_5702X	0x16a6
+ #define PCI_DEVICE_ID_TIGON3_5703X	0x16a7
+ #define PCI_DEVICE_ID_TIGON3_5704S	0x16a8
+ #define PCI_DEVICE_ID_TIGON3_5702A3	0x16c6
+ #define PCI_DEVICE_ID_TIGON3_5703A3	0x16c7
+ #define PCI_DEVICE_ID_TIGON3_5901	0x170d
+ #define PCI_DEVICE_ID_TIGON3_5901_2	0x170e
+ 
+ #define PCI_VENDOR_ID_SYBA		0x1592
+ #define PCI_DEVICE_ID_SYBA_2P_EPP	0x0782
+ #define PCI_DEVICE_ID_SYBA_1P_ECP	0x0783
+ 
+ #define PCI_VENDOR_ID_MORETON		0x15aa
+ #define PCI_DEVICE_ID_RASTEL_2PORT	0x2000
+ 
+ #define PCI_VENDOR_ID_ZOLTRIX		0x15b0
+ #define PCI_DEVICE_ID_ZOLTRIX_2BD0	0x2bd0 
+ 
+ #define PCI_VENDOR_ID_PDC		0x15e9
+ #define PCI_DEVICE_ID_PDC_1841		0x1841
+ 
+ #define PCI_VENDOR_ID_SYMPHONY		0x1c1c
+ #define PCI_DEVICE_ID_SYMPHONY_101	0x0001
+ 
+ #define PCI_VENDOR_ID_TEKRAM		0x1de1
+ #define PCI_DEVICE_ID_TEKRAM_DC290	0xdc29
+ 
+ #define PCI_VENDOR_ID_3DLABS		0x3d3d
+ #define PCI_DEVICE_ID_3DLABS_300SX	0x0001
+ #define PCI_DEVICE_ID_3DLABS_500TX	0x0002
+ #define PCI_DEVICE_ID_3DLABS_DELTA	0x0003
+ #define PCI_DEVICE_ID_3DLABS_PERMEDIA	0x0004
+ #define PCI_DEVICE_ID_3DLABS_MX		0x0006
+ #define PCI_DEVICE_ID_3DLABS_PERMEDIA2	0x0007
+ #define PCI_DEVICE_ID_3DLABS_GAMMA	0x0008
+ #define PCI_DEVICE_ID_3DLABS_PERMEDIA2V	0x0009
+ 
+ #define PCI_VENDOR_ID_AVANCE		0x4005
+ #define PCI_DEVICE_ID_AVANCE_ALG2064	0x2064
+ #define PCI_DEVICE_ID_AVANCE_2302	0x2302
+ 
+ #define PCI_VENDOR_ID_AKS		0x416c
+ #define PCI_DEVICE_ID_AKS_ALADDINCARD	0x0100
+ #define PCI_DEVICE_ID_AKS_CPC		0x0200
+ 
+ #define PCI_VENDOR_ID_NETVIN		0x4a14
+ #define PCI_DEVICE_ID_NETVIN_NV5000SC	0x5000
+ 
+ #define PCI_VENDOR_ID_S3		0x5333
+ #define PCI_DEVICE_ID_S3_PLATO_PXS	0x0551
+ #define PCI_DEVICE_ID_S3_ViRGE		0x5631
+ #define PCI_DEVICE_ID_S3_TRIO		0x8811
+ #define PCI_DEVICE_ID_S3_AURORA64VP	0x8812
+ #define PCI_DEVICE_ID_S3_TRIO64UVP	0x8814
+ #define PCI_DEVICE_ID_S3_ViRGE_VX	0x883d
+ #define PCI_DEVICE_ID_S3_868		0x8880
+ #define PCI_DEVICE_ID_S3_928		0x88b0
+ #define PCI_DEVICE_ID_S3_864_1		0x88c0
+ #define PCI_DEVICE_ID_S3_864_2		0x88c1
+ #define PCI_DEVICE_ID_S3_964_1		0x88d0
+ #define PCI_DEVICE_ID_S3_964_2		0x88d1
+ #define PCI_DEVICE_ID_S3_968		0x88f0
+ #define PCI_DEVICE_ID_S3_TRIO64V2	0x8901
+ #define PCI_DEVICE_ID_S3_PLATO_PXG	0x8902
+ #define PCI_DEVICE_ID_S3_ViRGE_DXGX	0x8a01
+ #define PCI_DEVICE_ID_S3_ViRGE_GX2	0x8a10
+ #define PCI_DEVICE_ID_S3_ViRGE_MX	0x8c01
+ #define PCI_DEVICE_ID_S3_ViRGE_MXP	0x8c02
+ #define PCI_DEVICE_ID_S3_ViRGE_MXPMV	0x8c03
+ #define PCI_DEVICE_ID_S3_SONICVIBES	0xca00
+ 
+ #define PCI_VENDOR_ID_DCI		0x6666
+ #define PCI_DEVICE_ID_DCI_PCCOM4	0x0001
+ #define PCI_DEVICE_ID_DCI_PCCOM8	0x0002
+ 
+ #define PCI_VENDOR_ID_GENROCO		0x5555
+ #define PCI_DEVICE_ID_GENROCO_HFP832	0x0003
+ 
+ #define PCI_VENDOR_ID_INTEL		0x8086
+ #define PCI_DEVICE_ID_INTEL_21145	0x0039
+ #define PCI_DEVICE_ID_INTEL_82375	0x0482
+ #define PCI_DEVICE_ID_INTEL_82424	0x0483
+ #define PCI_DEVICE_ID_INTEL_82378	0x0484
+ #define PCI_DEVICE_ID_INTEL_82430	0x0486
+ #define PCI_DEVICE_ID_INTEL_82434	0x04a3
+ #define PCI_DEVICE_ID_INTEL_I960	0x0960
+ #define PCI_DEVICE_ID_INTEL_82542       	0x1000
+ #define PCI_DEVICE_ID_INTEL_82543GC_FIBER  	0x1001
+ #define PCI_DEVICE_ID_INTEL_82543GC_COPPER 	0x1004
+ #define PCI_DEVICE_ID_INTEL_82544EI_COPPER 	0x1008
+ #define PCI_DEVICE_ID_INTEL_82544EI_FIBER 	0x1009
+ #define PCI_DEVICE_ID_INTEL_82544GC_COPPER 	0x100C
+ #define PCI_DEVICE_ID_INTEL_82544GC_LOM   	0x100D
+ #define PCI_DEVICE_ID_INTEL_82540EM		0x100E
+ #define PCI_DEVICE_ID_INTEL_82545EM_COPPER	0x100F
+ #define PCI_DEVICE_ID_INTEL_82546EB_COPPER	0x1010
+ #define PCI_DEVICE_ID_INTEL_82545EM_FIBER	0x1011
+ #define PCI_DEVICE_ID_INTEL_82546EB_FIBER	0x1012
+ #define PCI_DEVICE_ID_INTEL_82540EM_LOM		0x1015
+ #define PCI_DEVICE_ID_INTEL_ID1029	0x1029
+ #define PCI_DEVICE_ID_INTEL_ID1030	0x1030
+ #define PCI_DEVICE_ID_INTEL_ID1031	0x1031
+ #define PCI_DEVICE_ID_INTEL_ID1038	0x1038
+ #define PCI_DEVICE_ID_INTEL_ID1039	0x1039
+ #define PCI_DEVICE_ID_INTEL_ID103A	0x103A
+ #define PCI_DEVICE_ID_INTEL_82562ET	0x1031
+ #define PCI_DEVICE_ID_INTEL_82559ER	0x1209
+ #define PCI_DEVICE_ID_INTEL_82092AA_0	0x1221
+ #define PCI_DEVICE_ID_INTEL_82092AA_1	0x1222
+ #define PCI_DEVICE_ID_INTEL_7116	0x1223
+ #define PCI_DEVICE_ID_INTEL_82596	0x1226
+ #define PCI_DEVICE_ID_INTEL_82865	0x1227
+ #define PCI_DEVICE_ID_INTEL_82557	0x1229
+ #define PCI_DEVICE_ID_INTEL_82437	0x122d
+ #define PCI_DEVICE_ID_INTEL_82371FB_0	0x122e
+ #define PCI_DEVICE_ID_INTEL_82371FB_1	0x1230
+ #define PCI_DEVICE_ID_INTEL_82371MX	0x1234
+ #define PCI_DEVICE_ID_INTEL_82437MX	0x1235
+ #define PCI_DEVICE_ID_INTEL_82441	0x1237
+ #define PCI_DEVICE_ID_INTEL_82380FB	0x124b
+ #define PCI_DEVICE_ID_INTEL_82439	0x1250
+ #define PCI_DEVICE_ID_INTEL_80960_RP	0x1960
+ #define PCI_DEVICE_ID_INTEL_82801AA_0	0x2410
+ #define PCI_DEVICE_ID_INTEL_82801AA_1	0x2411
+ #define PCI_DEVICE_ID_INTEL_82801AA_2	0x2412
+ #define PCI_DEVICE_ID_INTEL_82801AA_3	0x2413
+ #define PCI_DEVICE_ID_INTEL_82801AA_5	0x2415
+ #define PCI_DEVICE_ID_INTEL_82801AA_6	0x2416
+ #define PCI_DEVICE_ID_INTEL_82801AA_8	0x2418
+ #define PCI_DEVICE_ID_INTEL_82801AB_0	0x2420
+ #define PCI_DEVICE_ID_INTEL_82801AB_1	0x2421
+ #define PCI_DEVICE_ID_INTEL_82801AB_2	0x2422
+ #define PCI_DEVICE_ID_INTEL_82801AB_3	0x2423
+ #define PCI_DEVICE_ID_INTEL_82801AB_5	0x2425
+ #define PCI_DEVICE_ID_INTEL_82801AB_6	0x2426
+ #define PCI_DEVICE_ID_INTEL_82801AB_8	0x2428
+ #define PCI_DEVICE_ID_INTEL_82801BA_0	0x2440
+ #define PCI_DEVICE_ID_INTEL_82801BA_1	0x2442
+ #define PCI_DEVICE_ID_INTEL_82801BA_2	0x2443
+ #define PCI_DEVICE_ID_INTEL_82801BA_3	0x2444
+ #define PCI_DEVICE_ID_INTEL_82801BA_4	0x2445
+ #define PCI_DEVICE_ID_INTEL_82801BA_5	0x2446
+ #define PCI_DEVICE_ID_INTEL_82801BA_6	0x2448
+ #define PCI_DEVICE_ID_INTEL_82801BA_7	0x2449
+ #define PCI_DEVICE_ID_INTEL_82562	0x2449
+ #define PCI_DEVICE_ID_INTEL_82801BA_8	0x244a
+ #define PCI_DEVICE_ID_INTEL_82801BA_9	0x244b
+ #define PCI_DEVICE_ID_INTEL_82801BA_10	0x244c
+ #define PCI_DEVICE_ID_INTEL_82801BA_11	0x244e
+ #define PCI_DEVICE_ID_INTEL_82801CA_0	0x2480
+ #define PCI_DEVICE_ID_INTEL_82801CA_2	0x2482
+ #define PCI_DEVICE_ID_INTEL_82801CA_3	0x2483
+ #define PCI_DEVICE_ID_INTEL_82801CA_4	0x2484
+ #define PCI_DEVICE_ID_INTEL_82801CA_5	0x2485
+ #define PCI_DEVICE_ID_INTEL_82801CA_6	0x2486
+ #define PCI_DEVICE_ID_INTEL_82801CA_7	0x2487
+ #define PCI_DEVICE_ID_INTEL_82801CA_10	0x248a
+ #define PCI_DEVICE_ID_INTEL_82801CA_11	0x248b
+ #define PCI_DEVICE_ID_INTEL_82801CA_12	0x248c
+ #define PCI_DEVICE_ID_INTEL_80310	0x530d
+ #define PCI_DEVICE_ID_INTEL_82371SB_0	0x7000
+ #define PCI_DEVICE_ID_INTEL_82371SB_1	0x7010
+ #define PCI_DEVICE_ID_INTEL_82371SB_2	0x7020
+ #define PCI_DEVICE_ID_INTEL_82437VX	0x7030
+ #define PCI_DEVICE_ID_INTEL_82439TX	0x7100
+ #define PCI_DEVICE_ID_INTEL_82371AB_0	0x7110
+ #define PCI_DEVICE_ID_INTEL_82371AB	0x7111
+ #define PCI_DEVICE_ID_INTEL_82371AB_2	0x7112
+ #define PCI_DEVICE_ID_INTEL_82371AB_3	0x7113
+ #define PCI_DEVICE_ID_INTEL_82810_MC1	0x7120
+ #define PCI_DEVICE_ID_INTEL_82810_IG1	0x7121
+ #define PCI_DEVICE_ID_INTEL_82810_MC3	0x7122
+ #define PCI_DEVICE_ID_INTEL_82810_IG3	0x7123
+ #define PCI_DEVICE_ID_INTEL_82443LX_0	0x7180
+ #define PCI_DEVICE_ID_INTEL_82443LX_1	0x7181
+ #define PCI_DEVICE_ID_INTEL_82443BX_0	0x7190
+ #define PCI_DEVICE_ID_INTEL_82443BX_1	0x7191
+ #define PCI_DEVICE_ID_INTEL_82443BX_2	0x7192
+ #define PCI_DEVICE_ID_INTEL_82443MX_0	0x7198
+ #define PCI_DEVICE_ID_INTEL_82443MX_1	0x7199
+ #define PCI_DEVICE_ID_INTEL_82443MX_2	0x719a
+ #define PCI_DEVICE_ID_INTEL_82443MX_3	0x719b
+ #define PCI_DEVICE_ID_INTEL_82372FB_0	0x7600
+ #define PCI_DEVICE_ID_INTEL_82372FB_1	0x7601
+ #define PCI_DEVICE_ID_INTEL_82372FB_2	0x7602
+ #define PCI_DEVICE_ID_INTEL_82372FB_3	0x7603
+ #define PCI_DEVICE_ID_INTEL_82454GX	0x84c4
+ #define PCI_DEVICE_ID_INTEL_82450GX	0x84c5
+ #define PCI_DEVICE_ID_INTEL_82451NX	0x84ca
+ 
+ #define PCI_VENDOR_ID_COMPUTONE		0x8e0e
+ #define PCI_DEVICE_ID_COMPUTONE_IP2EX	0x0291
+ #define PCI_DEVICE_ID_COMPUTONE_PG	0x0302
+ #define PCI_SUBVENDOR_ID_COMPUTONE	0x8e0e
+ #define PCI_SUBDEVICE_ID_COMPUTONE_PG4	0x0001
+ #define PCI_SUBDEVICE_ID_COMPUTONE_PG8	0x0002
+ #define PCI_SUBDEVICE_ID_COMPUTONE_PG6	0x0003
+ 
+ #define PCI_VENDOR_ID_KTI		0x8e2e
+ #define PCI_DEVICE_ID_KTI_ET32P2	0x3000
+ 
+ #define PCI_VENDOR_ID_ADAPTEC		0x9004
+ #define PCI_DEVICE_ID_ADAPTEC_7810	0x1078
+ #define PCI_DEVICE_ID_ADAPTEC_7821	0x2178
+ #define PCI_DEVICE_ID_ADAPTEC_38602	0x3860
+ #define PCI_DEVICE_ID_ADAPTEC_7850	0x5078
+ #define PCI_DEVICE_ID_ADAPTEC_7855	0x5578
+ #define PCI_DEVICE_ID_ADAPTEC_5800	0x5800
+ #define PCI_DEVICE_ID_ADAPTEC_3860	0x6038
+ #define PCI_DEVICE_ID_ADAPTEC_1480A	0x6075
+ #define PCI_DEVICE_ID_ADAPTEC_7860	0x6078
+ #define PCI_DEVICE_ID_ADAPTEC_7861	0x6178
+ #define PCI_DEVICE_ID_ADAPTEC_7870	0x7078
+ #define PCI_DEVICE_ID_ADAPTEC_7871	0x7178
+ #define PCI_DEVICE_ID_ADAPTEC_7872	0x7278
+ #define PCI_DEVICE_ID_ADAPTEC_7873	0x7378
+ #define PCI_DEVICE_ID_ADAPTEC_7874	0x7478
+ #define PCI_DEVICE_ID_ADAPTEC_7895	0x7895
+ #define PCI_DEVICE_ID_ADAPTEC_7880	0x8078
+ #define PCI_DEVICE_ID_ADAPTEC_7881	0x8178
+ #define PCI_DEVICE_ID_ADAPTEC_7882	0x8278
+ #define PCI_DEVICE_ID_ADAPTEC_7883	0x8378
+ #define PCI_DEVICE_ID_ADAPTEC_7884	0x8478
+ #define PCI_DEVICE_ID_ADAPTEC_7885	0x8578
+ #define PCI_DEVICE_ID_ADAPTEC_7886	0x8678
+ #define PCI_DEVICE_ID_ADAPTEC_7887	0x8778
+ #define PCI_DEVICE_ID_ADAPTEC_7888	0x8878
+ #define PCI_DEVICE_ID_ADAPTEC_1030	0x8b78
+ 
+ #define PCI_VENDOR_ID_ADAPTEC2		0x9005
+ #define PCI_DEVICE_ID_ADAPTEC2_2940U2	0x0010
+ #define PCI_DEVICE_ID_ADAPTEC2_2930U2	0x0011
+ #define PCI_DEVICE_ID_ADAPTEC2_7890B	0x0013
+ #define PCI_DEVICE_ID_ADAPTEC2_7890	0x001f
+ #define PCI_DEVICE_ID_ADAPTEC2_3940U2	0x0050
+ #define PCI_DEVICE_ID_ADAPTEC2_3950U2D	0x0051
+ #define PCI_DEVICE_ID_ADAPTEC2_7896	0x005f
+ #define PCI_DEVICE_ID_ADAPTEC2_7892A	0x0080
+ #define PCI_DEVICE_ID_ADAPTEC2_7892B	0x0081
+ #define PCI_DEVICE_ID_ADAPTEC2_7892D	0x0083
+ #define PCI_DEVICE_ID_ADAPTEC2_7892P	0x008f
+ #define PCI_DEVICE_ID_ADAPTEC2_7899A	0x00c0
+ #define PCI_DEVICE_ID_ADAPTEC2_7899B	0x00c1
+ #define PCI_DEVICE_ID_ADAPTEC2_7899D	0x00c3
+ #define PCI_DEVICE_ID_ADAPTEC2_7899P	0x00cf
+ 
+ #define PCI_VENDOR_ID_ATRONICS		0x907f
+ #define PCI_DEVICE_ID_ATRONICS_2015	0x2015
+ 
+ #define PCI_VENDOR_ID_HOLTEK2		0x9412
+ #define PCI_DEVICE_ID_HOLTEK2_6565	0x6565
+ 
+ #define PCI_VENDOR_ID_NETMOS		0x9710
+ #define PCI_DEVICE_ID_NETMOS_9735	0x9735
+ #define PCI_DEVICE_ID_NETMOS_9835	0x9835
+ 
+ #define PCI_SUBVENDOR_ID_EXSYS		0xd84d
+ #define PCI_SUBDEVICE_ID_EXSYS_4014	0x4014
+ 
+ #define PCI_VENDOR_ID_TIGERJET		0xe159
+ #define PCI_DEVICE_ID_TIGERJET_300	0x0001
+ #define PCI_DEVICE_ID_TIGERJET_100	0x0002
+ 
+ #define PCI_VENDOR_ID_ARK		0xedd8
+ #define PCI_DEVICE_ID_ARK_STING		0xa091
+ #define PCI_DEVICE_ID_ARK_STINGARK	0xa099
+ #define PCI_DEVICE_ID_ARK_2000MT	0xa0a1
+ 
diff -rc2P -x CVS GRUB_0.94/netboot/pci_io.c GRUB/netboot/pci_io.c
*** GRUB_0.94/netboot/pci_io.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/pci_io.c	2003-11-11 20:43:02.000000000 +0800
***************
*** 0 ****
--- 1,432 ----
+ /*
+ ** Support for NE2000 PCI clones added David Monro June 1997
+ ** Generalised to other NICs by Ken Yap July 1997
+ **
+ ** Most of this is taken from:
+ **
+ ** /usr/src/linux/drivers/pci/pci.c
+ ** /usr/src/linux/include/linux/pci.h
+ ** /usr/src/linux/arch/i386/bios32.c
+ ** /usr/src/linux/include/linux/bios32.h
+ ** /usr/src/linux/drivers/net/ne.c
+ */
+ 
+ #include "grub.h"
+ #include "types.h"
+ #include "io.h"
+ #include "pci.h"
+ 
+ #define PCBIOS
+ 
+ unsigned long virt_offset = 0;
+ 
+ #ifdef	CONFIG_PCI_DIRECT
+ #define  PCIBIOS_SUCCESSFUL                0x00
+ 
+ 
+ 
+ /*
+  * Functions for accessing PCI configuration space with type 1 accesses
+  */
+ 
+ #define CONFIG_CMD(bus, device_fn, where)   (0x80000000 | (bus << 16) | (device_fn << 8) | (where & ~3))
+ 
+ int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn,
+ 			       unsigned int where, uint8_t *value)
+ {
+     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+     *value = inb(0xCFC + (where&3));
+     return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ int pcibios_read_config_word (unsigned int bus,
+     unsigned int device_fn, unsigned int where, uint16_t *value)
+ {
+     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+     *value = inw(0xCFC + (where&2));
+     return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ int pcibios_read_config_dword (unsigned int bus, unsigned int device_fn,
+ 				 unsigned int where, uint32_t *value)
+ {
+     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+     *value = inl(0xCFC);
+     return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn,
+ 				 unsigned int where, uint8_t value)
+ {
+     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+     outb(value, 0xCFC + (where&3));
+     return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ int pcibios_write_config_word (unsigned int bus, unsigned int device_fn,
+ 				 unsigned int where, uint16_t value)
+ {
+     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+     outw(value, 0xCFC + (where&2));
+     return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ int pcibios_write_config_dword (unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t value)
+ {
+     outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+     outl(value, 0xCFC);
+     return PCIBIOS_SUCCESSFUL;
+ }
+ 
+ #undef CONFIG_CMD
+ 
+ #else	 /* CONFIG_PCI_DIRECT  not defined */
+ 
+ #define KERN_CODE_SEG 0X8
+ /* Stuff for asm */
+ #define save_flags(x) \
+ __asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
+ 
+ #define cli() __asm__ __volatile__ ("cli": : :"memory")
+ 
+ #define restore_flags(x) \
+ __asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
+ 
+ 
+ 
+ static struct {
+ 	unsigned long address;
+ 	unsigned short segment;
+ } bios32_indirect = { 0, KERN_CODE_SEG };
+ 
+ static long pcibios_entry = 0;
+ static struct {
+ 	unsigned long address;
+ 	unsigned short segment;
+ } pci_indirect = { 0, KERN_CODE_SEG };
+ 
+ static unsigned long bios32_service(unsigned long service)
+ {
+ 	unsigned char return_code;	/* %al */
+ 	unsigned long address;		/* %ebx */
+ 	unsigned long length;		/* %ecx */
+ 	unsigned long entry;		/* %edx */
+ 	unsigned long flags;
+ 
+ 	save_flags(flags);
+ 	__asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%edi)"
+ #else
+ 		"lcall *(%%edi)"
+ #endif
+ 		: "=a" (return_code),
+ 		  "=b" (address),
+ 		  "=c" (length),
+ 		  "=d" (entry)
+ 		: "0" (service),
+ 		  "1" (0),
+ 		  "D" (&bios32_indirect));
+ 	restore_flags(flags);
+ 
+ 	switch (return_code) {
+ 		case 0:
+ 			return address + entry;
+ 		case 0x80:	/* Not present */
+ 			printf("bios32_service(%d) : not present\n", service);
+ 			return 0;
+ 		default: /* Shouldn't happen */
+ 			printf("bios32_service(%d) : returned %#X, mail drew@colorado.edu\n",
+ 				service, return_code);
+ 			return 0;
+ 	}
+ }
+ 
+ int pcibios_read_config_byte(unsigned int bus,
+         unsigned int device_fn, unsigned int where, uint8_t *value)
+ {
+         unsigned long ret;
+         unsigned long bx = (bus << 8) | device_fn;
+         unsigned long flags;
+ 
+         save_flags(flags);
+         __asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%esi)\n\t"
+ #else
+ 		"lcall *(%%esi)\n\t"
+ #endif
+                 "jc 1f\n\t"
+                 "xor %%ah, %%ah\n"
+                 "1:"
+                 : "=c" (*value),
+                   "=a" (ret)
+                 : "1" (PCIBIOS_READ_CONFIG_BYTE),
+                   "b" (bx),
+                   "D" ((long) where),
+                   "S" (&pci_indirect));
+         restore_flags(flags);
+         return (int) (ret & 0xff00) >> 8;
+ }
+ 
+ int pcibios_read_config_word(unsigned int bus,
+         unsigned int device_fn, unsigned int where, uint16_t *value)
+ {
+         unsigned long ret;
+         unsigned long bx = (bus << 8) | device_fn;
+         unsigned long flags;
+ 
+         save_flags(flags);
+         __asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%esi)\n\t"
+ #else
+ 		"lcall *(%%esi)\n\t"
+ #endif
+                 "jc 1f\n\t"
+                 "xor %%ah, %%ah\n"
+                 "1:"
+                 : "=c" (*value),
+                   "=a" (ret)
+                 : "1" (PCIBIOS_READ_CONFIG_WORD),
+                   "b" (bx),
+                   "D" ((long) where),
+                   "S" (&pci_indirect));
+         restore_flags(flags);
+         return (int) (ret & 0xff00) >> 8;
+ }
+ 
+ int pcibios_read_config_dword(unsigned int bus,
+         unsigned int device_fn, unsigned int where, uint32_t *value)
+ {
+         unsigned long ret;
+         unsigned long bx = (bus << 8) | device_fn;
+         unsigned long flags;
+ 
+         save_flags(flags);
+         __asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%esi)\n\t"
+ #else
+ 		"lcall *(%%esi)\n\t"
+ #endif
+                 "jc 1f\n\t"
+                 "xor %%ah, %%ah\n"
+                 "1:"
+                 : "=c" (*value),
+                   "=a" (ret)
+                 : "1" (PCIBIOS_READ_CONFIG_DWORD),
+                   "b" (bx),
+                   "D" ((long) where),
+                   "S" (&pci_indirect));
+         restore_flags(flags);
+         return (int) (ret & 0xff00) >> 8;
+ }
+ 
+ int pcibios_write_config_byte (unsigned int bus,
+ 	unsigned int device_fn, unsigned int where, uint8_t value)
+ {
+ 	unsigned long ret;
+ 	unsigned long bx = (bus << 8) | device_fn;
+ 	unsigned long flags;
+ 
+ 	save_flags(flags); cli();
+ 	__asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%esi)\n\t"
+ #else
+ 		"lcall *(%%esi)\n\t"
+ #endif
+ 		"jc 1f\n\t"
+ 		"xor %%ah, %%ah\n"
+ 		"1:"
+ 		: "=a" (ret)
+ 		: "0" (PCIBIOS_WRITE_CONFIG_BYTE),
+ 		  "c" (value),
+ 		  "b" (bx),
+ 		  "D" ((long) where),
+ 		  "S" (&pci_indirect));
+ 	restore_flags(flags);
+ 	return (int) (ret & 0xff00) >> 8;
+ }
+ 
+ int pcibios_write_config_word (unsigned int bus,
+ 	unsigned int device_fn, unsigned int where, uint16_t value)
+ {
+ 	unsigned long ret;
+ 	unsigned long bx = (bus << 8) | device_fn;
+ 	unsigned long flags;
+ 
+ 	save_flags(flags); cli();
+ 	__asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%esi)\n\t"
+ #else
+ 		"lcall *(%%esi)\n\t"
+ #endif
+ 		"jc 1f\n\t"
+ 		"xor %%ah, %%ah\n"
+ 		"1:"
+ 		: "=a" (ret)
+ 		: "0" (PCIBIOS_WRITE_CONFIG_WORD),
+ 		  "c" (value),
+ 		  "b" (bx),
+ 		  "D" ((long) where),
+ 		  "S" (&pci_indirect));
+ 	restore_flags(flags);
+ 	return (int) (ret & 0xff00) >> 8;
+ }
+ 
+ int pcibios_write_config_dword (unsigned int bus,
+ 	unsigned int device_fn, unsigned int where, uint32_t value)
+ {
+ 	unsigned long ret;
+ 	unsigned long bx = (bus << 8) | device_fn;
+ 	unsigned long flags;
+ 
+ 	save_flags(flags); cli();
+ 	__asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 		"lcall (%%esi)\n\t"
+ #else
+ 		"lcall *(%%esi)\n\t"
+ #endif
+ 		"jc 1f\n\t"
+ 		"xor %%ah, %%ah\n"
+ 		"1:"
+ 		: "=a" (ret)
+ 		: "0" (PCIBIOS_WRITE_CONFIG_DWORD),
+ 		  "c" (value),
+ 		  "b" (bx),
+ 		  "D" ((long) where),
+ 		  "S" (&pci_indirect));
+ 	restore_flags(flags);
+ 	return (int) (ret & 0xff00) >> 8;
+ }
+ 
+ static void check_pcibios(void)
+ {
+ 	unsigned long signature;
+ 	unsigned char present_status;
+ 	unsigned char major_revision;
+ 	unsigned char minor_revision;
+ 	unsigned long flags;
+ 	int pack;
+ 
+ 	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
+ 		pci_indirect.address = pcibios_entry;
+ 
+ 		save_flags(flags);
+ 		__asm__(
+ #ifdef ABSOLUTE_WITHOUT_ASTERISK
+ 			"lcall (%%edi)\n\t"
+ #else
+ 			"lcall *(%%edi)\n\t"
+ #endif
+ 			"jc 1f\n\t"
+ 			"xor %%ah, %%ah\n"
+ 			"1:\tshl $8, %%eax\n\t"
+ 			"movw %%bx, %%ax"
+ 			: "=d" (signature),
+ 			  "=a" (pack)
+ 			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
+ 			  "D" (&pci_indirect)
+ 			: "bx", "cx");
+ 		restore_flags(flags);
+ 
+ 		present_status = (pack >> 16) & 0xff;
+ 		major_revision = (pack >> 8) & 0xff;
+ 		minor_revision = pack & 0xff;
+ 		if (present_status || (signature != PCI_SIGNATURE)) {
+ 			printf("ERROR: BIOS32 says PCI BIOS, but no PCI "
+ 				"BIOS????\n");
+ 			pcibios_entry = 0;
+ 		}
+ #if	DEBUG
+ 		if (pcibios_entry) {
+ 			printf ("pcibios_init : PCI BIOS revision %hhX.%hhX"
+ 				" entry at %#X\n", major_revision,
+ 				minor_revision, pcibios_entry);
+ 		}
+ #endif
+ 	}
+ }
+ 
+ static void pcibios_init(void)
+ {
+ 	union bios32 *check;
+ 	unsigned char sum;
+ 	int i, length;
+ 	unsigned long bios32_entry = 0;
+ 
+ 	EnterFunction("pcibios_init");
+ 	/*
+ 	 * Follow the standard procedure for locating the BIOS32 Service
+ 	 * directory by scanning the permissible address range from
+ 	 * 0xe0000 through 0xfffff for a valid BIOS32 structure.
+ 	 *
+ 	 */
+ 
+ 	for (check = (union bios32 *) 0xe0000; check <= (union bios32 *) 0xffff0; ++check) {
+ 		if (check->fields.signature != BIOS32_SIGNATURE)
+ 			continue;
+ 		length = check->fields.length * 16;
+ 		if (!length)
+ 			continue;
+ 		sum = 0;
+ 		for (i = 0; i < length ; ++i)
+ 			sum += check->chars[i];
+ 		if (sum != 0)
+ 			continue;
+ 		if (check->fields.revision != 0) {
+ 			printf("pcibios_init : unsupported revision %d at %#X, mail drew@colorado.edu\n",
+ 				check->fields.revision, check);
+ 			continue;
+ 		}
+ #if	DEBUG
+ 		printf("pcibios_init : BIOS32 Service Directory "
+ 			"structure at %#X\n", check);
+ #endif
+ 		if (!bios32_entry) {
+ 			if (check->fields.entry >= 0x100000) {
+ 				printf("pcibios_init: entry in high "
+ 					"memory, giving up\n");
+ 				return;
+ 			} else {
+ 				bios32_entry = check->fields.entry;
+ #if	DEBUG
+ 				printf("pcibios_init : BIOS32 Service Directory"
+ 					" entry at %#X\n", bios32_entry);
+ #endif
+ 				bios32_indirect.address = bios32_entry;
+ 			}
+ 		}
+ 	}
+ 	if (bios32_entry)
+ 		check_pcibios();
+ 	LeaveFunction("pcibios_init");
+ }
+ 
+ #endif	/* CONFIG_PCI_DIRECT not defined*/
+ 
+ unsigned long pcibios_bus_base(unsigned int bus __unused)
+ {
+ 	/* architecturally this must be 0 */
+ 	return 0;
+ }
+ 
+ void find_pci(int type, struct pci_device *dev)
+ {
+ 	EnterFunction("find_pci");
+ #ifndef	CONFIG_PCI_DIRECT
+ 	if (!pcibios_entry) {
+ 		pcibios_init();
+ 	}
+ 	if (!pcibios_entry) {
+ 		printf("pci_init: no BIOS32 detected\n");
+ 		return;
+ 	}
+ #endif
+ 	LeaveFunction("find_pci");
+ 	return scan_pci_bus(type, dev);
+ }
diff -rc2P -x CVS GRUB_0.94/netboot/pcnet32.c GRUB/netboot/pcnet32.c
*** GRUB_0.94/netboot/pcnet32.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/pcnet32.c	2003-11-20 11:46:08.000000000 +0800
***************
*** 0 ****
--- 1,926 ----
+ #define EB52
+ 
+ #ifdef EB50
+ #define __unused __attribute__((unused))
+ #endif
+ /**************************************************************************
+ *
+ *    pcnet32.c -- Etherboot device driver for the AMD PCnet32
+ *    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Portions of this code based on:
+ *		pcnet32.c: An AMD PCnet32 ethernet driver for linux:
+ *
+ *	(C) 1996-1999 Thomas Bogendoerfer
+ *		See Linux Driver for full information
+ *	
+ *	The transmit and poll functions were written with reference to:
+ *	lance.c - LANCE NIC driver for Etherboot written by Ken Yap 
+ *	
+ *	Linux Driver Version 1.27a, 10.02.2002
+ * 
+ * 
+ *    $Revision$
+ *    $Author$
+ *    $Date 2003/08/06 $
+ * 
+ *    REVISION HISTORY:
+ *    ================
+ *    v1.0	08-06-2003	timlegge	Initial port of Linux driver
+ *    v1.1	08-23-2003	timlegge	Add multicast support
+ *
+ *    Indent Options: indent -kr -i8
+ ***************************************************************************/
+ 
+ /* to get some global routines like printf */
+ #include "etherboot.h"
+ /* to get the interface to the body of the program */
+ #include "nic.h"
+ /* to get the PCI support functions, if this is a PCI NIC */
+ #include "pci.h"
+ /* Include the time functions */
+ #include "timer.h"
+ 
+ /* void hex_dump(const char *data, const unsigned int len); */
+ 
+ /* Etherboot Specific definations */
+ #define drv_version "v1.1"
+ #define drv_date "08-23-2003"
+ 
+ typedef unsigned char u8;
+ typedef signed char s8;
+ typedef unsigned short u16;
+ typedef signed short s16;
+ typedef unsigned int u32;
+ typedef signed int s32;
+ 
+ static u32 ioaddr;		/* Globally used for the card's io address */
+ 
+ #ifdef EB50
+ #define cpu_to_le32(val) (val)
+ #define le16_to_cpu(val) (val)
+ #define le32_to_cpu(val) (val)
+ #define virt_to_bus(x) ((unsigned long)x)
+ #define bus_to_virt(x) ((unsigned long) x)
+ #endif
+ 
+ /* Condensed operations for readability. */
+ #define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+ #define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+ 
+ /* End Etherboot Specific */
+ 
+ int cards_found /* __initdata */ ;
+ 
+ #ifdef REMOVE
+ /* FIXME: Remove these they are probably pointless */
+ 
+ /* 
+  * VLB I/O addresses 
+  */
+ static unsigned int pcnet32_portlist[] /*__initdata */  =
+ { 0x300, 0x320, 0x340, 0x360, 0 };
+ 
+ static int pcnet32_debug = 1;
+ static int tx_start = 1;	/* Mapping -- 0:20, 1:64, 2:128, 3:~220 (depends on chip vers) */
+ static int pcnet32vlb;		/* check for VLB cards ? */
+ 
+ static struct net_device *pcnet32_dev;
+ 
+ static int max_interrupt_work = 80;
+ static int rx_copybreak = 200;
+ #endif
+ #define PCNET32_PORT_AUI      0x00
+ #define PCNET32_PORT_10BT     0x01
+ #define PCNET32_PORT_GPSI     0x02
+ #define PCNET32_PORT_MII      0x03
+ 
+ #define PCNET32_PORT_PORTSEL  0x03
+ #define PCNET32_PORT_ASEL     0x04
+ #define PCNET32_PORT_100      0x40
+ #define PCNET32_PORT_FD	      0x80
+ 
+ #define PCNET32_DMA_MASK 0xffffffff
+ 
+ /*
+  * table to translate option values from tulip
+  * to internal options
+  */
+ static unsigned char options_mapping[] = {
+ 	PCNET32_PORT_ASEL,	/*  0 Auto-select      */
+ 	PCNET32_PORT_AUI,	/*  1 BNC/AUI          */
+ 	PCNET32_PORT_AUI,	/*  2 AUI/BNC          */
+ 	PCNET32_PORT_ASEL,	/*  3 not supported    */
+ 	PCNET32_PORT_10BT | PCNET32_PORT_FD,	/*  4 10baseT-FD       */
+ 	PCNET32_PORT_ASEL,	/*  5 not supported    */
+ 	PCNET32_PORT_ASEL,	/*  6 not supported    */
+ 	PCNET32_PORT_ASEL,	/*  7 not supported    */
+ 	PCNET32_PORT_ASEL,	/*  8 not supported    */
+ 	PCNET32_PORT_MII,	/*  9 MII 10baseT      */
+ 	PCNET32_PORT_MII | PCNET32_PORT_FD,	/* 10 MII 10baseT-FD   */
+ 	PCNET32_PORT_MII,	/* 11 MII (autosel)    */
+ 	PCNET32_PORT_10BT,	/* 12 10BaseT          */
+ 	PCNET32_PORT_MII | PCNET32_PORT_100,	/* 13 MII 100BaseTx    */
+ 	PCNET32_PORT_MII | PCNET32_PORT_100 | PCNET32_PORT_FD,	/* 14 MII 100BaseTx-FD */
+ 	PCNET32_PORT_ASEL	/* 15 not supported    */
+ };
+ 
+ #define MAX_UNITS 8		/* More are supported, limit only on options */
+ static int options[MAX_UNITS];
+ static int full_duplex[MAX_UNITS];
+ 
+ /*
+  *				Theory of Operation
+  * 
+  * This driver uses the same software structure as the normal lance
+  * driver. So look for a verbose description in lance.c. The differences
+  * to the normal lance driver is the use of the 32bit mode of PCnet32
+  * and PCnetPCI chips. Because these chips are 32bit chips, there is no
+  * 16MB limitation and we don't need bounce buffers.
+  */
+ 
+ 
+ 
+ /*
+  * Set the number of Tx and Rx buffers, using Log_2(# buffers).
+  * Reasonable default values are 4 Tx buffers, and 16 Rx buffers.
+  * That translates to 2 (4 == 2^^2) and 4 (16 == 2^^4).
+  */
+ #ifndef PCNET32_LOG_TX_BUFFERS
+ #define PCNET32_LOG_TX_BUFFERS 1
+ #define PCNET32_LOG_RX_BUFFERS 2
+ #endif
+ 
+ #define TX_RING_SIZE		(1 << (PCNET32_LOG_TX_BUFFERS))
+ #define TX_RING_MOD_MASK	(TX_RING_SIZE - 1)
+ /* FIXME: Fix this to allow multiple tx_ring descriptors */
+ #define TX_RING_LEN_BITS	0x0000	/*PCNET32_LOG_TX_BUFFERS) << 12) */
+ 
+ #define RX_RING_SIZE		(1 << (PCNET32_LOG_RX_BUFFERS))
+ #define RX_RING_MOD_MASK	(RX_RING_SIZE - 1)
+ #define RX_RING_LEN_BITS	((PCNET32_LOG_RX_BUFFERS) << 4)
+ 
+ #define PKT_BUF_SZ		1544
+ 
+ /* Offsets from base I/O address. */
+ #define PCNET32_WIO_RDP		0x10
+ #define PCNET32_WIO_RAP		0x12
+ #define PCNET32_WIO_RESET	0x14
+ #define PCNET32_WIO_BDP		0x16
+ 
+ #define PCNET32_DWIO_RDP	0x10
+ #define PCNET32_DWIO_RAP	0x14
+ #define PCNET32_DWIO_RESET	0x18
+ #define PCNET32_DWIO_BDP	0x1C
+ 
+ #define PCNET32_TOTAL_SIZE	0x20
+ 
+ /* Buffers for the tx and Rx */
+ 
+ /* Create a static buffer of size PKT_BUF_SZ for each
+ TX Descriptor.  All descriptors point to a
+ part of this buffer */
+ static unsigned char txb[PKT_BUF_SZ * TX_RING_SIZE]
+     __attribute__ ((aligned(16)));
+ 
+ /* Create a static buffer of size PKT_BUF_SZ for each
+ RX Descriptor   All descriptors point to a
+ part of this buffer */
+ static unsigned char rxb[RX_RING_SIZE * PKT_BUF_SZ]
+     __attribute__ ((aligned(16)));
+ 
+ /* The PCNET32 Rx and Tx ring descriptors. */
+ struct pcnet32_rx_head {
+ 	u32 base;
+ 	s16 buf_length;
+ 	s16 status;
+ 	u32 msg_length;
+ 	u32 reserved;
+ };
+ 
+ struct pcnet32_tx_head {
+ 	u32 base;
+ 	s16 length;
+ 	s16 status;
+ 	u32 misc;
+ 	u32 reserved;
+ };
+ 
+ /* The PCNET32 32-Bit initialization block, described in databook. */
+ struct pcnet32_init_block {
+ 	u16 mode;
+ 	u16 tlen_rlen;
+ 	u8 phys_addr[6];
+ 	u16 reserved;
+ 	u32 filter[2];
+ 	/* Receive and transmit ring base, along with extra bits. */
+ 	u32 rx_ring;
+ 	u32 tx_ring;
+ };
+ /* PCnet32 access functions */
+ struct pcnet32_access {
+ 	u16(*read_csr) (unsigned long, int);
+ 	void (*write_csr) (unsigned long, int, u16);
+ 	 u16(*read_bcr) (unsigned long, int);
+ 	void (*write_bcr) (unsigned long, int, u16);
+ 	 u16(*read_rap) (unsigned long);
+ 	void (*write_rap) (unsigned long, u16);
+ 	void (*reset) (unsigned long);
+ };
+ 
+ /* Define the TX Descriptor */
+ static struct pcnet32_tx_head tx_ring[TX_RING_SIZE]
+     __attribute__ ((aligned(16)));
+ 
+ 
+ /* Define the RX Descriptor */
+ static struct pcnet32_rx_head rx_ring[RX_RING_SIZE]
+     __attribute__ ((aligned(16)));
+ /*
+  * The first three fields of pcnet32_private are read by the ethernet device 
+  * so we allocate the structure should be allocated by pci_alloc_consistent().
+  */
+ struct pcnet32_private {
+ 	struct pcnet32_init_block init_block;
+ 	struct pci_dev *pci_dev;	/* Pointer to the associated pci device structure */
+ 	const char *name;
+ 	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+ 	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+ 	struct sk_buff *rx_skbuff[RX_RING_SIZE];
+ 	struct pcnet32_access a;
+ 	unsigned int cur_rx, cur_tx;	/* The next free ring entry */
+ 	unsigned int dirty_rx, dirty_tx;	/* The ring entries to be free()ed. */
+ 	char tx_full;
+ 	int options;
+ 	int shared_irq:1,	/* shared irq possible */
+ 	 ltint:1,		/* enable TxDone-intr inhibitor */
+ 	 dxsuflo:1,		/* disable transmit stop on uflo */
+ 	 mii:1;			/* mii port available */
+ 	struct net_device *next;
+ 	int full_duplex:1;
+ } lpx;
+ 
+ static struct pcnet32_private *lp;
+ 
+ enum pci_flags_bit {
+ 	PCI_USES_IO = 1, PCI_USES_MEM = 2, PCI_USES_MASTER = 4,
+ 	PCI_ADDR0 = 0x10 << 0, PCI_ADDR1 = 0x10 << 1, PCI_ADDR2 =
+ 	    0x10 << 2, PCI_ADDR3 = 0x10 << 3,
+ };
+ 
+ 
+ static u16 pcnet32_wio_read_csr(unsigned long addr, int index)
+ {
+ 	outw(index, addr + PCNET32_WIO_RAP);
+ 	return inw(addr + PCNET32_WIO_RDP);
+ }
+ 
+ static void pcnet32_wio_write_csr(unsigned long addr, int index, u16 val)
+ {
+ 	outw(index, addr + PCNET32_WIO_RAP);
+ 	outw(val, addr + PCNET32_WIO_RDP);
+ }
+ 
+ static u16 pcnet32_wio_read_bcr(unsigned long addr, int index)
+ {
+ 	outw(index, addr + PCNET32_WIO_RAP);
+ 	return inw(addr + PCNET32_WIO_BDP);
+ }
+ 
+ static void pcnet32_wio_write_bcr(unsigned long addr, int index, u16 val)
+ {
+ 	outw(index, addr + PCNET32_WIO_RAP);
+ 	outw(val, addr + PCNET32_WIO_BDP);
+ }
+ 
+ static u16 pcnet32_wio_read_rap(unsigned long addr)
+ {
+ 	return inw(addr + PCNET32_WIO_RAP);
+ }
+ 
+ static void pcnet32_wio_write_rap(unsigned long addr, u16 val)
+ {
+ 	outw(val, addr + PCNET32_WIO_RAP);
+ }
+ 
+ static void pcnet32_wio_reset(unsigned long addr)
+ {
+ 	inw(addr + PCNET32_WIO_RESET);
+ }
+ 
+ static int pcnet32_wio_check(unsigned long addr)
+ {
+ 	outw(88, addr + PCNET32_WIO_RAP);
+ 	return (inw(addr + PCNET32_WIO_RAP) == 88);
+ }
+ 
+ static struct pcnet32_access pcnet32_wio = {
+ 	read_csr:pcnet32_wio_read_csr,
+ 	write_csr:pcnet32_wio_write_csr,
+ 	read_bcr:pcnet32_wio_read_bcr,
+ 	write_bcr:pcnet32_wio_write_bcr,
+ 	read_rap:pcnet32_wio_read_rap,
+ 	write_rap:pcnet32_wio_write_rap,
+ 	reset:pcnet32_wio_reset
+ };
+ 
+ static u16 pcnet32_dwio_read_csr(unsigned long addr, int index)
+ {
+ 	outl(index, addr + PCNET32_DWIO_RAP);
+ 	return (inl(addr + PCNET32_DWIO_RDP) & 0xffff);
+ }
+ 
+ static void pcnet32_dwio_write_csr(unsigned long addr, int index, u16 val)
+ {
+ 	outl(index, addr + PCNET32_DWIO_RAP);
+ 	outl(val, addr + PCNET32_DWIO_RDP);
+ }
+ 
+ static u16 pcnet32_dwio_read_bcr(unsigned long addr, int index)
+ {
+ 	outl(index, addr + PCNET32_DWIO_RAP);
+ 	return (inl(addr + PCNET32_DWIO_BDP) & 0xffff);
+ }
+ 
+ static void pcnet32_dwio_write_bcr(unsigned long addr, int index, u16 val)
+ {
+ 	outl(index, addr + PCNET32_DWIO_RAP);
+ 	outl(val, addr + PCNET32_DWIO_BDP);
+ }
+ 
+ static u16 pcnet32_dwio_read_rap(unsigned long addr)
+ {
+ 	return (inl(addr + PCNET32_DWIO_RAP) & 0xffff);
+ }
+ 
+ static void pcnet32_dwio_write_rap(unsigned long addr, u16 val)
+ {
+ 	outl(val, addr + PCNET32_DWIO_RAP);
+ }
+ 
+ static void pcnet32_dwio_reset(unsigned long addr)
+ {
+ 	inl(addr + PCNET32_DWIO_RESET);
+ }
+ 
+ static int pcnet32_dwio_check(unsigned long addr)
+ {
+ 	outl(88, addr + PCNET32_DWIO_RAP);
+ 	return ((inl(addr + PCNET32_DWIO_RAP) & 0xffff) == 88);
+ }
+ 
+ static struct pcnet32_access pcnet32_dwio = {
+ 	read_csr:pcnet32_dwio_read_csr,
+ 	write_csr:pcnet32_dwio_write_csr,
+ 	read_bcr:pcnet32_dwio_read_bcr,
+ 	write_bcr:pcnet32_dwio_write_bcr,
+ 	read_rap:pcnet32_dwio_read_rap,
+ 	write_rap:pcnet32_dwio_write_rap,
+ 	reset:pcnet32_dwio_reset
+ };
+ 
+ 
+ /* Initialize the PCNET32 Rx and Tx rings. */
+ static int pcnet32_init_ring(struct nic *nic)
+ {
+ 	int i;
+ 
+ 	lp->tx_full = 0;
+ 	lp->cur_rx = lp->cur_tx = 0;
+ 	lp->dirty_rx = lp->dirty_tx = 0;
+ 
+ 	for (i = 0; i < RX_RING_SIZE; i++) {
+ 		rx_ring[i].base = (u32) virt_to_le32desc(&rxb[i]);
+ 		rx_ring[i].buf_length = le16_to_cpu(-PKT_BUF_SZ);
+ 		rx_ring[i].status = le16_to_cpu(0x8000);
+ 	}
+ 
+ 	/* The Tx buffer address is filled in as needed, but we do need to clear
+ 	   the upper ownership bit. */
+ 	for (i = 0; i < TX_RING_SIZE; i++) {
+ 		tx_ring[i].base = 0;
+ 		tx_ring[i].status = 0;
+ 	}
+ 
+ 
+ 	lp->init_block.tlen_rlen =
+ 	    le16_to_cpu(TX_RING_LEN_BITS | RX_RING_LEN_BITS);
+ 	for (i = 0; i < 6; i++)
+ 		lp->init_block.phys_addr[i] = nic->node_addr[i];
+ 	lp->init_block.rx_ring = (u32) virt_to_le32desc(&rx_ring[0]);
+ 	lp->init_block.tx_ring = (u32) virt_to_le32desc(&tx_ring[0]);
+ 	return 0;
+ }
+ 
+ /**************************************************************************
+ RESET - Reset adapter
+ ***************************************************************************/
+ static void pcnet32_reset(struct nic *nic)
+ {
+ 	/* put the card in its initial state */
+ 	u16 val;
+ 	int i;
+ 
+ 	/* Reset the PCNET32 */
+ 	lp->a.reset(ioaddr);
+ 
+ 	/* switch pcnet32 to 32bit mode */
+ 	lp->a.write_bcr(ioaddr, 20, 2);
+ 
+ 	/* set/reset autoselect bit */
+ 	val = lp->a.read_bcr(ioaddr, 2) & ~2;
+ 	if (lp->options & PCNET32_PORT_ASEL)
+ 		val |= 2;
+ 	lp->a.write_bcr(ioaddr, 2, val);
+ 	/* handle full duplex setting */
+ 	if (lp->full_duplex) {
+ 		val = lp->a.read_bcr(ioaddr, 9) & ~3;
+ 		if (lp->options & PCNET32_PORT_FD) {
+ 			val |= 1;
+ 			if (lp->options ==
+ 			    (PCNET32_PORT_FD | PCNET32_PORT_AUI))
+ 				val |= 2;
+ 		} else if (lp->options & PCNET32_PORT_ASEL) {
+ 			/* workaround of xSeries250, turn on for 79C975 only */
+ 			i = ((lp->a.
+ 			      read_csr(ioaddr,
+ 				       88) | (lp->a.read_csr(ioaddr,
+ 							     89) << 16)) >>
+ 			     12) & 0xffff;
+ 			if (i == 0x2627)
+ 				val |= 3;
+ 		}
+ 		lp->a.write_bcr(ioaddr, 9, val);
+ 	}
+ 
+ 	/* set/reset GPSI bit in test register */
+ 	val = lp->a.read_csr(ioaddr, 124) & ~0x10;
+ 	if ((lp->options & PCNET32_PORT_PORTSEL) == PCNET32_PORT_GPSI)
+ 		val |= 0x10;
+ 	lp->a.write_csr(ioaddr, 124, val);
+ 
+ 	if (lp->mii && !(lp->options & PCNET32_PORT_ASEL)) {
+ 		val = lp->a.read_bcr(ioaddr, 32) & ~0x38;	/* disable Auto Negotiation, set 10Mpbs, HD */
+ 		if (lp->options & PCNET32_PORT_FD)
+ 			val |= 0x10;
+ 		if (lp->options & PCNET32_PORT_100)
+ 			val |= 0x08;
+ 		lp->a.write_bcr(ioaddr, 32, val);
+ 	} else {
+ 		if (lp->options & PCNET32_PORT_ASEL) {	/* enable auto negotiate, setup, disable fd */
+ 			val = lp->a.read_bcr(ioaddr, 32) & ~0x98;
+ 			val |= 0x20;
+ 			lp->a.write_bcr(ioaddr, 32, val);
+ 		}
+ 	}
+ 
+ #ifdef DO_DXSUFLO
+ 	if (lp->dxsuflo) {	/* Disable transmit stop on underflow */
+ 		val = lp->a.read_csr(ioaddr, 3);
+ 		val |= 0x40;
+ 		lp->a.write_csr(ioaddr, 3, val);
+ 	}
+ #endif
+ 
+ 	if (lp->ltint) {	/* Enable TxDone-intr inhibitor */
+ 		val = lp->a.read_csr(ioaddr, 5);
+ 		val |= (1 << 14);
+ 		lp->a.write_csr(ioaddr, 5, val);
+ 	}
+ 	lp->init_block.mode =
+ 	    le16_to_cpu((lp->options & PCNET32_PORT_PORTSEL) << 7);
+ 	lp->init_block.filter[0] = 0xffffffff;
+ 	lp->init_block.filter[1] = 0xffffffff;
+ 
+ 	pcnet32_init_ring(nic);
+ 
+ 
+ 	/* Re-initialize the PCNET32, and start it when done. */
+ 	lp->a.write_csr(ioaddr, 1,
+ 			(virt_to_bus(&lp->init_block)) & 0xffff);
+ 	lp->a.write_csr(ioaddr, 2, (virt_to_bus(&lp->init_block)) >> 16);
+ 	lp->a.write_csr(ioaddr, 4, 0x0915);
+ 	lp->a.write_csr(ioaddr, 0, 0x0001);
+ 
+ 
+ 	i = 0;
+ 	while (i++ < 100)
+ 		if (lp->a.read_csr(ioaddr, 0) & 0x0100)
+ 			break;
+ 	/* 
+ 	 * We used to clear the InitDone bit, 0x0100, here but Mark Stockton
+ 	 * reports that doing so triggers a bug in the '974.
+ 	 */
+ 	lp->a.write_csr(ioaddr, 0, 0x0042);
+ 
+ 	printf("pcnet32 open, csr0 %hX.\n", lp->a.read_csr(ioaddr, 0));
+ 
+ }
+ 
+ /**************************************************************************
+ POLL - Wait for a frame
+ ***************************************************************************/
+ static int pcnet32_poll(struct nic *nic __unused)
+ {
+ 	/* return true if there's an ethernet packet ready to read */
+ 	/* nic->packet should contain data on return */
+ 	/* nic->packetlen should contain length of data */
+ 
+ 	int status;
+ 	int entry;
+ 
+ 	entry = lp->cur_rx & RX_RING_MOD_MASK;
+ 	status = ((short) le16_to_cpu(rx_ring[entry].status) >> 8);
+ 
+ 	if (status < 0)
+ 		return 0;
+ 
+ 	if (status == 0x03) {
+ 		nic->packetlen =
+ 		    (le32_to_cpu(rx_ring[entry].msg_length) & 0xfff) - 4;
+ 		memcpy(nic->packet, &rxb[entry], nic->packetlen);
+ 
+ 		/* Andrew Boyd of QNX reports that some revs of the 79C765
+ 		 * clear the buffer length */
+ 		rx_ring[entry].buf_length = le16_to_cpu(-PKT_BUF_SZ);
+ 		rx_ring[entry].status |= le16_to_cpu(0x8000);	/* prime for next receive */
+ 		/* Switch to the next Rx ring buffer */
+ 		lp->cur_rx++;
+ 
+ 	} else {
+ 		return 0;
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ /**************************************************************************
+ TRANSMIT - Transmit a frame
+ ***************************************************************************/
+ static void pcnet32_transmit(struct nic *nic __unused, const char *d,	/* Destination */
+ 			     unsigned int t,	/* Type */
+ 			     unsigned int s,	/* size */
+ 			     const char *p)
+ {				/* Packet */
+ 	/* send the packet to destination */
+ 	unsigned long time;
+ 	u8 *ptxb;
+ 	u16 nstype;
+ 	u16 status;
+ 	int entry = 0;		/*lp->cur_tx & TX_RING_MOD_MASK; */
+ 
+ 	status = 0x8300;
+ 	/* point to the current txb incase multiple tx_rings are used */
+ 	ptxb = txb + (lp->cur_tx * PKT_BUF_SZ);
+ 
+ 	/* copy the packet to ring buffer */
+ 	memcpy(ptxb, d, ETH_ALEN);	/* dst */
+ 	memcpy(ptxb + ETH_ALEN, nic->node_addr, ETH_ALEN);	/* src */
+ 	nstype = htons((u16) t);	/* type */
+ 	memcpy(ptxb + 2 * ETH_ALEN, (u8 *) & nstype, 2);	/* type */
+ 	memcpy(ptxb + ETH_HLEN, p, s);
+ 
+ 	s += ETH_HLEN;
+ 	while (s < ETH_ZLEN)	/* pad to min length */
+ 		ptxb[s++] = '\0';
+ 
+ 	tx_ring[entry].length = le16_to_cpu(-s);
+ 	tx_ring[entry].misc = 0x00000000;
+ 	tx_ring[entry].base = (u32) virt_to_le32desc(ptxb);
+ 
+ 	/* we set the top byte as the very last thing */
+ 	tx_ring[entry].status = le16_to_cpu(status);
+ 
+ 
+ 	/* Trigger an immediate send poll */
+ 	lp->a.write_csr(ioaddr, 0, 0x0048);
+ 
+ 	/* wait for transmit complete */
+ 	lp->cur_tx = 0;		/* (lp->cur_tx + 1); */
+ 	time = currticks() + TICKS_PER_SEC;	/* wait one second */
+ 	while (currticks() < time &&
+ 	       ((short) le16_to_cpu(tx_ring[entry].status) < 0));
+ 
+ 	if ((short) le16_to_cpu(tx_ring[entry].status) < 0)
+ 		printf("PCNET32 timed out on transmit\n");
+ 
+ 	/* Stop pointing at the current txb
+ 	 * otherwise the card continues to send the packet */
+ 	tx_ring[entry].base = 0;
+ 
+ }
+ 
+ /**************************************************************************
+ DISABLE - Turn off ethernet interface
+ ***************************************************************************/
+ #ifdef EB50
+ static void pcnet32_disable(struct nic *nic __unused)
+ #else
+ static void pcnet32_disable(struct dev *dev __unused)
+ #endif
+ {
+ 	/* Stop the PCNET32 here -- it ocassionally polls memory if we don't */
+ 	lp->a.write_csr(ioaddr, 0, 0x0004);
+ 
+ 	/*
+ 	 * Switch back to 16-bit mode to avoid problesm with dumb 
+ 	 * DOS packet driver after a warm reboot
+ 	 */
+ 	lp->a.write_bcr(ioaddr, 20, 4);
+ }
+ 
+ /**************************************************************************
+ PROBE - Look for an adapter, this routine's visible to the outside
+ You should omit the last argument struct pci_device * for a non-PCI NIC
+ ***************************************************************************/
+ #ifdef EB50
+ struct nic *pcnet32_probe(struct nic *nic, unsigned short *io_addr, struct pci_device *pci)
+ {
+ #else
+ static int pcnet32_probe(struct dev *dev, struct pci_device *pci)
+ {
+ 	struct nic *nic = (struct nic *) dev;
+ #endif
+ 
+ 	int i, media;
+ 	int fdx, mii, fset, dxsuflo, ltint;
+ 	int chip_version;
+ 	char *chipname;
+ 	/* struct net_device *dev; */
+ 	struct pcnet32_access *a = NULL;
+ 	u8 promaddr[6];
+ 
+ 	int shared = 1;
+ 	if (pci->ioaddr == 0)
+ 		return 0;
+ 
+ 	/* BASE is used throughout to address the card */
+ 	ioaddr = pci->ioaddr;
+ 	printf("\n");	
+ 	printf("pcnet32.c: %s, %s Written by Timothy Legge (tlegge@rogers.com)\n", drv_version, drv_date);
+ 	printf("%s: Probing for Vendor=%hX   Device=%hX\n",
+ 	       pci->name, pci->vendor, pci->dev_id);
+ 
+ 	/* reset the chip */
+ 	pcnet32_wio_reset(ioaddr);
+ 
+ 	/* NOTE: 16-bit check is first, otherwise some older PCnet chips fail */
+ 	if (pcnet32_wio_read_csr(ioaddr, 0) == 4
+ 	    && pcnet32_wio_check(ioaddr)) {
+ 		a = &pcnet32_wio;
+ 	} else {
+ 		pcnet32_dwio_reset(ioaddr);
+ 		if (pcnet32_dwio_read_csr(ioaddr, 0) == 4
+ 		    && pcnet32_dwio_check(ioaddr)) {
+ 			a = &pcnet32_dwio;
+ 		} else
+ 			/* return -ENODEV; */
+ 			return 0;
+ 	}
+ 
+ 	chip_version =
+ 	    a->read_csr(ioaddr, 88) | (a->read_csr(ioaddr, 89) << 16);
+ 
+ 	printf("PCnet chip version is %#x.\n", chip_version);
+ 	if ((chip_version & 0xfff) != 0x003)
+ 		/*return -ENODEV; */
+ 		return 0;
+ 
+ 	/* initialize variables */
+ 	fdx = mii = fset = dxsuflo = ltint = 0;
+ 	chip_version = (chip_version >> 12) & 0xffff;
+ 
+ 	switch (chip_version) {
+ 	case 0x2420:
+ 		chipname = "PCnet/PCI 79C970";	/* PCI */
+ 		break;
+ 	case 0x2430:
+ 		if (shared)
+ 			chipname = "PCnet/PCI 79C970";	/* 970 gives the wrong chip id back */
+ 		else
+ 			chipname = "PCnet/32 79C965";	/* 486/VL bus */
+ 		break;
+ 	case 0x2621:
+ 		chipname = "PCnet/PCI II 79C970A";	/* PCI */
+ 		fdx = 1;
+ 		break;
+ 	case 0x2623:
+ 		chipname = "PCnet/FAST 79C971";	/* PCI */
+ 		fdx = 1;
+ 		mii = 1;
+ 		fset = 1;
+ 		ltint = 1;
+ 		break;
+ 	case 0x2624:
+ 		chipname = "PCnet/FAST+ 79C972";	/* PCI */
+ 		fdx = 1;
+ 		mii = 1;
+ 		fset = 1;
+ 		break;
+ 	case 0x2625:
+ 		chipname = "PCnet/FAST III 79C973";	/* PCI */
+ 		fdx = 1;
+ 		mii = 1;
+ 		break;
+ 	case 0x2626:
+ 		chipname = "PCnet/Home 79C978";	/* PCI */
+ 		fdx = 1;
+ 		/* 
+ 		 * This is based on specs published at www.amd.com.  This section
+ 		 * assumes that a card with a 79C978 wants to go into 1Mb HomePNA
+ 		 * mode.  The 79C978 can also go into standard ethernet, and there
+ 		 * probably should be some sort of module option to select the
+ 		 * mode by which the card should operate
+ 		 */
+ 		/* switch to home wiring mode */
+ 		media = a->read_bcr(ioaddr, 49);
+ 
+ 		printf("media reset to %#x.\n", media);
+ 		a->write_bcr(ioaddr, 49, media);
+ 		break;
+ 	case 0x2627:
+ 		chipname = "PCnet/FAST III 79C975";	/* PCI */
+ 		fdx = 1;
+ 		mii = 1;
+ 		break;
+ 	default:
+ 		printf("PCnet version %#x, no PCnet32 chip.\n",
+ 		       chip_version);
+ 		/* return -ENODEV; */
+ 		return 0;
+ 	}
+ 
+ 	/*
+ 	 *  On selected chips turn on the BCR18:NOUFLO bit. This stops transmit
+ 	 *  starting until the packet is loaded. Strike one for reliability, lose
+ 	 *  one for latency - although on PCI this isnt a big loss. Older chips 
+ 	 *  have FIFO's smaller than a packet, so you can't do this.
+ 	 */
+ 
+ 	if (fset) {
+ 		a->write_bcr(ioaddr, 18,
+ 			     (a->read_bcr(ioaddr, 18) | 0x0800));
+ 		a->write_csr(ioaddr, 80,
+ 			     (a->read_csr(ioaddr, 80) & 0x0C00) | 0x0c00);
+ 		dxsuflo = 1;
+ 		ltint = 1;
+ 	}
+ 
+ 	printf("%s at %hX,", chipname, ioaddr);
+ 
+ 	/* read PROM address */
+ 	for (i = 0; i < 6; i++)
+ 		promaddr[i] = inb(ioaddr + i);
+ 
+ 	/* Update the nic structure with the MAC Address */
+ 	for (i = 0; i < ETH_ALEN; i++) {
+ 		nic->node_addr[i] = promaddr[i];
+ 	}
+ 	/* Print out some hardware info */
+ 	printf("%s: %! at ioaddr %hX\n", pci->name, nic->node_addr,
+ 	       ioaddr);
+ 
+ 	/* I really must find out what this does */
+ 	adjust_pci_device(pci);
+ 
+ 	/* point to private storage */
+ 	lp = &lpx;
+ 
+ 	if (((chip_version + 1) & 0xfffe) == 0x2624) {	/* Version 0x2623 or 0x2624 */
+ 		i = a->read_csr(ioaddr, 80) & 0x0C00;	/* Check tx_start_pt */
+ 		printf("    tx_start_pt(0x%hX):", i);
+ 		switch (i >> 10) {
+ 		case 0:
+ 			printf("  20 bytes,");
+ 			break;
+ 		case 1:
+ 			printf("  64 bytes,");
+ 			break;
+ 		case 2:
+ 			printf(" 128 bytes,");
+ 			break;
+ 		case 3:
+ 			printf("~220 bytes,");
+ 			break;
+ 		}
+ 		i = a->read_bcr(ioaddr, 18);	/* Check Burst/Bus control */
+ 		printf(" BCR18(%hX):", i & 0xffff);
+ 		if (i & (1 << 5))
+ 			printf("BurstWrEn ");
+ 		if (i & (1 << 6))
+ 			printf("BurstRdEn ");
+ 		if (i & (1 << 7))
+ 			printf("DWordIO ");
+ 		if (i & (1 << 11))
+ 			printf("NoUFlow ");
+ 		i = a->read_bcr(ioaddr, 25);
+ 		printf("    SRAMSIZE=0x%hX,", i << 8);
+ 		i = a->read_bcr(ioaddr, 26);
+ 		printf(" SRAM_BND=0x%hX,", i << 8);
+ 		i = a->read_bcr(ioaddr, 27);
+ 		if (i & (1 << 14))
+ 			printf("LowLatRx");
+ 	}
+ 
+ 	lp = &lpx;
+ 	lp->name = chipname;
+ 	lp->shared_irq = shared;
+ 	lp->full_duplex = fdx;
+ 	lp->dxsuflo = dxsuflo;
+ 	lp->ltint = ltint;
+ 	lp->mii = mii;
+ 	if ((cards_found >= MAX_UNITS)
+ 	    || (options[cards_found] > sizeof(options_mapping)))
+ 		lp->options = PCNET32_PORT_ASEL;
+ 	else
+ 		lp->options = options_mapping[options[cards_found]];
+ 
+ 	if (fdx && !(lp->options & PCNET32_PORT_ASEL) &&
+ 	    ((cards_found >= MAX_UNITS) || full_duplex[cards_found]))
+ 		lp->options |= PCNET32_PORT_FD;
+ 
+ 	if (!a) {
+ 		printf("No access methods\n");
+ 		return 0;
+ 	}
+ 	lp->a = *a;
+ 
+ 	/* detect special T1/E1 WAN card by checking for MAC address */
+ 	if (nic->node_addr[0] == 0x00 && nic->node_addr[1] == 0xe0
+ 	    && nic->node_addr[2] == 0x75)
+ 		lp->options = PCNET32_PORT_FD | PCNET32_PORT_GPSI;
+ 
+ 	lp->init_block.mode = le16_to_cpu(0x0003); 	/* Disable Rx and Tx. */
+ 	lp->init_block.tlen_rlen =
+ 	    le16_to_cpu(TX_RING_LEN_BITS | RX_RING_LEN_BITS);
+ 	for (i = 0; i < 6; i++)
+ 		lp->init_block.phys_addr[i] = nic->node_addr[i];
+ 	lp->init_block.filter[0] = 0xffffffff;
+ 	lp->init_block.filter[1] = 0xffffffff;
+ 	lp->init_block.rx_ring = virt_to_bus(&rx_ring);
+ 	lp->init_block.tx_ring = virt_to_bus(&tx_ring);
+ 
+ 	/* switch pcnet32 to 32bit mode */
+ 	a->write_bcr(ioaddr, 20, 2);
+ 
+ 
+ 	a->write_csr(ioaddr, 1, (virt_to_bus(&lp->init_block)) & 0xffff);
+ 	a->write_csr(ioaddr, 2, (virt_to_bus(&lp->init_block)) >> 16);
+ 
+ 	/* 
+ 	 * To auto-IRQ we enable the initialization-done and DMA error
+ 	 * interrupts. For ISA boards we get a DMA error, but VLB and PCI
+ 	 * boards will work.
+ 	 */
+ 	/* Trigger an initialization just for the interrupt. */
+ 
+ 	a->write_csr(ioaddr, 0, 0x41);
+ 	mdelay(1);
+ 
+ 	cards_found++;
+ 	
+ 	/* point to NIC specific routines */
+ 	pcnet32_reset(nic);
+ 
+ #ifdef EB50
+ 	nic->poll = pcnet32_poll;
+ 	nic->transmit = pcnet32_transmit;
+ 	nic->disable = pcnet32_disable;
+ 	return nic;
+ #else
+ 	nic->poll = pcnet32_poll;
+ 	nic->transmit = pcnet32_transmit;
+ 	dev->disable = pcnet32_disable;
+ 	return 1;
+ #endif
+ }
+ #ifndef EB50
+ static struct pci_id pcnet32_nics[] = {
+ 	PCI_ROM(0x1022, 0x2000, "lancepci", "AMD Lance/PCI"),
+ 	PCI_ROM(0x1022, 0x2625, "pcnetfastiii", "AMD Lance/PCI PCNet/32"),
+ 	PCI_ROM(0x1022, 0x2001, "amdhomepna", "AMD Lance/HomePNA"),
+ };
+ 
+ struct pci_driver pcnet32_driver = {
+ 	.type = NIC_DRIVER,
+ 	.name = "PCNET32/PCI",
+ 	.probe = pcnet32_probe,
+ 	.ids = pcnet32_nics,
+ 	.id_count = sizeof(pcnet32_nics) / sizeof(pcnet32_nics[0]),
+ 	.class = 0,
+ };
+ #endif
diff -rc2P -x CVS GRUB_0.94/netboot/rtl8139.c GRUB/netboot/rtl8139.c
*** GRUB_0.94/netboot/rtl8139.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/rtl8139.c	2003-11-05 18:10:24.000000000 +0800
***************
*** 18,21 ****
--- 18,23 ----
  
  /*
+   28 Dec 2002	ken_yap@users.sourceforge.net (Ken Yap)
+      Put in virt_to_bus calls to allow Etherboot relocation.
  
    06 Apr 2001	ken_yap@users.sourceforge.net (Ken Yap)
***************
*** 64,68 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  #include "timer.h"
  
--- 66,69 ----
***************
*** 161,190 ****
  /* The RTL8139 can only transmit from a contiguous, aligned memory block.  */
  static unsigned char tx_buffer[TX_BUF_SIZE] __attribute__((aligned(4)));
- 
- /* I know that this is a MEGA HACK, but the tagged boot image specification
-  * states that we can do whatever we want below 0x10000 - so we do!  */
- /* But we still give the user the choice of using an internal buffer
-    just in case - Ken */
- #ifdef	USE_LOWMEM_BUFFER
- #define rx_ring ((unsigned char *)(0x10000 - (RX_BUF_LEN + 16)))
- #else
  static unsigned char rx_ring[RX_BUF_LEN+16] __attribute__((aligned(4)));
- #endif
  
! struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
! 	struct pci_device *pci);
! static int read_eeprom(int location);
  static void rtl_reset(struct nic *nic);
  static void rtl_transmit(struct nic *nic, const char *destaddr,
  	unsigned int type, unsigned int len, const char *data);
  static int rtl_poll(struct nic *nic);
! static void rtl_disable(struct nic*);
  
  
! struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
! 	struct pci_device *pci)
  {
  	int i;
  	int speed10, fullduplex;
  
  	/* There are enough "RTL8139" strings on the console already, so
--- 162,183 ----
  /* The RTL8139 can only transmit from a contiguous, aligned memory block.  */
  static unsigned char tx_buffer[TX_BUF_SIZE] __attribute__((aligned(4)));
  static unsigned char rx_ring[RX_BUF_LEN+16] __attribute__((aligned(4)));
  
! static int rtl8139_probe(struct dev *dev, struct pci_device *pci);
! static int read_eeprom(int location, int addr_len);
  static void rtl_reset(struct nic *nic);
  static void rtl_transmit(struct nic *nic, const char *destaddr,
  	unsigned int type, unsigned int len, const char *data);
  static int rtl_poll(struct nic *nic);
! static void rtl_disable(struct dev *);
  
  
! static int rtl8139_probe(struct dev *dev, struct pci_device *pci)
  {
+ 	struct nic *nic = (struct nic *)dev;
  	int i;
  	int speed10, fullduplex;
+ 	int addr_len;
+ 	unsigned short *ap = (unsigned short*)nic->node_addr;
  
  	/* There are enough "RTL8139" strings on the console already, so
***************
*** 193,197 ****
  
  	/* Mask the bit that says "this is an io addr" */
! 	ioaddr = probeaddrs[0] & ~3;
  
  	adjust_pci_device(pci);
--- 186,190 ----
  
  	/* Mask the bit that says "this is an io addr" */
! 	ioaddr = pci->ioaddr & ~3;
  
  	adjust_pci_device(pci);
***************
*** 200,212 ****
  	outb(0x00, ioaddr + Config1);
  
! 	if (read_eeprom(0) != 0xffff) {
! 		unsigned short *ap = (unsigned short*)nic->node_addr;
! 		for (i = 0; i < 3; i++)
! 			*ap++ = read_eeprom(i + 7);
! 	} else {
! 		unsigned char *ap = (unsigned char*)nic->node_addr;
! 		for (i = 0; i < ETH_ALEN; i++)
! 			*ap++ = inb(ioaddr + MAC0 + i);
! 	}
  
  	speed10 = inb(ioaddr + MediaStatus) & MSRSpeed10;
--- 193,199 ----
  	outb(0x00, ioaddr + Config1);
  
! 	addr_len = read_eeprom(0,8) == 0x8129 ? 8 : 6;
! 	for (i = 0; i < 3; i++)
! 	  *ap++ = read_eeprom(i + 7,addr_len);
  
  	speed10 = inb(ioaddr + MediaStatus) & MSRSpeed10;
***************
*** 218,227 ****
  	rtl_reset(nic);
  
! 	nic->reset = rtl_reset;
! 	nic->poll = rtl_poll;
  	nic->transmit = rtl_transmit;
- 	nic->disable = rtl_disable;
  
! 	return nic;
  }
  
--- 205,218 ----
  	rtl_reset(nic);
  
! 	if (inb(ioaddr + MediaStatus) & MSRLinkFail) {
! 		printf("Cable not connected or other link failure\n");
! 		return(0);
! 	}
! 
! 	dev->disable  = rtl_disable;
! 	nic->poll     = rtl_poll;
  	nic->transmit = rtl_transmit;
  
! 	return 1;
  }
  
***************
*** 245,264 ****
  
  /* The EEPROM commands include the alway-set leading bit. */
! #define EE_WRITE_CMD    (5 << 6)
! #define EE_READ_CMD     (6 << 6)
! #define EE_ERASE_CMD    (7 << 6)
  
! static int read_eeprom(int location)
  {
  	int i;
  	unsigned int retval = 0;
  	long ee_addr = ioaddr + Cfg9346;
! 	int read_cmd = location | EE_READ_CMD;
  
  	outb(EE_ENB & ~EE_CS, ee_addr);
  	outb(EE_ENB, ee_addr);
  
  	/* Shift the read command bits out. */
! 	for (i = 10; i >= 0; i--) {
  		int dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;
  		outb(EE_ENB | dataval, ee_addr);
--- 236,256 ----
  
  /* The EEPROM commands include the alway-set leading bit. */
! #define EE_WRITE_CMD    (5)
! #define EE_READ_CMD     (6)
! #define EE_ERASE_CMD    (7)
  
! static int read_eeprom(int location, int addr_len)
  {
  	int i;
  	unsigned int retval = 0;
  	long ee_addr = ioaddr + Cfg9346;
! 	int read_cmd = location | (EE_READ_CMD << addr_len);
  
  	outb(EE_ENB & ~EE_CS, ee_addr);
  	outb(EE_ENB, ee_addr);
+ 	eeprom_delay();
  
  	/* Shift the read command bits out. */
! 	for (i = 4 + addr_len; i >= 0; i--) {
  		int dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;
  		outb(EE_ENB | dataval, ee_addr);
***************
*** 280,286 ****
--- 272,297 ----
  	/* Terminate the EEPROM access. */
  	outb(~EE_CS, ee_addr);
+ 	eeprom_delay();
  	return retval;
  }
  
+ static const unsigned int rtl8139_rx_config = 
+ 	(RX_BUF_LEN_IDX << 11) |
+ 	(RX_FIFO_THRESH << 13) |
+ 	(RX_DMA_BURST << 8);
+ 	
+ static void set_rx_mode(struct nic *nic) {
+ 	unsigned int mc_filter[2];
+ 	int rx_mode;
+ 	/* !IFF_PROMISC */
+ 	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+ 	mc_filter[1] = mc_filter[0] = 0xffffffff;
+ 
+ 	outl(rtl8139_rx_config | rx_mode, ioaddr + RxConfig);
+ 
+ 	outl(mc_filter[0], ioaddr + MAR0 + 0);
+ 	outl(mc_filter[1], ioaddr + MAR0 + 4);
+ }
+ 	
  static void rtl_reset(struct nic* nic)
  {
***************
*** 317,331 ****
  	printf("rx ring address is %X\n",(unsigned long)rx_ring);
  #endif
! 	outl((unsigned long)rx_ring, ioaddr + RxBuf);
  
- 	/* Start the chip's Tx and Rx process. */
- 	outl(0, ioaddr + RxMissed);
- 	/* set_rx_mode */
- 	outb(AcceptBroadcast|AcceptMyPhys, ioaddr + RxConfig);
  	/* If we add multicast support, the MAR0 register would have to be
  	 * initialized to 0xffffffffffffffff (two 32 bit accesses).  Etherboot
  	 * only needs broadcast (for ARP/RARP/BOOTP/DHCP) and unicast.  */
  	outb(CmdRxEnb | CmdTxEnb, ioaddr + ChipCmd);
  
  	/* Disable all known interrupts by setting the interrupt mask. */
  	outw(0, ioaddr + IntrMask);
--- 328,349 ----
  	printf("rx ring address is %X\n",(unsigned long)rx_ring);
  #endif
! 	outl((unsigned long)virt_to_bus(rx_ring), ioaddr + RxBuf);
! 
! 
  
  	/* If we add multicast support, the MAR0 register would have to be
  	 * initialized to 0xffffffffffffffff (two 32 bit accesses).  Etherboot
  	 * only needs broadcast (for ARP/RARP/BOOTP/DHCP) and unicast.  */
+ 
  	outb(CmdRxEnb | CmdTxEnb, ioaddr + ChipCmd);
+ 	
+ 	outl(rtl8139_rx_config, ioaddr + RxConfig);
+ 	
+ 	/* Start the chip's Tx and Rx process. */
+ 	outl(0, ioaddr + RxMissed);
  
+ 	/* set_rx_mode */
+ 	set_rx_mode(nic);
+ 	
  	/* Disable all known interrupts by setting the interrupt mask. */
  	outw(0, ioaddr + IntrMask);
***************
*** 338,345 ****
  	unsigned long txstatus;
  
  	memcpy(tx_buffer, destaddr, ETH_ALEN);
  	memcpy(tx_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
! 	nstype = htons(type);
! 	memcpy(tx_buffer + 2 * ETH_ALEN, (char*)&nstype, 2);
  	memcpy(tx_buffer + ETH_HLEN, data, len);
  
--- 356,364 ----
  	unsigned long txstatus;
  
+ 	/* nstype assignment moved up here to avoid gcc 3.0.3 compiler bug */
+ 	nstype = htons(type);
  	memcpy(tx_buffer, destaddr, ETH_ALEN);
  	memcpy(tx_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
! 	memcpy(tx_buffer + 2 * ETH_ALEN, &nstype, 2);
  	memcpy(tx_buffer + ETH_HLEN, data, len);
  
***************
*** 355,359 ****
  	}
  
! 	outl((unsigned long)tx_buffer, ioaddr + TxAddr0 + cur_tx*4);
  	outl(((TX_FIFO_THRESH<<11) & 0x003f0000) | len,
  		ioaddr + TxStatus0 + cur_tx*4);
--- 374,378 ----
  	}
  
! 	outl((unsigned long)virt_to_bus(tx_buffer), ioaddr + TxAddr0 + cur_tx*4);
  	outl(((TX_FIFO_THRESH<<11) & 0x003f0000) | len,
  		ioaddr + TxStatus0 + cur_tx*4);
***************
*** 447,452 ****
  }
  
! static void rtl_disable(struct nic *nic)
  {
  	/* reset the chip */
  	outb(CmdReset, ioaddr + ChipCmd);
--- 466,475 ----
  }
  
! static void rtl_disable(struct dev *dev)
  {
+ 	struct nic *nic = (struct nic *)dev;
+ 	/* merge reset and disable */
+ 	rtl_reset(nic);
+ 
  	/* reset the chip */
  	outb(CmdReset, ioaddr + ChipCmd);
***************
*** 457,458 ****
--- 480,507 ----
  		/* wait */;
  }
+ 
+ static struct pci_id rtl8139_nics[] = {
+ PCI_ROM(0x10ec, 0x8129, "rtl8129",       "Realtek 8129"),
+ PCI_ROM(0x10ec, 0x8139, "rtl8139",       "Realtek 8139"),
+ PCI_ROM(0x10ec, 0x8138, "rtl8139b",      "Realtek 8139B"),
+ PCI_ROM(0x1186, 0x1300, "dfe538",        "DFE530TX+/DFE538TX"),
+ PCI_ROM(0x1113, 0x1211, "smc1211-1",     "SMC EZ10/100"),
+ PCI_ROM(0x1112, 0x1211, "smc1211",       "SMC EZ10/100"),
+ PCI_ROM(0x1500, 0x1360, "delta8139",     "Delta Electronics 8139"),
+ PCI_ROM(0x4033, 0x1360, "addtron8139",   "Addtron Technology 8139"),
+ PCI_ROM(0x1186, 0x1340, "dfe690txd",     "D-Link DFE690TXD"),
+ PCI_ROM(0x13d1, 0xab06, "fe2000vx",      "AboCom FE2000VX"),
+ PCI_ROM(0x1259, 0xa117, "allied8139",    "Allied Telesyn 8139"),
+ PCI_ROM(0x14ea, 0xab06, "fnw3603tx",     "Planex FNW-3603-TX"),
+ PCI_ROM(0x14ea, 0xab07, "fnw3800tx",     "Planex FNW-3800-TX"),
+ PCI_ROM(0xffff, 0x8139, "clone-rtl8139", "Cloned 8139"),
+ };
+ 
+ struct pci_driver rtl8139_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "RTL8139",
+ 	.probe    = rtl8139_probe,
+ 	.ids      = rtl8139_nics,
+ 	.id_count = sizeof(rtl8139_nics)/sizeof(rtl8139_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/sis900.c GRUB/netboot/sis900.c
*** GRUB_0.94/netboot/sis900.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/sis900.c	2003-11-08 22:47:34.000000000 +0800
***************
*** 1,2 ****
--- 1,5 ----
+ #ifdef ALLMULTI
+ #error multicast support is not yet implemented
+ #endif
  /* -*- Mode:C; c-basic-offset:4; -*- */
  
***************
*** 28,31 ****
--- 31,37 ----
  
  /*
+   04 Jan 2002  Chien-Yu Chen, Doug Ambrisko, Marty Connor  Patch to Etherboot 5.0.5
+      Added support for the SiS 630ET plus various bug fixes from linux kernel
+      source 2.4.17.
    01 March 2001  mdc     1.0
       Initial Release.  Tested with PCI based sis900 card and ThinkNIC
***************
*** 42,46 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  
  #include "sis900.h"
--- 48,51 ----
***************
*** 52,55 ****
--- 57,61 ----
  static unsigned short vendor, dev_id;
  static unsigned long ioaddr;
+ static u8 pci_revision;
  
  static unsigned int cur_phy;
***************
*** 59,70 ****
  static BufferDesc txd;
  static BufferDesc rxd[NUM_RX_DESC];
- 
- #ifdef USE_LOWMEM_BUFFER
- #define txb ((char *)0x10000 - TX_BUF_SIZE)
- #define rxb ((char *)0x10000 - NUM_RX_DESC*RX_BUF_SIZE - TX_BUF_SIZE)
- #else
  static unsigned char txb[TX_BUF_SIZE];
  static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE];
- #endif
  
  static struct mac_chip_info {
--- 65,70 ----
***************
*** 84,87 ****
--- 84,88 ----
  static void ics1893_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
  static void rtl8201_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
+ static void vt6103_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
  
  static struct mii_chip_info {
***************
*** 97,100 ****
--- 98,102 ----
      {"ICS 1893 Integrated PHYceiver"   , 0x0015, 0xf441,ics1893_read_mode},
      {"RTL 8201 10/100Mbps Phyceiver"   , 0x0000, 0x8201,rtl8201_read_mode},
+     {"VIA 6103 10/100Mbps Phyceiver", 0x0101, 0x8f20,vt6103_read_mode},
      {0,0,0,0}
  };
***************
*** 109,121 ****
  
  // PCI to ISA bridge for SIS640E access
! static struct pci_device   pci_isa_bridge_list[] = {
  	{ 0x1039, 0x0008,
! 		"SIS 85C503/5513 PCI to ISA bridge", 0, 0, 0, 0},
! 	{0, 0, NULL, 0, 0, 0, 0}
  };
  
  /* Function Prototypes */
  
! struct nic *sis900_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci);
  
  static u16  sis900_read_eeprom(int location);
--- 111,131 ----
  
  // PCI to ISA bridge for SIS640E access
! static struct pci_id   pci_isa_bridge_list[] = {
  	{ 0x1039, 0x0008,
! 		"SIS 85C503/5513 PCI to ISA bridge"},
! };
! 
! static struct pci_driver sis_bridge_driver __pci_driver = {
! 	.type     = BRIDGE_DRIVER,
! 	.name     = "",
! 	.probe    = 0,
! 	.ids      = pci_isa_bridge_list,
! 	.id_count = sizeof(pci_isa_bridge_list)/sizeof(pci_isa_bridge_list[0]),
! 	.class    = 0,
  };
  
  /* Function Prototypes */
  
! static int sis900_probe(struct dev *dev, struct pci_device *pci);
  
  static u16  sis900_read_eeprom(int location);
***************
*** 139,143 ****
  static int  sis900_poll(struct nic *nic);
  
! static void sis900_disable(struct nic *nic);
  
  /**
--- 149,153 ----
  static int  sis900_poll(struct nic *nic);
  
! static void sis900_disable(struct dev *dev);
  
  /**
***************
*** 150,154 ****
   */
  
! static int sis900_get_mac_addr(struct pci_device * pci_dev , struct nic *nic)
  {
  	u16 signature;
--- 160,164 ----
   */
  
! static int sis900_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
  {
  	u16 signature;
***************
*** 169,172 ****
--- 179,226 ----
  
  /**
+  *	sis96x_get_mac_addr: - Get MAC address for SiS962 or SiS963 model
+  *	@pci_dev: the sis900 pci device
+  *	@net_dev: the net device to get address for 
+  *
+  *	SiS962 or SiS963 model, use EEPROM to store MAC address. And EEPROM 
+  *	is shared by
+  *	LAN and 1394. When access EEPROM, send EEREQ signal to hardware first 
+  *	and wait for EEGNT. If EEGNT is ON, EEPROM is permitted to be access 
+  *	by LAN, otherwise is not. After MAC address is read from EEPROM, send
+  *	EEDONE signal to refuse EEPROM access by LAN. 
+  *	The EEPROM map of SiS962 or SiS963 is different to SiS900. 
+  *	The signature field in SiS962 or SiS963 spec is meaningless. 
+  *	MAC address is read into @net_dev->dev_addr.
+  */
+ 
+ static int sis96x_get_mac_addr(struct pci_device * pci_dev, struct nic *nic)
+ {
+ /* 	long ioaddr = net_dev->base_addr; */
+ 	long ee_addr = ioaddr + mear;
+ 	u32 waittime = 0;
+ 	int i;
+ 	
+ 	printf("Alternate function\n");
+ 
+ 	outl(EEREQ, ee_addr);
+ 	while(waittime < 2000) {
+ 		if(inl(ee_addr) & EEGNT) {
+ 
+ 			/* get MAC address from EEPROM */
+ 			for (i = 0; i < 3; i++)
+ 			        ((u16 *)(nic->node_addr))[i] = sis900_read_eeprom(i+EEPROMMACAddr);
+ 
+ 			outl(EEDONE, ee_addr);
+ 			return 1;
+ 		} else {
+ 			udelay(1);	
+ 			waittime ++;
+ 		}
+ 	}
+ 	outl(EEDONE, ee_addr);
+ 	return 0;
+ }
+ 
+ /**
   *	sis630e_get_mac_addr: - Get MAC address for SiS630E model
   *	@pci_dev: the sis900 pci device
***************
*** 178,192 ****
   */
  
! static int sis630e_get_mac_addr(struct pci_device * pci_dev, struct nic *nic)
  {
  	u8 reg;
  	int i;
! 	struct pci_device	*p;
! 
! 	// find PCI to ISA bridge
! 	eth_pci_init(pci_isa_bridge_list);
  
!     /* the firts entry in this list should contain bus/devfn */
!     p = pci_isa_bridge_list;
  
  	pcibios_read_config_byte(p->bus,p->devfn, 0x48, &reg);
--- 232,250 ----
   */
  
! static int sis630e_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
  {
  	u8 reg;
  	int i;
! 	struct pci_device	p[1];
  
! 	/* find PCI to ISA bridge */
! 	memset(p, 0, sizeof(p));
! 	do {
! 		find_pci(BRIDGE_DRIVER, p);
! 	} while(p->driver && p->driver != &sis_bridge_driver);
! 
! 	/* error on failure */
! 	if (!p->driver)
! 	    return 0;
  
  	pcibios_read_config_byte(p->bus,p->devfn, 0x48, &reg);
***************
*** 202,205 ****
--- 260,298 ----
  	return 1;
  }
+ 
+ /**
+  *      sis630e_get_mac_addr: - Get MAC address for SiS630E model
+  *      @pci_dev: the sis900 pci device
+  *      @net_dev: the net device to get address for
+  *
+  *      SiS630E model, use APC CMOS RAM to store MAC address.
+  *      APC CMOS RAM is accessed through ISA bridge.
+  *      MAC address is read into @net_dev->dev_addr.
+  */
+ 
+ static int sis635_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
+ {
+         u32 rfcrSave;
+         u32 i;
+ 
+         rfcrSave = inl(rfcr + ioaddr);
+ 
+         outl(rfcrSave | RELOAD, ioaddr + cr);
+         outl(0, ioaddr + cr);
+ 
+         /* disable packet filtering before setting filter */
+         outl(rfcrSave & ~RFEN, rfcr + ioaddr);
+ 
+         /* load MAC addr to filter data register */
+         for (i = 0 ; i < 3 ; i++) {
+                 outl((i << RFADDR_shift), ioaddr + rfcr);
+                 *( ((u16 *)nic->node_addr) + i) = inw(ioaddr + rfdr);
+         }
+ 
+         /* enable packet filitering */
+         outl(rfcrSave | RFEN, rfcr + ioaddr);
+ 
+         return 1;
+ }
  
  /* 
***************
*** 217,233 ****
   */
  
! struct nic *sis900_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
  {
      int i;
      int found=0;
      int phy_addr;
-     u16 signature;
      u8 revision;
      int ret;
  
!     if (io_addrs == 0 || *io_addrs == 0)
!         return NULL;
  
!     ioaddr  = *io_addrs & ~3;
      vendor  = pci->vendor;
      dev_id  = pci->dev_id;
--- 310,326 ----
   */
  
! static int sis900_probe(struct dev *dev, struct pci_device *pci)
  {
+     struct nic *nic = (struct nic *)dev;
      int i;
      int found=0;
      int phy_addr;
      u8 revision;
      int ret;
  
!     if (pci->ioaddr == 0)
!         return 0;
  
!     ioaddr  = pci->ioaddr & ~3;
      vendor  = pci->vendor;
      dev_id  = pci->dev_id;
***************
*** 241,248 ****
      ret = 0;
      pcibios_read_config_byte(pci->bus,pci->devfn, PCI_REVISION, &revision);
!     if (revision == SIS630E_900_REV || revision == SIS630EA1_900_REV)
!        ret = sis630e_get_mac_addr(pci, nic);
!     else if (revision == SIS630S_900_REV)
          ret = sis630e_get_mac_addr(pci, nic);
      else
          ret = sis900_get_mac_addr(pci, nic);
--- 334,347 ----
      ret = 0;
      pcibios_read_config_byte(pci->bus,pci->devfn, PCI_REVISION, &revision);
!     
!     /* save for use later in sis900_reset() */
!     pci_revision = revision; 
! 
!     if (revision == SIS630E_900_REV)
          ret = sis630e_get_mac_addr(pci, nic);
+     else if ((revision > 0x81) && (revision <= 0x90))
+         ret = sis635_get_mac_addr(pci, nic);
+     else if (revision == SIS96x_900_REV)
+ 	ret = sis96x_get_mac_addr(pci, nic);
      else
          ret = sis900_get_mac_addr(pci, nic);
***************
*** 251,257 ****
      {
          printf ("sis900_probe: Error MAC address not found\n");
!         return NULL;
      }
  
      printf("\nsis900_probe: MAC addr %! at ioaddr %#hX\n",
             nic->node_addr, ioaddr);
--- 350,360 ----
      {
          printf ("sis900_probe: Error MAC address not found\n");
!         return 0;
      }
  
+     /* 630ET : set the mii access mode as software-mode */
+     if (revision == SIS630ET_900_REV)
+ 	outl(ACCESSMODE | inl(ioaddr + cr), ioaddr + cr);
+ 
      printf("\nsis900_probe: MAC addr %! at ioaddr %#hX\n",
             nic->node_addr, ioaddr);
***************
*** 265,269 ****
          u16 mii_status;
          u16 phy_id0, phy_id1;
!                 
          mii_status = sis900_mdio_read(phy_addr, MII_STATUS);
          if (mii_status == 0xffff || mii_status == 0x0000)
--- 368,372 ----
          u16 mii_status;
          u16 phy_id0, phy_id1;
! 
          mii_status = sis900_mdio_read(phy_addr, MII_STATUS);
          if (mii_status == 0xffff || mii_status == 0x0000)
***************
*** 273,277 ****
          phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
          phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
!                 
          /* search our mii table for the current mii */ 
          for (i = 0; mii_chip_table[i].phy_id1; i++) {
--- 376,380 ----
          phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
          phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
! 
          /* search our mii table for the current mii */ 
          for (i = 0; mii_chip_table[i].phy_id1; i++) {
***************
*** 295,299 ****
      if (found == 0) {
          printf("sis900_probe: No MII transceivers found!\n");
!         return NULL;
      }
  
--- 398,402 ----
      if (found == 0) {
          printf("sis900_probe: No MII transceivers found!\n");
!         return 0;
      }
  
***************
*** 305,314 ****
      sis900_init(nic);
  
!     nic->reset    = sis900_init;
      nic->poll     = sis900_poll;
      nic->transmit = sis900_transmit;
-     nic->disable  = sis900_disable;
  
!     return nic;
  }
  
--- 408,416 ----
      sis900_init(nic);
  
!     dev->disable  = sis900_disable;
      nic->poll     = sis900_poll;
      nic->transmit = sis900_transmit;
  
!     return 1;
  }
  
***************
*** 433,436 ****
--- 535,539 ----
          sis900_mdio_delay();
      }
+     outl(0x00, mdio_addr);
      return retval;
  }
***************
*** 472,475 ****
--- 575,579 ----
          sis900_mdio_delay();
      }
+     outl(0x00, mdio_addr);
      return;
  }
***************
*** 501,505 ****
      sis900_check_mode(nic);
  
!     outl(RxENA, ioaddr + cr);
  }
  
--- 605,609 ----
      sis900_check_mode(nic);
  
!     outl(RxENA| inl(ioaddr + cr), ioaddr + cr);
  }
  
***************
*** 516,520 ****
  
  static void 
! sis900_reset(struct nic *nic)
  {
      int i = 0;
--- 620,624 ----
  
  static void 
! sis900_reset(struct nic *nic __unused)
  {
      int i = 0;
***************
*** 525,535 ****
      outl(0, ioaddr + rfcr);
  
!     outl(RxRESET | TxRESET | RESET, ioaddr + cr);
!         
      /* Check that the chip has finished the reset. */
      while (status && (i++ < 1000)) {
          status ^= (inl(isr + ioaddr) & status);
      }
!     outl(PESEL, ioaddr + cfg);
  }
  
--- 629,643 ----
      outl(0, ioaddr + rfcr);
  
!     outl(RxRESET | TxRESET | RESET | inl(ioaddr + cr), ioaddr + cr);
! 
      /* Check that the chip has finished the reset. */
      while (status && (i++ < 1000)) {
          status ^= (inl(isr + ioaddr) & status);
      }
! 
!     if( (pci_revision == SIS635A_900_REV) || (pci_revision == SIS900B_900_REV) )
!             outl(PESEL | RND_CNT, ioaddr + cfg);
!     else
!             outl(PESEL, ioaddr + cfg);
  }
  
***************
*** 553,557 ****
  
      /* disable packet filtering before setting filter */
!     outl(rfcrSave & ~RFEN, rfcr);
  
      /* load MAC addr to filter data register */
--- 661,665 ----
  
      /* disable packet filtering before setting filter */
!     outl(rfcrSave & ~RFEN, rfcr + ioaddr);
  
      /* load MAC addr to filter data register */
***************
*** 584,595 ****
  
  static void
! sis900_init_txd(struct nic *nic)
  {
      txd.link   = (u32) 0;
      txd.cmdsts = (u32) 0;
!     txd.bufptr = (u32) &txb[0];
  
      /* load Transmit Descriptor Register */
!     outl((u32) &txd, ioaddr + txdp); 
      if (sis900_debug > 0)
          printf("sis900_init_txd: TX descriptor register loaded with: %X\n", 
--- 692,703 ----
  
  static void
! sis900_init_txd(struct nic *nic __unused)
  {
      txd.link   = (u32) 0;
      txd.cmdsts = (u32) 0;
!     txd.bufptr = virt_to_bus(&txb[0]);
  
      /* load Transmit Descriptor Register */
!     outl(virt_to_bus(&txd), ioaddr + txdp); 
      if (sis900_debug > 0)
          printf("sis900_init_txd: TX descriptor register loaded with: %X\n", 
***************
*** 608,612 ****
  
  static void 
! sis900_init_rxd(struct nic *nic) 
  { 
      int i;
--- 716,720 ----
  
  static void 
! sis900_init_rxd(struct nic *nic __unused) 
  { 
      int i;
***************
*** 616,622 ****
      /* init RX descriptor */
      for (i = 0; i < NUM_RX_DESC; i++) {
!         rxd[i].link   = (i+1 < NUM_RX_DESC) ? (u32) &rxd[i+1] : (u32) &rxd[0];
          rxd[i].cmdsts = (u32) RX_BUF_SIZE;
!         rxd[i].bufptr = (u32) &rxb[i*RX_BUF_SIZE];
          if (sis900_debug > 0)
              printf("sis900_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
--- 724,730 ----
      /* init RX descriptor */
      for (i = 0; i < NUM_RX_DESC; i++) {
!         rxd[i].link   = virt_to_bus((i+1 < NUM_RX_DESC) ? &rxd[i+1] : &rxd[0]);
          rxd[i].cmdsts = (u32) RX_BUF_SIZE;
!         rxd[i].bufptr = virt_to_bus(&rxb[i*RX_BUF_SIZE]);
          if (sis900_debug > 0)
              printf("sis900_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
***************
*** 625,629 ****
  
      /* load Receive Descriptor Register */
!     outl((u32) &rxd[0], ioaddr + rxdp);
  
      if (sis900_debug > 0)
--- 733,737 ----
  
      /* load Receive Descriptor Register */
!     outl(virt_to_bus(&rxd[0]), ioaddr + rxdp);
  
      if (sis900_debug > 0)
***************
*** 645,649 ****
   */
  
! static void sis900_set_rx_mode(struct nic *nic)
  {
      int i;
--- 753,757 ----
   */
  
! static void sis900_set_rx_mode(struct nic *nic __unused)
  {
      int i;
***************
*** 675,679 ****
  
  static void
! sis900_check_mode (struct nic *nic)
  {
      int speed, duplex;
--- 783,787 ----
  
  static void
! sis900_check_mode(struct nic *nic)
  {
      int speed, duplex;
***************
*** 682,687 ****
      mii.chip_info->read_mode(nic, cur_phy, &speed, &duplex);
  
!     tx_flags = TxATP | (TX_DMA_BURST << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
!     rx_flags = RX_DMA_BURST << RxMXDMA_shift;
  
      if (speed == HW_SPEED_HOME || speed == HW_SPEED_10_MBPS) {
--- 790,801 ----
      mii.chip_info->read_mode(nic, cur_phy, &speed, &duplex);
  
!     if( inl(ioaddr + cfg) & EDB_MASTER_EN ) {
!         tx_flags = TxATP | (DMA_BURST_64 << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
! 	rx_flags = DMA_BURST_64 << RxMXDMA_shift;
!     }
!     else {
!             tx_flags = TxATP | (DMA_BURST_512 << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
!             rx_flags = DMA_BURST_512 << RxMXDMA_shift;
!     }
  
      if (speed == HW_SPEED_HOME || speed == HW_SPEED_10_MBPS) {
***************
*** 715,722 ****
  
  static void
! sis900_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
  {
      int i = 0;
      u32 status;
          
      /* STSOUT register is Latched on Transition, read operation updates it */
--- 829,837 ----
  
  static void
! sis900_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
  {
      int i = 0;
      u32 status;
+     u16 phy_id0, phy_id1;
          
      /* STSOUT register is Latched on Transition, read operation updates it */
***************
*** 724,736 ****
          status = sis900_mdio_read(phy_addr, MII_STSOUT);
  
!     if (status & MII_STSOUT_SPD)
!         *speed = HW_SPEED_100_MBPS;
!     else
!         *speed = HW_SPEED_10_MBPS;
! 
!     if (status & MII_STSOUT_DPLX)
!         *duplex = FDX_CAPABLE_FULL_SELECTED;
!     else
!         *duplex = FDX_CAPABLE_HALF_SELECTED;
  
      if (status & MII_STSOUT_LINK_FAIL)
--- 839,859 ----
          status = sis900_mdio_read(phy_addr, MII_STSOUT);
  
!     *speed = HW_SPEED_10_MBPS;
!     *duplex = FDX_CAPABLE_HALF_SELECTED;
!     
!     if (status & (MII_NWAY_TX | MII_NWAY_TX_FDX))
! 	*speed = HW_SPEED_100_MBPS;
!     if (status & ( MII_NWAY_TX_FDX | MII_NWAY_T_FDX))
! 	*duplex = FDX_CAPABLE_FULL_SELECTED;
! 	
!     /* Workaround for Realtek RTL8201 PHY issue */
!     phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
!     phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
!     if((phy_id0 == 0x0000) && ((phy_id1 & 0xFFF0) == 0x8200)){
! 	if(sis900_mdio_read(phy_addr, MII_CONTROL) & MII_CNTL_FDX)
! 	    *duplex = FDX_CAPABLE_FULL_SELECTED;
! 	if(sis900_mdio_read(phy_addr, 0x0019) & 0x01)
! 	    *speed = HW_SPEED_100_MBPS;
!     }
  
      if (status & MII_STSOUT_LINK_FAIL)
***************
*** 756,760 ****
  
  static void
! amd79c901_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
  {
      int i;
--- 879,883 ----
  
  static void
! amd79c901_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
  {
      int i;
***************
*** 809,813 ****
   */
  
! static void ics1893_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
  {
  	int i = 0;
--- 932,936 ----
   */
  
! static void ics1893_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
  {
  	int i = 0;
***************
*** 849,853 ****
   */
  
! static void rtl8201_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
  {
  	u32 status;
--- 972,976 ----
   */
  
! static void rtl8201_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
  {
  	u32 status;
***************
*** 879,883 ****
  		       "full" : "half");
  	else
! 		printf("rtl9201_read_config_mode: Media Link Off\n");
  }
  
--- 1002,1050 ----
  		       "full" : "half");
  	else
! 		printf("rtl8201_read_config_mode: Media Link Off\n");
! }
! 
! /**
!  *	vt6103_read_mode: - read media mode for vt6103 phy
!  *	@nic: the net device to read mode for
!  *	@phy_addr: mii phy address
!  *	@speed: the transmit speed to be determined
!  *	@duplex: the duplex mode to be determined
!  *
!  *	read MII_STATUS register from rtl8201 phy
!  *	to determine the speed and duplex mode for sis900
!  */
! 
! static void vt6103_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
! {
! 	u32 status;
! 
! 	status = sis900_mdio_read(phy_addr, MII_STATUS);
! 
! 	if (status & MII_STAT_CAN_TX_FDX) {
! 		*speed = HW_SPEED_100_MBPS;
! 		*duplex = FDX_CAPABLE_FULL_SELECTED;
! 	}
! 	else if (status & MII_STAT_CAN_TX) {
! 		*speed = HW_SPEED_100_MBPS;
! 		*duplex = FDX_CAPABLE_HALF_SELECTED;
! 	}
! 	else if (status & MII_STAT_CAN_T_FDX) {
! 		*speed = HW_SPEED_10_MBPS;
! 		*duplex = FDX_CAPABLE_FULL_SELECTED;
! 	}
! 	else if (status & MII_STAT_CAN_T) {
! 		*speed = HW_SPEED_10_MBPS;
! 		*duplex = FDX_CAPABLE_HALF_SELECTED;
! 	}
! 
! 	if (status & MII_STAT_LINK)
! 		printf("vt6103_read_mode: Media Link On %s %s-duplex \n",
! 		       *speed == HW_SPEED_100_MBPS ?
! 		       "100mbps" : "10mbps",
! 		       *duplex == FDX_CAPABLE_FULL_SELECTED ?
! 		       "full" : "half");
! 	else
! 		printf("vt6103_read_config_mode: Media Link Off\n");
  }
  
***************
*** 901,912 ****
                  const char  *p)     /* Packet */
  {
!     u32 status, to, nstype;
      u32 tx_status;
      
      /* Stop the transmitter */
!     outl(TxDIS, ioaddr + cr);
  
      /* load Transmit Descriptor Register */
!     outl((u32) &txd, ioaddr + txdp); 
      if (sis900_debug > 1)
          printf("sis900_transmit: TX descriptor register loaded with: %X\n", 
--- 1068,1079 ----
                  const char  *p)     /* Packet */
  {
!     u32 to, nstype;
      u32 tx_status;
      
      /* Stop the transmitter */
!     outl(TxDIS | inl(ioaddr + cr), ioaddr + cr);
  
      /* load Transmit Descriptor Register */
!     outl(virt_to_bus(&txd), ioaddr + txdp); 
      if (sis900_debug > 1)
          printf("sis900_transmit: TX descriptor register loaded with: %X\n", 
***************
*** 934,938 ****
  
      /* restart the transmitter */
!     outl(TxENA, ioaddr + cr);
  
      if (sis900_debug > 1)
--- 1101,1105 ----
  
      /* restart the transmitter */
!     outl(TxENA | inl(ioaddr + cr), ioaddr + cr);
  
      if (sis900_debug > 1)
***************
*** 1008,1012 ****
  
      /* re-enable the potentially idle receive state machine */
!     outl(RxENA , ioaddr + cr);
  
      return retstat;
--- 1175,1179 ----
  
      /* re-enable the potentially idle receive state machine */
!     outl(RxENA | inl(ioaddr + cr), ioaddr + cr);
  
      return retstat;
***************
*** 1024,1029 ****
  
  static void
! sis900_disable(struct nic *nic)
  {
      /* Disable interrupts by clearing the interrupt mask. */
      outl(0, ioaddr + imr);
--- 1191,1200 ----
  
  static void
! sis900_disable(struct dev *dev)
  {
+     struct nic *nic = (struct nic *)dev;
+     /* merge reset and disable */
+     sis900_init(nic);
+ 
      /* Disable interrupts by clearing the interrupt mask. */
      outl(0, ioaddr + imr);
***************
*** 1031,1034 ****
      
      /* Stop the chip's Tx and Rx Status Machine */
!     outl(RxDIS | TxDIS, ioaddr + cr);
  }
--- 1202,1219 ----
      
      /* Stop the chip's Tx and Rx Status Machine */
!     outl(RxDIS | TxDIS | inl(ioaddr + cr), ioaddr + cr);
  }
+ 
+ static struct pci_id sis900_nics[] = {
+ PCI_ROM(0x1039, 0x0900, "sis900",  "SIS900"),
+ PCI_ROM(0x1039, 0x7016, "sis7016", "SIS7016"),
+ };
+ 
+ struct pci_driver sis900_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "SIS900",
+ 	.probe    = sis900_probe,
+ 	.ids      = sis900_nics,
+ 	.id_count = sizeof(sis900_nics)/sizeof(sis900_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/sis900.h GRUB/netboot/sis900.h
*** GRUB_0.94/netboot/sis900.h	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/sis900.h	2003-11-04 05:17:41.000000000 +0800
***************
*** 40,51 ****
  /* Symbolic names for bits in various registers */
  enum sis900_command_register_bits {
!     RESET   = 0x00000100, 
!     SWI     = 0x00000080, 
!     RxRESET = 0x00000020,
!     TxRESET = 0x00000010, 
!     RxDIS   = 0x00000008, 
!     RxENA   = 0x00000004,
!     TxDIS   = 0x00000002, 
!     TxENA   = 0x00000001
  };
  
--- 40,53 ----
  /* Symbolic names for bits in various registers */
  enum sis900_command_register_bits {
!     RELOAD     = 0x00000400,
!     ACCESSMODE = 0x00000200,
!     RESET      = 0x00000100, 
!     SWI        = 0x00000080, 
!     RxRESET    = 0x00000020,
!     TxRESET    = 0x00000010, 
!     RxDIS      = 0x00000008, 
!     RxENA      = 0x00000004,
!     TxDIS      = 0x00000002, 
!     TxENA      = 0x00000001
  };
  
***************
*** 58,62 ****
      PESEL    = 0x00000008, 
      LPM      = 0x00000004, 
!     BEM      = 0x00000001
  };
  
--- 60,67 ----
      PESEL    = 0x00000008, 
      LPM      = 0x00000004, 
!     BEM      = 0x00000001,
!     RND_CNT  = 0x00000400,
!     FAIR_BACKOFF = 0x00000200,
!     EDB_MASTER_EN = 0x00002000
  };
  
***************
*** 109,112 ****
--- 114,121 ----
  #define RX_DMA_BURST    0
  
+ enum sis900_tx_rx_dma{
+ 	        DMA_BURST_512 = 0,      DMA_BURST_64 = 5
+ };
+ 
  /* transmit FIFO threshholds */
  #define TX_FILL_THRESH  16      /* 1/4 FIFO size */
***************
*** 173,176 ****
--- 182,190 ----
      EEwriteAll      = 0x0110, 
      EEaddrMask      = 0x013F, 
+     EEcmdShift 	    = 16
+ };
+ /* For SiS962 or SiS963, request the eeprom software access */
+ enum sis96x_eeprom_command {
+ 	EEREQ = 0x00000400, EEDONE = 0x00000200, EEGNT = 0x00000100
  };
  
***************
*** 237,241 ****
      MII_CONFIG2 = 0x0011,
      MII_STSOUT  = 0x0012,
!     MII_MASK    = 0x0013
  };
  
--- 251,256 ----
      MII_CONFIG2 = 0x0011,
      MII_STSOUT  = 0x0012,
!     MII_MASK    = 0x0013,
!     MII_RESV    = 0x0014
  };
  
***************
*** 321,325 ****
  enum sis900_revision_id {
  	SIS630A_900_REV = 0x80,		SIS630E_900_REV = 0x81,
! 	SIS630S_900_REV = 0x82,		SIS630EA1_900_REV = 0x83
  };
  
--- 336,342 ----
  enum sis900_revision_id {
  	SIS630A_900_REV = 0x80,		SIS630E_900_REV = 0x81,
! 	SIS630S_900_REV = 0x82,		SIS630EA1_900_REV = 0x83,
! 	SIS630ET_900_REV = 0x84,        SIS635A_900_REV = 0x90,
! 	SIS96x_900_REV = 0X91,		SIS900B_900_REV = 0x03
  };
  
diff -rc2P -x CVS GRUB_0.94/netboot/sis900.txt GRUB/netboot/sis900.txt
*** GRUB_0.94/netboot/sis900.txt	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/sis900.txt	2003-11-04 05:17:41.000000000 +0800
***************
*** 75,79 ****
  
  At this point, you can begin creating your driver source file.  See
! the "Writing and Etherboot Driver" section of the Etherboot
  documentation for some hints.  See the skel.c file for a starting
  point.  If there is a Linux driver for the card, you may be able to
--- 75,79 ----
  
  At this point, you can begin creating your driver source file.  See
! the "Writing an Etherboot Driver" section of the Etherboot
  documentation for some hints.  See the skel.c file for a starting
  point.  If there is a Linux driver for the card, you may be able to
***************
*** 82,86 ****
  
  Join the etherboot-developers and etherboot-users mailing lists
! (information is on etherboot.sourceforge.net) for information and
  assistance. We invite more developers to help improve Etherboot.
  
--- 82,86 ----
  
  Join the etherboot-developers and etherboot-users mailing lists
! (information is on http://etherboot.sourceforge.net) for information and
  assistance. We invite more developers to help improve Etherboot.
  
diff -rc2P -x CVS GRUB_0.94/netboot/skel.c GRUB/netboot/skel.c
*** GRUB_0.94/netboot/skel.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/skel.c	2003-11-04 05:24:09.000000000 +0800
***************
*** 0 ****
--- 1,129 ----
+ /**************************************************************************
+ Etherboot -  BOOTP/TFTP Bootstrap Program
+ Skeleton NIC driver for Etherboot
+ ***************************************************************************/
+ 
+ /*
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2, or (at
+  * your option) any later version.
+  */
+ 
+ /* to get some global routines like printf */
+ #include "etherboot.h"
+ /* to get the interface to the body of the program */
+ #include "nic.h"
+ /* to get the PCI support functions, if this is a PCI NIC */
+ #include "pci.h"
+ /* to get the ISA support functions, if this is an ISA NIC */
+ #include "isa.h"
+ 
+ /* NIC specific static variables go here */
+ 
+ /**************************************************************************
+ POLL - Wait for a frame
+ ***************************************************************************/
+ static int skel_poll(struct nic *nic)
+ {
+ 	/* return true if there's an ethernet packet ready to read */
+ 	/* nic->packet should contain data on return */
+ 	/* nic->packetlen should contain length of data */
+ 	return (0);	/* initially as this is called to flush the input */
+ }
+ 
+ /**************************************************************************
+ TRANSMIT - Transmit a frame
+ ***************************************************************************/
+ static void skel_transmit(
+ 	struct nic *nic,
+ 	const char *d,			/* Destination */
+ 	unsigned int t,			/* Type */
+ 	unsigned int s,			/* size */
+ 	const char *p)			/* Packet */
+ {
+ 	/* send the packet to destination */
+ }
+ 
+ /**************************************************************************
+ DISABLE - Turn off ethernet interface
+ ***************************************************************************/
+ static void skel_disable(struct dev *dev)
+ {
+ 	/* put the card in its initial state */
+ 	/* This function serves 3 purposes.
+ 	 * This disables DMA and interrupts so we don't receive
+ 	 *  unexpected packets or interrupts from the card after
+ 	 *  etherboot has finished. 
+ 	 * This frees resources so etherboot may use
+ 	 *  this driver on another interface
+ 	 * This allows etherboot to reinitialize the interface
+ 	 *  if something is something goes wrong.
+ 	 */
+ }
+ 
+ /**************************************************************************
+ PROBE - Look for an adapter, this routine's visible to the outside
+ ***************************************************************************/
+ 
+ #define board_found 1
+ #define valid_link 0
+ static int skel_probe(struct dev *dev, struct pci_device *pci)
+ {
+ 	struct nic *nic = (struct nic *)dev;
+ 	if (board_found && valid_link)
+ 	{
+ 		/* point to NIC specific routines */
+ 		dev->disable  = skel_disable;
+ 		nic->poll     = skel_poll;
+ 		nic->transmit = skel_transmit;
+ 		return 1;
+ 	}
+ 	/* else */
+ 	return 0;
+ }
+ 
+ static struct pci_id skel_nics[] = {
+ PCI_ROM(0x0000, 0x0000, "skel-pci", "Skeleton PCI Adaptor"),
+ };
+ 
+ static struct pci_driver skel_driver __pci_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "SKELETON/PCI",
+ 	.probe    = skel_probe,
+ 	.ids      = skel_nics,
+ 	.id_count = sizeof(skel_nics)/sizeof(skel_nics[0]),
+ 	.class    = 0,
+ };
+ 
+ /**************************************************************************
+ PROBE - Look for an adapter, this routine's visible to the outside
+ ***************************************************************************/
+ static int skel_isa_probe(struct dev *dev, unsigned short *probe_addrs)
+ {
+ 	struct nic *nic = (struct nic *)dev;
+ 	/* if probe_addrs is 0, then routine can use a hardwired default */
+ 	if (board_found && valid_link)
+ 	{
+ 		/* point to NIC specific routines */
+ 		dev->disable  = skel_disable;
+ 		nic->poll     = skel_poll;
+ 		nic->transmit = skel_transmit;
+ 
+ 		/* Report the ISA pnp id of the board */
+ 		dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+ 		dev->devid.vendor_id = htons(0x1234);
+ 		return 1;
+ 	}
+ 	/* else */
+ 	return 0;
+ }
+ 
+ ISA_ROM("skel-isa", "Skeleton ISA driver")
+ static struct isa_driver skel_isa_driver __isa_driver = {
+ 	.type    = NIC_DRIVER,
+ 	.name    = "SKELETON/ISA",
+ 	.probe   = skel_isa_probe,
+ 	.ioaddrs = 0,
+ };
+ 
Only in GRUB_0.94/netboot: sk_g16.c
Only in GRUB_0.94/netboot: sk_g16.h
Only in GRUB_0.94/netboot: smc9000.c
Only in GRUB_0.94/netboot: smc9000.h
diff -rc2P -x CVS GRUB_0.94/netboot/stdint.h GRUB/netboot/stdint.h
*** GRUB_0.94/netboot/stdint.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/stdint.h	2003-11-12 21:03:29.000000000 +0800
***************
*** 0 ****
--- 1,18 ----
+ #ifndef STDINT_H
+ #define STDINT_H
+ /* 
+  * I'm architecture depended. Check me before port GRUB
+  */
+ typedef unsigned           size_t;
+ 
+ typedef unsigned char      uint8_t;
+ typedef unsigned short     uint16_t;
+ typedef unsigned long      uint32_t;
+ typedef unsigned long long uint64_t;
+ 
+ typedef signed char        int8_t;
+ typedef signed short       int16_t;
+ typedef signed long        int32_t;
+ typedef signed long long   int64_t;
+ 
+ #endif /* STDINT_H */
diff -rc2P -x CVS GRUB_0.94/netboot/sundance.c GRUB/netboot/sundance.c
*** GRUB_0.94/netboot/sundance.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/sundance.c	2003-11-20 11:46:08.000000000 +0800
***************
*** 0 ****
--- 1,882 ----
+ /**************************************************************************
+ *
+ *    sundance.c -- Etherboot device driver for the Sundance ST201 "Alta".
+ *    Written 2002-2002 by Timothy Legge <tlegge@rogers.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Portions of this code based on:
+ *               sundance.c: A Linux device driver for the Sundance ST201 "Alta"
+ *               Written 1999-2002 by Donald Becker
+ *
+ *               tulip.c: Tulip and Clone Etherboot Driver
+ *               By Marty Conner
+ *               Copyright (C) 2001 Entity Cyber, Inc.
+ *
+ *    $Revision$
+ *    $Author$
+ *    $Date 2003/04/13 $
+ *
+ *    REVISION HISTORY:
+ *    ================
+ *    v1.1	01-01-2003	timlegge	Initial implementation
+ *    v1.7	04-10-2003	timlegge	Transfers Linux Kernel (30 sec)
+ *    v1.8	04-13-2003	timlegge	Fix multiple transmission bug
+ *    v1.9	08-19-2003	timlegge	Support Multicast
+ *    
+ ***************************************************************************/
+ 
+ /* to get some global routines like printf */
+ #include "etherboot.h"
+ /* to get the interface to the body of the program */
+ #include "nic.h"
+ /* to get the PCI support functions, if this is a PCI NIC */
+ #include "pci.h"
+ #include "timer.h"
+ 
+ #define drv_version "v1.9"
+ #define drv_date "08-19-2003"
+ 
+ /* #define EDEBUG */
+ /* Set the mtu */
+ static int mtu = 1514;
+ 
+ /* Maximum events (Rx packets, etc.) to handle at each interrupt. */
+ static int max_interrupt_work = 20;
+ 
+ /* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
+    The sundance uses a 64 element hash table based on the Ethernet CRC.  */
+ static int multicast_filter_limit = 32;
+ 
+ /* Set the copy breakpoint for the copy-only-tiny-frames scheme.
+    Setting to > 1518 effectively disables this feature.
+    This chip can receive into any byte alignment buffers, so word-oriented
+    archs do not need a copy-align of the IP header. */
+ static int rx_copybreak = 0;
+ 
+ /* Used to pass the media type, etc.
+    Both 'options[]' and 'full_duplex[]' should exist for driver
+    interoperability.
+    The media type is usually passed in 'options[]'.
+     The default is autonegotation for speed and duplex.
+ 	This should rarely be overridden.
+     Use option values 0x10/0x20 for 10Mbps, 0x100,0x200 for 100Mbps.
+     Use option values 0x10 and 0x100 for forcing half duplex fixed speed.
+     Use option values 0x20 and 0x200 for forcing full duplex operation.
+ */
+ #define MAX_UNITS 8
+ static int options[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+ static int full_duplex[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+ 
+ typedef unsigned char u8;
+ typedef signed char s8;
+ typedef unsigned short u16;
+ typedef signed short s16;
+ typedef unsigned int u32;
+ typedef signed int s32;
+ 
+ /* Condensed operations for readability. */
+ #define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+ #define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+ 
+ /* Operational parameters that are set at compile time. */
+ 
+ /* Ring sizes are a power of two only for compile efficiency.
+    The compiler will convert <unsigned>'%'<2^N> into a bit mask.
+    There must be at least five Tx entries for the tx_full hysteresis, and
+    more than 31 requires modifying the Tx status handling error recovery.
+    Leave a inactive gap in the Tx ring for better cache behavior.
+    Making the Tx ring too large decreases the effectiveness of channel
+    bonding and packet priority.
+    Large receive rings waste memory and impact buffer accounting.
+    The driver need to protect against interrupt latency and the kernel
+    not reserving enough available memory.
+ */
+ #define TX_RING_SIZE	2
+ #define TX_QUEUE_LEN	10	/* Limit ring entries actually used.  */
+ #define RX_RING_SIZE	4
+ 
+ 
+ /* Operational parameters that usually are not changed. */
+ /* Time in jiffies before concluding the transmitter is hung. */
+ #define HZ 100
+ #define TX_TIME_OUT	  (6*HZ)
+ 
+ /* Allocation size of Rx buffers with normal sized Ethernet frames.
+    Do not change this value without good reason.  This is not a limit,
+    but a way to keep a consistent allocation size among drivers.
+  */
+ #define PKT_BUF_SZ	1536
+ 
+ /* Set iff a MII transceiver on any interface requires mdio preamble.
+    This only set with older tranceivers, so the extra
+    code size of a per-interface flag is not worthwhile. */
+ static int mii_preamble_required = 0;
+ 
+ /* Offsets to the device registers.
+    Unlike software-only systems, device drivers interact with complex hardware.
+    It's not useful to define symbolic names for every register bit in the
+    device.  The name can only partially document the semantics and make
+    the driver longer and more difficult to read.
+    In general, only the important configuration values or bits changed
+    multiple times should be defined symbolically.
+ */
+ enum alta_offsets {
+ 	DMACtrl = 0x00, TxListPtr = 0x04, TxDMACtrl = 0x08, TxDescPoll =
+ 	    0x0a,
+ 	RxDMAStatus = 0x0c, RxListPtr = 0x10, RxDMACtrl =
+ 	    0x14, RxDescPoll = 0x16,
+ 	LEDCtrl = 0x1a, ASICCtrl = 0x30,
+ 	EEData = 0x34, EECtrl = 0x36, TxThreshold = 0x3c,
+ 	FlashAddr = 0x40, FlashData = 0x44, WakeEvent = 0x45, TxStatus =
+ 	    0x46,
+ 	DownCounter = 0x48, IntrClear = 0x4a, IntrEnable =
+ 	    0x4c, IntrStatus = 0x4e,
+ 	MACCtrl0 = 0x50, MACCtrl1 = 0x52, StationAddr = 0x54,
+ 	MaxFrameSize = 0x5A, RxMode = 0x5c, MIICtrl = 0x5e,
+ 	MulticastFilter0 = 0x60, MulticastFilter1 = 0x64,
+ 	RxOctetsLow = 0x68, RxOctetsHigh = 0x6a, TxOctetsLow =
+ 	    0x6c, TxOctetsHigh = 0x6e,
+ 	TxFramesOK = 0x70, RxFramesOK = 0x72, StatsCarrierError = 0x74,
+ 	StatsLateColl = 0x75, StatsMultiColl = 0x76, StatsOneColl = 0x77,
+ 	StatsTxDefer = 0x78, RxMissed = 0x79, StatsTxXSDefer =
+ 	    0x7a, StatsTxAbort = 0x7b,
+ 	StatsBcastTx = 0x7c, StatsBcastRx = 0x7d, StatsMcastTx =
+ 	    0x7e, StatsMcastRx = 0x7f,
+ 	/* Aliased and bogus values! */
+ 	RxStatus = 0x0c,
+ };
+ 
+ /* Bits in the interrupt status/mask registers. */
+ enum intr_status_bits {
+ 	IntrSummary = 0x0001, IntrPCIErr = 0x0002, IntrMACCtrl = 0x0008,
+ 	IntrTxDone = 0x0004, IntrRxDone = 0x0010, IntrRxStart = 0x0020,
+ 	IntrDrvRqst = 0x0040,
+ 	StatsMax = 0x0080, LinkChange = 0x0100,
+ 	IntrTxDMADone = 0x0200, IntrRxDMADone = 0x0400,
+ };
+ 
+ /* Bits in the RxMode register. */
+ enum rx_mode_bits {
+ 	AcceptAllIPMulti = 0x20, AcceptMultiHash = 0x10, AcceptAll = 0x08,
+ 	AcceptBroadcast = 0x04, AcceptMulticast = 0x02, AcceptMyPhys =
+ 	    0x01,
+ };
+ /* Bits in MACCtrl. */
+ enum mac_ctrl0_bits {
+ 	EnbFullDuplex = 0x20, EnbRcvLargeFrame = 0x40,
+ 	EnbFlowCtrl = 0x100, EnbPassRxCRC = 0x200,
+ };
+ enum mac_ctrl1_bits {
+ 	StatsEnable = 0x0020, StatsDisable = 0x0040, StatsEnabled = 0x0080,
+ 	TxEnable = 0x0100, TxDisable = 0x0200, TxEnabled = 0x0400,
+ 	RxEnable = 0x0800, RxDisable = 0x1000, RxEnabled = 0x2000,
+ };
+ 
+ /* The Rx and Tx buffer descriptors.
+    Using only 32 bit fields simplifies software endian correction.
+    This structure must be aligned, and should avoid spanning cache lines.
+ */
+ struct netdev_desc {
+ 	u32 next_desc;
+ 	u32 status;
+ 	u32 addr;
+ 	u32 length;
+ };
+ 
+ /* Bits in netdev_desc.status */
+ enum desc_status_bits {
+ 	DescOwn = 0x8000, DescEndPacket = 0x4000, DescEndRing = 0x2000,
+ 	DescTxDMADone = 0x10000,
+ 	LastFrag = 0x80000000, DescIntrOnTx = 0x8000, DescIntrOnDMADone =
+ 	    0x80000000,
+ };
+ 
+ 
+ /* Define the TX Descriptor */
+ static struct netdev_desc tx_ring[TX_RING_SIZE]
+     __attribute__ ((aligned(8)));
+ 
+ /* Create a static buffer of size PKT_BUF_SZ for each
+ TX Descriptor.  All descriptors point to a
+ part of this buffer */
+ static unsigned char txb[PKT_BUF_SZ * TX_RING_SIZE]
+     __attribute__ ((aligned(8)));
+ 
+ 
+ /* Define the RX Descriptor */
+ static struct netdev_desc rx_ring[RX_RING_SIZE]
+     __attribute__ ((aligned(8)));
+ 
+ /* Create a static buffer of size PKT_BUF_SZ for each
+ RX Descriptor   All descriptors point to a
+ part of this buffer */
+ static unsigned char rxb[RX_RING_SIZE * PKT_BUF_SZ]
+     __attribute__ ((aligned(8)));
+ 
+ 
+ static u32 BASE;
+ #define EEPROM_SIZE	128
+ 
+ enum pci_id_flags_bits {
+ 	PCI_USES_IO = 1, PCI_USES_MEM = 2, PCI_USES_MASTER = 4,
+ 	PCI_ADDR0 = 0 << 4, PCI_ADDR1 = 1 << 4, PCI_ADDR2 =
+ 	    2 << 4, PCI_ADDR3 = 3 << 4,
+ };
+ 
+ enum chip_capability_flags { CanHaveMII = 1, KendinPktDropBug = 2, };
+ #define PCI_IOTYPE (PCI_USES_MASTER | PCI_USES_IO  | PCI_ADDR0)
+ 
+ struct pci_id_info {
+ 	char *name;
+ 	struct match_info {
+ 		u32 pci, pci_mask, subsystem, subsystem_mask;
+ 		u32 revision, revision_mask;	/* Only 8 bits. */
+ 	} id;
+ 	enum pci_id_flags_bits pci_flags;
+ 	int io_size;		/* Needed for I/O region check or ioremap(). */
+ 	int drv_flags;		/* Driver use, intended as capability flags. */
+ };
+ 
+ struct sundance_private {
+ 	unsigned short vendor_id;	/* PCI Vendor code */
+ 	unsigned short dev_id;	/* PCI Device code */
+ 	unsigned char ethr[ETH_HLEN];	/* Buffer for ethernet header */
+ 	const char *nic_name;
+ 	unsigned int if_port;
+ 	/* Frequently used values */
+ 	int msg_level;
+ 	int chip_id, drv_flags;
+ 
+ 	int max_interrupt_word;
+ 
+ 	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indicies */
+ 	unsigned rx_buf_sz;	/* Based on mtu + Slack */
+ 	int rx_copybreak;
+ 
+ 	struct netdev_desc *rx_head_desc;
+ 	unsigned int cur_tx, dirty_tx;
+ 	unsigned int tx_full:1;
+ 	unsigned int mtu;
+ 
+ 	/* These values keep track of the tranceiver/media in use */
+ 	unsigned int full_duplex:1;	/* Full Duplex Requested */
+ 	unsigned int duplex_lock:1;
+ 	unsigned int medialock:1;	/* Do not sense media */
+ 	unsigned int default_port:4;
+ 
+ 	unsigned int an_enable:1;
+ 	unsigned int speed;
+ 
+ 	/* Multicast and receive mode */
+ 	u16 mcast_filter[4];
+ 	int multicast_filter_limit;
+ 
+ 	/* MII tranceiver section */
+ 	int mii_cnt;		/* MII device addresses */
+ 	int link_status;
+ 	u16 advertizing;	/* NWay media advertizing */
+ 	unsigned char phys[2];
+ 	int budget;
+ 
+ 	int saved_if_port;
+ } sdx;
+ 
+ static struct sundance_private *sdc;
+ 
+ /* Station Address location within the EEPROM */
+ #define EEPROM_SA_OFFSET	0x10
+ 
+ 
+ 
+ static int eeprom_read(long ioaddr, int location);
+ static int mdio_read(struct nic *nic, int phy_id, unsigned int location);
+ static void mdio_write(struct nic *nic, int phy_id, unsigned int location,
+ 		       int value);
+ static void set_rx_mode(struct nic *nic);
+ static void refill_rx(struct nic *nic);
+ 
+ static void check_duplex(struct nic *nic)
+ {
+ 	int mii_reg5 = mdio_read(nic, sdc->phys[0], 5);
+ 	int negotiated = mii_reg5 & sdc->advertizing;
+ 	int duplex;
+ 
+ 	if (sdc->duplex_lock || mii_reg5 == 0xffff)
+ 		return;
+ 	duplex = (negotiated & 0x0100) || (negotiated & 0x01C0) == 0x0040;
+ 	if (sdc->full_duplex != duplex) {
+ 		sdc->full_duplex = duplex;
+ 		printf("%s: Setting %s-duplex based on MII #%d "
+ 		       "negociated capability %hX\n", sdc->nic_name,
+ 		       duplex ? "full" : "half", sdc->phys[0], negotiated);
+ 		outw(duplex ? 0x20 : 0, BASE + MACCtrl0);
+ 
+ 	}
+ }
+ 
+ 
+ /**************************************************************************
+  *  init_ring - setup the tx and rx descriptors
+  *************************************************************************/
+ static void init_ring(struct nic *nic __unused)
+ {
+ 	int i;
+ 
+ 	sdc->cur_rx = 0;
+ 	sdc->rx_buf_sz = (PKT_BUF_SZ);
+ 	sdc->rx_head_desc = &rx_ring[0];
+ 
+ 	/* Initialize all the Rx descriptors */
+ 	for (i = 0; i < RX_RING_SIZE; i++) {
+ 		rx_ring[i].next_desc = virt_to_le32desc(&rx_ring[i + 1]);
+ 		rx_ring[i].status = 0;
+ 		rx_ring[i].length = 0;
+ 		rx_ring[i].addr = 0;
+ 	}
+ 
+ 	/* Mark the last entry as wrapping the ring */
+ 	rx_ring[i - 1].next_desc = virt_to_le32desc(&rx_ring[0]);
+ 
+ 	for (i = 0; i < RX_RING_SIZE; i++) {
+ 		rx_ring[i].addr = virt_to_le32desc(&rxb[i * PKT_BUF_SZ]);
+ 		rx_ring[i].length = cpu_to_le32(sdc->rx_buf_sz | LastFrag);
+ 	}
+ 	sdc->dirty_rx = (unsigned int) (i - RX_RING_SIZE);
+ 
+ 	/* We only use one transmit buffer, but two 
+ 	 * descriptors so transmit engines have somewhere 
+ 	 * to point should they feel the need */
+ 	tx_ring[0].status = 0x00000000;
+ 	tx_ring[0].addr = virt_to_bus(&txb[0]);
+ 	tx_ring[0].next_desc = 0; /* virt_to_bus(&tx_ring[1]); */
+ 
+ 	/* This descriptor is never used */
+ 	tx_ring[1].status = 0x00000000;
+ 	tx_ring[1].addr = 0; /*virt_to_bus(&txb[0]); */
+ 	tx_ring[1].next_desc = 0; 
+ 
+ 	/* Mark the last entry as wrapping the ring, 
+ 	 * though this should never happen */
+ 	tx_ring[1].length = cpu_to_le32(LastFrag | PKT_BUF_SZ);
+ }
+ 
+ /**************************************************************************
+  *  RESET - Reset Adapter
+  * ***********************************************************************/
+ static void sundance_reset(struct nic *nic)
+ {
+ 	int i;
+ 
+ 	init_ring(nic);
+ 
+ 	/* FIXME: find out where the linux driver sets duplex_lock */
+ 	sdc->full_duplex = sdc->duplex_lock;
+ 
+ 	/* The Tx List Pointer is written as packets are queued */
+ 	outl(virt_to_le32desc(&rx_ring[0]), BASE + RxListPtr);
+ 
+ 	/* Write the MAC address to the StationAddress */
+ 	for (i = 0; i < 6; i++)
+ 		outb(nic->node_addr[i], BASE + StationAddr + i);
+ 
+ 	/* Get the link status */
+ 	sdc->link_status = inb(BASE + MIICtrl) & 0xE0;
+ 	/* Write the status to the MACCtrl0 register */
+ 	outw((sdc->full_duplex || (sdc->link_status & 0x20)) ? 0x120 : 0,
+ 	     BASE + MACCtrl0);
+ 	outw(sdc->mtu + 14, BASE + MaxFrameSize);
+ 	if (sdc->mtu > 2047)/* this will never happen with default options */
+ 		outl(inl(BASE + ASICCtrl) | 0x0c, BASE + ASICCtrl);
+ 
+ 	set_rx_mode(nic);
+ 	outw(0, BASE + DownCounter);
+ 	/* Set the chip to poll every N*30nsec */
+ 	outb(100, BASE + RxDescPoll);
+ /*	outb(127, BASE + TxDescPoll); */
+ 
+ /* FIXME: Linux Driver has a bug fix for kendin nic */
+ 
+ /* FIXME: Do we really need stats enabled?*/
+ 	outw(StatsEnable | RxEnable | TxEnable, BASE + MACCtrl1);
+ 
+ 	/* Construct a perfect filter frame with the mac address as first match
+ 	 * and broadcast for all others */
+ 	for (i = 0; i < 192; i++)
+ 		txb[i] = 0xFF;
+ 
+ 	txb[0] = nic->node_addr[0];
+ 	txb[1] = nic->node_addr[1];
+ 	txb[2] = nic->node_addr[2];
+ 	txb[3] = nic->node_addr[3];
+ 	txb[4] = nic->node_addr[4];
+ 	txb[5] = nic->node_addr[5];
+ 
+ 	check_duplex(nic);
+ #ifdef EDEBUG
+ 	printf("%s: Done sundance_reset, status: Rx %hX Tx %hX "
+ 	       "MAC Control %hX, %hX %hX\n",
+ 	       sdc->nic_name, (int) inl(BASE + RxStatus),
+ 	       (int) inw(BASE + TxStatus), (int) inl(BASE + MACCtrl0),
+ 	       (int) inw(BASE + MACCtrl1), (int) inw(BASE + MACCtrl0));
+ #endif
+ }
+ 
+ /**************************************************************************
+ POLL - Wait for a frame
+ ***************************************************************************/
+ static int sundance_poll(struct nic *nic)
+ {
+ 
+ 	/* FIXME: The entire POLL procedure needs to be cleand up */
+ 
+ 	/* return true if there's an ethernet packet ready to read */
+ 	/* nic->packet should contain data on return */
+ 	/* nic->packetlen should contain length of data */
+ 	int entry = sdc->cur_rx % RX_RING_SIZE;
+ 	int boguscnt = 32;
+ 	int received = 0;
+ 	struct netdev_desc *desc = &(rx_ring[entry]);
+ 	u32 frame_status = le32_to_cpu(desc->status);
+ 	int pkt_len = 0;
+ 
+ 	if (--boguscnt < 0) {
+ 		goto not_done;
+ 	}
+ 	if (!(frame_status & DescOwn))
+ 		return 0;
+ 	pkt_len = frame_status & 0x1fff;
+ 	if (frame_status & 0x001f4000) {
+ #ifdef EDEBUG
+ 		/* FIXME: Do we really care about this */
+ 		printf("There was an error\n");
+ #endif
+ 	} else {
+ 		if (pkt_len < rx_copybreak) {
+ 			/* FIXME: What should happen Will this ever occur */
+ 			printf("Problem");
+ 		} else {
+ 			nic->packetlen = pkt_len;
+ 			memcpy(nic->packet, rxb +
+ 			       (sdc->cur_rx * PKT_BUF_SZ), nic->packetlen);
+ 
+ 		}
+ 	}
+ 	entry = (entry + 1) % RX_RING_SIZE;
+ 	received++;
+ 	sdc->cur_rx = entry;
+ 	refill_rx(nic);
+ 	sdc->budget -= received;
+ 	return 1;
+ 
+ 
+       not_done:
+ 	sdc->cur_rx = entry;
+ 	refill_rx(nic);
+ 	if (!received)
+ 		received = 1;
+ 	sdc->budget -= received;
+ 	if (sdc->budget <= 0)
+ 		sdc->budget = 32;
+ #ifdef EDEBUG
+ 	printf("Not Done\n");
+ #endif
+ 	return 0;
+ 
+ }
+ static void refill_rx(struct nic *nic __unused)
+ {
+ 	int entry;
+ 	int cnt = 0;
+ 
+ 	/* Refill the Rx ring buffers. */
+ 	for (;
+ 	     (sdc->cur_rx - sdc->dirty_rx + RX_RING_SIZE) % RX_RING_SIZE >
+ 	     0; sdc->dirty_rx = (sdc->dirty_rx + 1) % RX_RING_SIZE) {
+ 		entry = sdc->dirty_rx % RX_RING_SIZE;
+ 		/* Perhaps we need not reset this field. */
+ 		rx_ring[entry].length =
+ 		    cpu_to_le32(sdc->rx_buf_sz | LastFrag);
+ 		rx_ring[entry].status = 0;
+ 		cnt++;
+ 	}
+ 	return;
+ }
+ 
+ /**************************************************************************
+ TRANSMIT - Transmit a frame
+ ***************************************************************************/
+ static void sundance_transmit(struct nic *nic, const char *d,	/* Destination */
+ 			      unsigned int t,	/* Type */
+ 			      unsigned int s,	/* size */
+ 			      const char *p)
+ {				/* Packet */
+ 	u16 nstype;
+ 	u32 to;
+ 	/* Disable the Tx */
+ 	outw(TxDisable, BASE + MACCtrl1);
+ 
+ 	memcpy(txb, d, ETH_ALEN);
+ 	memcpy(txb + ETH_ALEN, nic->node_addr, ETH_ALEN);
+ 	nstype = htons((u16) t);
+ 	memcpy(txb + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+ 	memcpy(txb + ETH_HLEN, p, s);
+ 
+ 	s += ETH_HLEN;
+ 	s &= 0x0FFF;
+ 	while (s < ETH_ZLEN)
+ 		txb[s++] = '\0';
+ 
+ 	/* Setup the transmit descriptor */
+ 	tx_ring[0].length = cpu_to_le32(s | LastFrag);
+ 	tx_ring[0].status = cpu_to_le32(0x00000001);
+ 
+ 	/* Point to transmit descriptor */
+ 	outl(virt_to_le32desc(&tx_ring[0]), BASE + TxListPtr);
+ 
+ 	/* Enable Tx */
+ 	outw(TxEnable, BASE + MACCtrl1);
+ 	outw(0, BASE + TxStatus);
+ 	to = currticks() + TX_TIME_OUT;
+ 	while(!(tx_ring[0].status & 0x00010000) &&  (currticks() < to))
+ 		; /* wait */ 
+ 
+ 	if (currticks() >= to) {
+ 		printf("TX Time Out");
+ 	}
+ 	/* Disable Tx */
+ 	outw(TxDisable, BASE + MACCtrl1);
+ }
+ 
+ /**************************************************************************
+ DISABLE - Turn off ethernet interface
+ ***************************************************************************/
+ static void sundance_disable(struct dev *dev)
+ {
+ 	/* put the card in its initial state */
+ 	/* This function serves 3 purposes.
+ 	 * This disables DMA and interrupts so we don't receive
+ 	 *  unexpected packets or interrupts from the card after
+ 	 *  etherboot has finished.
+ 	 * This frees resources so etherboot may use
+ 	 *  this driver on another interface
+ 	 * This allows etherboot to reinitialize the interface
+ 	 *  if something is something goes wrong.
+ 	 */
+ 	sundance_reset((struct nic *) dev); 
+ 	outw(0x0000, BASE + IntrEnable);
+ 	/* Stop the Chipchips Tx and Rx Status */
+ 	outw(TxDisable | RxDisable | StatsDisable, BASE + MACCtrl1);
+ }
+ 
+ /**************************************************************************
+ PROBE - Look for an adapter, this routine's visible to the outside
+ ***************************************************************************/
+ static int sundance_probe(struct dev *dev, struct pci_device *pci)
+ {
+ 	struct nic *nic = (struct nic *) dev;
+ 	int card_idx = 1;
+ 	u8 ee_data[EEPROM_SIZE];
+ 	int i, option = card_idx < MAX_UNITS ? options[card_idx] : 0;
+ 
+ 	if (pci->ioaddr == 0)
+ 		return 0;
+ 
+ 	/* BASE is used throughout to address the card */
+ 	BASE = pci->ioaddr;
+ 	printf("\n");
+ 	printf("sundance.c: %s, %s Written by Timothy Legge (tlegge@rogers.com)\n", drv_version, drv_date);
+ 	printf("%s: Probing for Vendor=%hX   Device=%hX, %s\n",
+ 	       pci->name, pci->vendor, pci->dev_id);
+ 
+ 	/* Get the MAC Address by reading the EEPROM */
+ 	for (i = 0; i < 3; i++) {
+ 		((u16 *) ee_data)[i] =
+ 		    le16_to_cpu(eeprom_read(BASE, i + EEPROM_SA_OFFSET));
+ 	}
+ 	/* Update the nic structure with the MAC Address */
+ 	for (i = 0; i < ETH_ALEN; i++) {
+ 		nic->node_addr[i] = ee_data[i];
+ 	}
+ 	/* Print out some hardware info */
+ 	printf("%s: %! at ioaddr %hX\n", pci->name, nic->node_addr, BASE);
+ 
+ 	/* I really must find out what this does */
+ 	adjust_pci_device(pci);
+ 
+ 	/* point to private storage */
+ 	sdc = &sdx;
+ 
+ 	sdc->chip_id = 0;	/* Undefined */
+ 	sdc->drv_flags = 0;	/* Undefined */
+ 	sdc->rx_copybreak = rx_copybreak;
+ 	sdc->max_interrupt_word = max_interrupt_work;
+ 	sdc->multicast_filter_limit = multicast_filter_limit;
+ 	sdc->vendor_id = pci->vendor;
+ 	sdc->dev_id = pci->dev_id;
+ 	sdc->nic_name = pci->name;
+ 	sdc->mtu = mtu;
+ 
+ 	if (card_idx < MAX_UNITS && full_duplex[card_idx] > 0) {
+ 		sdc->full_duplex = 1;
+ #ifdef EDEBUG
+ 		printf("sdc->full_duplex = 1\n");
+ #endif
+ 	}
+ 	if (sdc->full_duplex) {
+ 		sdc->medialock = 1;
+ #ifdef EDEBUG
+ 		printf("sdc->media_lock = 1\n");
+ #endif
+ 	}
+ 
+ 	if (1) {
+ 		int phy, phy_idx = 0;
+ 		sdc->phys[0] = 1;	/* Default Setting */
+ 		mii_preamble_required++;
+ 		for (phy = 1; phy < 32 && phy_idx < 4; phy++) {
+ 			int mii_status = mdio_read(nic, phy, 1);
+ 			if (mii_status != 0xffff && mii_status != 0x0000) {
+ 				sdc->phys[phy_idx++] = phy;
+ 				sdc->advertizing = mdio_read(nic, phy, 4);
+ 				if ((mii_status & 0x0040) == 0)
+ 					mii_preamble_required++;
+ #ifdef EDEBUG
+ 				printf
+ 				    ("%s: MII PHY found at address %d, status "
+ 				     "%hX advertizing %hX\n",
+ 				     sdc->nic_name, phy, mii_status,
+ 				     sdc->advertizing);
+ #endif
+ 			}
+ 		}
+ 		mii_preamble_required--;
+ 		sdc->mii_cnt = phy_idx;
+ 		if (phy_idx == 0)
+ 			printf("%s: No MII transceiver found!\n",
+ 			       sdc->nic_name);
+ 	}
+ 
+ 	/* Allow forcing the media type */
+ 	if (option > 0) {
+ #ifdef EDEBUG
+ 		printf("Trying to force the media type\n");
+ #endif
+ 		if (option & 0x220)
+ 			sdc->full_duplex = 1;
+ 		sdc->default_port = option & 0x3ff;
+ 		if (sdc->default_port & 0x330) {
+ 			sdc->medialock = 1;
+ #ifdef EDEBUG
+ 			printf("Forcing %dMbs %s-duplex operation.\n",
+ 			       (option & 0x300 ? 100 : 10),
+ 			       (sdc->full_duplex ? "full" : "half"));
+ #endif
+ 			if (sdc->mii_cnt)
+ 				mdio_write(nic, sdc->phys[0],
+ 					0, ((option & 0x300) ? 0x2000 : 0)
+ 					|	/* 100mbps */
+ 					(sdc->full_duplex ? 0x0100 : 0));	/* Full Duplex? */
+ 		}
+ 	}
+ 
+ 	/* Reset the chip to erase previous misconfiguration */
+ #ifdef EDEBUG
+ 	printf("ASIC Control is %hX\n", (int) inl(BASE + ASICCtrl));
+ #endif
+ 	outl(0x007f0000 | inl(BASE + ASICCtrl), BASE + ASICCtrl);
+ #ifdef EDEBUG
+ 	printf("ASIC Control is now %hX\n", (int) inl(BASE + ASICCtrl));
+ #endif
+ 
+ 	sundance_reset(nic);
+ 
+ 	/* point to NIC specific routines */
+ 	dev->disable = sundance_disable;
+ 	nic->poll = sundance_poll;
+ 	nic->transmit = sundance_transmit;
+ 
+ 	return 1;
+ }
+ 
+ 
+ /* Read the EEPROM and MII Management Data I/O (MDIO) interfaces. */
+ static int eeprom_read(long ioaddr, int location)
+ {
+ 	int boguscnt = 2000;	/* Typical 190 ticks */
+ 	outw(0x0200 | (location & 0xff), ioaddr + EECtrl);
+ 	do {
+ 		if (!(inw(ioaddr + EECtrl) & 0x8000)) {
+ 			return inw(ioaddr + EEData);
+ 		}
+ 	}
+ 	while (--boguscnt > 0);
+ 	return 0;
+ }
+ 
+ /*  MII transceiver control section.
+ 	Read and write the MII registers using software-generated serial
+ 	MDIO protocol.  See the MII specifications or DP83840A data sheet
+ 	for details.
+ 
+ 	The maximum data clock rate is 2.5 Mhz.
+ 	The timing is decoupled from the processor clock by flushing the write
+ 	from the CPU write buffer with a following read, and using PCI
+ 	transaction time. */
+ 
+ #define mdio_in(mdio_addr) inb(mdio_addr)
+ #define mdio_out(value, mdio_addr) outb(value, mdio_addr)
+ #define mdio_delay(mdio_addr) inb(mdio_addr)
+ 
+ enum mii_reg_bits {
+ 	MDIO_ShiftClk = 0x0001, MDIO_Data = 0x0002, MDIO_EnbOutput =
+ 	    0x0004,
+ };
+ #define MDIO_EnbIn  (0)
+ #define MDIO_WRITE0 (MDIO_EnbOutput)
+ #define MDIO_WRITE1 (MDIO_Data | MDIO_EnbOutput)
+ 
+ /* Generate the preamble required for initial synchronization and
+    a few older transceivers. */
+ static void mdio_sync(long mdio_addr)
+ {
+ 	int bits = 32;
+ 
+ 	/* Establish sync by sending at least 32 logic ones. */
+ 	while (--bits >= 0) {
+ 		mdio_out(MDIO_WRITE1, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 		mdio_out(MDIO_WRITE1 | MDIO_ShiftClk, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 	}
+ }
+ 
+ static int
+ mdio_read(struct nic *nic __unused, int phy_id, unsigned int location)
+ {
+ 	long mdio_addr = BASE + MIICtrl;
+ 	int mii_cmd = (0xf6 << 10) | (phy_id << 5) | location;
+ 	int i, retval = 0;
+ 
+ 	if (mii_preamble_required)
+ 		mdio_sync(mdio_addr);
+ 
+ 	/* Shift the read command bits out. */
+ 	for (i = 15; i >= 0; i--) {
+ 		int dataval =
+ 		    (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;
+ 
+ 		mdio_out(dataval, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 		mdio_out(dataval | MDIO_ShiftClk, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 	}
+ 	/* Read the two transition, 16 data, and wire-idle bits. */
+ 	for (i = 19; i > 0; i--) {
+ 		mdio_out(MDIO_EnbIn, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 		retval = (retval << 1) | ((mdio_in(mdio_addr) & MDIO_Data)
+ 					  ? 1 : 0);
+ 		mdio_out(MDIO_EnbIn | MDIO_ShiftClk, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 	}
+ 	return (retval >> 1) & 0xffff;
+ }
+ 
+ static void
+ mdio_write(struct nic *nic __unused, int phy_id,
+ 	   unsigned int location, int value)
+ {
+ 	long mdio_addr = BASE + MIICtrl;
+ 	int mii_cmd =
+ 	    (0x5002 << 16) | (phy_id << 23) | (location << 18) | value;
+ 	int i;
+ 
+ 	if (mii_preamble_required)
+ 		mdio_sync(mdio_addr);
+ 
+ 	/* Shift the command bits out. */
+ 	for (i = 31; i >= 0; i--) {
+ 		int dataval =
+ 		    (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;
+ 		mdio_out(dataval, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 		mdio_out(dataval | MDIO_ShiftClk, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 	}
+ 	/* Clear out extra bits. */
+ 	for (i = 2; i > 0; i--) {
+ 		mdio_out(MDIO_EnbIn, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 		mdio_out(MDIO_EnbIn | MDIO_ShiftClk, mdio_addr);
+ 		mdio_delay(mdio_addr);
+ 	}
+ 	return;
+ }
+ 
+ /* The little-endian AUTODIN II ethernet CRC calculations.
+    A big-endian version is also available.
+    This is slow but compact code.  Do not use this routine for bulk data,
+    use a table-based routine instead.
+    This is common code and should be moved to net/core/crc.c.
+    Chips may use the upper or lower CRC bits, and may reverse and/or invert
+    them.  Select the endian-ness that results in minimal calculations.
+ */
+ static unsigned const ethernet_polynomial_le = 0xedb88320U;
+ static inline unsigned ether_crc_le(int length, unsigned char *data)
+ {
+ 	unsigned int crc = ~0;	/* Initial value. */
+ 	while (--length >= 0) {
+ 		unsigned char current_octet = *data++;
+ 		int bit;
+ 		for (bit = 8; --bit >= 0; current_octet >>= 1) {
+ 			if ((crc ^ current_octet) & 1) {
+ 				crc >>= 1;
+ 				crc ^= ethernet_polynomial_le;
+ 			} else
+ 				crc >>= 1;
+ 		}
+ 	}
+ 	return crc;
+ }
+ 
+ static void set_rx_mode(struct nic *nic __unused)
+ {
+ 	int i;
+ 	u16 mc_filter[4];	/* Multicast hash filter */
+ 	u32 rx_mode;
+ 
+ 	memset(mc_filter, 0xff, sizeof(mc_filter));
+ 	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+ 	
+ 	for(i = 0; i < 4; i++) 
+ 		outw(mc_filter[i], BASE + MulticastFilter0 + i*2);	
+ 	outb(rx_mode, BASE + RxMode);
+ 	return;
+ }
+ 
+ static struct pci_id sundance_nics[] = {
+ PCI_ROM(0x13f0, 0x0201, "sundance",  "ST201 Sundance 'Alta' based Adaptor"),
+ PCI_ROM(0x1186, 0x1002, "dfe530txs", "D-Link DFE530TXS (Sundance ST201 Alta)"),
+ };
+ 
+ struct pci_driver sundance_driver = {
+ 	.type = NIC_DRIVER,
+ 	.name = "SUNDANCE/PCI",
+ 	.probe = sundance_probe,
+ 	.ids = sundance_nics,
+ 	.id_count = sizeof(sundance_nics) / sizeof(sundance_nics[0]),
+ 	.class = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/tftp.h GRUB/netboot/tftp.h
*** GRUB_0.94/netboot/tftp.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/tftp.h	2003-11-11 20:43:02.000000000 +0800
***************
*** 0 ****
--- 1,82 ----
+ #ifndef	_TFTP_H
+ #define	_TFTP_H
+ 
+ #include "if_ether.h"
+ #include "ip.h"
+ #include "udp.h"
+ 
+ #ifndef	MAX_TFTP_RETRIES
+ #define MAX_TFTP_RETRIES	20
+ #endif
+ 
+ /* These settings have sense only if compiled with -DCONGESTED */
+ /* total retransmission timeout in ticks */
+ #define TFTP_TIMEOUT		(30*TICKS_PER_SEC)
+ /* packet retransmission timeout in ticks */
+ #define TFTP_REXMT		(3*TICKS_PER_SEC)
+ 
+ #define TFTP_PORT	69
+ #define	TFTP_DEFAULTSIZE_PACKET	512
+ #define	TFTP_MAX_PACKET		1432 /* 512 */
+ 
+ #define TFTP_RRQ	1
+ #define TFTP_WRQ	2
+ #define TFTP_DATA	3
+ #define TFTP_ACK	4
+ #define TFTP_ERROR	5
+ #define TFTP_OACK	6
+ 
+ #define TFTP_CODE_EOF	1
+ #define TFTP_CODE_MORE	2
+ #define TFTP_CODE_ERROR	3
+ #define TFTP_CODE_BOOT	4
+ #define TFTP_CODE_CFG	5
+ 
+ struct tftp_t {
+ 	struct iphdr ip;
+ 	struct udphdr udp;
+ 	uint16_t opcode;
+ 	union {
+ 		uint8_t rrq[TFTP_DEFAULTSIZE_PACKET];
+ 		struct {
+ 			uint16_t block;
+ 			uint8_t  download[TFTP_MAX_PACKET];
+ 		} data;
+ 		struct {
+ 			uint16_t block;
+ 		} ack;
+ 		struct {
+ 			uint16_t errcode;
+ 			uint8_t  errmsg[TFTP_DEFAULTSIZE_PACKET];
+ 		} err;
+ 		struct {
+ 			uint8_t  data[TFTP_DEFAULTSIZE_PACKET+2];
+ 		} oack;
+ 	} u;
+ };
+ 
+ /* define a smaller tftp packet solely for making requests to conserve stack
+    512 bytes should be enough */
+ struct tftpreq_t {
+ 	struct iphdr ip;
+ 	struct udphdr udp;
+ 	uint16_t opcode;
+ 	union {
+ 		uint8_t rrq[512];
+ 		struct {
+ 			uint16_t block;
+ 		} ack;
+ 		struct {
+ 			uint16_t errcode;
+ 			uint8_t  errmsg[512-2];
+ 		} err;
+ 	} u;
+ };
+ 
+ #define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
+ 
+ typedef int (*read_actor_t)(unsigned char *, unsigned int, unsigned int, int);
+ 
+ int tftp_file_read(const char *name, read_actor_t);
+ 
+ #endif	/* _TFTP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/tg3.c GRUB/netboot/tg3.c
*** GRUB_0.94/netboot/tg3.c	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/tg3.c	2003-11-20 11:46:08.000000000 +0800
***************
*** 0 ****
--- 1,3278 ----
+ /* $Id$
+  * tg3.c: Broadcom Tigon3 ethernet driver.
+  *
+  * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+  * Copyright (C) 2001, 2002 Jeff Garzik (jgarzik@mandrakesoft.com)
+  * Copyright (C) 2003 Eric Biederman (ebiederman@lnxi.com)  [etherboot port]
+  */
+ 
+ /* 11-13-2003	timlegge	Fix Issue with NetGear GA302T */
+ 
+ #include "etherboot.h"
+ #include "nic.h"
+ #include "pci.h"
+ #include "timer.h"
+ #include "string.h"
+ #include "tg3.h"
+ 
+ #define SUPPORT_COPPER_PHY  1
+ #define SUPPORT_FIBER_PHY   1
+ #define SUPPORT_LINK_REPORT 1
+ #define SUPPORT_PARTNO_STR  1
+ #define SUPPORT_PHY_STR     1
+ 
+ struct tg3 tg3;
+ 
+ /* Dummy defines for error handling */
+ #define EBUSY  1
+ #define ENODEV 2
+ #define EINVAL 3
+ #define ENOMEM 4
+ 
+ 
+ /* These numbers seem to be hard coded in the NIC firmware somehow.
+  * You can't change the ring sizes, but you can change where you place
+  * them in the NIC onboard memory.
+  */
+ #define TG3_RX_RING_SIZE		512
+ #define TG3_DEF_RX_RING_PENDING		20	/* RX_RING_PENDING seems to be o.k. at 20 and 200 */
+ #define TG3_RX_RCB_RING_SIZE		1024
+ #define TG3_TX_RING_SIZE		512
+ #define TG3_DEF_TX_RING_PENDING		(TG3_TX_RING_SIZE - 1)
+ 
+ #define TG3_RX_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_RING_SIZE)
+ #define TG3_RX_RCB_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_RCB_RING_SIZE)
+ 
+ #define TG3_TX_RING_BYTES	(sizeof(struct tg3_tx_buffer_desc) * TG3_TX_RING_SIZE)
+ #define NEXT_TX(N)		(((N) + 1) & (TG3_TX_RING_SIZE - 1))
+ #define PREV_TX(N)		(((N) - 1) & (TG3_TX_RING_SIZE - 1))
+ 
+ #define RX_PKT_BUF_SZ		(1536 + 2 + 64)
+ 
+ 
+ static struct bss {
+ 	struct tg3_rx_buffer_desc rx_std[TG3_RX_RING_SIZE];
+ 	struct tg3_rx_buffer_desc rx_rcb[TG3_RX_RCB_RING_SIZE];
+ 	struct tg3_tx_buffer_desc tx_ring[TG3_TX_RING_SIZE];
+ 	struct tg3_hw_status      hw_status;
+ 	struct tg3_hw_stats       hw_stats;
+ 	unsigned char             rx_bufs[TG3_DEF_RX_RING_PENDING][RX_PKT_BUF_SZ];
+ } tg3_bss;
+ 
+ /**
+  * pci_save_state - save the PCI configuration space of a device before suspending
+  * @dev: - PCI device that we're dealing with
+  * @buffer: - buffer to hold config space context
+  *
+  * @buffer must be large enough to hold the entire PCI 2.2 config space 
+  * (>= 64 bytes).
+  */
+ static int pci_save_state(struct pci_device *dev, uint32_t *buffer)
+ {
+ 	int i;
+ 	for (i = 0; i < 16; i++)
+ 		pci_read_config_dword(dev, i * 4,&buffer[i]);
+ 	return 0;
+ }
+ 
+ /** 
+  * pci_restore_state - Restore the saved state of a PCI device
+  * @dev: - PCI device that we're dealing with
+  * @buffer: - saved PCI config space
+  *
+  */
+ static int pci_restore_state(struct pci_device *dev, uint32_t *buffer)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < 16; i++)
+ 		pci_write_config_dword(dev,i * 4, buffer[i]);
+ 	return 0;
+ }
+ 
+ static void tg3_write_indirect_reg32(uint32_t off, uint32_t val)
+ {
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_REG_BASE_ADDR, off);
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_REG_DATA, val);
+ }
+ 
+ #define tw32(reg,val)		tg3_write_indirect_reg32((reg),(val))
+ #define tw32_mailbox(reg, val)	writel(((val) & 0xffffffff), tg3.regs + (reg))
+ #define tw16(reg,val)		writew(((val) & 0xffff), tg3.regs + (reg))
+ #define tw8(reg,val)		writeb(((val) & 0xff), tg3.regs + (reg))
+ #define tr32(reg)		readl(tg3.regs + (reg))
+ #define tr16(reg)		readw(tg3.regs + (reg))
+ #define tr8(reg)		readb(tg3.regs + (reg))
+ 
+ static void tw32_carefully(uint32_t reg, uint32_t val)
+ {
+ 	tw32(reg, val);
+ 	tr32(reg);
+ 	udelay(100);
+ }
+ 
+ static void tw32_mailbox2(uint32_t reg, uint32_t val)
+ {
+ 	tw32_mailbox(reg, val);
+ 	tr32(reg);
+ }
+ 
+ static void tg3_write_mem(uint32_t off, uint32_t val)
+ {
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_DATA, val);
+ 
+ 	/* Always leave this as zero. */
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+ }
+ 
+ static void tg3_read_mem(uint32_t off, uint32_t *val)
+ {
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+ 	pci_read_config_dword(tg3.pdev, TG3PCI_MEM_WIN_DATA, val);
+ 
+ 	/* Always leave this as zero. */
+ 	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+ }
+ 
+ static void tg3_disable_ints(struct tg3 *tp)
+ {
+ 	tw32(TG3PCI_MISC_HOST_CTRL,
+ 	     (tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));
+ 	tw32_mailbox2(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);
+ }
+ 
+ static void tg3_switch_clocks(struct tg3 *tp)
+ {
+ 	uint32_t orig_clock_ctrl, clock_ctrl;
+ 
+ 	clock_ctrl = tr32(TG3PCI_CLOCK_CTRL);
+ 
+ 	orig_clock_ctrl = clock_ctrl;
+ 	clock_ctrl &= (CLOCK_CTRL_FORCE_CLKRUN | CLOCK_CTRL_CLKRUN_OENABLE | 0x1f);
+ 	tp->pci_clock_ctrl = clock_ctrl;
+ 	
+ 	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) &&
+ 		(orig_clock_ctrl & CLOCK_CTRL_44MHZ_CORE)) {
+ 		tw32_carefully(TG3PCI_CLOCK_CTRL, 
+ 			clock_ctrl | (CLOCK_CTRL_44MHZ_CORE | CLOCK_CTRL_ALTCLK));
+ 		tw32_carefully(TG3PCI_CLOCK_CTRL, 
+ 			clock_ctrl | (CLOCK_CTRL_ALTCLK));
+ 	}
+ 	tw32_carefully(TG3PCI_CLOCK_CTRL, clock_ctrl);
+ }
+ 
+ #define PHY_BUSY_LOOPS	5000
+ 
+ static int tg3_readphy(struct tg3 *tp, int reg, uint32_t *val)
+ {
+ 	uint32_t frame_val;
+ 	int loops, ret;
+ 
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL);
+ 
+ 	*val = 0xffffffff;
+ 
+ 	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+ 		      MI_COM_PHY_ADDR_MASK);
+ 	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+ 		      MI_COM_REG_ADDR_MASK);
+ 	frame_val |= (MI_COM_CMD_READ | MI_COM_START);
+ 	
+ 	tw32_carefully(MAC_MI_COM, frame_val);
+ 
+ 	loops = PHY_BUSY_LOOPS;
+ 	while (loops-- > 0) {
+ 		udelay(10);
+ 		frame_val = tr32(MAC_MI_COM);
+ 
+ 		if ((frame_val & MI_COM_BUSY) == 0) {
+ 			udelay(5);
+ 			frame_val = tr32(MAC_MI_COM);
+ 			break;
+ 		}
+ 	}
+ 
+ 	ret = -EBUSY;
+ 	if (loops > 0) {
+ 		*val = frame_val & MI_COM_DATA_MASK;
+ 		ret = 0;
+ 	}
+ 
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+ 
+ 	return ret;
+ }
+ 
+ static int tg3_writephy(struct tg3 *tp, int reg, uint32_t val)
+ {
+ 	uint32_t frame_val;
+ 	int loops, ret;
+ 
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL);
+ 
+ 	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+ 		      MI_COM_PHY_ADDR_MASK);
+ 	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+ 		      MI_COM_REG_ADDR_MASK);
+ 	frame_val |= (val & MI_COM_DATA_MASK);
+ 	frame_val |= (MI_COM_CMD_WRITE | MI_COM_START);
+ 	
+ 	tw32_carefully(MAC_MI_COM, frame_val);
+ 
+ 	loops = PHY_BUSY_LOOPS;
+ 	while (loops-- > 0) {
+ 		udelay(10);
+ 		frame_val = tr32(MAC_MI_COM);
+ 		if ((frame_val & MI_COM_BUSY) == 0) {
+ 			udelay(5);
+ 			frame_val = tr32(MAC_MI_COM);
+ 			break;
+ 		}
+ 	}
+ 
+ 	ret = -EBUSY;
+ 	if (loops > 0)
+ 		ret = 0;
+ 
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+ 
+ 	return ret;
+ }
+ 
+ static int tg3_writedsp(struct tg3 *tp, uint16_t addr, uint16_t val)
+ {
+ 	int err;
+ 	err  = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, addr);
+ 	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, val);
+ 	return err;
+ }
+ 
+ 
+ static void tg3_phy_set_wirespeed(struct tg3 *tp)
+ {
+ 	uint32_t val;
+ 
+ 	if (tp->tg3_flags2 & TG3_FLG2_NO_ETH_WIRE_SPEED)
+ 		return;
+ 
+ 	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x7007);
+ 	tg3_readphy(tp, MII_TG3_AUX_CTRL, &val);
+ 	tg3_writephy(tp, MII_TG3_AUX_CTRL, (val | (1 << 15) | (1 << 4)));
+ }
+ 
+ static int tg3_bmcr_reset(struct tg3 *tp)
+ {
+ 	uint32_t phy_control;
+ 	int limit, err;
+ 
+ 	/* OK, reset it, and poll the BMCR_RESET bit until it
+ 	 * clears or we time out.
+ 	 */
+ 	phy_control = BMCR_RESET;
+ 	err = tg3_writephy(tp, MII_BMCR, phy_control);
+ 	if (err != 0)
+ 		return -EBUSY;
+ 
+ 	limit = 5000;
+ 	while (limit--) {
+ 		err = tg3_readphy(tp, MII_BMCR, &phy_control);
+ 		if (err != 0)
+ 			return -EBUSY;
+ 
+ 		if ((phy_control & BMCR_RESET) == 0) {
+ 			udelay(40);
+ 			break;
+ 		}
+ 		udelay(10);
+ 	}
+ 	if (limit <= 0)
+ 		return -EBUSY;
+ 
+ 	return 0;
+ }
+ 
+ static int tg3_wait_macro_done(struct tg3 *tp)
+ {
+ 	int limit = 100;
+ 
+ 	while (limit--) {
+ 		uint32_t tmp32;
+ 
+ 		tg3_readphy(tp, 0x16, &tmp32);
+ 		if ((tmp32 & 0x1000) == 0)
+ 			break;
+ 	}
+ 	if (limit <= 0)
+ 		return -EBUSY;
+ 
+ 	return 0;
+ }
+ 
+ static int tg3_phy_write_and_check_testpat(struct tg3 *tp, int *resetp)
+ {
+ 	static const uint32_t test_pat[4][6] = {
+ 	{ 0x00005555, 0x00000005, 0x00002aaa, 0x0000000a, 0x00003456, 0x00000003 },
+ 	{ 0x00002aaa, 0x0000000a, 0x00003333, 0x00000003, 0x0000789a, 0x00000005 },
+ 	{ 0x00005a5a, 0x00000005, 0x00002a6a, 0x0000000a, 0x00001bcd, 0x00000003 },
+ 	{ 0x00002a5a, 0x0000000a, 0x000033c3, 0x00000003, 0x00002ef1, 0x00000005 }
+ 	};
+ 	int chan;
+ 
+ 	for (chan = 0; chan < 4; chan++) {
+ 		int i;
+ 
+ 		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+ 			(chan * 0x2000) | 0x0200);
+ 		tg3_writephy(tp, 0x16, 0x0002);
+ 
+ 		for (i = 0; i < 6; i++)
+ 			tg3_writephy(tp, MII_TG3_DSP_RW_PORT,
+ 				test_pat[chan][i]);
+ 
+ 		tg3_writephy(tp, 0x16, 0x0202);
+ 		if (tg3_wait_macro_done(tp)) {
+ 			*resetp = 1;
+ 			return -EBUSY;
+ 		}
+ 
+ 		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+ 			     (chan * 0x2000) | 0x0200);
+ 		tg3_writephy(tp, 0x16, 0x0082);
+ 		if (tg3_wait_macro_done(tp)) {
+ 			*resetp = 1;
+ 			return -EBUSY;
+ 		}
+ 
+ 		tg3_writephy(tp, 0x16, 0x0802);
+ 		if (tg3_wait_macro_done(tp)) {
+ 			*resetp = 1;
+ 			return -EBUSY;
+ 		}
+ 
+ 		for (i = 0; i < 6; i += 2) {
+ 			uint32_t low, high;
+ 
+ 			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low);
+ 			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high);
+ 			if (tg3_wait_macro_done(tp)) {
+ 				*resetp = 1;
+ 				return -EBUSY;
+ 			}
+ 			low &= 0x7fff;
+ 			high &= 0x000f;
+ 			if (low != test_pat[chan][i] ||
+ 			    high != test_pat[chan][i+1]) {
+ 				tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000b);
+ 				tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4001);
+ 				tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4005);
+ 
+ 				return -EBUSY;
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tg3_phy_reset_chanpat(struct tg3 *tp)
+ {
+ 	int chan;
+ 
+ 	for (chan = 0; chan < 4; chan++) {
+ 		int i;
+ 
+ 		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+ 			     (chan * 0x2000) | 0x0200);
+ 		tg3_writephy(tp, 0x16, 0x0002);
+ 		for (i = 0; i < 6; i++)
+ 			tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x000);
+ 		tg3_writephy(tp, 0x16, 0x0202);
+ 		if (tg3_wait_macro_done(tp))
+ 			return -EBUSY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tg3_phy_reset_5703_4_5(struct tg3 *tp)
+ {
+ 	uint32_t reg32, phy9_orig;
+ 	int retries, do_phy_reset, err;
+ 
+ 	retries = 10;
+ 	do_phy_reset = 1;
+ 	do {
+ 		if (do_phy_reset) {
+ 			err = tg3_bmcr_reset(tp);
+ 			if (err)
+ 				return err;
+ 			do_phy_reset = 0;
+ 		}
+ 		
+ 		/* Disable transmitter and interrupt.  */
+ 		tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+ 		reg32 |= 0x3000;
+ 		tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+ 
+ 		/* Set full-duplex, 1000 mbps.  */
+ 		tg3_writephy(tp, MII_BMCR,
+ 			BMCR_FULLDPLX | TG3_BMCR_SPEED1000);
+ 
+ 		/* Set to master mode.  */
+ 		tg3_readphy(tp, MII_TG3_CTRL, &phy9_orig);
+ 		tg3_writephy(tp, MII_TG3_CTRL,
+ 			(MII_TG3_CTRL_AS_MASTER |
+ 				MII_TG3_CTRL_ENABLE_AS_MASTER));
+ 
+ 		/* Enable SM_DSP_CLOCK and 6dB.  */
+ 		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+ 
+ 		/* Block the PHY control access.  */
+ 		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8005);
+ 		tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0800);
+ 
+ 		err = tg3_phy_write_and_check_testpat(tp, &do_phy_reset);
+ 		if (!err)
+ 			break;
+ 	} while (--retries);
+ 
+ 	err = tg3_phy_reset_chanpat(tp);
+ 	if (err)
+ 		return err;
+ 
+ 	tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8005);
+ 	tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0000);
+ 
+ 	tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8200);
+ 	tg3_writephy(tp, 0x16, 0x0000);
+ 
+ 	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0400);
+ 
+ 	tg3_writephy(tp, MII_TG3_CTRL, phy9_orig);
+ 
+ 	tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+ 	reg32 &= ~0x3000;
+ 	tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+ 
+ 	return err;
+ }
+ 
+ /* This will reset the tigon3 PHY if there is no valid
+  * link.
+  */
+ static int tg3_phy_reset(struct tg3 *tp)
+ {
+ 	uint32_t phy_status;
+ 	int err;
+ 
+ 	err  = tg3_readphy(tp, MII_BMSR, &phy_status);
+ 	err |= tg3_readphy(tp, MII_BMSR, &phy_status);
+ 	if (err != 0)
+ 		return -EBUSY;
+ 
+ 	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+ 		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+ 		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) {
+ 		err = tg3_phy_reset_5703_4_5(tp);
+ 		if (err)
+ 			return err;
+ 		goto out;
+ 	}
+ 	err = tg3_bmcr_reset(tp);
+ 	if (err)
+ 		return err;
+  out:
+ 	tg3_phy_set_wirespeed(tp);
+ 	return 0;
+ }
+ 
+ static void tg3_set_power_state_0(struct tg3 *tp)
+ {
+ 	uint16_t power_control;
+ 	int pm = tp->pm_cap;
+ 
+ 	/* Make sure register accesses (indirect or otherwise)
+ 	 * will function correctly.
+ 	 */
+ 	pci_write_config_dword(tp->pdev,  TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+ 
+ 	pci_read_config_word(tp->pdev, pm + PCI_PM_CTRL, &power_control);
+ 
+ 	power_control |= PCI_PM_CTRL_PME_STATUS;
+ 	power_control &= ~(PCI_PM_CTRL_STATE_MASK);
+ 	power_control |= 0;
+ 	pci_write_config_word(tp->pdev, pm + PCI_PM_CTRL, power_control);
+ 
+ 	tw32_carefully(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+ 
+ 	return;
+ }
+ 
+ 
+ #if SUPPORT_LINK_REPORT
+ static void tg3_link_report(struct tg3 *tp)
+ {
+ 	if (!tp->carrier_ok) {
+ 		printf("Link is down.\n");
+ 	} else {
+ 		printf("Link is up at %d Mbps, %s duplex. %s %s %s\n",
+ 			(tp->link_config.active_speed == SPEED_1000 ?
+ 			       1000 :
+ 			(tp->link_config.active_speed == SPEED_100 ?
+ 				100 : 10)),
+ 			(tp->link_config.active_duplex == DUPLEX_FULL ?  
+ 				"full" : "half"),
+ 			(tp->tg3_flags & TG3_FLAG_TX_PAUSE) ? "TX" : "",
+ 			(tp->tg3_flags & TG3_FLAG_RX_PAUSE) ? "RX" : "",
+ 			(tp->tg3_flags & (TG3_FLAG_TX_PAUSE |TG3_FLAG_RX_PAUSE)) ? "flow control" : "");
+ 	}
+ }
+ #else
+ #define tg3_link_report(tp)
+ #endif
+ 
+ static void tg3_setup_flow_control(struct tg3 *tp, uint32_t local_adv, uint32_t remote_adv)
+ {
+ 	uint32_t new_tg3_flags = 0;
+ 
+ 	if (local_adv & ADVERTISE_PAUSE_CAP) {
+ 		if (local_adv & ADVERTISE_PAUSE_ASYM) {
+ 			if (remote_adv & LPA_PAUSE_CAP)
+ 				new_tg3_flags |=
+ 					(TG3_FLAG_RX_PAUSE |
+ 					 TG3_FLAG_TX_PAUSE);
+ 			else if (remote_adv & LPA_PAUSE_ASYM)
+ 				new_tg3_flags |=
+ 					(TG3_FLAG_RX_PAUSE);
+ 		} else {
+ 			if (remote_adv & LPA_PAUSE_CAP)
+ 				new_tg3_flags |=
+ 					(TG3_FLAG_RX_PAUSE |
+ 					 TG3_FLAG_TX_PAUSE);
+ 		}
+ 	} else if (local_adv & ADVERTISE_PAUSE_ASYM) {
+ 		if ((remote_adv & LPA_PAUSE_CAP) &&
+ 		    (remote_adv & LPA_PAUSE_ASYM))
+ 			new_tg3_flags |= TG3_FLAG_TX_PAUSE;
+ 	}
+ 
+ 	tp->tg3_flags &= ~(TG3_FLAG_RX_PAUSE | TG3_FLAG_TX_PAUSE);
+ 	tp->tg3_flags |= new_tg3_flags;
+ 
+ 	if (new_tg3_flags & TG3_FLAG_RX_PAUSE)
+ 		tp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;
+ 	else
+ 		tp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;
+ 
+ 	if (new_tg3_flags & TG3_FLAG_TX_PAUSE)
+ 		tp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;
+ 	else
+ 		tp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;
+ }
+ 
+ #if SUPPORT_COPPER_PHY
+ static void tg3_aux_stat_to_speed_duplex(
+ 	struct tg3 *tp __unused, uint32_t val, uint8_t *speed, uint8_t *duplex)
+ {
+ 	static const uint8_t map[] = {
+ 		[0] = (SPEED_INVALID << 2) | DUPLEX_INVALID,
+ 		[MII_TG3_AUX_STAT_10HALF >> 8]   = (SPEED_10 << 2) | DUPLEX_HALF,
+ 		[MII_TG3_AUX_STAT_10FULL >> 8]   = (SPEED_10 << 2) | DUPLEX_FULL,
+ 		[MII_TG3_AUX_STAT_100HALF >> 8]  = (SPEED_100 << 2) | DUPLEX_HALF,
+ 		[MII_TG3_AUX_STAT_100_4 >> 8] = (SPEED_INVALID << 2) | DUPLEX_INVALID,
+ 		[MII_TG3_AUX_STAT_100FULL >> 8]  = (SPEED_100 << 2) | DUPLEX_FULL,
+ 		[MII_TG3_AUX_STAT_1000HALF >> 8] = (SPEED_1000 << 2) | DUPLEX_HALF,
+ 		[MII_TG3_AUX_STAT_1000FULL >> 8] = (SPEED_1000 << 2) | DUPLEX_FULL,
+ 	};
+ 	uint8_t result;
+ 	result = map[(val & MII_TG3_AUX_STAT_SPDMASK) >> 8];
+ 	*speed = result >> 2;
+ 	*duplex = result & 3;
+ }
+ 
+ static int tg3_phy_copper_begin(struct tg3 *tp)
+ {
+ 	uint32_t new_adv;
+ 
+ 	tp->link_config.advertising =
+ 		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+ 			ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+ 			ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+ 			ADVERTISED_Autoneg | ADVERTISED_MII);
+ 	
+ 	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY) {
+ 		tp->link_config.advertising &=
+ 			~(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full);
+ 	}
+ 	
+ 	new_adv = (ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+ 	if (tp->link_config.advertising & ADVERTISED_10baseT_Half) {
+ 		new_adv |= ADVERTISE_10HALF;
+ 	}
+ 	if (tp->link_config.advertising & ADVERTISED_10baseT_Full) {
+ 		new_adv |= ADVERTISE_10FULL;
+ 	}
+ 	if (tp->link_config.advertising & ADVERTISED_100baseT_Half) {
+ 		new_adv |= ADVERTISE_100HALF;
+ 	}
+ 	if (tp->link_config.advertising & ADVERTISED_100baseT_Full) {
+ 		new_adv |= ADVERTISE_100FULL;
+ 	}
+ 	tg3_writephy(tp, MII_ADVERTISE, new_adv);
+ 	
+ 	if (tp->link_config.advertising &
+ 		(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {
+ 		new_adv = 0;
+ 		if (tp->link_config.advertising & ADVERTISED_1000baseT_Half) {
+ 			new_adv |= MII_TG3_CTRL_ADV_1000_HALF;
+ 		}
+ 		if (tp->link_config.advertising & ADVERTISED_1000baseT_Full) {
+ 			new_adv |= MII_TG3_CTRL_ADV_1000_FULL;
+ 		}
+ 		if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+ 			(tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+ 				tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)) {
+ 			new_adv |= (MII_TG3_CTRL_AS_MASTER |
+ 				MII_TG3_CTRL_ENABLE_AS_MASTER);
+ 		}
+ 		tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+ 	} else {
+ 		tg3_writephy(tp, MII_TG3_CTRL, 0);
+ 	}
+ 
+ 	tg3_writephy(tp, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+ 
+ 	return 0;
+ }
+ 
+ static int tg3_init_5401phy_dsp(struct tg3 *tp)
+ {
+ 	int err;
+ 
+ 	/* Turn off tap power management. */
+ 	err  = tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c20);
+ 	
+ 	err |= tg3_writedsp(tp, 0x0012, 0x1804);
+ 	err |= tg3_writedsp(tp, 0x0013, 0x1204);
+ 	err |= tg3_writedsp(tp, 0x8006, 0x0132);
+ 	err |= tg3_writedsp(tp, 0x8006, 0x0232);
+ 	err |= tg3_writedsp(tp, 0x201f, 0x0a20);
+ 
+ 	udelay(40);
+ 
+ 	return err;
+ }
+ 
+ static int tg3_setup_copper_phy(struct tg3 *tp)
+ {
+ 	int current_link_up;
+ 	uint32_t bmsr, dummy;
+ 	int i, err;
+ 
+ 	tw32_carefully(MAC_STATUS,
+ 		(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+ 
+ 	tp->mi_mode = MAC_MI_MODE_BASE;
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+ 
+ 	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x02);
+ 
+ 	/* Some third-party PHYs need to be reset on link going
+ 	 * down.
+ 	 */
+ 	if (	(	(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+ 			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+ 			(tp->pci_chip_rev_id == CHIPREV_ID_5705_A0)) &&
+ 		(tp->carrier_ok)) {
+ 		tg3_readphy(tp, MII_BMSR, &bmsr);
+ 		tg3_readphy(tp, MII_BMSR, &bmsr);
+ 		if (!(bmsr & BMSR_LSTATUS))
+ 			tg3_phy_reset(tp);
+ 	}
+ 
+ 	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401) {
+ 		tg3_readphy(tp, MII_BMSR, &bmsr);
+ 		tg3_readphy(tp, MII_BMSR, &bmsr);
+ 
+ 		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
+ 			bmsr = 0;
+ 
+ 		if (!(bmsr & BMSR_LSTATUS)) {
+ 			err = tg3_init_5401phy_dsp(tp);
+ 			if (err)
+ 				return err;
+ 
+ 			tg3_readphy(tp, MII_BMSR, &bmsr);
+ 			for (i = 0; i < 1000; i++) {
+ 				udelay(10);
+ 				tg3_readphy(tp, MII_BMSR, &bmsr);
+ 				if (bmsr & BMSR_LSTATUS) {
+ 					udelay(40);
+ 					break;
+ 				}
+ 			}
+ 
+ 			if ((tp->phy_id & PHY_ID_REV_MASK) == PHY_REV_BCM5401_B0 &&
+ 			    !(bmsr & BMSR_LSTATUS) &&
+ 			    tp->link_config.active_speed == SPEED_1000) {
+ 				err = tg3_phy_reset(tp);
+ 				if (!err)
+ 					err = tg3_init_5401phy_dsp(tp);
+ 				if (err)
+ 					return err;
+ 			}
+ 		}
+ 	} else if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+ 		   tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+ 		/* 5701 {A0,B0} CRC bug workaround */
+ 		tg3_writephy(tp, 0x15, 0x0a75);
+ 		tg3_writephy(tp, 0x1c, 0x8c68);
+ 		tg3_writephy(tp, 0x1c, 0x8d68);
+ 		tg3_writephy(tp, 0x1c, 0x8c68);
+ 	}
+ 
+ 	/* Clear pending interrupts... */
+ 	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+ 	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+ 
+ 	tg3_writephy(tp, MII_TG3_IMASK, ~0);
+ 
+ 	if (tp->led_mode == led_mode_three_link)
+ 		tg3_writephy(tp, MII_TG3_EXT_CTRL,
+ 			     MII_TG3_EXT_CTRL_LNK3_LED_MODE);
+ 	else
+ 		tg3_writephy(tp, MII_TG3_EXT_CTRL, 0);
+ 
+ 	current_link_up = 0;
+ 
+ 	tg3_readphy(tp, MII_BMSR, &bmsr);
+ 	tg3_readphy(tp, MII_BMSR, &bmsr);
+ 
+ 	if (bmsr & BMSR_LSTATUS) {
+ 		uint32_t aux_stat, bmcr;
+ 
+ 		tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+ 		for (i = 0; i < 2000; i++) {
+ 			udelay(10);
+ 			tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+ 			if (aux_stat)
+ 				break;
+ 		}
+ 
+ 		tg3_aux_stat_to_speed_duplex(tp, aux_stat,
+ 			&tp->link_config.active_speed,
+ 			&tp->link_config.active_duplex);
+ 		tg3_readphy(tp, MII_BMCR, &bmcr);
+ 		tg3_readphy(tp, MII_BMCR, &bmcr);
+ 		if (bmcr & BMCR_ANENABLE) {
+ 			uint32_t gig_ctrl;
+ 			
+ 			current_link_up = 1;
+ 			
+ 			/* Force autoneg restart if we are exiting
+ 			 * low power mode.
+ 			 */
+ 			tg3_readphy(tp, MII_TG3_CTRL, &gig_ctrl);
+ 			if (!(gig_ctrl & (MII_TG3_CTRL_ADV_1000_HALF |
+ 				      MII_TG3_CTRL_ADV_1000_FULL))) {
+ 				current_link_up = 0;
+ 			}
+ 		} else {
+ 			current_link_up = 0;
+ 		}
+ 	}
+ 
+ 	if (current_link_up == 1 &&
+ 		(tp->link_config.active_duplex == DUPLEX_FULL)) {
+ 		uint32_t local_adv, remote_adv;
+ 
+ 		tg3_readphy(tp, MII_ADVERTISE, &local_adv);
+ 		local_adv &= (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+ 
+ 		tg3_readphy(tp, MII_LPA, &remote_adv);
+ 		remote_adv &= (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);
+ 
+ 		/* If we are not advertising full pause capability,
+ 		 * something is wrong.  Bring the link down and reconfigure.
+ 		 */
+ 		if (local_adv != ADVERTISE_PAUSE_CAP) {
+ 			current_link_up = 0;
+ 		} else {
+ 			tg3_setup_flow_control(tp, local_adv, remote_adv);
+ 		}
+ 	}
+ 
+ 	if (current_link_up == 0) {
+ 		uint32_t tmp;
+ 
+ 		tg3_phy_copper_begin(tp);
+ 
+ 		tg3_readphy(tp, MII_BMSR, &tmp);
+ 		tg3_readphy(tp, MII_BMSR, &tmp);
+ 		if (tmp & BMSR_LSTATUS)
+ 			current_link_up = 1;
+ 	}
+ 
+ 	tp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;
+ 	if (current_link_up == 1) {
+ 		if (tp->link_config.active_speed == SPEED_100 ||
+ 		    tp->link_config.active_speed == SPEED_10)
+ 			tp->mac_mode |= MAC_MODE_PORT_MODE_MII;
+ 		else
+ 			tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+ 	} else
+ 		tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+ 
+ 	tp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;
+ 	if (tp->link_config.active_duplex == DUPLEX_HALF)
+ 		tp->mac_mode |= MAC_MODE_HALF_DUPLEX;
+ 
+ 	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) {
+ 		if ((tp->led_mode == led_mode_link10) ||
+ 		    (current_link_up == 1 &&
+ 		     tp->link_config.active_speed == SPEED_10))
+ 			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+ 	} else {
+ 		if (current_link_up == 1)
+ 			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+ 		tw32(MAC_LED_CTRL, LED_CTRL_PHY_MODE_1);
+ 	}
+ 
+ 	/* ??? Without this setting Netgear GA302T PHY does not
+ 	 * ??? send/receive packets...
+ 	 * With this other PHYs cannot bring up the link
+ 	 */
+ 	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5411 &&
+ 		tp->pci_chip_rev_id == CHIPREV_ID_5700_ALTIMA) {
+ 		tp->mi_mode |= MAC_MI_MODE_AUTO_POLL;
+ 		tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+ 	}
+ 
+ 	tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 	/* Link change polled. */
+ 	tw32_carefully(MAC_EVENT, 0);
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 &&
+ 	    current_link_up == 1 &&
+ 	    tp->link_config.active_speed == SPEED_1000 &&
+ 	    ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ||
+ 	     (tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED))) {
+ 		udelay(120);
+ 		tw32_carefully(MAC_STATUS,
+ 			(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+ 		tg3_write_mem(
+ 			      NIC_SRAM_FIRMWARE_MBOX,
+ 			      NIC_SRAM_FIRMWARE_MBOX_MAGIC2);
+ 	}
+ 
+ 	if (current_link_up != tp->carrier_ok) {
+ 		tp->carrier_ok = current_link_up;
+ 		tg3_link_report(tp);
+ 	}
+ 
+ 	return 0;
+ }
+ #else
+ #define tg3_setup_copper_phy(TP) (-EINVAL)
+ #endif /* SUPPORT_COPPER_PHY */
+ 
+ #if SUPPORT_FIBER_PHY
+ struct tg3_fiber_aneginfo {
+ 	int state;
+ #define ANEG_STATE_UNKNOWN		0
+ #define ANEG_STATE_AN_ENABLE		1
+ #define ANEG_STATE_RESTART_INIT		2
+ #define ANEG_STATE_RESTART		3
+ #define ANEG_STATE_DISABLE_LINK_OK	4
+ #define ANEG_STATE_ABILITY_DETECT_INIT	5
+ #define ANEG_STATE_ABILITY_DETECT	6
+ #define ANEG_STATE_ACK_DETECT_INIT	7
+ #define ANEG_STATE_ACK_DETECT		8
+ #define ANEG_STATE_COMPLETE_ACK_INIT	9
+ #define ANEG_STATE_COMPLETE_ACK		10
+ #define ANEG_STATE_IDLE_DETECT_INIT	11
+ #define ANEG_STATE_IDLE_DETECT		12
+ #define ANEG_STATE_LINK_OK		13
+ #define ANEG_STATE_NEXT_PAGE_WAIT_INIT	14
+ #define ANEG_STATE_NEXT_PAGE_WAIT	15
+ 
+ 	uint32_t flags;
+ #define MR_AN_ENABLE		0x00000001
+ #define MR_RESTART_AN		0x00000002
+ #define MR_AN_COMPLETE		0x00000004
+ #define MR_PAGE_RX		0x00000008
+ #define MR_NP_LOADED		0x00000010
+ #define MR_TOGGLE_TX		0x00000020
+ #define MR_LP_ADV_FULL_DUPLEX	0x00000040
+ #define MR_LP_ADV_HALF_DUPLEX	0x00000080
+ #define MR_LP_ADV_SYM_PAUSE	0x00000100
+ #define MR_LP_ADV_ASYM_PAUSE	0x00000200
+ #define MR_LP_ADV_REMOTE_FAULT1	0x00000400
+ #define MR_LP_ADV_REMOTE_FAULT2	0x00000800
+ #define MR_LP_ADV_NEXT_PAGE	0x00001000
+ #define MR_TOGGLE_RX		0x00002000
+ #define MR_NP_RX		0x00004000
+ 
+ #define MR_LINK_OK		0x80000000
+ 
+ 	unsigned long link_time, cur_time;
+ 
+ 	uint32_t ability_match_cfg;
+ 	int ability_match_count;
+ 
+ 	char ability_match, idle_match, ack_match;
+ 
+ 	uint32_t txconfig, rxconfig;
+ #define ANEG_CFG_NP		0x00000080
+ #define ANEG_CFG_ACK		0x00000040
+ #define ANEG_CFG_RF2		0x00000020
+ #define ANEG_CFG_RF1		0x00000010
+ #define ANEG_CFG_PS2		0x00000001
+ #define ANEG_CFG_PS1		0x00008000
+ #define ANEG_CFG_HD		0x00004000
+ #define ANEG_CFG_FD		0x00002000
+ #define ANEG_CFG_INVAL		0x00001f06
+ 
+ };
+ #define ANEG_OK		0
+ #define ANEG_DONE	1
+ #define ANEG_TIMER_ENAB	2
+ #define ANEG_FAILED	-1
+ 
+ #define ANEG_STATE_SETTLE_TIME	10000
+ 
+ static int tg3_fiber_aneg_smachine(struct tg3 *tp,
+ 				   struct tg3_fiber_aneginfo *ap)
+ {
+ 	unsigned long delta;
+ 	uint32_t rx_cfg_reg;
+ 	int ret;
+ 
+ 	if (ap->state == ANEG_STATE_UNKNOWN) {
+ 		ap->rxconfig = 0;
+ 		ap->link_time = 0;
+ 		ap->cur_time = 0;
+ 		ap->ability_match_cfg = 0;
+ 		ap->ability_match_count = 0;
+ 		ap->ability_match = 0;
+ 		ap->idle_match = 0;
+ 		ap->ack_match = 0;
+ 	}
+ 	ap->cur_time++;
+ 
+ 	if (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {
+ 		rx_cfg_reg = tr32(MAC_RX_AUTO_NEG);
+ 
+ 		if (rx_cfg_reg != ap->ability_match_cfg) {
+ 			ap->ability_match_cfg = rx_cfg_reg;
+ 			ap->ability_match = 0;
+ 			ap->ability_match_count = 0;
+ 		} else {
+ 			if (++ap->ability_match_count > 1) {
+ 				ap->ability_match = 1;
+ 				ap->ability_match_cfg = rx_cfg_reg;
+ 			}
+ 		}
+ 		if (rx_cfg_reg & ANEG_CFG_ACK)
+ 			ap->ack_match = 1;
+ 		else
+ 			ap->ack_match = 0;
+ 
+ 		ap->idle_match = 0;
+ 	} else {
+ 		ap->idle_match = 1;
+ 		ap->ability_match_cfg = 0;
+ 		ap->ability_match_count = 0;
+ 		ap->ability_match = 0;
+ 		ap->ack_match = 0;
+ 
+ 		rx_cfg_reg = 0;
+ 	}
+ 
+ 	ap->rxconfig = rx_cfg_reg;
+ 	ret = ANEG_OK;
+ 
+ 	switch(ap->state) {
+ 	case ANEG_STATE_UNKNOWN:
+ 		if (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))
+ 			ap->state = ANEG_STATE_AN_ENABLE;
+ 
+ 		/* fallthru */
+ 	case ANEG_STATE_AN_ENABLE:
+ 		ap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);
+ 		if (ap->flags & MR_AN_ENABLE) {
+ 			ap->link_time = 0;
+ 			ap->cur_time = 0;
+ 			ap->ability_match_cfg = 0;
+ 			ap->ability_match_count = 0;
+ 			ap->ability_match = 0;
+ 			ap->idle_match = 0;
+ 			ap->ack_match = 0;
+ 
+ 			ap->state = ANEG_STATE_RESTART_INIT;
+ 		} else {
+ 			ap->state = ANEG_STATE_DISABLE_LINK_OK;
+ 		}
+ 		break;
+ 
+ 	case ANEG_STATE_RESTART_INIT:
+ 		ap->link_time = ap->cur_time;
+ 		ap->flags &= ~(MR_NP_LOADED);
+ 		ap->txconfig = 0;
+ 		tw32(MAC_TX_AUTO_NEG, 0);
+ 		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+ 		tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 		ret = ANEG_TIMER_ENAB;
+ 		ap->state = ANEG_STATE_RESTART;
+ 
+ 		/* fallthru */
+ 	case ANEG_STATE_RESTART:
+ 		delta = ap->cur_time - ap->link_time;
+ 		if (delta > ANEG_STATE_SETTLE_TIME) {
+ 			ap->state = ANEG_STATE_ABILITY_DETECT_INIT;
+ 		} else {
+ 			ret = ANEG_TIMER_ENAB;
+ 		}
+ 		break;
+ 
+ 	case ANEG_STATE_DISABLE_LINK_OK:
+ 		ret = ANEG_DONE;
+ 		break;
+ 
+ 	case ANEG_STATE_ABILITY_DETECT_INIT:
+ 		ap->flags &= ~(MR_TOGGLE_TX);
+ 		ap->txconfig = (ANEG_CFG_FD | ANEG_CFG_PS1);
+ 		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+ 		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+ 		tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 		ap->state = ANEG_STATE_ABILITY_DETECT;
+ 		break;
+ 
+ 	case ANEG_STATE_ABILITY_DETECT:
+ 		if (ap->ability_match != 0 && ap->rxconfig != 0) {
+ 			ap->state = ANEG_STATE_ACK_DETECT_INIT;
+ 		}
+ 		break;
+ 
+ 	case ANEG_STATE_ACK_DETECT_INIT:
+ 		ap->txconfig |= ANEG_CFG_ACK;
+ 		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+ 		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+ 		tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 		ap->state = ANEG_STATE_ACK_DETECT;
+ 
+ 		/* fallthru */
+ 	case ANEG_STATE_ACK_DETECT:
+ 		if (ap->ack_match != 0) {
+ 			if ((ap->rxconfig & ~ANEG_CFG_ACK) ==
+ 			    (ap->ability_match_cfg & ~ANEG_CFG_ACK)) {
+ 				ap->state = ANEG_STATE_COMPLETE_ACK_INIT;
+ 			} else {
+ 				ap->state = ANEG_STATE_AN_ENABLE;
+ 			}
+ 		} else if (ap->ability_match != 0 &&
+ 			   ap->rxconfig == 0) {
+ 			ap->state = ANEG_STATE_AN_ENABLE;
+ 		}
+ 		break;
+ 
+ 	case ANEG_STATE_COMPLETE_ACK_INIT:
+ 		if (ap->rxconfig & ANEG_CFG_INVAL) {
+ 			ret = ANEG_FAILED;
+ 			break;
+ 		}
+ 		ap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |
+ 			       MR_LP_ADV_HALF_DUPLEX |
+ 			       MR_LP_ADV_SYM_PAUSE |
+ 			       MR_LP_ADV_ASYM_PAUSE |
+ 			       MR_LP_ADV_REMOTE_FAULT1 |
+ 			       MR_LP_ADV_REMOTE_FAULT2 |
+ 			       MR_LP_ADV_NEXT_PAGE |
+ 			       MR_TOGGLE_RX |
+ 			       MR_NP_RX);
+ 		if (ap->rxconfig & ANEG_CFG_FD)
+ 			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+ 		if (ap->rxconfig & ANEG_CFG_HD)
+ 			ap->flags |= MR_LP_ADV_HALF_DUPLEX;
+ 		if (ap->rxconfig & ANEG_CFG_PS1)
+ 			ap->flags |= MR_LP_ADV_SYM_PAUSE;
+ 		if (ap->rxconfig & ANEG_CFG_PS2)
+ 			ap->flags |= MR_LP_ADV_ASYM_PAUSE;
+ 		if (ap->rxconfig & ANEG_CFG_RF1)
+ 			ap->flags |= MR_LP_ADV_REMOTE_FAULT1;
+ 		if (ap->rxconfig & ANEG_CFG_RF2)
+ 			ap->flags |= MR_LP_ADV_REMOTE_FAULT2;
+ 		if (ap->rxconfig & ANEG_CFG_NP)
+ 			ap->flags |= MR_LP_ADV_NEXT_PAGE;
+ 
+ 		ap->link_time = ap->cur_time;
+ 
+ 		ap->flags ^= (MR_TOGGLE_TX);
+ 		if (ap->rxconfig & 0x0008)
+ 			ap->flags |= MR_TOGGLE_RX;
+ 		if (ap->rxconfig & ANEG_CFG_NP)
+ 			ap->flags |= MR_NP_RX;
+ 		ap->flags |= MR_PAGE_RX;
+ 
+ 		ap->state = ANEG_STATE_COMPLETE_ACK;
+ 		ret = ANEG_TIMER_ENAB;
+ 		break;
+ 
+ 	case ANEG_STATE_COMPLETE_ACK:
+ 		if (ap->ability_match != 0 &&
+ 		    ap->rxconfig == 0) {
+ 			ap->state = ANEG_STATE_AN_ENABLE;
+ 			break;
+ 		}
+ 		delta = ap->cur_time - ap->link_time;
+ 		if (delta > ANEG_STATE_SETTLE_TIME) {
+ 			if (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {
+ 				ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+ 			} else {
+ 				if ((ap->txconfig & ANEG_CFG_NP) == 0 &&
+ 				    !(ap->flags & MR_NP_RX)) {
+ 					ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+ 				} else {
+ 					ret = ANEG_FAILED;
+ 				}
+ 			}
+ 		}
+ 		break;
+ 
+ 	case ANEG_STATE_IDLE_DETECT_INIT:
+ 		ap->link_time = ap->cur_time;
+ 		tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+ 		tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 		ap->state = ANEG_STATE_IDLE_DETECT;
+ 		ret = ANEG_TIMER_ENAB;
+ 		break;
+ 
+ 	case ANEG_STATE_IDLE_DETECT:
+ 		if (ap->ability_match != 0 &&
+ 		    ap->rxconfig == 0) {
+ 			ap->state = ANEG_STATE_AN_ENABLE;
+ 			break;
+ 		}
+ 		delta = ap->cur_time - ap->link_time;
+ 		if (delta > ANEG_STATE_SETTLE_TIME) {
+ 			/* XXX another gem from the Broadcom driver :( */
+ 			ap->state = ANEG_STATE_LINK_OK;
+ 		}
+ 		break;
+ 
+ 	case ANEG_STATE_LINK_OK:
+ 		ap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);
+ 		ret = ANEG_DONE;
+ 		break;
+ 
+ 	case ANEG_STATE_NEXT_PAGE_WAIT_INIT:
+ 		/* ??? unimplemented */
+ 		break;
+ 
+ 	case ANEG_STATE_NEXT_PAGE_WAIT:
+ 		/* ??? unimplemented */
+ 		break;
+ 
+ 	default:
+ 		ret = ANEG_FAILED;
+ 		break;
+ 	};
+ 
+ 	return ret;
+ }
+ 
+ static int tg3_setup_fiber_phy(struct tg3 *tp)
+ {
+ 	uint32_t orig_pause_cfg;
+ 	uint16_t orig_active_speed;
+ 	uint8_t orig_active_duplex;
+ 	int current_link_up;
+ 	int i;
+ 
+ 	orig_pause_cfg =
+ 		(tp->tg3_flags & (TG3_FLAG_RX_PAUSE |
+ 				  TG3_FLAG_TX_PAUSE));
+ 	orig_active_speed = tp->link_config.active_speed;
+ 	orig_active_duplex = tp->link_config.active_duplex;
+ 
+ 	tp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);
+ 	tp->mac_mode |= MAC_MODE_PORT_MODE_TBI;
+ 	tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 	/* Reset when initting first time or we have a link. */
+ 	if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+ 	    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+ 		/* Set PLL lock range. */
+ 		tg3_writephy(tp, 0x16, 0x8007);
+ 
+ 		/* SW reset */
+ 		tg3_writephy(tp, MII_BMCR, BMCR_RESET);
+ 
+ 		/* Wait for reset to complete. */
+ 		mdelay(5);
+ 
+ 		/* Config mode; select PMA/Ch 1 regs. */
+ 		tg3_writephy(tp, 0x10, 0x8411);
+ 
+ 		/* Enable auto-lock and comdet, select txclk for tx. */
+ 		tg3_writephy(tp, 0x11, 0x0a10);
+ 
+ 		tg3_writephy(tp, 0x18, 0x00a0);
+ 		tg3_writephy(tp, 0x16, 0x41ff);
+ 
+ 		/* Assert and deassert POR. */
+ 		tg3_writephy(tp, 0x13, 0x0400);
+ 		udelay(40);
+ 		tg3_writephy(tp, 0x13, 0x0000);
+ 
+ 		tg3_writephy(tp, 0x11, 0x0a50);
+ 		udelay(40);
+ 		tg3_writephy(tp, 0x11, 0x0a10);
+ 
+ 		/* Wait for signal to stabilize */
+ 		mdelay(150);
+ 
+ 		/* Deselect the channel register so we can read the PHYID
+ 		 * later.
+ 		 */
+ 		tg3_writephy(tp, 0x10, 0x8011);
+ 	}
+ 
+ 	/* Disable link change interrupt.  */
+ 	tw32_carefully(MAC_EVENT, 0);
+ 
+ 	current_link_up = 0;
+ 	if (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) {
+ 		if (!(tp->tg3_flags & TG3_FLAG_GOT_SERDES_FLOWCTL)) {
+ 			struct tg3_fiber_aneginfo aninfo;
+ 			int status = ANEG_FAILED;
+ 			unsigned int tick;
+ 			uint32_t tmp;
+ 
+ 			memset(&aninfo, 0, sizeof(aninfo));
+ 			aninfo.flags |= (MR_AN_ENABLE);
+ 
+ 			tw32(MAC_TX_AUTO_NEG, 0);
+ 
+ 			tmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;
+ 			tw32_carefully(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);
+ 
+ 			tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);
+ 
+ 			aninfo.state = ANEG_STATE_UNKNOWN;
+ 			aninfo.cur_time = 0;
+ 			tick = 0;
+ 			while (++tick < 195000) {
+ 				status = tg3_fiber_aneg_smachine(tp, &aninfo);
+ 				if (status == ANEG_DONE ||
+ 				    status == ANEG_FAILED)
+ 					break;
+ 
+ 				udelay(1);
+ 			}
+ 
+ 			tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+ 			tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 			if (status == ANEG_DONE &&
+ 			    (aninfo.flags &
+ 			     (MR_AN_COMPLETE | MR_LINK_OK |
+ 			      MR_LP_ADV_FULL_DUPLEX))) {
+ 				uint32_t local_adv, remote_adv;
+ 
+ 				local_adv = ADVERTISE_PAUSE_CAP;
+ 				remote_adv = 0;
+ 				if (aninfo.flags & MR_LP_ADV_SYM_PAUSE)
+ 					remote_adv |= LPA_PAUSE_CAP;
+ 				if (aninfo.flags & MR_LP_ADV_ASYM_PAUSE)
+ 					remote_adv |= LPA_PAUSE_ASYM;
+ 
+ 				tg3_setup_flow_control(tp, local_adv, remote_adv);
+ 
+ 				tp->tg3_flags |=
+ 					TG3_FLAG_GOT_SERDES_FLOWCTL;
+ 				current_link_up = 1;
+ 			}
+ 			for (i = 0; i < 60; i++) {
+ 				udelay(20);
+ 				tw32_carefully(MAC_STATUS,
+ 					(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+ 				if ((tr32(MAC_STATUS) &
+ 				     (MAC_STATUS_SYNC_CHANGED |
+ 				      MAC_STATUS_CFG_CHANGED)) == 0)
+ 					break;
+ 			}
+ 			if (current_link_up == 0 &&
+ 			    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+ 				current_link_up = 1;
+ 			}
+ 		} else {
+ 			/* Forcing 1000FD link up. */
+ 			current_link_up = 1;
+ 		}
+ 	}
+ 
+ 	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+ 	tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 	tp->hw_status->status =
+ 		(SD_STATUS_UPDATED |
+ 		 (tp->hw_status->status & ~SD_STATUS_LINK_CHG));
+ 
+ 	for (i = 0; i < 100; i++) {
+ 		udelay(20);
+ 		tw32_carefully(MAC_STATUS,
+ 			(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+ 		if ((tr32(MAC_STATUS) &
+ 		     (MAC_STATUS_SYNC_CHANGED |
+ 		      MAC_STATUS_CFG_CHANGED)) == 0)
+ 			break;
+ 	}
+ 
+ 	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0)
+ 		current_link_up = 0;
+ 
+ 	if (current_link_up == 1) {
+ 		tp->link_config.active_speed = SPEED_1000;
+ 		tp->link_config.active_duplex = DUPLEX_FULL;
+ 	} else {
+ 		tp->link_config.active_speed = SPEED_INVALID;
+ 		tp->link_config.active_duplex = DUPLEX_INVALID;
+ 	}
+ 
+ 	if (current_link_up != tp->carrier_ok) {
+ 		tp->carrier_ok = current_link_up;
+ 		tg3_link_report(tp);
+ 	} else {
+ 		uint32_t now_pause_cfg =
+ 			tp->tg3_flags & (TG3_FLAG_RX_PAUSE |
+ 					 TG3_FLAG_TX_PAUSE);
+ 		if (orig_pause_cfg != now_pause_cfg ||
+ 		    orig_active_speed != tp->link_config.active_speed ||
+ 		    orig_active_duplex != tp->link_config.active_duplex)
+ 			tg3_link_report(tp);
+ 	}
+ 
+ 	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0) {
+ 		tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_LINK_POLARITY);
+ 		if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+ 			tw32_carefully(MAC_MODE, tp->mac_mode);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ #else
+ #define tg3_setup_fiber_phy(TP) (-EINVAL)
+ #endif /* SUPPORT_FIBER_PHY */
+ 
+ static int tg3_setup_phy(struct tg3 *tp)
+ {
+ 	int err;
+ 
+ 	if (tp->phy_id == PHY_ID_SERDES) {
+ 		err = tg3_setup_fiber_phy(tp);
+ 	} else {
+ 		err = tg3_setup_copper_phy(tp);
+ 	}
+ 
+ 	if (tp->link_config.active_speed == SPEED_1000 &&
+ 	    tp->link_config.active_duplex == DUPLEX_HALF)
+ 		tw32(MAC_TX_LENGTHS,
+ 		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+ 		      (6 << TX_LENGTHS_IPG_SHIFT) |
+ 		      (0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));
+ 	else
+ 		tw32(MAC_TX_LENGTHS,
+ 		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+ 		      (6 << TX_LENGTHS_IPG_SHIFT) |
+ 		      (32 << TX_LENGTHS_SLOT_TIME_SHIFT)));
+ 
+ 	return err;
+ }
+ 
+ 
+ #define MAX_WAIT_CNT 1000
+ 
+ /* To stop a block, clear the enable bit and poll till it
+  * clears.  
+  */
+ static int tg3_stop_block(struct tg3 *tp, unsigned long ofs, uint32_t enable_bit)
+ {
+ 	unsigned int i;
+ 	uint32_t val;
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+ 		switch(ofs) {
+ 		case RCVLSC_MODE:
+ 		case DMAC_MODE:
+ 		case MBFREE_MODE:
+ 		case BUFMGR_MODE:
+ 		case MEMARB_MODE:
+ 			/* We can't enable/disable these bits of the
+ 			 * 5705, just say success.
+ 			 */
+ 			return 0;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 	val = tr32(ofs);
+ 	val &= ~enable_bit;
+ 	tw32(ofs, val);
+ 	tr32(ofs);
+ 
+ 	for (i = 0; i < MAX_WAIT_CNT; i++) {
+ 		udelay(100);
+ 		val = tr32(ofs);
+ 		if ((val & enable_bit) == 0)
+ 			break;
+ 	}
+ 
+ 	if (i == MAX_WAIT_CNT) {
+ 		printf("tg3_stop_block timed out, ofs=%lx enable_bit=%x\n",
+ 		       ofs, enable_bit);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int tg3_abort_hw(struct tg3 *tp)
+ {
+ 	int i, err;
+ 
+ 	tg3_disable_ints(tp);
+ 
+ 	tp->rx_mode &= ~RX_MODE_ENABLE;
+ 	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+ 
+ 	err  = tg3_stop_block(tp, RCVBDI_MODE,   RCVBDI_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, RCVLPC_MODE,   RCVLPC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, RCVLSC_MODE,   RCVLSC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, RCVDBDI_MODE,  RCVDBDI_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, RCVDCC_MODE,   RCVDCC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, RCVCC_MODE,    RCVCC_MODE_ENABLE);
+ 
+ 	err |= tg3_stop_block(tp, SNDBDS_MODE,   SNDBDS_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, SNDBDI_MODE,   SNDBDI_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, RDMAC_MODE,    RDMAC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, SNDBDC_MODE,   SNDBDC_MODE_ENABLE);
+ 	if (err)
+ 		goto out;
+ 
+ 	tp->mac_mode &= ~MAC_MODE_TDE_ENABLE;
+ 	tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 	tp->tx_mode &= ~TX_MODE_ENABLE;
+ 	tw32_carefully(MAC_TX_MODE, tp->tx_mode);
+ 
+ 	for (i = 0; i < MAX_WAIT_CNT; i++) {
+ 		udelay(100);
+ 		if (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))
+ 			break;
+ 	}
+ 	if (i >= MAX_WAIT_CNT) {
+ 		printf("tg3_abort_hw timed out TX_MODE_ENABLE will not clear MAC_TX_MODE=%x\n",
+ 			tr32(MAC_TX_MODE));
+ 		return -ENODEV;
+ 	}
+ 
+ 	err  = tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, WDMAC_MODE,  WDMAC_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE);
+ 
+ 	tw32(FTQ_RESET, 0xffffffff);
+ 	tw32(FTQ_RESET, 0x00000000);
+ 
+ 	err |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE);
+ 	err |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE);
+ 	if (err)
+ 		goto out;
+ 
+ 	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+ 
+ out:
+ 	return err;
+ }
+ 
+ static void tg3_chip_reset(struct tg3 *tp)
+ {
+ 	uint32_t val;
+ 
+ 
+ 	/* Force NVRAM to settle.
+ 	 * This deals with a chip bug which can result in EEPROM
+ 	 * corruption.
+ 	 */
+ 	if (tp->tg3_flags & TG3_FLAG_NVRAM) {
+ 		int i;
+ 
+ 		tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+ 		for (i = 0; i < 100000; i++) {
+ 			if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+ 				break;
+ 			udelay(10);
+ 		}
+ 	}
+ 	/* In Etherboot we don't need to worry about the 5701
+ 	 * REG_WRITE_BUG because we do all register writes indirectly.
+ 	 */
+ 
+ 	/* do the reset */
+ 	val = GRC_MISC_CFG_CORECLK_RESET;
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)
+ 		val |= GRC_MISC_CFG_KEEP_GPHY_POWER;
+ 	tw32(GRC_MISC_CFG, val);
+ 
+ 	/* Flush PCI posted writes.  The normal MMIO registers
+ 	 * are inaccessible at this time so this is the only
+ 	 * way to make this reliably.  I tried to use indirect
+ 	 * register read/write but this upset some 5701 variants.
+ 	 */
+ 	pci_read_config_dword(tp->pdev, PCI_COMMAND, &val);
+ 
+ 	udelay(120);
+ 
+ 	/* Re-enable indirect register accesses. */
+ 	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+ 			       tp->misc_host_ctrl);
+ 
+ 	/* Set MAX PCI retry to zero. */
+ 	val = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);
+ 	if (tp->pci_chip_rev_id == CHIPREV_ID_5704_A0 &&
+ 	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE))
+ 		val |= PCISTATE_RETRY_SAME_DMA;
+ 	pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);
+ 
+ 	pci_restore_state(tp->pdev, tp->pci_cfg_state);
+ 
+ 	/* Make sure PCI-X relaxed ordering bit is clear. */
+ 	pci_read_config_dword(tp->pdev, TG3PCI_X_CAPS, &val);
+ 	val &= ~PCIX_CAPS_RELAXED_ORDERING;
+ 	pci_write_config_dword(tp->pdev, TG3PCI_X_CAPS, val);
+ 
+ 	tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
+ 
+ 	if (((tp->nic_sram_data_cfg & NIC_SRAM_DATA_CFG_MINI_PCI) != 0) &&
+ 		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) {
+ 		tp->pci_clock_ctrl |=
+ 			(CLOCK_CTRL_FORCE_CLKRUN | CLOCK_CTRL_CLKRUN_OENABLE);
+ 		tw32(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);
+ 	}
+ 
+ 	tw32(TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+ }
+ 
+ static void tg3_stop_fw(struct tg3 *tp)
+ {
+ 	if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF) {
+ 		uint32_t val;
+ 		int i;
+ 
+ 		tg3_write_mem(NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_PAUSE_FW);
+ 		val = tr32(GRC_RX_CPU_EVENT);
+ 		val |= (1 << 14);
+ 		tw32(GRC_RX_CPU_EVENT, val);
+ 
+ 		/* Wait for RX cpu to ACK the event.  */
+ 		for (i = 0; i < 100; i++) {
+ 			if (!(tr32(GRC_RX_CPU_EVENT) & (1 << 14)))
+ 				break;
+ 			udelay(1);
+ 		}
+ 	}
+ }
+ 
+ static int tg3_restart_fw(struct tg3 *tp, uint32_t state)
+ {
+ 	uint32_t val;
+ 	int i;
+ 	
+ 	tg3_write_mem(NIC_SRAM_FIRMWARE_MBOX, 
+ 		NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+ 	/* Wait for firmware initialization to complete. */
+ 	for (i = 0; i < 100000; i++) {
+ 		tg3_read_mem(NIC_SRAM_FIRMWARE_MBOX, &val);
+ 		if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+ 			break;
+ 		udelay(10);
+ 	}
+ 	if (i >= 100000) {
+ 		printf("Firmware will not restart magic=%x\n",
+ 			val);
+ 		return -ENODEV;
+ 	}
+ 	if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+ 		state = DRV_STATE_SUSPEND;
+ 	}
+ 	tg3_write_mem(NIC_SRAM_FW_DRV_STATE_MBOX, state);
+ 	return 0;
+ }
+ 
+ static int tg3_halt(struct tg3 *tp)
+ {
+ 	tg3_stop_fw(tp);
+ 	tg3_abort_hw(tp);
+ 	tg3_chip_reset(tp);
+ 	return tg3_restart_fw(tp, DRV_STATE_UNLOAD);
+ }
+ 
+ static void __tg3_set_mac_addr(struct tg3 *tp)
+ {
+ 	uint32_t addr_high, addr_low;
+ 	int i;
+ 
+ 	addr_high = ((tp->nic->node_addr[0] << 8) |
+ 		     tp->nic->node_addr[1]);
+ 	addr_low = ((tp->nic->node_addr[2] << 24) |
+ 		    (tp->nic->node_addr[3] << 16) |
+ 		    (tp->nic->node_addr[4] <<  8) |
+ 		    (tp->nic->node_addr[5] <<  0));
+ 	for (i = 0; i < 4; i++) {
+ 		tw32(MAC_ADDR_0_HIGH + (i * 8), addr_high);
+ 		tw32(MAC_ADDR_0_LOW + (i * 8), addr_low);
+ 	}
+ 
+ 	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700) &&
+ 		(GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) &&
+ 		(GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705)) {
+ 		for(i = 0; i < 12; i++) {
+ 			tw32(MAC_EXTADDR_0_HIGH + (i * 8), addr_high);
+ 			tw32(MAC_EXTADDR_0_LOW + (i * 8), addr_low);
+ 		}
+ 	}
+ 	addr_high = (tp->nic->node_addr[0] +
+ 		     tp->nic->node_addr[1] +
+ 		     tp->nic->node_addr[2] +
+ 		     tp->nic->node_addr[3] +
+ 		     tp->nic->node_addr[4] +
+ 		     tp->nic->node_addr[5]) &
+ 		TX_BACKOFF_SEED_MASK;
+ 	tw32(MAC_TX_BACKOFF_SEED, addr_high);
+ }
+ 
+ static void tg3_set_bdinfo(struct tg3 *tp, uint32_t bdinfo_addr,
+ 			   dma_addr_t mapping, uint32_t maxlen_flags,
+ 			   uint32_t nic_addr)
+ {
+ 	tg3_write_mem((bdinfo_addr +
+ 		       TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH),
+ 		      ((uint64_t) mapping >> 32));
+ 	tg3_write_mem((bdinfo_addr +
+ 		       TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW),
+ 		      ((uint64_t) mapping & 0xffffffff));
+ 	tg3_write_mem((bdinfo_addr +
+ 		       TG3_BDINFO_MAXLEN_FLAGS),
+ 		       maxlen_flags);
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+ 		tg3_write_mem((bdinfo_addr + TG3_BDINFO_NIC_ADDR), nic_addr);
+ 	}
+ }
+ 
+ 
+ static void tg3_init_rings(struct tg3 *tp)
+ {
+ 	unsigned i;
+ 
+ 	/* Zero out the tg3 variables */
+ 	memset(&tg3_bss, 0, sizeof(tg3_bss));
+ 	tp->rx_std    = &tg3_bss.rx_std[0];
+ 	tp->rx_rcb    = &tg3_bss.rx_rcb[0];
+ 	tp->tx_ring   = &tg3_bss.tx_ring[0];
+ 	tp->hw_status = &tg3_bss.hw_status;
+ 	tp->hw_stats  = &tg3_bss.hw_stats;
+ 	tp->mac_mode  = 0;
+ 
+ 
+ 	/* Initialize tx/rx rings for packet processing.
+ 	 *
+ 	 * The chip has been shut down and the driver detached from
+ 	 * the networking, so no interrupts or new tx packets will
+ 	 * end up in the driver.
+ 	 */
+ 
+ 	/* Initialize invariants of the rings, we only set this
+ 	 * stuff once.  This works because the card does not
+ 	 * write into the rx buffer posting rings.
+ 	 */
+ 	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+ 		struct tg3_rx_buffer_desc *rxd;
+ 
+ 		rxd = &tp->rx_std[i];
+ 		rxd->idx_len = (RX_PKT_BUF_SZ - 2 - 64)	<< RXD_LEN_SHIFT;
+ 		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);
+ 		rxd->opaque = (RXD_OPAQUE_RING_STD | (i << RXD_OPAQUE_INDEX_SHIFT));
+ 
+ 		/* Note where the receive buffer for the ring is placed */
+ 		rxd->addr_hi = 0;
+ 		rxd->addr_lo = virt_to_bus(
+ 			&tg3_bss.rx_bufs[i%TG3_DEF_RX_RING_PENDING][2]);
+ 	}
+ }
+ 
+ #define TG3_WRITE_SETTINGS(TABLE) \
+ do { \
+ 	const uint32_t *_table, *_end; \
+ 	_table = TABLE; \
+ 	_end = _table + sizeof(TABLE)/sizeof(TABLE[0]);  \
+ 	for(; _table < _end; _table += 2) { \
+ 		tw32(_table[0], _table[1]); \
+ 	} \
+ } while(0)
+ 
+ 
+ /* initialize/reset the tg3 */
+ static int tg3_setup_hw(struct tg3 *tp)
+ {
+ 	uint32_t val, rdmac_mode;
+ 	int i, err, limit;
+ 
+ 	/* Simply don't support setups with extremly buggy firmware in etherboot */
+ 	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {
+ 		printf("Error 5701_A0 firmware bug detected\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	tg3_disable_ints(tp);
+ 
+ 	/* Originally this was all in tg3_init_hw */
+ 
+ 	/* Force the chip into D0. */
+ 	tg3_set_power_state_0(tp);
+ 
+ 	tg3_switch_clocks(tp);
+ 
+ 	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+ 
+ 
+ 	/* Originally this was all in tg3_reset_hw */
+ 
+ 	tg3_stop_fw(tp);
+ 
+ 	/* No need to call tg3_abort_hw here, it is called before tg3_setup_hw. */
+ 
+ 	tg3_chip_reset(tp);
+ 
+ 	tw32(GRC_MODE, tp->grc_mode);  /* Redundant? */
+ 
+ 	err = tg3_restart_fw(tp, DRV_STATE_START);
+ 	if (err)
+ 		return err;
+ 
+ 	if (tp->phy_id == PHY_ID_SERDES) {
+ 		tp->mac_mode = MAC_MODE_PORT_MODE_TBI;
+ 	}
+ 	tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 
+ 	/* This works around an issue with Athlon chipsets on
+ 	 * B3 tigon3 silicon.  This bit has no effect on any
+ 	 * other revision.
+ 	 */
+ 	tp->pci_clock_ctrl |= CLOCK_CTRL_DELAY_PCI_GRANT;
+ 	tw32_carefully(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);
+ 
+ 	if (tp->pci_chip_rev_id == CHIPREV_ID_5704_A0 &&
+ 	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE)) {
+ 		val = tr32(TG3PCI_PCISTATE);
+ 		val |= PCISTATE_RETRY_SAME_DMA;
+ 		tw32(TG3PCI_PCISTATE, val);
+ 	}
+ 
+ 	/* Descriptor ring init may make accesses to the
+ 	 * NIC SRAM area to setup the TX descriptors, so we
+ 	 * can only do this after the hardware has been
+ 	 * successfully reset.
+ 	 */
+ 	tg3_init_rings(tp);
+ 
+ 	/* Clear statistics/status block in chip */
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+ 		for (i = NIC_SRAM_STATS_BLK;
+ 		     i < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;
+ 		     i += sizeof(uint32_t)) {
+ 			tg3_write_mem(i, 0);
+ 			udelay(40);
+ 		}
+ 	}
+ 
+ 	/* This value is determined during the probe time DMA
+ 	 * engine test, tg3_setup_dma.
+ 	 */
+ 	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+ 
+ 	tp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |
+ 			  GRC_MODE_4X_NIC_SEND_RINGS |
+ 			  GRC_MODE_NO_TX_PHDR_CSUM |
+ 			  GRC_MODE_NO_RX_PHDR_CSUM);
+ 	tp->grc_mode |= GRC_MODE_HOST_SENDBDS;
+ 	tp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;
+ 	tp->grc_mode |= GRC_MODE_NO_RX_PHDR_CSUM;
+ 
+ 	tw32(GRC_MODE,
+ 		tp->grc_mode | 
+ 		(GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP));
+ 
+ 	{
+ 		static const uint32_t table[] = {
+ 			/* Setup the timer prescalar register.  Clock is always 66Mhz. */
+ 			GRC_MISC_CFG, (65 << GRC_MISC_CFG_PRESCALAR_SHIFT),
+ 			
+ 			/* Initialize MBUF/DESC pool. */
+ 			BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE,
+ 			BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE,
+ 			BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE,
+ 			
+ 			BUFMGR_MB_RDMA_LOW_WATER,  DEFAULT_MB_RDMA_LOW_WATER,
+ 			BUFMGR_MB_MACRX_LOW_WATER, DEFAULT_MB_MACRX_LOW_WATER,
+ 			BUFMGR_MB_HIGH_WATER,      DEFAULT_MB_HIGH_WATER,
+ 			
+ 			BUFMGR_DMA_LOW_WATER,  DEFAULT_DMA_LOW_WATER,
+ 			BUFMGR_DMA_HIGH_WATER, DEFAULT_DMA_HIGH_WATER,
+ 			
+ 			BUFMGR_MODE, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE,
+ 			
+ 		};
+ 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)
+ 			tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE64);
+ 		else
+ 			tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE96);
+ 		
+ 		TG3_WRITE_SETTINGS(table);
+ 		for (i = 0; i < 2000; i++) {
+ 			if (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)
+ 				break;
+ 			udelay(10);
+ 		}
+ 		if (i >= 2000) {
+ 			printf("tg3_setup_hw cannot enable BUFMGR\n");
+ 			return -ENODEV;
+ 		}
+ 	}
+ 	tw32(FTQ_RESET, 0xffffffff);
+ 	tw32(FTQ_RESET, 0x00000000);
+ 	for (i = 0; i < 2000; i++) {
+ 		if (tr32(FTQ_RESET) == 0x00000000)
+ 			break;
+ 		udelay(10);
+ 	}
+ 	if (i >= 2000) {
+ 		printf("tg3_setup_hw cannot reset FTQ\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Initialize TG3_BDINFO's at:
+ 	 *  RCVDBDI_STD_BD:	standard eth size rx ring
+ 	 *  RCVDBDI_JUMBO_BD:	jumbo frame rx ring
+ 	 *  RCVDBDI_MINI_BD:	small frame rx ring (??? does not work)
+ 	 *
+ 	 * like so:
+ 	 *  TG3_BDINFO_HOST_ADDR:	high/low parts of DMA address of ring
+ 	 *  TG3_BDINFO_MAXLEN_FLAGS:	(rx max buffer size << 16) |
+ 	 *                              ring attribute flags
+ 	 *  TG3_BDINFO_NIC_ADDR:	location of descriptors in nic SRAM
+ 	 *
+ 	 * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.
+ 	 * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.
+ 	 *
+ 	 * ??? No space allocated for mini receive ring? :(
+ 	 *
+ 	 * The size of each ring is fixed in the firmware, but the location is
+ 	 * configurable.
+ 	 */
+ 	{
+ 		static const uint32_t table_all[] = {
+ 			/* Setup replenish thresholds. */
+ 			RCVBDI_STD_THRESH, TG3_DEF_RX_RING_PENDING / 8,
+ 
+ 			/* Etherboot lives below 4GB */
+ 			RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+ 			RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR, NIC_SRAM_RX_BUFFER_DESC,
+ 		};
+ 		static const uint32_t table_not_5705[] = {
+ 			/* Buffer maximum length */
+ 			RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS, RX_STD_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT,
+ 			
+ 			/* Disable the mini frame rx ring */
+ 			RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,	BDINFO_FLAGS_DISABLED,
+ 			
+ 			/* Disable the jumbo frame rx ring */
+ 			RCVBDI_JUMBO_THRESH, 0,
+ 			RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED,
+ 			
+ 			
+ 		};
+ 		TG3_WRITE_SETTINGS(table_all);
+ 		tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW, 
+ 			virt_to_bus(tp->rx_std));
+ 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+ 			tw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS,
+ 				RX_STD_MAX_SIZE_5705 << BDINFO_FLAGS_MAXLEN_SHIFT);
+ 		} else {
+ 			TG3_WRITE_SETTINGS(table_not_5705);
+ 		}
+ 	}
+ 
+ 	
+ 	/* There is only one send ring on 5705, no need to explicitly
+ 	 * disable the others.
+ 	 */
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+ 		/* Clear out send RCB ring in SRAM. */
+ 		for (i = NIC_SRAM_SEND_RCB; i < NIC_SRAM_RCV_RET_RCB; i += TG3_BDINFO_SIZE)
+ 			tg3_write_mem(i + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED);
+ 	}
+ 
+ 	tp->tx_prod = 0;
+ 	tw32_mailbox(MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+ 	tw32_mailbox2(MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+ 
+ 	tg3_set_bdinfo(tp,
+ 		NIC_SRAM_SEND_RCB,
+ 		virt_to_bus(tp->tx_ring),
+ 		(TG3_TX_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),
+ 		NIC_SRAM_TX_BUFFER_DESC);
+ 
+ 	/* There is only one receive return ring on 5705, no need to explicitly
+ 	 * disable the others.
+ 	 */
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+ 		for (i = NIC_SRAM_RCV_RET_RCB; i < NIC_SRAM_STATS_BLK; i += TG3_BDINFO_SIZE) {
+ 			tg3_write_mem(i + TG3_BDINFO_MAXLEN_FLAGS,
+ 				BDINFO_FLAGS_DISABLED);
+ 		}
+ 	}
+ 
+ 	tp->rx_rcb_ptr = 0;
+ 	tw32_mailbox2(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, 0);
+ 
+ 	tg3_set_bdinfo(tp,
+ 		NIC_SRAM_RCV_RET_RCB,
+ 		virt_to_bus(tp->rx_rcb),
+ 		(TG3_RX_RCB_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),
+ 		0);
+ 
+ 	tp->rx_std_ptr = TG3_DEF_RX_RING_PENDING;
+ 	tw32_mailbox2(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+ 		     tp->rx_std_ptr);
+ 
+ 	tw32_mailbox2(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW, 0);
+ 
+ 	/* Initialize MAC address and backoff seed. */
+ 	__tg3_set_mac_addr(tp);
+ 
+ 	/* Calculate RDMAC_MODE setting early, we need it to determine
+ 	 * the RCVLPC_STATE_ENABLE mask.
+ 	 */
+ 	rdmac_mode = (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |
+ 		RDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |
+ 		RDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |
+ 		RDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |
+ 		RDMAC_MODE_LNGREAD_ENAB);
+ 	if (tp->tg3_flags & TG3_FLAG_SPLIT_MODE)
+ 		rdmac_mode |= RDMAC_MODE_SPLIT_ENABLE;
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+ 		if (tp->pci_chip_rev_id != CHIPREV_ID_5705_A0) {
+ 			if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&
+ 				!(tp->tg3_flags2 & TG3_FLG2_IS_5788)) {
+ 				rdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Setup host coalescing engine. */
+ 	tw32(HOSTCC_MODE, 0);
+ 	for (i = 0; i < 2000; i++) {
+ 		if (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))
+ 			break;
+ 		udelay(10);
+ 	}
+ 
+ 	tp->mac_mode = MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |
+ 		MAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE | MAC_MODE_FHDE_ENABLE;
+ 	tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);
+ 
+ 	tp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_AUTO_SEEPROM;
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+ 		tp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |
+ 				       GRC_LCLCTRL_GPIO_OUTPUT1);
+ 	tw32_carefully(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+ 
+ 	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0);
+ 	tr32(MAILBOX_INTERRUPT_0);
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+ 		tw32_carefully(DMAC_MODE, DMAC_MODE_ENABLE);
+ 	}
+ 	
+ 	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) &&
+ 		(((tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) != 0) || (tp->pci_chip_rev_id == CHIPREV_ID_5701_B5)) &&  
+ 		!(tp->tg3_flags2 & TG3_FLG2_IS_5788)) {    
+ 		tw32_carefully(WDMAC_MODE, 
+ 			(	WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |
+ 				WDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |
+ 				WDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |
+ 				WDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |
+ 				WDMAC_MODE_LNGREAD_ENAB));
+ 	}
+ 
+ 	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) != 0) {
+ 		val = tr32(TG3PCI_X_CAPS);
+ 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+ 			val &= PCIX_CAPS_BURST_MASK;
+ 			val |= (PCIX_CAPS_MAX_BURST_CPIOB << PCIX_CAPS_BURST_SHIFT);
+ 		} else if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) {
+ 			val &= ~(PCIX_CAPS_SPLIT_MASK | PCIX_CAPS_BURST_MASK);
+ 			val |= (PCIX_CAPS_MAX_BURST_CPIOB << PCIX_CAPS_BURST_SHIFT);
+ 			if (tp->tg3_flags & TG3_FLAG_SPLIT_MODE)
+ 				val |= (tp->split_mode_max_reqs <<
+ 					PCIX_CAPS_SPLIT_SHIFT);
+ 		}
+ 		tw32(TG3PCI_X_CAPS, val);
+ 	}
+ 
+ 	tw32_carefully(RDMAC_MODE, rdmac_mode);
+ 	{
+ 		static const uint32_t table_all[] = {
+ 			/* MTU + ethernet header + FCS + optional VLAN tag */
+ 			MAC_RX_MTU_SIZE, ETH_MAX_MTU + ETH_HLEN + 8,
+ 			
+ 			/* The slot time is changed by tg3_setup_phy if we
+ 			 * run at gigabit with half duplex.
+ 			 */
+ 			MAC_TX_LENGTHS,	
+ 			(2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+ 			(6 << TX_LENGTHS_IPG_SHIFT) |
+ 			(32 << TX_LENGTHS_SLOT_TIME_SHIFT),
+ 			
+ 			/* Receive rules. */
+ 			MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS,
+ 			RCVLPC_CONFIG, 0x0181,
+ 			
+ 			/* Receive/send statistics. */
+ 			RCVLPC_STATS_ENABLE, 0xffffff,
+ 			RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE,
+ 			SNDDATAI_STATSENAB, 0xffffff,
+ 			SNDDATAI_STATSCTRL, (SNDDATAI_SCTRL_ENABLE |SNDDATAI_SCTRL_FASTUPD),
+ 			
+ 			/* Host coalescing engine */
+ 			HOSTCC_RXCOL_TICKS, 0,
+ 			HOSTCC_TXCOL_TICKS, LOW_TXCOL_TICKS,
+ 			HOSTCC_RXMAX_FRAMES, 1,
+ 			HOSTCC_TXMAX_FRAMES, LOW_RXMAX_FRAMES,
+ 			HOSTCC_RXCOAL_MAXF_INT, 1,
+ 			HOSTCC_TXCOAL_MAXF_INT, 0,
+ 			
+ 			/* Status/statistics block address. */
+ 			/* Etherboot lives below 4GB, so HIGH == 0 */
+ 			HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+ 
+ 			/* No need to enable 32byte coalesce mode. */
+ 			HOSTCC_MODE, HOSTCC_MODE_ENABLE | 0,
+ 			
+ 			RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE,
+ 			RCVLPC_MODE, RCVLPC_MODE_ENABLE,
+ 			
+ 			RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE,
+ 
+ 			SNDDATAC_MODE, SNDDATAC_MODE_ENABLE,
+ 			SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE,
+ 			RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB,
+ 			RCVDBDI_MODE, RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ,
+ 			SNDDATAI_MODE, SNDDATAI_MODE_ENABLE,
+ 			SNDBDI_MODE, SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE,
+ 			SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE,
+ 			
+ 			/* Accept all multicast frames. */
+ 			MAC_HASH_REG_0, 0xffffffff,
+ 			MAC_HASH_REG_1, 0xffffffff,
+ 			MAC_HASH_REG_2, 0xffffffff,
+ 			MAC_HASH_REG_3, 0xffffffff,
+ 		};
+ 		static const uint32_t table_not_5705[] = {
+ 			/* Host coalescing engine */
+ 			HOSTCC_RXCOAL_TICK_INT, 0,
+ 			HOSTCC_TXCOAL_TICK_INT, 0,
+ 
+ 			/* Status/statistics block address. */
+ 			/* Etherboot lives below 4GB, so HIGH == 0 */
+ 			HOSTCC_STAT_COAL_TICKS, DEFAULT_STAT_COAL_TICKS,
+ 			HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+ 			HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK,
+ 			HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK,
+ 
+ 			RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE,
+ 
+ 			MBFREE_MODE, MBFREE_MODE_ENABLE,
+ 		};
+ 		TG3_WRITE_SETTINGS(table_all);
+ 		tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+ 			virt_to_bus(tp->hw_stats));
+ 		tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+ 			virt_to_bus(tp->hw_status));
+ 		if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+ 			TG3_WRITE_SETTINGS(table_not_5705);
+ 		}
+ 	}
+ 
+ 	tp->tx_mode = TX_MODE_ENABLE;
+ 	tw32_carefully(MAC_TX_MODE, tp->tx_mode);
+ 
+ 	tp->rx_mode = RX_MODE_ENABLE;
+ 	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+ 
+ 	tp->mi_mode = MAC_MI_MODE_BASE;
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+ 
+ 	tw32(MAC_LED_CTRL, 0);
+ 	tw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);
+ 	tw32_carefully(MAC_RX_MODE, RX_MODE_RESET);
+ 	tp->rx_mode |= RX_MODE_KEEP_VLAN_TAG; /* drop tagged vlan packets */
+ 	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+ 
+ 	if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1)
+ 		tw32(MAC_SERDES_CFG, 0x616000);
+ 
+ 	/* Prevent chip from dropping frames when flow control
+ 	 * is enabled.
+ 	 */
+ 	tw32(MAC_LOW_WMARK_MAX_RX_FRAME, 2);
+ 	tr32(MAC_LOW_WMARK_MAX_RX_FRAME);
+ 
+ 	err = tg3_setup_phy(tp);
+ 
+ 	/* Ignore CRC stats */
+ 
+ 	/* Initialize receive rules. */
+ 	tw32(MAC_RCV_RULE_0,  0xc2000000 & RCV_RULE_DISABLE_MASK);
+ 	tw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);
+ 	tw32(MAC_RCV_RULE_1,  0x86000004 & RCV_RULE_DISABLE_MASK);
+ 	tw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)
+ 		limit = 8;
+ 	else
+ 		limit = 16;
+ 	if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF)
+ 		limit -= 4;
+ 	switch (limit) {
+ 	case 16:	tw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);
+ 	case 15:	tw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);
+ 	case 14:	tw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);
+ 	case 13:	tw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);
+ 	case 12:	tw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);
+ 	case 11:	tw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);
+ 	case 10:	tw32(MAC_RCV_RULE_9,  0);  tw32(MAC_RCV_VALUE_9,  0);
+ 	case 9:		tw32(MAC_RCV_RULE_8,  0);  tw32(MAC_RCV_VALUE_8,  0);
+ 	case 8:		tw32(MAC_RCV_RULE_7,  0);  tw32(MAC_RCV_VALUE_7,  0);
+ 	case 7:		tw32(MAC_RCV_RULE_6,  0);  tw32(MAC_RCV_VALUE_6,  0);
+ 	case 6:		tw32(MAC_RCV_RULE_5,  0);  tw32(MAC_RCV_VALUE_5,  0);
+ 	case 5:		tw32(MAC_RCV_RULE_4,  0);  tw32(MAC_RCV_VALUE_4,  0);
+ 	case 4:		/* tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0); */
+ 	case 3:		/* tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0); */
+ 	case 2:
+ 	case 1:
+ 	default:
+ 		break;
+ 	};
+ 
+ 	return err;
+ }
+ 
+ 
+ 
+ /* Chips other than 5700/5701 use the NVRAM for fetching info. */
+ static void tg3_nvram_init(struct tg3 *tp)
+ {
+ 	tw32(GRC_EEPROM_ADDR,
+ 	     (EEPROM_ADDR_FSM_RESET |
+ 	      (EEPROM_DEFAULT_CLOCK_PERIOD <<
+ 	       EEPROM_ADDR_CLKPERD_SHIFT)));
+ 
+ 	mdelay(1);
+ 
+ 	/* Enable seeprom accesses. */
+ 	tw32_carefully(GRC_LOCAL_CTRL,
+ 		tr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+ 	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
+ 		uint32_t nvcfg1 = tr32(NVRAM_CFG1);
+ 
+ 		tp->tg3_flags |= TG3_FLAG_NVRAM;
+ 		if (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {
+ 			if (nvcfg1 & NVRAM_CFG1_BUFFERED_MODE)
+ 				tp->tg3_flags |= TG3_FLAG_NVRAM_BUFFERED;
+ 		} else {
+ 			nvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;
+ 			tw32(NVRAM_CFG1, nvcfg1);
+ 		}
+ 
+ 	} else {
+ 		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
+ 	}
+ }
+ 
+ 
+ static int tg3_nvram_read_using_eeprom(
+ 	struct tg3 *tp __unused, uint32_t offset, uint32_t *val)
+ {
+ 	uint32_t tmp;
+ 	int i;
+ 
+ 	if (offset > EEPROM_ADDR_ADDR_MASK ||
+ 		(offset % 4) != 0) {
+ 		return -EINVAL;
+ 	}
+ 
+ 	tmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |
+ 					EEPROM_ADDR_DEVID_MASK |
+ 					EEPROM_ADDR_READ);
+ 	tw32(GRC_EEPROM_ADDR,
+ 	     tmp |
+ 	     (0 << EEPROM_ADDR_DEVID_SHIFT) |
+ 	     ((offset << EEPROM_ADDR_ADDR_SHIFT) &
+ 	      EEPROM_ADDR_ADDR_MASK) |
+ 	     EEPROM_ADDR_READ | EEPROM_ADDR_START);
+ 
+ 	for (i = 0; i < 10000; i++) {
+ 		tmp = tr32(GRC_EEPROM_ADDR);
+ 
+ 		if (tmp & EEPROM_ADDR_COMPLETE)
+ 			break;
+ 		udelay(100);
+ 	}
+ 	if (!(tmp & EEPROM_ADDR_COMPLETE)) {
+ 		return -EBUSY;
+ 	}
+ 
+ 	*val = tr32(GRC_EEPROM_DATA);
+ 	return 0;
+ }
+ 
+ static int tg3_nvram_read(struct tg3 *tp, uint32_t offset, uint32_t *val)
+ {
+ 	int i, saw_done_clear;
+ 
+ 	if (!(tp->tg3_flags & TG3_FLAG_NVRAM))
+ 		return tg3_nvram_read_using_eeprom(tp, offset, val);
+ 
+ 	if (tp->tg3_flags & TG3_FLAG_NVRAM_BUFFERED)
+ 		offset = ((offset / NVRAM_BUFFERED_PAGE_SIZE) <<
+ 			  NVRAM_BUFFERED_PAGE_POS) +
+ 			(offset % NVRAM_BUFFERED_PAGE_SIZE);
+ 
+ 	if (offset > NVRAM_ADDR_MSK)
+ 		return -EINVAL;
+ 
+ 	tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+ 	for (i = 0; i < 1000; i++) {
+ 		if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+ 			break;
+ 		udelay(20);
+ 	}
+ 
+ 	tw32(NVRAM_ADDR, offset);
+ 	tw32(NVRAM_CMD,
+ 	     NVRAM_CMD_RD | NVRAM_CMD_GO |
+ 	     NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+ 
+ 	/* Wait for done bit to clear then set again. */
+ 	saw_done_clear = 0;
+ 	for (i = 0; i < 1000; i++) {
+ 		udelay(10);
+ 		if (!saw_done_clear &&
+ 		    !(tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+ 			saw_done_clear = 1;
+ 		else if (saw_done_clear &&
+ 			 (tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+ 			break;
+ 	}
+ 	if (i >= 1000) {
+ 		tw32(NVRAM_SWARB, SWARB_REQ_CLR1);
+ 		return -EBUSY;
+ 	}
+ 
+ 	*val = bswap_32(tr32(NVRAM_RDDATA));
+ 	tw32(NVRAM_SWARB, 0x20);
+ 
+ 	return 0;
+ }
+ 
+ struct subsys_tbl_ent {
+ 	uint16_t subsys_vendor, subsys_devid;
+ 	uint32_t phy_id;
+ };
+ 
+ static struct subsys_tbl_ent subsys_id_to_phy_id[] = {
+ 	/* Broadcom boards. */
+ 	{ 0x14e4, 0x1644, PHY_ID_BCM5401 }, /* BCM95700A6 */
+ 	{ 0x14e4, 0x0001, PHY_ID_BCM5701 }, /* BCM95701A5 */
+ 	{ 0x14e4, 0x0002, PHY_ID_BCM8002 }, /* BCM95700T6 */
+ 	{ 0x14e4, 0x0003, PHY_ID_SERDES  }, /* BCM95700A9 */
+ 	{ 0x14e4, 0x0005, PHY_ID_BCM5701 }, /* BCM95701T1 */
+ 	{ 0x14e4, 0x0006, PHY_ID_BCM5701 }, /* BCM95701T8 */
+ 	{ 0x14e4, 0x0007, PHY_ID_SERDES  }, /* BCM95701A7 */
+ 	{ 0x14e4, 0x0008, PHY_ID_BCM5701 }, /* BCM95701A10 */
+ 	{ 0x14e4, 0x8008, PHY_ID_BCM5701 }, /* BCM95701A12 */
+ 	{ 0x14e4, 0x0009, PHY_ID_BCM5701 }, /* BCM95703Ax1 */
+ 	{ 0x14e4, 0x8009, PHY_ID_BCM5701 }, /* BCM95703Ax2 */
+ 
+ 	/* 3com boards. */
+ 	{ PCI_VENDOR_ID_3COM, 0x1000, PHY_ID_BCM5401 }, /* 3C996T */
+ 	{ PCI_VENDOR_ID_3COM, 0x1006, PHY_ID_BCM5701 }, /* 3C996BT */
+ 	/* { PCI_VENDOR_ID_3COM, 0x1002, PHY_ID_XXX },     3C996CT */
+ 	/* { PCI_VENDOR_ID_3COM, 0x1003, PHY_ID_XXX },     3C997T */
+ 	{ PCI_VENDOR_ID_3COM, 0x1004, PHY_ID_SERDES  }, /* 3C996SX */
+ 	/* { PCI_VENDOR_ID_3COM, 0x1005, PHY_ID_XXX },     3C997SZ */
+ 	{ PCI_VENDOR_ID_3COM, 0x1007, PHY_ID_BCM5701 }, /* 3C1000T */
+ 	{ PCI_VENDOR_ID_3COM, 0x1008, PHY_ID_BCM5701 }, /* 3C940BR01 */
+ 
+ 	/* DELL boards. */
+ 	{ PCI_VENDOR_ID_DELL, 0x00d1, PHY_ID_BCM5401 }, /* VIPER */
+ 	{ PCI_VENDOR_ID_DELL, 0x0106, PHY_ID_BCM5401 }, /* JAGUAR */
+ 	{ PCI_VENDOR_ID_DELL, 0x0109, PHY_ID_BCM5411 }, /* MERLOT */
+ 	{ PCI_VENDOR_ID_DELL, 0x010a, PHY_ID_BCM5411 }, /* SLIM_MERLOT */
+ 
+ 	/* Compaq boards. */
+ 	{ PCI_VENDOR_ID_COMPAQ, 0x007c, PHY_ID_BCM5701 }, /* BANSHEE */
+ 	{ PCI_VENDOR_ID_COMPAQ, 0x009a, PHY_ID_BCM5701 }, /* BANSHEE_2 */
+ 	{ PCI_VENDOR_ID_COMPAQ, 0x007d, PHY_ID_SERDES  }, /* CHANGELING */
+ 	{ PCI_VENDOR_ID_COMPAQ, 0x0085, PHY_ID_BCM5701 }, /* NC7780 */
+ 	{ PCI_VENDOR_ID_COMPAQ, 0x0099, PHY_ID_BCM5701 }  /* NC7780_2 */
+ };
+ 
+ static int tg3_phy_probe(struct tg3 *tp)
+ {
+ 	uint32_t eeprom_phy_id, hw_phy_id_1, hw_phy_id_2;
+ 	uint32_t hw_phy_id, hw_phy_id_masked;
+ 	enum phy_led_mode eeprom_led_mode;
+ 	uint32_t val;
+ 	unsigned i;
+ 	int eeprom_signature_found, err;
+ 
+ 	tp->phy_id = PHY_ID_INVALID;
+ 
+ 	for (i = 0; i < sizeof(subsys_id_to_phy_id)/sizeof(subsys_id_to_phy_id[0]); i++) {
+ 		if ((subsys_id_to_phy_id[i].subsys_vendor == tp->subsystem_vendor) &&
+ 			(subsys_id_to_phy_id[i].subsys_devid == tp->subsystem_device)) {
+ 			tp->phy_id = subsys_id_to_phy_id[i].phy_id;
+ 			break;
+ 		}
+ 	}
+ 
+ 	eeprom_phy_id = PHY_ID_INVALID;
+ 	eeprom_led_mode = led_mode_auto;
+ 	eeprom_signature_found = 0;
+ 	tg3_read_mem(NIC_SRAM_DATA_SIG, &val);
+ 	if (val == NIC_SRAM_DATA_SIG_MAGIC) {
+ 		uint32_t nic_cfg;
+ 
+ 		tg3_read_mem(NIC_SRAM_DATA_CFG, &nic_cfg);
+ 		tp->nic_sram_data_cfg = nic_cfg;
+ 
+ 		eeprom_signature_found = 1;
+ 
+ 		if ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==
+ 		    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER) {
+ 			eeprom_phy_id = PHY_ID_SERDES;
+ 		} else {
+ 			uint32_t nic_phy_id;
+ 
+ 			tg3_read_mem(NIC_SRAM_DATA_PHY_ID, &nic_phy_id);
+ 			if (nic_phy_id != 0) {
+ 				uint32_t id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;
+ 				uint32_t id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;
+ 
+ 				eeprom_phy_id  = (id1 >> 16) << 10;
+ 				eeprom_phy_id |= (id2 & 0xfc00) << 16;
+ 				eeprom_phy_id |= (id2 & 0x03ff) <<  0;
+ 			}
+ 		}
+ 
+ 		switch (nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK) {
+ 		case NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD:
+ 			eeprom_led_mode = led_mode_three_link;
+ 			break;
+ 
+ 		case NIC_SRAM_DATA_CFG_LED_LINK_SPD:
+ 			eeprom_led_mode = led_mode_link10;
+ 			break;
+ 
+ 		default:
+ 			eeprom_led_mode = led_mode_auto;
+ 			break;
+ 		};
+ 		if (((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+ 			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+ 			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) &&
+ 			(nic_cfg & NIC_SRAM_DATA_CFG_EEPROM_WP)) {
+ 			tp->tg3_flags |= TG3_FLAG_EEPROM_WRITE_PROT;
+ 		}
+ 
+ 		if (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE)
+ 			tp->tg3_flags |= TG3_FLAG_ENABLE_ASF;
+ 		if (nic_cfg & NIC_SRAM_DATA_CFG_FIBER_WOL)
+ 			tp->tg3_flags |= TG3_FLAG_SERDES_WOL_CAP;
+ 	}
+ 
+ 	/* Now read the physical PHY_ID from the chip and verify
+ 	 * that it is sane.  If it doesn't look good, we fall back
+ 	 * to either the hard-coded table based PHY_ID and failing
+ 	 * that the value found in the eeprom area.
+ 	 */
+ 	err  = tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);
+ 	err |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);
+ 
+ 	hw_phy_id  = (hw_phy_id_1 & 0xffff) << 10;
+ 	hw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;
+ 	hw_phy_id |= (hw_phy_id_2 & 0x03ff) <<  0;
+ 
+ 	hw_phy_id_masked = hw_phy_id & PHY_ID_MASK;
+ 
+ 	if (!err && KNOWN_PHY_ID(hw_phy_id_masked)) {
+ 		tp->phy_id = hw_phy_id;
+ 	} else {
+ 		/* phy_id currently holds the value found in the
+ 		 * subsys_id_to_phy_id[] table or PHY_ID_INVALID
+ 		 * if a match was not found there.
+ 		 */
+ 		if (tp->phy_id == PHY_ID_INVALID) {
+ 			if (!eeprom_signature_found ||
+ 			    !KNOWN_PHY_ID(eeprom_phy_id & PHY_ID_MASK))
+ 				return -ENODEV;
+ 			tp->phy_id = eeprom_phy_id;
+ 		}
+ 	}
+ 
+ 	err = tg3_phy_reset(tp);
+ 	if (err)
+ 		return err;
+ 
+ 	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+ 	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+ 		uint32_t mii_tg3_ctrl;
+ 		
+ 		/* These chips, when reset, only advertise 10Mb
+ 		 * capabilities.  Fix that.
+ 		 */
+ 		err  = tg3_writephy(tp, MII_ADVERTISE,
+ 				    (ADVERTISE_CSMA |
+ 				     ADVERTISE_PAUSE_CAP |
+ 				     ADVERTISE_10HALF |
+ 				     ADVERTISE_10FULL |
+ 				     ADVERTISE_100HALF |
+ 				     ADVERTISE_100FULL));
+ 		mii_tg3_ctrl = (MII_TG3_CTRL_ADV_1000_HALF |
+ 				MII_TG3_CTRL_ADV_1000_FULL |
+ 				MII_TG3_CTRL_AS_MASTER |
+ 				MII_TG3_CTRL_ENABLE_AS_MASTER);
+ 		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+ 			mii_tg3_ctrl = 0;
+ 
+ 		err |= tg3_writephy(tp, MII_TG3_CTRL, mii_tg3_ctrl);
+ 		err |= tg3_writephy(tp, MII_BMCR,
+ 				    (BMCR_ANRESTART | BMCR_ANENABLE));
+ 	}
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+ 		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+ 		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+ 		tg3_writedsp(tp, MII_TG3_DSP_RW_PORT, 0x2aaa);
+ 	}
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) {
+ 		tg3_writephy(tp, 0x1c, 0x8d68);
+ 		tg3_writephy(tp, 0x1c, 0x8d68);
+ 	}
+ 
+ 	/* Enable Ethernet@WireSpeed */
+ 	tg3_phy_set_wirespeed(tp);
+ 
+ 	if (!err && ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401)) {
+ 		err = tg3_init_5401phy_dsp(tp);
+ 	}
+ 
+ 	/* Determine the PHY led mode. 
+ 	 * Be careful if this gets set wrong it can result in an inability to 
+ 	 * establish a link.
+ 	 */
+ 	if (tp->phy_id == PHY_ID_SERDES) {
+ 		tp->led_mode = led_mode_three_link;
+ 	}
+ 	else if (tp->subsystem_vendor == PCI_VENDOR_ID_DELL) {
+ 		tp->led_mode = led_mode_link10;
+ 	} else {
+ 		tp->led_mode = led_mode_three_link;
+ 		if (eeprom_signature_found &&
+ 		    eeprom_led_mode != led_mode_auto)
+ 			tp->led_mode = eeprom_led_mode;
+ 	}
+ 
+ 	if (tp->phy_id == PHY_ID_SERDES)
+ 		tp->link_config.advertising =
+ 			(ADVERTISED_1000baseT_Half |
+ 			 ADVERTISED_1000baseT_Full |
+ 			 ADVERTISED_Autoneg |
+ 			 ADVERTISED_FIBRE);
+ 	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+ 		tp->link_config.advertising &=
+ 			~(ADVERTISED_1000baseT_Half |
+ 			  ADVERTISED_1000baseT_Full);
+ 
+ 	return err;
+ }
+ 
+ #if SUPPORT_PARTNO_STR
+ static void tg3_read_partno(struct tg3 *tp)
+ {
+ 	unsigned char vpd_data[256];
+ 	int i;
+ 
+ 	for (i = 0; i < 256; i += 4) {
+ 		uint32_t tmp;
+ 
+ 		if (tg3_nvram_read(tp, 0x100 + i, &tmp))
+ 			goto out_not_found;
+ 
+ 		vpd_data[i + 0] = ((tmp >>  0) & 0xff);
+ 		vpd_data[i + 1] = ((tmp >>  8) & 0xff);
+ 		vpd_data[i + 2] = ((tmp >> 16) & 0xff);
+ 		vpd_data[i + 3] = ((tmp >> 24) & 0xff);
+ 	}
+ 
+ 	/* Now parse and find the part number. */
+ 	for (i = 0; i < 256; ) {
+ 		unsigned char val = vpd_data[i];
+ 		int block_end;
+ 
+ 		if (val == 0x82 || val == 0x91) {
+ 			i = (i + 3 +
+ 			     (vpd_data[i + 1] +
+ 			      (vpd_data[i + 2] << 8)));
+ 			continue;
+ 		}
+ 
+ 		if (val != 0x90)
+ 			goto out_not_found;
+ 
+ 		block_end = (i + 3 +
+ 			     (vpd_data[i + 1] +
+ 			      (vpd_data[i + 2] << 8)));
+ 		i += 3;
+ 		while (i < block_end) {
+ 			if (vpd_data[i + 0] == 'P' &&
+ 			    vpd_data[i + 1] == 'N') {
+ 				int partno_len = vpd_data[i + 2];
+ 
+ 				if (partno_len > 24)
+ 					goto out_not_found;
+ 
+ 				memcpy(tp->board_part_number,
+ 				       &vpd_data[i + 3],
+ 				       partno_len);
+ 
+ 				/* Success. */
+ 				return;
+ 			}
+ 		}
+ 
+ 		/* Part number not found. */
+ 		goto out_not_found;
+ 	}
+ 
+ out_not_found:
+ 	memcpy(tp->board_part_number, "none", sizeof("none"));
+ }
+ #else
+ #define tg3_read_partno(TP) ((TP)->board_part_number[0] = '\0')
+ #endif
+ 
+ static int tg3_get_invariants(struct tg3 *tp)
+ {
+ 	uint32_t misc_ctrl_reg;
+ 	uint32_t pci_state_reg, grc_misc_cfg;
+ 	uint16_t pci_cmd;
+ 	uint8_t  pci_latency;
+ 	int err;
+ 
+ 	/* Read the subsystem vendor and device ids */
+ 	pci_read_config_word(tp->pdev, PCI_SUBSYSTEM_VENDOR_ID, &tp->subsystem_vendor);
+ 	pci_read_config_word(tp->pdev, PCI_SUBSYSTEM_ID, &tp->subsystem_device);
+ 
+ 	/* The sun_5704 code needs infrastructure etherboot does have
+ 	 * ignore it for now.
+ 	 */
+ 
+ 	/* If we have an AMD 762 or Intel ICH/ICH0 chipset, write
+ 	 * reordering to the mailbox registers done by the host
+ 	 * controller can cause major troubles.  We read back from
+ 	 * every mailbox register write to force the writes to be
+ 	 * posted to the chip in order.
+ 	 *
+ 	 * TG3_FLAG_MBOX_WRITE_REORDER has been forced on.
+ 	 */
+ 
+ 	/* Force memory write invalidate off.  If we leave it on,
+ 	 * then on 5700_BX chips we have to enable a workaround.
+ 	 * The workaround is to set the TG3PCI_DMA_RW_CTRL boundry
+ 	 * to match the cacheline size.  The Broadcom driver have this
+ 	 * workaround but turns MWI off all the times so never uses
+ 	 * it.  This seems to suggest that the workaround is insufficient.
+ 	 */
+ 	pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+ 	pci_cmd &= ~PCI_COMMAND_INVALIDATE;
+ 	/* Also, force SERR#/PERR# in PCI command. */
+ 	pci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+ 	pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+ 
+ 	/* It is absolutely critical that TG3PCI_MISC_HOST_CTRL
+ 	 * has the register indirect write enable bit set before
+ 	 * we try to access any of the MMIO registers.  It is also
+ 	 * critical that the PCI-X hw workaround situation is decided
+ 	 * before that as well.
+ 	 */
+ 	pci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL, &misc_ctrl_reg);
+ 
+ 	tp->pci_chip_rev_id = (misc_ctrl_reg >> MISC_HOST_CTRL_CHIPREV_SHIFT);
+ 
+ 	/* Initialize misc host control in PCI block. */
+ 	tp->misc_host_ctrl |= (misc_ctrl_reg &
+ 			       MISC_HOST_CTRL_CHIPREV);
+ 	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+ 			       tp->misc_host_ctrl);
+ 
+ 	pci_read_config_byte(tp->pdev, PCI_LATENCY_TIMER, &pci_latency);
+ 	if (pci_latency < 64) {
+ 		pci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER, 64);
+ 	}
+ 
+ 	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE, &pci_state_reg);
+ 
+ 	/* If this is a 5700 BX chipset, and we are in PCI-X
+ 	 * mode, enable register write workaround.
+ 	 *
+ 	 * The workaround is to use indirect register accesses
+ 	 * for all chip writes not to mailbox registers.
+ 	 *
+ 	 * In etherboot to simplify things we just always use this work around.
+ 	 */
+ 	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0) {
+ 		tp->tg3_flags |= TG3_FLAG_PCIX_MODE;
+ 	}
+ 	/* Back to back register writes can cause problems on the 5701,
+ 	 * the workaround is to read back all reg writes except those to
+ 	 * mailbox regs.
+ 	 * In etherboot we always use indirect register accesses so
+ 	 * we don't see this.
+ 	 */
+ 
+ 	if ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)
+ 		tp->tg3_flags |= TG3_FLAG_PCI_HIGH_SPEED;
+ 	if ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)
+ 		tp->tg3_flags |= TG3_FLAG_PCI_32BIT;
+ 
+ 	/* Chip-specific fixup from Broadcom driver */
+ 	if ((tp->pci_chip_rev_id == CHIPREV_ID_5704_A0) &&
+ 	    (!(pci_state_reg & PCISTATE_RETRY_SAME_DMA))) {
+ 		pci_state_reg |= PCISTATE_RETRY_SAME_DMA;
+ 		pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, pci_state_reg);
+ 	}
+ 
+ 	/* Force the chip into D0. */
+ 	tg3_set_power_state_0(tp);
+ 
+ 	/* Etherboot does not ask the tg3 to do checksums */
+ 	/* Etherboot does not ask the tg3 to do jumbo frames */
+ 	/* Ehterboot does not ask the tg3 to use WakeOnLan. */
+ 
+ 	/* A few boards don't want Ethernet@WireSpeed phy feature */
+ 	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) ||
+ 		((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
+ 			(tp->pci_chip_rev_id != CHIPREV_ID_5705_A0) &&
+ 			(tp->pci_chip_rev_id != CHIPREV_ID_5705_A1))) {
+ 		tp->tg3_flags2 |= TG3_FLG2_NO_ETH_WIRE_SPEED;
+ 	}
+ 
+ 	/* Avoid tagged irq status etherboot does not use irqs */
+ 
+ 	/* Only 5701 and later support tagged irq status mode.
+ 	 * Also, 5788 chips cannot use tagged irq status.
+ 	 *
+ 	 * However, since etherboot does not use irqs avoid tagged irqs
+ 	 * status  because the interrupt condition is more difficult to
+ 	 * fully clear in that mode.
+ 	 */
+ 	
+ 	/* Since some 5700_AX && 5700_BX have problems with 32BYTE
+ 	 * coalesce_mode, and the rest work fine anything set.
+ 	 * Don't enable HOST_CC_MODE_32BYTE in etherboot.
+ 	 */
+ 
+ 	/* Initialize MAC MI mode, polling disabled. */
+ 	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+ 
+ 	/* Initialize data/descriptor byte/word swapping. */
+ 	tw32(GRC_MODE, tp->grc_mode);
+ 
+ 	tg3_switch_clocks(tp);
+ 
+ 	/* Clear this out for sanity. */
+ 	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+ 
+ 	/* Etherboot does not need to check if the PCIX_TARGET_HWBUG
+ 	 * is needed.  It always uses it.
+ 	 */
+ 	
+ 	udelay(50);
+ 	tg3_nvram_init(tp);
+ 
+ 	/* The TX descriptors will reside in main memory.
+ 	 */
+ 
+ 	/* See which board we are using.
+ 	 */
+ 	grc_misc_cfg = tr32(GRC_MISC_CFG);
+ 	grc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704 &&
+ 	    grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5704CIOBE) {
+ 		tp->tg3_flags |= TG3_FLAG_SPLIT_MODE;
+ 		tp->split_mode_max_reqs = SPLIT_MODE_5704_MAX_REQ;
+ 	}
+ 
+ 	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705 &&
+ 	    (grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788 ||
+ 	     grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788M))
+ 		tp->tg3_flags2 |= TG3_FLG2_IS_5788;
+ 
+ 	/* these are limited to 10/100 only */
+ 	if (((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) &&
+ 		    ((grc_misc_cfg == 0x8000) || (grc_misc_cfg == 0x4000))) ||
+ 		((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
+ 			(tp->pdev->vendor == PCI_VENDOR_ID_BROADCOM) &&
+ 			((tp->pdev->dev_id == PCI_DEVICE_ID_TIGON3_5901) ||
+ 				(tp->pdev->dev_id == PCI_DEVICE_ID_TIGON3_5901_2)))) {
+ 		tp->tg3_flags |= TG3_FLAG_10_100_ONLY;
+ 	}
+ 
+ 	err = tg3_phy_probe(tp);
+ 	if (err) {
+ 		printf("phy probe failed, err %d\n", err);
+ 	}
+ 
+ 	tg3_read_partno(tp);
+ 
+ 
+ 	/* 5700 BX chips need to have their TX producer index mailboxes
+ 	 * written twice to workaround a bug.
+ 	 * In etherboot we do this unconditionally to simplify things.
+ 	 */
+ 
+ 	/* 5700 chips can get confused if TX buffers straddle the
+ 	 * 4GB address boundary in some cases.
+ 	 * 
+ 	 * In etherboot we can ignore the problem as etherboot lives below 4GB.
+ 	 */
+ 
+ 	/* In etherboot wake-on-lan is unconditionally disabled */
+ 	return err;
+ }
+ 
+ static int  tg3_get_device_address(struct tg3 *tp)
+ {
+ 	struct nic *nic = tp->nic;
+ 	uint32_t hi, lo, mac_offset;
+ 
+ 	if (PCI_FUNC(tp->pdev->devfn) == 0)
+ 		mac_offset = 0x7c;
+ 	else
+ 		mac_offset = 0xcc;
+ 
+ 	/* First try to get it from MAC address mailbox. */
+ 	tg3_read_mem(NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);
+ 	if ((hi >> 16) == 0x484b) {
+ 		nic->node_addr[0] = (hi >>  8) & 0xff;
+ 		nic->node_addr[1] = (hi >>  0) & 0xff;
+ 
+ 		tg3_read_mem(NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);
+ 		nic->node_addr[2] = (lo >> 24) & 0xff;
+ 		nic->node_addr[3] = (lo >> 16) & 0xff;
+ 		nic->node_addr[4] = (lo >>  8) & 0xff;
+ 		nic->node_addr[5] = (lo >>  0) & 0xff;
+ 	}
+ 	/* Next, try NVRAM. */
+ 	else if (!tg3_nvram_read(tp, mac_offset + 0, &hi) &&
+ 		 !tg3_nvram_read(tp, mac_offset + 4, &lo)) {
+ 		nic->node_addr[0] = ((hi >> 16) & 0xff);
+ 		nic->node_addr[1] = ((hi >> 24) & 0xff);
+ 		nic->node_addr[2] = ((lo >>  0) & 0xff);
+ 		nic->node_addr[3] = ((lo >>  8) & 0xff);
+ 		nic->node_addr[4] = ((lo >> 16) & 0xff);
+ 		nic->node_addr[5] = ((lo >> 24) & 0xff);
+ 	}
+ 	/* Finally just fetch it out of the MAC control regs. */
+ 	else {
+ 		hi = tr32(MAC_ADDR_0_HIGH);
+ 		lo = tr32(MAC_ADDR_0_LOW);
+ 
+ 		nic->node_addr[5] = lo & 0xff;
+ 		nic->node_addr[4] = (lo >> 8) & 0xff;
+ 		nic->node_addr[3] = (lo >> 16) & 0xff;
+ 		nic->node_addr[2] = (lo >> 24) & 0xff;
+ 		nic->node_addr[1] = hi & 0xff;
+ 		nic->node_addr[0] = (hi >> 8) & 0xff;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ 
+ static int tg3_setup_dma(struct tg3 *tp)
+ {
+ 	tw32(TG3PCI_CLOCK_CTRL, 0);
+ 
+ 	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) == 0) {
+ 		tp->dma_rwctrl =
+ 			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+ 			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+ 			(0x7 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+ 			(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+ 			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+ 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+ 			tp->dma_rwctrl &= ~(DMA_RWCTRL_MIN_DMA << DMA_RWCTRL_MIN_DMA_SHIFT);
+ 		}
+ 	} else {
+ 		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)
+ 			tp->dma_rwctrl =
+ 				(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+ 				(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+ 				(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+ 				(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+ 				(0x00 << DMA_RWCTRL_MIN_DMA_SHIFT);
+ 		else
+ 			tp->dma_rwctrl =
+ 				(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+ 				(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+ 				(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+ 				(0x3 << DMA_RWCTRL_READ_WATER_SHIFT) |
+ 				(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+ 
+ 		/* Wheee, some more chip bugs... */
+ 		if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+ 			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)) {
+ 			uint32_t ccval = tr32(TG3PCI_CLOCK_CTRL) & 0x1f;
+ 
+ 			if ((ccval == 0x6) || (ccval == 0x7)) {
+ 				tp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;
+ 			}
+ 		}
+ 	}
+ 
+ 	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+ 		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)) {
+ 		tp->dma_rwctrl &= ~(DMA_RWCTRL_MIN_DMA << DMA_RWCTRL_MIN_DMA_SHIFT);
+ 	}
+ 
+ 	tp->dma_rwctrl |= DMA_RWCTRL_ASSERT_ALL_BE;
+ 
+ 	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+ 
+ 	return 0;
+ }
+ 
+ static void tg3_init_link_config(struct tg3 *tp)
+ {
+ 	tp->link_config.advertising =
+ 		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+ 		 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+ 		 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+ 		 ADVERTISED_Autoneg | ADVERTISED_MII);
+ 	tp->carrier_ok = 0;
+ 	tp->link_config.active_speed = SPEED_INVALID;
+ 	tp->link_config.active_duplex = DUPLEX_INVALID;
+ }
+ 
+ 
+ #if SUPPORT_PHY_STR
+ static const char * tg3_phy_string(struct tg3 *tp)
+ {
+ 	switch (tp->phy_id & PHY_ID_MASK) {
+ 	case PHY_ID_BCM5400:	return "5400";
+ 	case PHY_ID_BCM5401:	return "5401";
+ 	case PHY_ID_BCM5411:	return "5411";
+ 	case PHY_ID_BCM5701:	return "5701";
+ 	case PHY_ID_BCM5703:	return "5703";
+ 	case PHY_ID_BCM5704:	return "5704";
+ 	case PHY_ID_BCM8002:	return "8002";
+ 	case PHY_ID_SERDES:	return "serdes";
+ 	default:		return "unknown";
+ 	};
+ }
+ #else
+ #define tg3_phy_string(TP) "?"
+ #endif
+ 
+ 
+ static void tg3_poll_link(struct tg3 *tp)
+ {
+ 	uint32_t mac_stat;
+ 
+ 	mac_stat = tr32(MAC_STATUS);
+ 	if (tp->phy_id == PHY_ID_SERDES) {
+ 		if (tp->carrier_ok?
+ 			(mac_stat & MAC_STATUS_LNKSTATE_CHANGED):
+ 			(mac_stat & MAC_STATUS_PCS_SYNCED)) {
+ 			tw32_carefully(MAC_MODE, tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK);
+ 			tw32_carefully(MAC_MODE, tp->mac_mode);
+ 
+ 			tg3_setup_phy(tp);
+ 		}
+ 	}
+ 	else {
+ 		if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED) {
+ 			tg3_setup_phy(tp);
+ 		}
+ 	}
+ }
+ 
+ /**************************************************************************
+ POLL - Wait for a frame
+ ***************************************************************************/
+ static void tg3_ack_irqs(struct tg3 *tp)
+ {
+ 	if (tp->hw_status->status & SD_STATUS_UPDATED) {
+ 		/*
+ 		 * writing any value to intr-mbox-0 clears PCI INTA# and
+ 		 * chip-internal interrupt pending events.
+ 		 * writing non-zero to intr-mbox-0 additional tells the
+ 		 * NIC to stop sending us irqs, engaging "in-intr-handler"
+ 		 * event coalescing.
+ 		 */
+ 		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 
+ 			0x00000001);
+ 		/*
+ 		 * Flush PCI write.  This also guarantees that our
+ 		 * status block has been flushed to host memory.
+ 		 */
+ 		tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
+ 		tp->hw_status->status &= ~SD_STATUS_UPDATED;
+ 	}
+ }
+ 
+ static int tg3_poll(struct nic *nic)
+ {
+ 	/* return true if there's an ethernet packet ready to read */
+ 	/* nic->packet should contain data on return */
+ 	/* nic->packetlen should contain length of data */
+ 
+ 	struct tg3 *tp = &tg3;
+ 	int result;
+ 
+ 	result = 0;
+ 	tg3_ack_irqs(tp);
+ 	if (tp->hw_status->idx[0].rx_producer != tp->rx_rcb_ptr) {
+ 		struct tg3_rx_buffer_desc *desc;
+ 		unsigned int len;
+ 		desc = &tp->rx_rcb[tp->rx_rcb_ptr];
+ 		if ((desc->opaque & RXD_OPAQUE_RING_MASK) == RXD_OPAQUE_RING_STD) {
+ 			len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) - 4; /* omit crc */
+ 			
+ 			nic->packetlen = len;
+ 			memcpy(nic->packet, bus_to_virt(desc->addr_lo), len);
+ 			result = 1;
+ 		}
+ 		tp->rx_rcb_ptr = (tp->rx_rcb_ptr + 1) % TG3_RX_RCB_RING_SIZE;
+ 		
+ 		/* ACK the status ring */
+ 		tw32_mailbox2(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, tp->rx_rcb_ptr);
+ 
+ 		/* Refill RX ring. */
+ 		if (result) {
+ 			tp->rx_std_ptr = (tp->rx_std_ptr + 1) % TG3_RX_RING_SIZE;
+ 			tw32_mailbox2(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW, tp->rx_std_ptr);
+ 		}
+ 	}
+ 	tg3_poll_link(tp);
+ 	return result;
+ }
+ 
+ /**************************************************************************
+ TRANSMIT - Transmit a frame
+ ***************************************************************************/
+ static void tg3_set_txd(struct tg3 *tp, int entry,
+ 	dma_addr_t mapping, int len, uint32_t flags,
+ 	uint32_t mss_and_is_end)
+ {
+ 	struct tg3_tx_buffer_desc *txd =  &tp->tx_ring[entry];
+ 	int is_end = (mss_and_is_end & 0x1);
+ 	if (is_end) {
+ 		flags |= TXD_FLAG_END;
+ 	}
+ 
+ 	txd->addr_hi   = 0;
+ 	txd->addr_lo   = mapping & 0xffffffff;
+ 	txd->len_flags = (len << TXD_LEN_SHIFT) | flags;
+ 	txd->vlan_tag  = 0 << TXD_VLAN_TAG_SHIFT;
+ }
+ 
+ static void tg3_transmit(struct nic *nic, const char *dst_addr,
+ 	unsigned int type, unsigned int size, const char *packet)
+ {
+ 	static struct eth_frame {
+ 		uint8_t  dst_addr[ETH_ALEN];
+ 		uint8_t  src_addr[ETH_ALEN];
+ 		uint16_t type;
+ 		uint8_t  data [ETH_FRAME_LEN - ETH_HLEN];
+ 	} frame[2];
+ 	static int frame_idx;
+ 	
+ 	/* send the packet to destination */
+ 	struct tg3_tx_buffer_desc *txd;
+ 	struct tg3 *tp;
+ 	uint32_t entry;
+ 	int i;
+ 
+ 	/* Wait until there is a free packet frame */
+ 	tp = &tg3;
+ 	i = 0;
+ 	entry = tp->tx_prod;
+ 	while((tp->hw_status->idx[0].tx_consumer != entry) &&
+ 		(tp->hw_status->idx[0].tx_consumer != PREV_TX(entry))) {
+ 		mdelay(10);	/* give the nick a chance */
+ 		poll_interruptions();
+ 		if (++i > 500) { /* timeout 5s for transmit */
+ 			printf("transmit timed out\n");
+ 			tg3_halt(tp);
+ 			tg3_setup_hw(tp);
+ 			return;
+ 		}
+ 	}
+ 	if (i != 0) {
+ 		printf("#");
+ 	}
+ 	
+ 	/* Copy the packet to the our local buffer */
+ 	memcpy(&frame[frame_idx].dst_addr, dst_addr, ETH_ALEN);
+ 	memcpy(&frame[frame_idx].src_addr, nic->node_addr, ETH_ALEN);
+ 	frame[frame_idx].type = htons(type);
+ 	memset(&frame[frame_idx].data, 0, sizeof(frame[frame_idx].data));
+ 	memcpy(&frame[frame_idx].data, packet, size);
+ 
+ 	/* Setup the ring buffer entry to transmit */
+ 	txd            = &tp->tx_ring[entry];
+ 	txd->addr_hi   = 0; /* Etherboot runs under 4GB */
+ 	txd->addr_lo   = virt_to_bus(&frame[frame_idx]);
+ 	txd->len_flags = ((size + ETH_HLEN) << TXD_LEN_SHIFT) | TXD_FLAG_END;
+ 	txd->vlan_tag  = 0 << TXD_VLAN_TAG_SHIFT;
+ 
+ 	/* Advance to the next entry */
+ 	entry = NEXT_TX(entry);
+ 	frame_idx ^= 1;
+ 
+ 	/* Packets are ready, update Tx producer idx local and on card */
+ 	tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW), entry);
+ 	tw32_mailbox2((MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW), entry);
+ 	tp->tx_prod = entry;
+ }
+ 
+ /**************************************************************************
+ DISABLE - Turn off ethernet interface
+ ***************************************************************************/
+ static void tg3_disable(struct dev *dev __unused)
+ {
+ 	struct tg3 *tp = &tg3;
+ 	/* put the card in its initial state */
+ 	/* This function serves 3 purposes.
+ 	 * This disables DMA and interrupts so we don't receive
+ 	 *  unexpected packets or interrupts from the card after
+ 	 *  etherboot has finished. 
+ 	 * This frees resources so etherboot may use
+ 	 *  this driver on another interface
+ 	 * This allows etherboot to reinitialize the interface
+ 	 *  if something is something goes wrong.
+ 	 */
+ 	tg3_halt(tp);
+ 	tp->tg3_flags &= ~(TG3_FLAG_INIT_COMPLETE|TG3_FLAG_GOT_SERDES_FLOWCTL);
+ 	tp->carrier_ok = 0;
+ 	iounmap((void *)tp->regs);
+ }
+ 
+ 
+ 
+ /**************************************************************************
+ PROBE - Look for an adapter, this routine's visible to the outside
+ You should omit the last argument struct pci_device * for a non-PCI NIC
+ ***************************************************************************/
+ static int tg3_probe(struct dev *dev, struct pci_device *pdev)
+ {
+ 	struct nic *nic = (struct nic *)dev;
+ 	struct tg3 *tp = &tg3;
+ 	unsigned long tg3reg_base, tg3reg_len;
+ 	int i, err, pm_cap;
+ 
+ 	if (pdev == 0)
+ 		return 0;
+ 
+ 	memset(tp, 0, sizeof(*tp));
+ 
+ 	adjust_pci_device(pdev);
+ 
+ 	/* Find power-management capability. */
+ 	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+ 	if (pm_cap == 0) {
+ 		printf("Cannot find PowerManagement capability, aborting.\n");
+ 		return 0;
+ 	}
+ 	tg3reg_base = pci_bar_start(pdev, PCI_BASE_ADDRESS_0);
+ 	if (tg3reg_base == -1UL) {
+ 		printf("Unuseable bar\n");
+ 		return 0;
+ 	}
+ 	tg3reg_len  = pci_bar_size(pdev,  PCI_BASE_ADDRESS_0);
+ 
+ 	tp->pdev       = pdev;
+ 	tp->nic        = nic;
+ 	tp->pm_cap     = pm_cap;
+ 	tp->rx_mode    = 0;
+ 	tp->tx_mode    = 0;
+ 	tp->mi_mode    = MAC_MI_MODE_BASE;
+ 	tp->tg3_flags  = 0 & ~TG3_FLAG_INIT_COMPLETE; 
+ 	
+ 	/* The word/byte swap controls here control register access byte
+ 	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE
+ 	 * setting below.
+ 	 */
+ 	tp->misc_host_ctrl =
+ 		MISC_HOST_CTRL_MASK_PCI_INT |
+ 		MISC_HOST_CTRL_WORD_SWAP |
+ 		MISC_HOST_CTRL_INDIR_ACCESS |
+ 		MISC_HOST_CTRL_PCISTATE_RW;
+ 
+ 	/* The NONFRM (non-frame) byte/word swap controls take effect
+ 	 * on descriptor entries, anything which isn't packet data.
+ 	 *
+ 	 * The StrongARM chips on the board (one for tx, one for rx)
+ 	 * are running in big-endian mode.
+ 	 */
+ 	tp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |
+ 			GRC_MODE_WSWAP_NONFRM_DATA);
+ #if __BYTE_ORDER == __BIG_ENDIAN
+ 	tp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;
+ #endif
+ 	tp->regs = (unsigned long) ioremap(tg3reg_base, tg3reg_len);
+ 	if (tp->regs == 0UL) {
+ 		printf("Cannot map device registers, aborting\n");
+ 		return 0;
+ 	}
+ 
+ 	tg3_init_link_config(tp);
+ 
+ 	err = tg3_get_invariants(tp);
+ 	if (err) {
+ 		printf("Problem fetching invariants of chip, aborting.\n");
+ 		goto err_out_iounmap;
+ 	}
+ 
+ 	err = tg3_get_device_address(tp);
+ 	if (err) {
+ 		printf("Could not obtain valid ethernet address, aborting.\n");
+ 		goto err_out_iounmap;
+ 	}
+ 	printf("Ethernet addr: %!\n", nic->node_addr);
+ 
+ 	tg3_setup_dma(tp);
+ 
+ 	/* Now that we have fully setup the chip, save away a snapshot
+ 	 * of the PCI config space.  We need to restore this after
+ 	 * GRC_MISC_CFG core clock resets and some resume events.
+ 	 */
+ 	pci_save_state(tp->pdev, tp->pci_cfg_state);
+ 
+ 	printf("Tigon3 [partno(%s) rev %hx PHY(%s)] (PCI%s:%s:%s)\n",
+ 		tp->board_part_number,
+ 		tp->pci_chip_rev_id,
+ 		tg3_phy_string(tp),
+ 		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "X" : ""),
+ 		((tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED) ?
+ 			((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "133MHz" : "66MHz") :
+ 			((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "100MHz" : "33MHz")),
+ 		((tp->tg3_flags & TG3_FLAG_PCI_32BIT) ? "32-bit" : "64-bit"));
+ 
+ 
+ 	err = tg3_setup_hw(tp); 
+ 	if (err) {
+ 		goto err_out_disable;
+ 	} 
+ 	tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
+ 
+ 	/* Wait for a reasonable time for the link to come up */
+ 	tg3_poll_link(tp);
+ 	for(i = 0; !tp->carrier_ok && (i < VALID_LINK_TIMEOUT*100); i++) {
+ 		mdelay(1);
+ 		tg3_poll_link(tp);
+ 	}
+ 	if (!tp->carrier_ok){
+ 		printf("Valid link not established\n");
+ 		goto err_out_disable;
+ 	}
+ 
+ 	dev->disable  = tg3_disable;
+ 	nic->poll     = tg3_poll;
+ 	nic->transmit = tg3_transmit;
+ 	return 1;
+ 
+  err_out_iounmap:
+ 	iounmap((void *)tp->regs);
+ 	return 0;
+  err_out_disable:
+ 	tg3_disable(dev);
+ 	return 0;
+ }
+ 
+ static struct pci_id tg3_nics[] = {
+ PCI_ROM(0x14e4, 0x1644, "tg3-5700",        "Broadcom Tigon 3 5700"),
+ PCI_ROM(0x14e4, 0x1645, "tg3-5701",        "Broadcom Tigon 3 5701"),
+ PCI_ROM(0x14e4, 0x1646, "tg3-5702",        "Broadcom Tigon 3 5702"),
+ PCI_ROM(0x14e4, 0x1647, "tg3-5703",        "Broadcom Tigon 3 5703"),
+ PCI_ROM(0x14e4, 0x1648, "tg3-5704",        "Broadcom Tigon 3 5704"),
+ PCI_ROM(0x14e4, 0x164d, "tg3-5702FE",      "Broadcom Tigon 3 5702FE"),
+ PCI_ROM(0x14e4, 0x1653, "tg3-5705",        "Broadcom Tigon 3 5705"),
+ PCI_ROM(0x14e4, 0x1654, "tg3-5705_2",      "Broadcom Tigon 3 5705_2"),
+ PCI_ROM(0x14e4, 0x165d, "tg3-5705M",       "Broadcom Tigon 3 5705M"),
+ PCI_ROM(0x14e4, 0x165e, "tg3-5705M_2",     "Broadcom Tigon 3 5705M_2"),
+ PCI_ROM(0x14e4, 0x1696, "tg3-5782",        "Broadcom Tigon 3 5782"),
+ PCI_ROM(0x14e4, 0x169c, "tg3-5788",        "Broadcom Tigon 3 5788"),
+ PCI_ROM(0x14e4, 0x16a6, "tg3-5702X",       "Broadcom Tigon 3 5702X"),
+ PCI_ROM(0x14e4, 0x16a7, "tg3-5703X",       "Broadcom Tigon 3 5703X"),
+ PCI_ROM(0x14e4, 0x16a8, "tg3-5704S",       "Broadcom Tigon 3 5704S"),
+ PCI_ROM(0x14e4, 0x16c6, "tg3-5702A3",      "Broadcom Tigon 3 5702A3"),
+ PCI_ROM(0x14e4, 0x16c7, "tg3-5703A3",      "Broadcom Tigon 3 5703A3"),
+ PCI_ROM(0x14e4, 0x170d, "tg3-5901",        "Broadcom Tigon 3 5901"),
+ PCI_ROM(0x14e4, 0x170e, "tg3-5901_2",      "Broadcom Tigon 3 5901_2"),
+ PCI_ROM(0x1148, 0x4400, "tg3-9DXX",        "Sysconnet 9DXX"),
+ PCI_ROM(0x1148, 0x4500, "tg3-9MXX",        "Sysconnet 9MXX"),
+ PCI_ROM(0x173b, 0x03e8, "tg3-ac1000",      "Altima AC1000"),
+ PCI_ROM(0x173b, 0x03e9, "tg3-ac1001",      "Altima AC1001"),
+ PCI_ROM(0x173b, 0x03ea, "tg3-ac9100",      "Altima AC9100"),
+ PCI_ROM(0x173b, 0x03eb, "tg3-ac1003",      "Altima AC1003"),
+ };
+ 
+ struct pci_driver tg3_driver = {
+ 	.type	  = NIC_DRIVER,
+ 	.name	  = "TG3",
+ 	.probe	  = tg3_probe,
+ 	.ids	  = tg3_nics,
+ 	.id_count = sizeof(tg3_nics)/sizeof(tg3_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/tg3.h GRUB/netboot/tg3.h
*** GRUB_0.94/netboot/tg3.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/tg3.h	2003-11-20 11:46:08.000000000 +0800
***************
*** 0 ****
--- 1,2200 ----
+ /* $Id$
+  * tg3.h: Definitions for Broadcom Tigon3 ethernet driver.
+  *
+  * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+  * Copyright (C) 2001 Jeff Garzik (jgarzik@mandrakesoft.com)
+  */
+ 
+ #ifndef _T3_H
+ #define _T3_H
+ 
+ #include "stdint.h"
+ 
+ typedef unsigned long dma_addr_t;
+ 
+ /* From mii.h */
+ 
+ /* Indicates what features are advertised by the interface. */
+ #define ADVERTISED_10baseT_Half		(1 << 0)
+ #define ADVERTISED_10baseT_Full		(1 << 1)
+ #define ADVERTISED_100baseT_Half	(1 << 2)
+ #define ADVERTISED_100baseT_Full	(1 << 3)
+ #define ADVERTISED_1000baseT_Half	(1 << 4)
+ #define ADVERTISED_1000baseT_Full	(1 << 5)
+ #define ADVERTISED_Autoneg		(1 << 6)
+ #define ADVERTISED_TP			(1 << 7)
+ #define ADVERTISED_AUI			(1 << 8)
+ #define ADVERTISED_MII			(1 << 9)
+ #define ADVERTISED_FIBRE		(1 << 10)
+ #define ADVERTISED_BNC			(1 << 11)
+ 
+ /* The following are all involved in forcing a particular link
+  * mode for the device for setting things.  When getting the
+  * devices settings, these indicate the current mode and whether
+  * it was foced up into this mode or autonegotiated.
+  */
+ 
+ /* The forced speed, 10Mb, 100Mb, gigabit. */
+ #define SPEED_10		0
+ #define SPEED_100		1
+ #define SPEED_1000		2
+ #define SPEED_INVALID           3
+ 
+ 
+ /* Duplex, half or full. */
+ #define DUPLEX_HALF		0x00
+ #define DUPLEX_FULL		0x01
+ #define DUPLEX_INVALID          0x02
+ 
+ /* Which connector port. */
+ #define PORT_TP			0x00
+ #define PORT_AUI		0x01
+ #define PORT_MII		0x02
+ #define PORT_FIBRE		0x03
+ #define PORT_BNC		0x04
+ 
+ /* Which tranceiver to use. */
+ #define XCVR_INTERNAL		0x00
+ #define XCVR_EXTERNAL		0x01
+ #define XCVR_DUMMY1		0x02
+ #define XCVR_DUMMY2		0x03
+ #define XCVR_DUMMY3		0x04
+ 
+ /* Enable or disable autonegotiation.  If this is set to enable,
+  * the forced link modes above are completely ignored.
+  */
+ #define AUTONEG_DISABLE		0x00
+ #define AUTONEG_ENABLE		0x01
+ 
+ /* Wake-On-Lan options. */
+ #define WAKE_PHY		(1 << 0)
+ #define WAKE_UCAST		(1 << 1)
+ #define WAKE_MCAST		(1 << 2)
+ #define WAKE_BCAST		(1 << 3)
+ #define WAKE_ARP		(1 << 4)
+ #define WAKE_MAGIC		(1 << 5)
+ #define WAKE_MAGICSECURE	(1 << 6) /* only meaningful if WAKE_MAGIC */
+ 
+ /* Generic MII registers. */
+ 
+ #define MII_BMCR            0x00        /* Basic mode control register */
+ #define MII_BMSR            0x01        /* Basic mode status register  */
+ #define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+ #define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+ #define MII_ADVERTISE       0x04        /* Advertisement control reg   */
+ #define MII_LPA             0x05        /* Link partner ability reg    */
+ #define MII_EXPANSION       0x06        /* Expansion register          */
+ #define MII_DCOUNTER        0x12        /* Disconnect counter          */
+ #define MII_FCSCOUNTER      0x13        /* False carrier counter       */
+ #define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
+ #define MII_RERRCOUNTER     0x15        /* Receive error counter       */
+ #define MII_SREVISION       0x16        /* Silicon revision            */
+ #define MII_RESV1           0x17        /* Reserved...                 */
+ #define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
+ #define MII_PHYADDR         0x19        /* PHY address                 */
+ #define MII_RESV2           0x1a        /* Reserved...                 */
+ #define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
+ #define MII_NCONFIG         0x1c        /* Network interface config    */
+ 
+ /* Basic mode control register. */
+ #define BMCR_RESV               0x007f  /* Unused...                   */
+ #define BMCR_CTST               0x0080  /* Collision test              */
+ #define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
+ #define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
+ #define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
+ #define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
+ #define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
+ #define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
+ #define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
+ #define BMCR_RESET              0x8000  /* Reset the DP83840           */
+ 
+ /* Basic mode status register. */
+ #define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+ #define BMSR_JCD                0x0002  /* Jabber detected             */
+ #define BMSR_LSTATUS            0x0004  /* Link status                 */
+ #define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+ #define BMSR_RFAULT             0x0010  /* Remote fault detected       */
+ #define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
+ #define BMSR_RESV               0x07c0  /* Unused...                   */
+ #define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+ #define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+ #define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+ #define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+ #define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
+ 
+ /* Advertisement control register. */
+ #define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+ #define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+ #define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+ #define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+ #define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+ #define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+ #define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+ #define ADVERTISE_RESV          0x1c00  /* Unused...                   */
+ #define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+ #define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+ #define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+ 
+ #define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
+ 			ADVERTISE_CSMA)
+ #define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                        ADVERTISE_100HALF | ADVERTISE_100FULL)
+ 
+ /* Link partner ability register. */
+ #define LPA_SLCT                0x001f  /* Same as advertise selector  */
+ #define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
+ #define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
+ #define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
+ #define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
+ #define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
+ #define LPA_RESV                0x1c00  /* Unused...                   */
+ #define LPA_RFAULT              0x2000  /* Link partner faulted        */
+ #define LPA_LPACK               0x4000  /* Link partner acked us       */
+ #define LPA_NPAGE               0x8000  /* Next page bit               */
+ 
+ #define LPA_DUPLEX		(LPA_10FULL | LPA_100FULL)
+ #define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+ 
+ /* Expansion register for auto-negotiation. */
+ #define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
+ #define EXPANSION_LCWP          0x0002  /* Got new RX page code word   */
+ #define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
+ #define EXPANSION_NPCAPABLE     0x0008  /* Link partner supports npage */
+ #define EXPANSION_MFAULTS       0x0010  /* Multiple faults detected    */
+ #define EXPANSION_RESV          0xffe0  /* Unused...                   */
+ 
+ /* N-way test register. */
+ #define NWAYTEST_RESV1          0x00ff  /* Unused...                   */
+ #define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
+ #define NWAYTEST_RESV2          0xfe00  /* Unused...                   */
+ 
+ 
+ /* From tg3.h */
+ 
+ #define TG3_64BIT_REG_HIGH		0x00UL
+ #define TG3_64BIT_REG_LOW		0x04UL
+ 
+ /* Descriptor block info. */
+ #define TG3_BDINFO_HOST_ADDR		0x0UL /* 64-bit */
+ #define TG3_BDINFO_MAXLEN_FLAGS		0x8UL /* 32-bit */
+ #define  BDINFO_FLAGS_USE_EXT_RECV	 0x00000001 /* ext rx_buffer_desc */
+ #define  BDINFO_FLAGS_DISABLED		 0x00000002
+ #define  BDINFO_FLAGS_MAXLEN_MASK	 0xffff0000
+ #define  BDINFO_FLAGS_MAXLEN_SHIFT	 16
+ #define TG3_BDINFO_NIC_ADDR		0xcUL /* 32-bit */
+ #define TG3_BDINFO_SIZE			0x10UL
+ 
+ #define RX_COPY_THRESHOLD  		256
+ 
+ #define RX_STD_MAX_SIZE			1536
+ #define RX_STD_MAX_SIZE_5705		512
+ #define RX_JUMBO_MAX_SIZE		0xdeadbeef /* XXX */
+ 
+ /* First 256 bytes are a mirror of PCI config space. */
+ #define TG3PCI_VENDOR			0x00000000
+ #define  TG3PCI_VENDOR_BROADCOM		 0x14e4
+ #define TG3PCI_DEVICE			0x00000002
+ #define  TG3PCI_DEVICE_TIGON3_1		 0x1644 /* BCM5700 */
+ #define  TG3PCI_DEVICE_TIGON3_2		 0x1645 /* BCM5701 */
+ #define  TG3PCI_DEVICE_TIGON3_3		 0x1646 /* BCM5702 */
+ #define  TG3PCI_DEVICE_TIGON3_4		 0x1647 /* BCM5703 */
+ #define TG3PCI_COMMAND			0x00000004
+ #define TG3PCI_STATUS			0x00000006
+ #define TG3PCI_CCREVID			0x00000008
+ #define TG3PCI_CACHELINESZ		0x0000000c
+ #define TG3PCI_LATTIMER			0x0000000d
+ #define TG3PCI_HEADERTYPE		0x0000000e
+ #define TG3PCI_BIST			0x0000000f
+ #define TG3PCI_BASE0_LOW		0x00000010
+ #define TG3PCI_BASE0_HIGH		0x00000014
+ /* 0x18 --> 0x2c unused */
+ #define TG3PCI_SUBSYSVENID		0x0000002c
+ #define TG3PCI_SUBSYSID			0x0000002e
+ #define TG3PCI_ROMADDR			0x00000030
+ #define TG3PCI_CAPLIST			0x00000034
+ /* 0x35 --> 0x3c unused */
+ #define TG3PCI_IRQ_LINE			0x0000003c
+ #define TG3PCI_IRQ_PIN			0x0000003d
+ #define TG3PCI_MIN_GNT			0x0000003e
+ #define TG3PCI_MAX_LAT			0x0000003f
+ #define TG3PCI_X_CAPS			0x00000040
+ #define  PCIX_CAPS_RELAXED_ORDERING	 0x00020000
+ #define  PCIX_CAPS_SPLIT_MASK		 0x00700000
+ #define  PCIX_CAPS_SPLIT_SHIFT		 20
+ #define  PCIX_CAPS_BURST_MASK		 0x000c0000
+ #define  PCIX_CAPS_BURST_SHIFT		 18
+ #define  PCIX_CAPS_MAX_BURST_CPIOB	 2
+ #define TG3PCI_PM_CAP_PTR		0x00000041
+ #define TG3PCI_X_COMMAND		0x00000042
+ #define TG3PCI_X_STATUS			0x00000044
+ #define TG3PCI_PM_CAP_ID		0x00000048
+ #define TG3PCI_VPD_CAP_PTR		0x00000049
+ #define TG3PCI_PM_CAPS			0x0000004a
+ #define TG3PCI_PM_CTRL_STAT		0x0000004c
+ #define TG3PCI_BR_SUPP_EXT		0x0000004e
+ #define TG3PCI_PM_DATA			0x0000004f
+ #define TG3PCI_VPD_CAP_ID		0x00000050
+ #define TG3PCI_MSI_CAP_PTR		0x00000051
+ #define TG3PCI_VPD_ADDR_FLAG		0x00000052
+ #define  VPD_ADDR_FLAG_WRITE		0x00008000
+ #define TG3PCI_VPD_DATA			0x00000054
+ #define TG3PCI_MSI_CAP_ID		0x00000058
+ #define TG3PCI_NXT_CAP_PTR		0x00000059
+ #define TG3PCI_MSI_CTRL			0x0000005a
+ #define TG3PCI_MSI_ADDR_LOW		0x0000005c
+ #define TG3PCI_MSI_ADDR_HIGH		0x00000060
+ #define TG3PCI_MSI_DATA			0x00000064
+ /* 0x66 --> 0x68 unused */
+ #define TG3PCI_MISC_HOST_CTRL		0x00000068
+ #define  MISC_HOST_CTRL_CLEAR_INT	 0x00000001
+ #define  MISC_HOST_CTRL_MASK_PCI_INT	 0x00000002
+ #define  MISC_HOST_CTRL_BYTE_SWAP	 0x00000004
+ #define  MISC_HOST_CTRL_WORD_SWAP	 0x00000008
+ #define  MISC_HOST_CTRL_PCISTATE_RW	 0x00000010
+ #define  MISC_HOST_CTRL_CLKREG_RW	 0x00000020
+ #define  MISC_HOST_CTRL_REGWORD_SWAP	 0x00000040
+ #define  MISC_HOST_CTRL_INDIR_ACCESS	 0x00000080
+ #define  MISC_HOST_CTRL_IRQ_MASK_MODE	 0x00000100
+ #define  MISC_HOST_CTRL_TAGGED_STATUS	 0x00000200
+ #define  MISC_HOST_CTRL_CHIPREV		 0xffff0000
+ #define  MISC_HOST_CTRL_CHIPREV_SHIFT	 16
+ #define  GET_CHIP_REV_ID(MISC_HOST_CTRL) \
+ 	 (((MISC_HOST_CTRL) & MISC_HOST_CTRL_CHIPREV) >> \
+ 	  MISC_HOST_CTRL_CHIPREV_SHIFT)
+ #define  CHIPREV_ID_5700_A0		 0x7000
+ #define  CHIPREV_ID_5700_A1		 0x7001
+ #define  CHIPREV_ID_5700_B0		 0x7100
+ #define  CHIPREV_ID_5700_B1		 0x7101
+ #define  CHIPREV_ID_5700_B3		 0x7102
+ #define  CHIPREV_ID_5700_ALTIMA		 0x7104
+ #define  CHIPREV_ID_5700_C0		 0x7200
+ #define  CHIPREV_ID_5701_A0		 0x0000
+ #define  CHIPREV_ID_5701_B0		 0x0100
+ #define  CHIPREV_ID_5701_B2		 0x0102
+ #define  CHIPREV_ID_5701_B5		 0x0105
+ #define  CHIPREV_ID_5703_A0		 0x1000
+ #define  CHIPREV_ID_5703_A1		 0x1001
+ #define  CHIPREV_ID_5703_A2		 0x1002
+ #define  CHIPREV_ID_5703_A3		 0x1003
+ #define  CHIPREV_ID_5704_A0		 0x2000
+ #define  CHIPREV_ID_5704_A1		 0x2001
+ #define  CHIPREV_ID_5704_A2		 0x2002
+ #define  CHIPREV_ID_5705_A0		 0x3000
+ #define  CHIPREV_ID_5705_A1		 0x3001
+ #define  GET_ASIC_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 12)
+ #define   ASIC_REV_5700			 0x07
+ #define   ASIC_REV_5701			 0x00
+ #define   ASIC_REV_5703			 0x01
+ #define   ASIC_REV_5704			 0x02
+ #define   ASIC_REV_5705			 0x03
+ #define  GET_CHIP_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 8)
+ #define   CHIPREV_5700_AX		 0x70
+ #define   CHIPREV_5700_BX		 0x71
+ #define   CHIPREV_5700_CX		 0x72
+ #define   CHIPREV_5701_AX		 0x00
+ #define  GET_METAL_REV(CHIP_REV_ID)	((CHIP_REV_ID) & 0xff)
+ #define   METAL_REV_A0			 0x00
+ #define   METAL_REV_A1			 0x01
+ #define   METAL_REV_B0			 0x00
+ #define   METAL_REV_B1			 0x01
+ #define   METAL_REV_B2			 0x02
+ #define TG3PCI_DMA_RW_CTRL		0x0000006c
+ #define  DMA_RWCTRL_MIN_DMA		 0x000000ff
+ #define  DMA_RWCTRL_MIN_DMA_SHIFT	 0
+ #define  DMA_RWCTRL_READ_BNDRY_MASK	 0x00000700
+ #define  DMA_RWCTRL_READ_BNDRY_DISAB	 0x00000000
+ #define  DMA_RWCTRL_READ_BNDRY_16	 0x00000100
+ #define  DMA_RWCTRL_READ_BNDRY_32	 0x00000200
+ #define  DMA_RWCTRL_READ_BNDRY_64	 0x00000300
+ #define  DMA_RWCTRL_READ_BNDRY_128	 0x00000400
+ #define  DMA_RWCTRL_READ_BNDRY_256	 0x00000500
+ #define  DMA_RWCTRL_READ_BNDRY_512	 0x00000600
+ #define  DMA_RWCTRL_READ_BNDRY_1024	 0x00000700
+ #define  DMA_RWCTRL_WRITE_BNDRY_MASK	 0x00003800
+ #define  DMA_RWCTRL_WRITE_BNDRY_DISAB	 0x00000000
+ #define  DMA_RWCTRL_WRITE_BNDRY_16	 0x00000800
+ #define  DMA_RWCTRL_WRITE_BNDRY_32	 0x00001000
+ #define  DMA_RWCTRL_WRITE_BNDRY_64	 0x00001800
+ #define  DMA_RWCTRL_WRITE_BNDRY_128	 0x00002000
+ #define  DMA_RWCTRL_WRITE_BNDRY_256	 0x00002800
+ #define  DMA_RWCTRL_WRITE_BNDRY_512	 0x00003000
+ #define  DMA_RWCTRL_WRITE_BNDRY_1024	 0x00003800
+ #define  DMA_RWCTRL_ONE_DMA		 0x00004000
+ #define  DMA_RWCTRL_READ_WATER		 0x00070000
+ #define  DMA_RWCTRL_READ_WATER_SHIFT	 16
+ #define  DMA_RWCTRL_WRITE_WATER		 0x00380000
+ #define  DMA_RWCTRL_WRITE_WATER_SHIFT	 19
+ #define  DMA_RWCTRL_USE_MEM_READ_MULT	 0x00400000
+ #define  DMA_RWCTRL_ASSERT_ALL_BE	 0x00800000
+ #define  DMA_RWCTRL_PCI_READ_CMD	 0x0f000000
+ #define  DMA_RWCTRL_PCI_READ_CMD_SHIFT	 24
+ #define  DMA_RWCTRL_PCI_WRITE_CMD	 0xf0000000
+ #define  DMA_RWCTRL_PCI_WRITE_CMD_SHIFT	 28
+ #define TG3PCI_PCISTATE			0x00000070
+ #define  PCISTATE_FORCE_RESET		 0x00000001
+ #define  PCISTATE_INT_NOT_ACTIVE	 0x00000002
+ #define  PCISTATE_CONV_PCI_MODE		 0x00000004
+ #define  PCISTATE_BUS_SPEED_HIGH	 0x00000008
+ #define  PCISTATE_BUS_32BIT		 0x00000010
+ #define  PCISTATE_ROM_ENABLE		 0x00000020
+ #define  PCISTATE_ROM_RETRY_ENABLE	 0x00000040
+ #define  PCISTATE_FLAT_VIEW		 0x00000100
+ #define  PCISTATE_RETRY_SAME_DMA	 0x00002000
+ #define TG3PCI_CLOCK_CTRL		0x00000074
+ #define  CLOCK_CTRL_CORECLK_DISABLE	 0x00000200
+ #define  CLOCK_CTRL_RXCLK_DISABLE	 0x00000400
+ #define  CLOCK_CTRL_TXCLK_DISABLE	 0x00000800
+ #define  CLOCK_CTRL_ALTCLK		 0x00001000
+ #define  CLOCK_CTRL_PWRDOWN_PLL133	 0x00008000
+ #define  CLOCK_CTRL_44MHZ_CORE		 0x00040000
+ #define  CLOCK_CTRL_625_CORE		 0x00100000
+ #define  CLOCK_CTRL_FORCE_CLKRUN	 0x00200000
+ #define  CLOCK_CTRL_CLKRUN_OENABLE	 0x00400000
+ #define  CLOCK_CTRL_DELAY_PCI_GRANT	 0x80000000
+ #define TG3PCI_REG_BASE_ADDR		0x00000078
+ #define TG3PCI_MEM_WIN_BASE_ADDR	0x0000007c
+ #define TG3PCI_REG_DATA			0x00000080
+ #define TG3PCI_MEM_WIN_DATA		0x00000084
+ #define TG3PCI_MODE_CTRL		0x00000088
+ #define TG3PCI_MISC_CFG			0x0000008c
+ #define TG3PCI_MISC_LOCAL_CTRL		0x00000090
+ /* 0x94 --> 0x98 unused */
+ #define TG3PCI_STD_RING_PROD_IDX	0x00000098 /* 64-bit */
+ #define TG3PCI_RCV_RET_RING_CON_IDX	0x000000a0 /* 64-bit */
+ #define TG3PCI_SND_PROD_IDX		0x000000a8 /* 64-bit */
+ /* 0xb0 --> 0x100 unused */
+ 
+ /* 0x100 --> 0x200 unused */
+ 
+ /* Mailbox registers */
+ #define MAILBOX_INTERRUPT_0		0x00000200 /* 64-bit */
+ #define MAILBOX_INTERRUPT_1		0x00000208 /* 64-bit */
+ #define MAILBOX_INTERRUPT_2		0x00000210 /* 64-bit */
+ #define MAILBOX_INTERRUPT_3		0x00000218 /* 64-bit */
+ #define MAILBOX_GENERAL_0		0x00000220 /* 64-bit */
+ #define MAILBOX_GENERAL_1		0x00000228 /* 64-bit */
+ #define MAILBOX_GENERAL_2		0x00000230 /* 64-bit */
+ #define MAILBOX_GENERAL_3		0x00000238 /* 64-bit */
+ #define MAILBOX_GENERAL_4		0x00000240 /* 64-bit */
+ #define MAILBOX_GENERAL_5		0x00000248 /* 64-bit */
+ #define MAILBOX_GENERAL_6		0x00000250 /* 64-bit */
+ #define MAILBOX_GENERAL_7		0x00000258 /* 64-bit */
+ #define MAILBOX_RELOAD_STAT		0x00000260 /* 64-bit */
+ #define MAILBOX_RCV_STD_PROD_IDX	0x00000268 /* 64-bit */
+ #define MAILBOX_RCV_JUMBO_PROD_IDX	0x00000270 /* 64-bit */
+ #define MAILBOX_RCV_MINI_PROD_IDX	0x00000278 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_0	0x00000280 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_1	0x00000288 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_2	0x00000290 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_3	0x00000298 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_4	0x000002a0 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_5	0x000002a8 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_6	0x000002b0 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_7	0x000002b8 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_8	0x000002c0 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_9	0x000002c8 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_10	0x000002d0 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_11	0x000002d8 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_12	0x000002e0 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_13	0x000002e8 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_14	0x000002f0 /* 64-bit */
+ #define MAILBOX_RCVRET_CON_IDX_15	0x000002f8 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_0	0x00000300 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_1	0x00000308 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_2	0x00000310 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_3	0x00000318 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_4	0x00000320 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_5	0x00000328 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_6	0x00000330 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_7	0x00000338 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_8	0x00000340 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_9	0x00000348 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_10	0x00000350 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_11	0x00000358 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_12	0x00000360 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_13	0x00000368 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_14	0x00000370 /* 64-bit */
+ #define MAILBOX_SNDHOST_PROD_IDX_15	0x00000378 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_0	0x00000380 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_1	0x00000388 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_2	0x00000390 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_3	0x00000398 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_4	0x000003a0 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_5	0x000003a8 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_6	0x000003b0 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_7	0x000003b8 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_8	0x000003c0 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_9	0x000003c8 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_10	0x000003d0 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_11	0x000003d8 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_12	0x000003e0 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_13	0x000003e8 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_14	0x000003f0 /* 64-bit */
+ #define MAILBOX_SNDNIC_PROD_IDX_15	0x000003f8 /* 64-bit */
+ 
+ /* MAC control registers */
+ #define MAC_MODE			0x00000400
+ #define  MAC_MODE_RESET			 0x00000001
+ #define  MAC_MODE_HALF_DUPLEX		 0x00000002
+ #define  MAC_MODE_PORT_MODE_MASK	 0x0000000c
+ #define  MAC_MODE_PORT_MODE_TBI		 0x0000000c
+ #define  MAC_MODE_PORT_MODE_GMII	 0x00000008
+ #define  MAC_MODE_PORT_MODE_MII		 0x00000004
+ #define  MAC_MODE_PORT_MODE_NONE	 0x00000000
+ #define  MAC_MODE_PORT_INT_LPBACK	 0x00000010
+ #define  MAC_MODE_TAGGED_MAC_CTRL	 0x00000080
+ #define  MAC_MODE_TX_BURSTING		 0x00000100
+ #define  MAC_MODE_MAX_DEFER		 0x00000200
+ #define  MAC_MODE_LINK_POLARITY		 0x00000400
+ #define  MAC_MODE_RXSTAT_ENABLE		 0x00000800
+ #define  MAC_MODE_RXSTAT_CLEAR		 0x00001000
+ #define  MAC_MODE_RXSTAT_FLUSH		 0x00002000
+ #define  MAC_MODE_TXSTAT_ENABLE		 0x00004000
+ #define  MAC_MODE_TXSTAT_CLEAR		 0x00008000
+ #define  MAC_MODE_TXSTAT_FLUSH		 0x00010000
+ #define  MAC_MODE_SEND_CONFIGS		 0x00020000
+ #define  MAC_MODE_MAGIC_PKT_ENABLE	 0x00040000
+ #define  MAC_MODE_ACPI_ENABLE		 0x00080000
+ #define  MAC_MODE_MIP_ENABLE		 0x00100000
+ #define  MAC_MODE_TDE_ENABLE		 0x00200000
+ #define  MAC_MODE_RDE_ENABLE		 0x00400000
+ #define  MAC_MODE_FHDE_ENABLE		 0x00800000
+ #define MAC_STATUS			0x00000404
+ #define  MAC_STATUS_PCS_SYNCED		 0x00000001
+ #define  MAC_STATUS_SIGNAL_DET		 0x00000002
+ #define  MAC_STATUS_RCVD_CFG		 0x00000004
+ #define  MAC_STATUS_CFG_CHANGED		 0x00000008
+ #define  MAC_STATUS_SYNC_CHANGED	 0x00000010
+ #define  MAC_STATUS_PORT_DEC_ERR	 0x00000400
+ #define  MAC_STATUS_LNKSTATE_CHANGED	 0x00001000
+ #define  MAC_STATUS_MI_COMPLETION	 0x00400000
+ #define  MAC_STATUS_MI_INTERRUPT	 0x00800000
+ #define  MAC_STATUS_AP_ERROR		 0x01000000
+ #define  MAC_STATUS_ODI_ERROR		 0x02000000
+ #define  MAC_STATUS_RXSTAT_OVERRUN	 0x04000000
+ #define  MAC_STATUS_TXSTAT_OVERRUN	 0x08000000
+ #define MAC_EVENT			0x00000408
+ #define  MAC_EVENT_PORT_DECODE_ERR	 0x00000400
+ #define  MAC_EVENT_LNKSTATE_CHANGED	 0x00001000
+ #define  MAC_EVENT_MI_COMPLETION	 0x00400000
+ #define  MAC_EVENT_MI_INTERRUPT		 0x00800000
+ #define  MAC_EVENT_AP_ERROR		 0x01000000
+ #define  MAC_EVENT_ODI_ERROR		 0x02000000
+ #define  MAC_EVENT_RXSTAT_OVERRUN	 0x04000000
+ #define  MAC_EVENT_TXSTAT_OVERRUN	 0x08000000
+ #define MAC_LED_CTRL			0x0000040c
+ #define  LED_CTRL_LNKLED_OVERRIDE	 0x00000001
+ #define  LED_CTRL_1000MBPS_ON		 0x00000002
+ #define  LED_CTRL_100MBPS_ON		 0x00000004
+ #define  LED_CTRL_10MBPS_ON		 0x00000008
+ #define  LED_CTRL_TRAFFIC_OVERRIDE	 0x00000010
+ #define  LED_CTRL_TRAFFIC_BLINK		 0x00000020
+ #define  LED_CTRL_TRAFFIC_LED		 0x00000040
+ #define  LED_CTRL_1000MBPS_STATUS	 0x00000080
+ #define  LED_CTRL_100MBPS_STATUS	 0x00000100
+ #define  LED_CTRL_10MBPS_STATUS		 0x00000200
+ #define  LED_CTRL_TRAFFIC_STATUS	 0x00000400
+ #define  LED_CTRL_MAC_MODE		 0x00000000
+ #define  LED_CTRL_PHY_MODE_1		 0x00000800
+ #define  LED_CTRL_PHY_MODE_2		 0x00001000
+ #define  LED_CTRL_BLINK_RATE_MASK	 0x7ff80000
+ #define  LED_CTRL_BLINK_RATE_SHIFT	 19
+ #define  LED_CTRL_BLINK_PER_OVERRIDE	 0x00080000
+ #define  LED_CTRL_BLINK_RATE_OVERRIDE	 0x80000000
+ #define MAC_ADDR_0_HIGH			0x00000410 /* upper 2 bytes */
+ #define MAC_ADDR_0_LOW			0x00000414 /* lower 4 bytes */
+ #define MAC_ADDR_1_HIGH			0x00000418 /* upper 2 bytes */
+ #define MAC_ADDR_1_LOW			0x0000041c /* lower 4 bytes */
+ #define MAC_ADDR_2_HIGH			0x00000420 /* upper 2 bytes */
+ #define MAC_ADDR_2_LOW			0x00000424 /* lower 4 bytes */
+ #define MAC_ADDR_3_HIGH			0x00000428 /* upper 2 bytes */
+ #define MAC_ADDR_3_LOW			0x0000042c /* lower 4 bytes */
+ #define MAC_ACPI_MBUF_PTR		0x00000430
+ #define MAC_ACPI_LEN_OFFSET		0x00000434
+ #define  ACPI_LENOFF_LEN_MASK		 0x0000ffff
+ #define  ACPI_LENOFF_LEN_SHIFT		 0
+ #define  ACPI_LENOFF_OFF_MASK		 0x0fff0000
+ #define  ACPI_LENOFF_OFF_SHIFT		 16
+ #define MAC_TX_BACKOFF_SEED		0x00000438
+ #define  TX_BACKOFF_SEED_MASK		 0x000003ff
+ #define MAC_RX_MTU_SIZE			0x0000043c
+ #define  RX_MTU_SIZE_MASK		 0x0000ffff
+ #define MAC_PCS_TEST			0x00000440
+ #define  PCS_TEST_PATTERN_MASK		 0x000fffff
+ #define  PCS_TEST_PATTERN_SHIFT		 0
+ #define  PCS_TEST_ENABLE		 0x00100000
+ #define MAC_TX_AUTO_NEG			0x00000444
+ #define  TX_AUTO_NEG_MASK		 0x0000ffff
+ #define  TX_AUTO_NEG_SHIFT		 0
+ #define MAC_RX_AUTO_NEG			0x00000448
+ #define  RX_AUTO_NEG_MASK		 0x0000ffff
+ #define  RX_AUTO_NEG_SHIFT		 0
+ #define MAC_MI_COM			0x0000044c
+ #define  MI_COM_CMD_MASK		 0x0c000000
+ #define  MI_COM_CMD_WRITE		 0x04000000
+ #define  MI_COM_CMD_READ		 0x08000000
+ #define  MI_COM_READ_FAILED		 0x10000000
+ #define  MI_COM_START			 0x20000000
+ #define  MI_COM_BUSY			 0x20000000
+ #define  MI_COM_PHY_ADDR_MASK		 0x03e00000
+ #define  MI_COM_PHY_ADDR_SHIFT		 21
+ #define  MI_COM_REG_ADDR_MASK		 0x001f0000
+ #define  MI_COM_REG_ADDR_SHIFT		 16
+ #define  MI_COM_DATA_MASK		 0x0000ffff
+ #define MAC_MI_STAT			0x00000450
+ #define  MAC_MI_STAT_LNKSTAT_ATTN_ENAB	 0x00000001
+ #define MAC_MI_MODE			0x00000454
+ #define  MAC_MI_MODE_CLK_10MHZ		 0x00000001
+ #define  MAC_MI_MODE_SHORT_PREAMBLE	 0x00000002
+ #define  MAC_MI_MODE_AUTO_POLL		 0x00000010
+ #define  MAC_MI_MODE_CORE_CLK_62MHZ	 0x00008000
+ #define  MAC_MI_MODE_BASE		 0x000c0000 /* XXX magic values XXX */
+ #define MAC_AUTO_POLL_STATUS		0x00000458
+ #define  MAC_AUTO_POLL_ERROR		 0x00000001
+ #define MAC_TX_MODE			0x0000045c
+ #define  TX_MODE_RESET			 0x00000001
+ #define  TX_MODE_ENABLE			 0x00000002
+ #define  TX_MODE_FLOW_CTRL_ENABLE	 0x00000010
+ #define  TX_MODE_BIG_BCKOFF_ENABLE	 0x00000020
+ #define  TX_MODE_LONG_PAUSE_ENABLE	 0x00000040
+ #define MAC_TX_STATUS			0x00000460
+ #define  TX_STATUS_XOFFED		 0x00000001
+ #define  TX_STATUS_SENT_XOFF		 0x00000002
+ #define  TX_STATUS_SENT_XON		 0x00000004
+ #define  TX_STATUS_LINK_UP		 0x00000008
+ #define  TX_STATUS_ODI_UNDERRUN		 0x00000010
+ #define  TX_STATUS_ODI_OVERRUN		 0x00000020
+ #define MAC_TX_LENGTHS			0x00000464
+ #define  TX_LENGTHS_SLOT_TIME_MASK	 0x000000ff
+ #define  TX_LENGTHS_SLOT_TIME_SHIFT	 0
+ #define  TX_LENGTHS_IPG_MASK		 0x00000f00
+ #define  TX_LENGTHS_IPG_SHIFT		 8
+ #define  TX_LENGTHS_IPG_CRS_MASK	 0x00003000
+ #define  TX_LENGTHS_IPG_CRS_SHIFT	 12
+ #define MAC_RX_MODE			0x00000468
+ #define  RX_MODE_RESET			 0x00000001
+ #define  RX_MODE_ENABLE			 0x00000002
+ #define  RX_MODE_FLOW_CTRL_ENABLE	 0x00000004
+ #define  RX_MODE_KEEP_MAC_CTRL		 0x00000008
+ #define  RX_MODE_KEEP_PAUSE		 0x00000010
+ #define  RX_MODE_ACCEPT_OVERSIZED	 0x00000020
+ #define  RX_MODE_ACCEPT_RUNTS		 0x00000040
+ #define  RX_MODE_LEN_CHECK		 0x00000080
+ #define  RX_MODE_PROMISC		 0x00000100
+ #define  RX_MODE_NO_CRC_CHECK		 0x00000200
+ #define  RX_MODE_KEEP_VLAN_TAG		 0x00000400
+ #define MAC_RX_STATUS			0x0000046c
+ #define  RX_STATUS_REMOTE_TX_XOFFED	 0x00000001
+ #define  RX_STATUS_XOFF_RCVD		 0x00000002
+ #define  RX_STATUS_XON_RCVD		 0x00000004
+ #define MAC_HASH_REG_0			0x00000470
+ #define MAC_HASH_REG_1			0x00000474
+ #define MAC_HASH_REG_2			0x00000478
+ #define MAC_HASH_REG_3			0x0000047c
+ #define MAC_RCV_RULE_0			0x00000480
+ #define MAC_RCV_VALUE_0			0x00000484
+ #define MAC_RCV_RULE_1			0x00000488
+ #define MAC_RCV_VALUE_1			0x0000048c
+ #define MAC_RCV_RULE_2			0x00000490
+ #define MAC_RCV_VALUE_2			0x00000494
+ #define MAC_RCV_RULE_3			0x00000498
+ #define MAC_RCV_VALUE_3			0x0000049c
+ #define MAC_RCV_RULE_4			0x000004a0
+ #define MAC_RCV_VALUE_4			0x000004a4
+ #define MAC_RCV_RULE_5			0x000004a8
+ #define MAC_RCV_VALUE_5			0x000004ac
+ #define MAC_RCV_RULE_6			0x000004b0
+ #define MAC_RCV_VALUE_6			0x000004b4
+ #define MAC_RCV_RULE_7			0x000004b8
+ #define MAC_RCV_VALUE_7			0x000004bc
+ #define MAC_RCV_RULE_8			0x000004c0
+ #define MAC_RCV_VALUE_8			0x000004c4
+ #define MAC_RCV_RULE_9			0x000004c8
+ #define MAC_RCV_VALUE_9			0x000004cc
+ #define MAC_RCV_RULE_10			0x000004d0
+ #define MAC_RCV_VALUE_10		0x000004d4
+ #define MAC_RCV_RULE_11			0x000004d8
+ #define MAC_RCV_VALUE_11		0x000004dc
+ #define MAC_RCV_RULE_12			0x000004e0
+ #define MAC_RCV_VALUE_12		0x000004e4
+ #define MAC_RCV_RULE_13			0x000004e8
+ #define MAC_RCV_VALUE_13		0x000004ec
+ #define MAC_RCV_RULE_14			0x000004f0
+ #define MAC_RCV_VALUE_14		0x000004f4
+ #define MAC_RCV_RULE_15			0x000004f8
+ #define MAC_RCV_VALUE_15		0x000004fc
+ #define  RCV_RULE_DISABLE_MASK		 0x7fffffff
+ #define MAC_RCV_RULE_CFG		0x00000500
+ #define  RCV_RULE_CFG_DEFAULT_CLASS	0x00000008
+ #define MAC_LOW_WMARK_MAX_RX_FRAME	0x00000504
+ /* 0x508 --> 0x520 unused */
+ #define MAC_HASHREGU_0			0x00000520
+ #define MAC_HASHREGU_1			0x00000524
+ #define MAC_HASHREGU_2			0x00000528
+ #define MAC_HASHREGU_3			0x0000052c
+ #define MAC_EXTADDR_0_HIGH		0x00000530
+ #define MAC_EXTADDR_0_LOW		0x00000534
+ #define MAC_EXTADDR_1_HIGH		0x00000538
+ #define MAC_EXTADDR_1_LOW		0x0000053c
+ #define MAC_EXTADDR_2_HIGH		0x00000540
+ #define MAC_EXTADDR_2_LOW		0x00000544
+ #define MAC_EXTADDR_3_HIGH		0x00000548
+ #define MAC_EXTADDR_3_LOW		0x0000054c
+ #define MAC_EXTADDR_4_HIGH		0x00000550
+ #define MAC_EXTADDR_4_LOW		0x00000554
+ #define MAC_EXTADDR_5_HIGH		0x00000558
+ #define MAC_EXTADDR_5_LOW		0x0000055c
+ #define MAC_EXTADDR_6_HIGH		0x00000560
+ #define MAC_EXTADDR_6_LOW		0x00000564
+ #define MAC_EXTADDR_7_HIGH		0x00000568
+ #define MAC_EXTADDR_7_LOW		0x0000056c
+ #define MAC_EXTADDR_8_HIGH		0x00000570
+ #define MAC_EXTADDR_8_LOW		0x00000574
+ #define MAC_EXTADDR_9_HIGH		0x00000578
+ #define MAC_EXTADDR_9_LOW		0x0000057c
+ #define MAC_EXTADDR_10_HIGH		0x00000580
+ #define MAC_EXTADDR_10_LOW		0x00000584
+ #define MAC_EXTADDR_11_HIGH		0x00000588
+ #define MAC_EXTADDR_11_LOW		0x0000058c
+ #define MAC_SERDES_CFG			0x00000590
+ #define MAC_SERDES_STAT			0x00000594
+ /* 0x598 --> 0x600 unused */
+ #define MAC_TX_MAC_STATE_BASE		0x00000600 /* 16 bytes */
+ #define MAC_RX_MAC_STATE_BASE		0x00000610 /* 20 bytes */
+ /* 0x624 --> 0x800 unused */
+ #define MAC_TX_STATS_OCTETS		0x00000800
+ #define MAC_TX_STATS_RESV1		0x00000804
+ #define MAC_TX_STATS_COLLISIONS		0x00000808
+ #define MAC_TX_STATS_XON_SENT		0x0000080c
+ #define MAC_TX_STATS_XOFF_SENT		0x00000810
+ #define MAC_TX_STATS_RESV2		0x00000814
+ #define MAC_TX_STATS_MAC_ERRORS		0x00000818
+ #define MAC_TX_STATS_SINGLE_COLLISIONS	0x0000081c
+ #define MAC_TX_STATS_MULT_COLLISIONS	0x00000820
+ #define MAC_TX_STATS_DEFERRED		0x00000824
+ #define MAC_TX_STATS_RESV3		0x00000828
+ #define MAC_TX_STATS_EXCESSIVE_COL	0x0000082c
+ #define MAC_TX_STATS_LATE_COL		0x00000830
+ #define MAC_TX_STATS_RESV4_1		0x00000834
+ #define MAC_TX_STATS_RESV4_2		0x00000838
+ #define MAC_TX_STATS_RESV4_3		0x0000083c
+ #define MAC_TX_STATS_RESV4_4		0x00000840
+ #define MAC_TX_STATS_RESV4_5		0x00000844
+ #define MAC_TX_STATS_RESV4_6		0x00000848
+ #define MAC_TX_STATS_RESV4_7		0x0000084c
+ #define MAC_TX_STATS_RESV4_8		0x00000850
+ #define MAC_TX_STATS_RESV4_9		0x00000854
+ #define MAC_TX_STATS_RESV4_10		0x00000858
+ #define MAC_TX_STATS_RESV4_11		0x0000085c
+ #define MAC_TX_STATS_RESV4_12		0x00000860
+ #define MAC_TX_STATS_RESV4_13		0x00000864
+ #define MAC_TX_STATS_RESV4_14		0x00000868
+ #define MAC_TX_STATS_UCAST		0x0000086c
+ #define MAC_TX_STATS_MCAST		0x00000870
+ #define MAC_TX_STATS_BCAST		0x00000874
+ #define MAC_TX_STATS_RESV5_1		0x00000878
+ #define MAC_TX_STATS_RESV5_2		0x0000087c
+ #define MAC_RX_STATS_OCTETS		0x00000880
+ #define MAC_RX_STATS_RESV1		0x00000884
+ #define MAC_RX_STATS_FRAGMENTS		0x00000888
+ #define MAC_RX_STATS_UCAST		0x0000088c
+ #define MAC_RX_STATS_MCAST		0x00000890
+ #define MAC_RX_STATS_BCAST		0x00000894
+ #define MAC_RX_STATS_FCS_ERRORS		0x00000898
+ #define MAC_RX_STATS_ALIGN_ERRORS	0x0000089c
+ #define MAC_RX_STATS_XON_PAUSE_RECVD	0x000008a0
+ #define MAC_RX_STATS_XOFF_PAUSE_RECVD	0x000008a4
+ #define MAC_RX_STATS_MAC_CTRL_RECVD	0x000008a8
+ #define MAC_RX_STATS_XOFF_ENTERED	0x000008ac
+ #define MAC_RX_STATS_FRAME_TOO_LONG	0x000008b0
+ #define MAC_RX_STATS_JABBERS		0x000008b4
+ #define MAC_RX_STATS_UNDERSIZE		0x000008b8
+ /* 0x8bc --> 0xc00 unused */
+ 
+ /* Send data initiator control registers */
+ #define SNDDATAI_MODE			0x00000c00
+ #define  SNDDATAI_MODE_RESET		 0x00000001
+ #define  SNDDATAI_MODE_ENABLE		 0x00000002
+ #define  SNDDATAI_MODE_STAT_OFLOW_ENAB	 0x00000004
+ #define SNDDATAI_STATUS			0x00000c04
+ #define  SNDDATAI_STATUS_STAT_OFLOW	 0x00000004
+ #define SNDDATAI_STATSCTRL		0x00000c08
+ #define  SNDDATAI_SCTRL_ENABLE		 0x00000001
+ #define  SNDDATAI_SCTRL_FASTUPD		 0x00000002
+ #define  SNDDATAI_SCTRL_CLEAR		 0x00000004
+ #define  SNDDATAI_SCTRL_FLUSH		 0x00000008
+ #define  SNDDATAI_SCTRL_FORCE_ZERO	 0x00000010
+ #define SNDDATAI_STATSENAB		0x00000c0c
+ #define SNDDATAI_STATSINCMASK		0x00000c10
+ /* 0xc14 --> 0xc80 unused */
+ #define SNDDATAI_COS_CNT_0		0x00000c80
+ #define SNDDATAI_COS_CNT_1		0x00000c84
+ #define SNDDATAI_COS_CNT_2		0x00000c88
+ #define SNDDATAI_COS_CNT_3		0x00000c8c
+ #define SNDDATAI_COS_CNT_4		0x00000c90
+ #define SNDDATAI_COS_CNT_5		0x00000c94
+ #define SNDDATAI_COS_CNT_6		0x00000c98
+ #define SNDDATAI_COS_CNT_7		0x00000c9c
+ #define SNDDATAI_COS_CNT_8		0x00000ca0
+ #define SNDDATAI_COS_CNT_9		0x00000ca4
+ #define SNDDATAI_COS_CNT_10		0x00000ca8
+ #define SNDDATAI_COS_CNT_11		0x00000cac
+ #define SNDDATAI_COS_CNT_12		0x00000cb0
+ #define SNDDATAI_COS_CNT_13		0x00000cb4
+ #define SNDDATAI_COS_CNT_14		0x00000cb8
+ #define SNDDATAI_COS_CNT_15		0x00000cbc
+ #define SNDDATAI_DMA_RDQ_FULL_CNT	0x00000cc0
+ #define SNDDATAI_DMA_PRIO_RDQ_FULL_CNT	0x00000cc4
+ #define SNDDATAI_SDCQ_FULL_CNT		0x00000cc8
+ #define SNDDATAI_NICRNG_SSND_PIDX_CNT	0x00000ccc
+ #define SNDDATAI_STATS_UPDATED_CNT	0x00000cd0
+ #define SNDDATAI_INTERRUPTS_CNT		0x00000cd4
+ #define SNDDATAI_AVOID_INTERRUPTS_CNT	0x00000cd8
+ #define SNDDATAI_SND_THRESH_HIT_CNT	0x00000cdc
+ /* 0xce0 --> 0x1000 unused */
+ 
+ /* Send data completion control registers */
+ #define SNDDATAC_MODE			0x00001000
+ #define  SNDDATAC_MODE_RESET		 0x00000001
+ #define  SNDDATAC_MODE_ENABLE		 0x00000002
+ /* 0x1004 --> 0x1400 unused */
+ 
+ /* Send BD ring selector */
+ #define SNDBDS_MODE			0x00001400
+ #define  SNDBDS_MODE_RESET		 0x00000001
+ #define  SNDBDS_MODE_ENABLE		 0x00000002
+ #define  SNDBDS_MODE_ATTN_ENABLE	 0x00000004
+ #define SNDBDS_STATUS			0x00001404
+ #define  SNDBDS_STATUS_ERROR_ATTN	 0x00000004
+ #define SNDBDS_HWDIAG			0x00001408
+ /* 0x140c --> 0x1440 */
+ #define SNDBDS_SEL_CON_IDX_0		0x00001440
+ #define SNDBDS_SEL_CON_IDX_1		0x00001444
+ #define SNDBDS_SEL_CON_IDX_2		0x00001448
+ #define SNDBDS_SEL_CON_IDX_3		0x0000144c
+ #define SNDBDS_SEL_CON_IDX_4		0x00001450
+ #define SNDBDS_SEL_CON_IDX_5		0x00001454
+ #define SNDBDS_SEL_CON_IDX_6		0x00001458
+ #define SNDBDS_SEL_CON_IDX_7		0x0000145c
+ #define SNDBDS_SEL_CON_IDX_8		0x00001460
+ #define SNDBDS_SEL_CON_IDX_9		0x00001464
+ #define SNDBDS_SEL_CON_IDX_10		0x00001468
+ #define SNDBDS_SEL_CON_IDX_11		0x0000146c
+ #define SNDBDS_SEL_CON_IDX_12		0x00001470
+ #define SNDBDS_SEL_CON_IDX_13		0x00001474
+ #define SNDBDS_SEL_CON_IDX_14		0x00001478
+ #define SNDBDS_SEL_CON_IDX_15		0x0000147c
+ /* 0x1480 --> 0x1800 unused */
+ 
+ /* Send BD initiator control registers */
+ #define SNDBDI_MODE			0x00001800
+ #define  SNDBDI_MODE_RESET		 0x00000001
+ #define  SNDBDI_MODE_ENABLE		 0x00000002
+ #define  SNDBDI_MODE_ATTN_ENABLE	 0x00000004
+ #define SNDBDI_STATUS			0x00001804
+ #define  SNDBDI_STATUS_ERROR_ATTN	 0x00000004
+ #define SNDBDI_IN_PROD_IDX_0		0x00001808
+ #define SNDBDI_IN_PROD_IDX_1		0x0000180c
+ #define SNDBDI_IN_PROD_IDX_2		0x00001810
+ #define SNDBDI_IN_PROD_IDX_3		0x00001814
+ #define SNDBDI_IN_PROD_IDX_4		0x00001818
+ #define SNDBDI_IN_PROD_IDX_5		0x0000181c
+ #define SNDBDI_IN_PROD_IDX_6		0x00001820
+ #define SNDBDI_IN_PROD_IDX_7		0x00001824
+ #define SNDBDI_IN_PROD_IDX_8		0x00001828
+ #define SNDBDI_IN_PROD_IDX_9		0x0000182c
+ #define SNDBDI_IN_PROD_IDX_10		0x00001830
+ #define SNDBDI_IN_PROD_IDX_11		0x00001834
+ #define SNDBDI_IN_PROD_IDX_12		0x00001838
+ #define SNDBDI_IN_PROD_IDX_13		0x0000183c
+ #define SNDBDI_IN_PROD_IDX_14		0x00001840
+ #define SNDBDI_IN_PROD_IDX_15		0x00001844
+ /* 0x1848 --> 0x1c00 unused */
+ 
+ /* Send BD completion control registers */
+ #define SNDBDC_MODE			0x00001c00
+ #define SNDBDC_MODE_RESET		 0x00000001
+ #define SNDBDC_MODE_ENABLE		 0x00000002
+ #define SNDBDC_MODE_ATTN_ENABLE		 0x00000004
+ /* 0x1c04 --> 0x2000 unused */
+ 
+ /* Receive list placement control registers */
+ #define RCVLPC_MODE			0x00002000
+ #define  RCVLPC_MODE_RESET		 0x00000001
+ #define  RCVLPC_MODE_ENABLE		 0x00000002
+ #define  RCVLPC_MODE_CLASS0_ATTN_ENAB	 0x00000004
+ #define  RCVLPC_MODE_MAPOOR_AATTN_ENAB	 0x00000008
+ #define  RCVLPC_MODE_STAT_OFLOW_ENAB	 0x00000010
+ #define RCVLPC_STATUS			0x00002004
+ #define  RCVLPC_STATUS_CLASS0		 0x00000004
+ #define  RCVLPC_STATUS_MAPOOR		 0x00000008
+ #define  RCVLPC_STATUS_STAT_OFLOW	 0x00000010
+ #define RCVLPC_LOCK			0x00002008
+ #define  RCVLPC_LOCK_REQ_MASK		 0x0000ffff
+ #define  RCVLPC_LOCK_REQ_SHIFT		 0
+ #define  RCVLPC_LOCK_GRANT_MASK		 0xffff0000
+ #define  RCVLPC_LOCK_GRANT_SHIFT	 16
+ #define RCVLPC_NON_EMPTY_BITS		0x0000200c
+ #define  RCVLPC_NON_EMPTY_BITS_MASK	 0x0000ffff
+ #define RCVLPC_CONFIG			0x00002010
+ #define RCVLPC_STATSCTRL		0x00002014
+ #define  RCVLPC_STATSCTRL_ENABLE	 0x00000001
+ #define  RCVLPC_STATSCTRL_FASTUPD	 0x00000002
+ #define RCVLPC_STATS_ENABLE		0x00002018
+ #define  RCVLPC_STATSENAB_LNGBRST_RFIX	 0x00400000
+ #define RCVLPC_STATS_INCMASK		0x0000201c
+ /* 0x2020 --> 0x2100 unused */
+ #define RCVLPC_SELLST_BASE		0x00002100 /* 16 16-byte entries */
+ #define  SELLST_TAIL			0x00000004
+ #define  SELLST_CONT			0x00000008
+ #define  SELLST_UNUSED			0x0000000c
+ #define RCVLPC_COS_CNTL_BASE		0x00002200 /* 16 4-byte entries */
+ #define RCVLPC_DROP_FILTER_CNT		0x00002240
+ #define RCVLPC_DMA_WQ_FULL_CNT		0x00002244
+ #define RCVLPC_DMA_HIPRIO_WQ_FULL_CNT	0x00002248
+ #define RCVLPC_NO_RCV_BD_CNT		0x0000224c
+ #define RCVLPC_IN_DISCARDS_CNT		0x00002250
+ #define RCVLPC_IN_ERRORS_CNT		0x00002254
+ #define RCVLPC_RCV_THRESH_HIT_CNT	0x00002258
+ /* 0x225c --> 0x2400 unused */
+ 
+ /* Receive Data and Receive BD Initiator Control */
+ #define RCVDBDI_MODE			0x00002400
+ #define  RCVDBDI_MODE_RESET		 0x00000001
+ #define  RCVDBDI_MODE_ENABLE		 0x00000002
+ #define  RCVDBDI_MODE_JUMBOBD_NEEDED	 0x00000004
+ #define  RCVDBDI_MODE_FRM_TOO_BIG	 0x00000008
+ #define  RCVDBDI_MODE_INV_RING_SZ	 0x00000010
+ #define RCVDBDI_STATUS			0x00002404
+ #define  RCVDBDI_STATUS_JUMBOBD_NEEDED	 0x00000004
+ #define  RCVDBDI_STATUS_FRM_TOO_BIG	 0x00000008
+ #define  RCVDBDI_STATUS_INV_RING_SZ	 0x00000010
+ #define RCVDBDI_SPLIT_FRAME_MINSZ	0x00002408
+ /* 0x240c --> 0x2440 unused */
+ #define RCVDBDI_JUMBO_BD		0x00002440 /* TG3_BDINFO_... */
+ #define RCVDBDI_STD_BD			0x00002450 /* TG3_BDINFO_... */
+ #define RCVDBDI_MINI_BD			0x00002460 /* TG3_BDINFO_... */
+ #define RCVDBDI_JUMBO_CON_IDX		0x00002470
+ #define RCVDBDI_STD_CON_IDX		0x00002474
+ #define RCVDBDI_MINI_CON_IDX		0x00002478
+ /* 0x247c --> 0x2480 unused */
+ #define RCVDBDI_BD_PROD_IDX_0		0x00002480
+ #define RCVDBDI_BD_PROD_IDX_1		0x00002484
+ #define RCVDBDI_BD_PROD_IDX_2		0x00002488
+ #define RCVDBDI_BD_PROD_IDX_3		0x0000248c
+ #define RCVDBDI_BD_PROD_IDX_4		0x00002490
+ #define RCVDBDI_BD_PROD_IDX_5		0x00002494
+ #define RCVDBDI_BD_PROD_IDX_6		0x00002498
+ #define RCVDBDI_BD_PROD_IDX_7		0x0000249c
+ #define RCVDBDI_BD_PROD_IDX_8		0x000024a0
+ #define RCVDBDI_BD_PROD_IDX_9		0x000024a4
+ #define RCVDBDI_BD_PROD_IDX_10		0x000024a8
+ #define RCVDBDI_BD_PROD_IDX_11		0x000024ac
+ #define RCVDBDI_BD_PROD_IDX_12		0x000024b0
+ #define RCVDBDI_BD_PROD_IDX_13		0x000024b4
+ #define RCVDBDI_BD_PROD_IDX_14		0x000024b8
+ #define RCVDBDI_BD_PROD_IDX_15		0x000024bc
+ #define RCVDBDI_HWDIAG			0x000024c0
+ /* 0x24c4 --> 0x2800 unused */
+ 
+ /* Receive Data Completion Control */
+ #define RCVDCC_MODE			0x00002800
+ #define  RCVDCC_MODE_RESET		 0x00000001
+ #define  RCVDCC_MODE_ENABLE		 0x00000002
+ #define  RCVDCC_MODE_ATTN_ENABLE	 0x00000004
+ /* 0x2804 --> 0x2c00 unused */
+ 
+ /* Receive BD Initiator Control Registers */
+ #define RCVBDI_MODE			0x00002c00
+ #define  RCVBDI_MODE_RESET		 0x00000001
+ #define  RCVBDI_MODE_ENABLE		 0x00000002
+ #define  RCVBDI_MODE_RCB_ATTN_ENAB	 0x00000004
+ #define RCVBDI_STATUS			0x00002c04
+ #define  RCVBDI_STATUS_RCB_ATTN		 0x00000004
+ #define RCVBDI_JUMBO_PROD_IDX		0x00002c08
+ #define RCVBDI_STD_PROD_IDX		0x00002c0c
+ #define RCVBDI_MINI_PROD_IDX		0x00002c10
+ #define RCVBDI_MINI_THRESH		0x00002c14
+ #define RCVBDI_STD_THRESH		0x00002c18
+ #define RCVBDI_JUMBO_THRESH		0x00002c1c
+ /* 0x2c20 --> 0x3000 unused */
+ 
+ /* Receive BD Completion Control Registers */
+ #define RCVCC_MODE			0x00003000
+ #define  RCVCC_MODE_RESET		 0x00000001
+ #define  RCVCC_MODE_ENABLE		 0x00000002
+ #define  RCVCC_MODE_ATTN_ENABLE		 0x00000004
+ #define RCVCC_STATUS			0x00003004
+ #define  RCVCC_STATUS_ERROR_ATTN	 0x00000004
+ #define RCVCC_JUMP_PROD_IDX		0x00003008
+ #define RCVCC_STD_PROD_IDX		0x0000300c
+ #define RCVCC_MINI_PROD_IDX		0x00003010
+ /* 0x3014 --> 0x3400 unused */
+ 
+ /* Receive list selector control registers */
+ #define RCVLSC_MODE			0x00003400
+ #define  RCVLSC_MODE_RESET		 0x00000001
+ #define  RCVLSC_MODE_ENABLE		 0x00000002
+ #define  RCVLSC_MODE_ATTN_ENABLE	 0x00000004
+ #define RCVLSC_STATUS			0x00003404
+ #define  RCVLSC_STATUS_ERROR_ATTN	 0x00000004
+ /* 0x3408 --> 0x3800 unused */
+ 
+ /* Mbuf cluster free registers */
+ #define MBFREE_MODE			0x00003800
+ #define  MBFREE_MODE_RESET		 0x00000001
+ #define  MBFREE_MODE_ENABLE		 0x00000002
+ #define MBFREE_STATUS			0x00003804
+ /* 0x3808 --> 0x3c00 unused */
+ 
+ /* Host coalescing control registers */
+ #define HOSTCC_MODE			0x00003c00
+ #define  HOSTCC_MODE_RESET		 0x00000001
+ #define  HOSTCC_MODE_ENABLE		 0x00000002
+ #define  HOSTCC_MODE_ATTN		 0x00000004
+ #define  HOSTCC_MODE_NOW		 0x00000008
+ #define  HOSTCC_MODE_FULL_STATUS	 0x00000000
+ #define  HOSTCC_MODE_64BYTE		 0x00000080
+ #define  HOSTCC_MODE_32BYTE		 0x00000100
+ #define  HOSTCC_MODE_CLRTICK_RXBD	 0x00000200
+ #define  HOSTCC_MODE_CLRTICK_TXBD	 0x00000400
+ #define  HOSTCC_MODE_NOINT_ON_NOW	 0x00000800
+ #define  HOSTCC_MODE_NOINT_ON_FORCE	 0x00001000
+ #define HOSTCC_STATUS			0x00003c04
+ #define  HOSTCC_STATUS_ERROR_ATTN	 0x00000004
+ #define HOSTCC_RXCOL_TICKS		0x00003c08
+ #define  LOW_RXCOL_TICKS		 0x00000032
+ #define  DEFAULT_RXCOL_TICKS		 0x00000048
+ #define  HIGH_RXCOL_TICKS		 0x00000096
+ #define HOSTCC_TXCOL_TICKS		0x00003c0c
+ #define  LOW_TXCOL_TICKS		 0x00000096
+ #define  DEFAULT_TXCOL_TICKS		 0x0000012c
+ #define  HIGH_TXCOL_TICKS		 0x00000145
+ #define HOSTCC_RXMAX_FRAMES		0x00003c10
+ #define  LOW_RXMAX_FRAMES		 0x00000005
+ #define  DEFAULT_RXMAX_FRAMES		 0x00000008
+ #define  HIGH_RXMAX_FRAMES		 0x00000012
+ #define HOSTCC_TXMAX_FRAMES		0x00003c14
+ #define  LOW_TXMAX_FRAMES		 0x00000035
+ #define  DEFAULT_TXMAX_FRAMES		 0x0000004b
+ #define  HIGH_TXMAX_FRAMES		 0x00000052
+ #define HOSTCC_RXCOAL_TICK_INT		0x00003c18
+ #define  DEFAULT_RXCOAL_TICK_INT	 0x00000019
+ #define HOSTCC_TXCOAL_TICK_INT		0x00003c1c
+ #define  DEFAULT_TXCOAL_TICK_INT	 0x00000019
+ #define HOSTCC_RXCOAL_MAXF_INT		0x00003c20
+ #define  DEFAULT_RXCOAL_MAXF_INT	 0x00000005
+ #define HOSTCC_TXCOAL_MAXF_INT		0x00003c24
+ #define  DEFAULT_TXCOAL_MAXF_INT	 0x00000005
+ #define HOSTCC_STAT_COAL_TICKS		0x00003c28
+ #define  DEFAULT_STAT_COAL_TICKS	 0x000f4240
+ /* 0x3c2c --> 0x3c30 unused */
+ #define HOSTCC_STATS_BLK_HOST_ADDR	0x00003c30 /* 64-bit */
+ #define HOSTCC_STATUS_BLK_HOST_ADDR	0x00003c38 /* 64-bit */
+ #define HOSTCC_STATS_BLK_NIC_ADDR	0x00003c40
+ #define HOSTCC_STATUS_BLK_NIC_ADDR	0x00003c44
+ #define HOSTCC_FLOW_ATTN		0x00003c48
+ /* 0x3c4c --> 0x3c50 unused */
+ #define HOSTCC_JUMBO_CON_IDX		0x00003c50
+ #define HOSTCC_STD_CON_IDX		0x00003c54
+ #define HOSTCC_MINI_CON_IDX		0x00003c58
+ /* 0x3c5c --> 0x3c80 unused */
+ #define HOSTCC_RET_PROD_IDX_0		0x00003c80
+ #define HOSTCC_RET_PROD_IDX_1		0x00003c84
+ #define HOSTCC_RET_PROD_IDX_2		0x00003c88
+ #define HOSTCC_RET_PROD_IDX_3		0x00003c8c
+ #define HOSTCC_RET_PROD_IDX_4		0x00003c90
+ #define HOSTCC_RET_PROD_IDX_5		0x00003c94
+ #define HOSTCC_RET_PROD_IDX_6		0x00003c98
+ #define HOSTCC_RET_PROD_IDX_7		0x00003c9c
+ #define HOSTCC_RET_PROD_IDX_8		0x00003ca0
+ #define HOSTCC_RET_PROD_IDX_9		0x00003ca4
+ #define HOSTCC_RET_PROD_IDX_10		0x00003ca8
+ #define HOSTCC_RET_PROD_IDX_11		0x00003cac
+ #define HOSTCC_RET_PROD_IDX_12		0x00003cb0
+ #define HOSTCC_RET_PROD_IDX_13		0x00003cb4
+ #define HOSTCC_RET_PROD_IDX_14		0x00003cb8
+ #define HOSTCC_RET_PROD_IDX_15		0x00003cbc
+ #define HOSTCC_SND_CON_IDX_0		0x00003cc0
+ #define HOSTCC_SND_CON_IDX_1		0x00003cc4
+ #define HOSTCC_SND_CON_IDX_2		0x00003cc8
+ #define HOSTCC_SND_CON_IDX_3		0x00003ccc
+ #define HOSTCC_SND_CON_IDX_4		0x00003cd0
+ #define HOSTCC_SND_CON_IDX_5		0x00003cd4
+ #define HOSTCC_SND_CON_IDX_6		0x00003cd8
+ #define HOSTCC_SND_CON_IDX_7		0x00003cdc
+ #define HOSTCC_SND_CON_IDX_8		0x00003ce0
+ #define HOSTCC_SND_CON_IDX_9		0x00003ce4
+ #define HOSTCC_SND_CON_IDX_10		0x00003ce8
+ #define HOSTCC_SND_CON_IDX_11		0x00003cec
+ #define HOSTCC_SND_CON_IDX_12		0x00003cf0
+ #define HOSTCC_SND_CON_IDX_13		0x00003cf4
+ #define HOSTCC_SND_CON_IDX_14		0x00003cf8
+ #define HOSTCC_SND_CON_IDX_15		0x00003cfc
+ /* 0x3d00 --> 0x4000 unused */
+ 
+ /* Memory arbiter control registers */
+ #define MEMARB_MODE			0x00004000
+ #define  MEMARB_MODE_RESET		 0x00000001
+ #define  MEMARB_MODE_ENABLE		 0x00000002
+ #define MEMARB_STATUS			0x00004004
+ #define MEMARB_TRAP_ADDR_LOW		0x00004008
+ #define MEMARB_TRAP_ADDR_HIGH		0x0000400c
+ /* 0x4010 --> 0x4400 unused */
+ 
+ /* Buffer manager control registers */
+ #define BUFMGR_MODE			0x00004400
+ #define  BUFMGR_MODE_RESET		 0x00000001
+ #define  BUFMGR_MODE_ENABLE		 0x00000002
+ #define  BUFMGR_MODE_ATTN_ENABLE	 0x00000004
+ #define  BUFMGR_MODE_BM_TEST		 0x00000008
+ #define  BUFMGR_MODE_MBLOW_ATTN_ENAB	 0x00000010
+ #define BUFMGR_STATUS			0x00004404
+ #define  BUFMGR_STATUS_ERROR		 0x00000004
+ #define  BUFMGR_STATUS_MBLOW		 0x00000010
+ #define BUFMGR_MB_POOL_ADDR		0x00004408
+ #define BUFMGR_MB_POOL_SIZE		0x0000440c
+ #define BUFMGR_MB_RDMA_LOW_WATER	0x00004410
+ #define  DEFAULT_MB_RDMA_LOW_WATER	 0x00000050
+ #define  DEFAULT_MB_RDMA_LOW_WATER_5705	 0x00000000
+ #define  DEFAULT_MB_RDMA_LOW_WATER_JUMBO 0x00000130
+ #define BUFMGR_MB_MACRX_LOW_WATER	0x00004414
+ #define  DEFAULT_MB_MACRX_LOW_WATER	  0x00000020
+ #define  DEFAULT_MB_MACRX_LOW_WATER_5705  0x00000010
+ #define  DEFAULT_MB_MACRX_LOW_WATER_JUMBO 0x00000098
+ #define BUFMGR_MB_HIGH_WATER		0x00004418
+ #define  DEFAULT_MB_HIGH_WATER		 0x00000060
+ #define  DEFAULT_MB_HIGH_WATER_5705	 0x00000060
+ #define  DEFAULT_MB_HIGH_WATER_JUMBO	 0x0000017c
+ #define BUFMGR_RX_MB_ALLOC_REQ		0x0000441c
+ #define  BUFMGR_MB_ALLOC_BIT		 0x10000000
+ #define BUFMGR_RX_MB_ALLOC_RESP		0x00004420
+ #define BUFMGR_TX_MB_ALLOC_REQ		0x00004424
+ #define BUFMGR_TX_MB_ALLOC_RESP		0x00004428
+ #define BUFMGR_DMA_DESC_POOL_ADDR	0x0000442c
+ #define BUFMGR_DMA_DESC_POOL_SIZE	0x00004430
+ #define BUFMGR_DMA_LOW_WATER		0x00004434
+ #define  DEFAULT_DMA_LOW_WATER		 0x00000005
+ #define BUFMGR_DMA_HIGH_WATER		0x00004438
+ #define  DEFAULT_DMA_HIGH_WATER		 0x0000000a
+ #define BUFMGR_RX_DMA_ALLOC_REQ		0x0000443c
+ #define BUFMGR_RX_DMA_ALLOC_RESP	0x00004440
+ #define BUFMGR_TX_DMA_ALLOC_REQ		0x00004444
+ #define BUFMGR_TX_DMA_ALLOC_RESP	0x00004448
+ #define BUFMGR_HWDIAG_0			0x0000444c
+ #define BUFMGR_HWDIAG_1			0x00004450
+ #define BUFMGR_HWDIAG_2			0x00004454
+ /* 0x4458 --> 0x4800 unused */
+ 
+ /* Read DMA control registers */
+ #define RDMAC_MODE			0x00004800
+ #define  RDMAC_MODE_RESET		 0x00000001
+ #define  RDMAC_MODE_ENABLE		 0x00000002
+ #define  RDMAC_MODE_TGTABORT_ENAB	 0x00000004
+ #define  RDMAC_MODE_MSTABORT_ENAB	 0x00000008
+ #define  RDMAC_MODE_PARITYERR_ENAB	 0x00000010
+ #define  RDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+ #define  RDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+ #define  RDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+ #define  RDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+ #define  RDMAC_MODE_LNGREAD_ENAB	 0x00000200
+ #define  RDMAC_MODE_SPLIT_ENABLE	 0x00000800
+ #define  RDMAC_MODE_SPLIT_RESET		 0x00001000
+ #define  RDMAC_MODE_FIFO_SIZE_128	 0x00020000
+ #define  RDMAC_MODE_FIFO_LONG_BURST	 0x00030000
+ #define RDMAC_STATUS			0x00004804
+ #define  RDMAC_STATUS_TGTABORT		 0x00000004
+ #define  RDMAC_STATUS_MSTABORT		 0x00000008
+ #define  RDMAC_STATUS_PARITYERR		 0x00000010
+ #define  RDMAC_STATUS_ADDROFLOW		 0x00000020
+ #define  RDMAC_STATUS_FIFOOFLOW		 0x00000040
+ #define  RDMAC_STATUS_FIFOURUN		 0x00000080
+ #define  RDMAC_STATUS_FIFOOREAD		 0x00000100
+ #define  RDMAC_STATUS_LNGREAD		 0x00000200
+ /* 0x4808 --> 0x4c00 unused */
+ 
+ /* Write DMA control registers */
+ #define WDMAC_MODE			0x00004c00
+ #define  WDMAC_MODE_RESET		 0x00000001
+ #define  WDMAC_MODE_ENABLE		 0x00000002
+ #define  WDMAC_MODE_TGTABORT_ENAB	 0x00000004
+ #define  WDMAC_MODE_MSTABORT_ENAB	 0x00000008
+ #define  WDMAC_MODE_PARITYERR_ENAB	 0x00000010
+ #define  WDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+ #define  WDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+ #define  WDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+ #define  WDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+ #define  WDMAC_MODE_LNGREAD_ENAB	 0x00000200
+ #define  WDMAC_MODE_RX_ACCEL	 	 0x00000400
+ #define WDMAC_STATUS			0x00004c04
+ #define  WDMAC_STATUS_TGTABORT		 0x00000004
+ #define  WDMAC_STATUS_MSTABORT		 0x00000008
+ #define  WDMAC_STATUS_PARITYERR		 0x00000010
+ #define  WDMAC_STATUS_ADDROFLOW		 0x00000020
+ #define  WDMAC_STATUS_FIFOOFLOW		 0x00000040
+ #define  WDMAC_STATUS_FIFOURUN		 0x00000080
+ #define  WDMAC_STATUS_FIFOOREAD		 0x00000100
+ #define  WDMAC_STATUS_LNGREAD		 0x00000200
+ /* 0x4c08 --> 0x5000 unused */
+ 
+ /* Per-cpu register offsets (arm9) */
+ #define CPU_MODE			0x00000000
+ #define  CPU_MODE_RESET			 0x00000001
+ #define  CPU_MODE_HALT			 0x00000400
+ #define CPU_STATE			0x00000004
+ #define CPU_EVTMASK			0x00000008
+ /* 0xc --> 0x1c reserved */
+ #define CPU_PC				0x0000001c
+ #define CPU_INSN			0x00000020
+ #define CPU_SPAD_UFLOW			0x00000024
+ #define CPU_WDOG_CLEAR			0x00000028
+ #define CPU_WDOG_VECTOR			0x0000002c
+ #define CPU_WDOG_PC			0x00000030
+ #define CPU_HW_BP			0x00000034
+ /* 0x38 --> 0x44 unused */
+ #define CPU_WDOG_SAVED_STATE		0x00000044
+ #define CPU_LAST_BRANCH_ADDR		0x00000048
+ #define CPU_SPAD_UFLOW_SET		0x0000004c
+ /* 0x50 --> 0x200 unused */
+ #define CPU_R0				0x00000200
+ #define CPU_R1				0x00000204
+ #define CPU_R2				0x00000208
+ #define CPU_R3				0x0000020c
+ #define CPU_R4				0x00000210
+ #define CPU_R5				0x00000214
+ #define CPU_R6				0x00000218
+ #define CPU_R7				0x0000021c
+ #define CPU_R8				0x00000220
+ #define CPU_R9				0x00000224
+ #define CPU_R10				0x00000228
+ #define CPU_R11				0x0000022c
+ #define CPU_R12				0x00000230
+ #define CPU_R13				0x00000234
+ #define CPU_R14				0x00000238
+ #define CPU_R15				0x0000023c
+ #define CPU_R16				0x00000240
+ #define CPU_R17				0x00000244
+ #define CPU_R18				0x00000248
+ #define CPU_R19				0x0000024c
+ #define CPU_R20				0x00000250
+ #define CPU_R21				0x00000254
+ #define CPU_R22				0x00000258
+ #define CPU_R23				0x0000025c
+ #define CPU_R24				0x00000260
+ #define CPU_R25				0x00000264
+ #define CPU_R26				0x00000268
+ #define CPU_R27				0x0000026c
+ #define CPU_R28				0x00000270
+ #define CPU_R29				0x00000274
+ #define CPU_R30				0x00000278
+ #define CPU_R31				0x0000027c
+ /* 0x280 --> 0x400 unused */
+ 
+ #define RX_CPU_BASE			0x00005000
+ #define TX_CPU_BASE			0x00005400
+ 
+ /* Mailboxes */
+ #define GRCMBOX_INTERRUPT_0		0x00005800 /* 64-bit */
+ #define GRCMBOX_INTERRUPT_1		0x00005808 /* 64-bit */
+ #define GRCMBOX_INTERRUPT_2		0x00005810 /* 64-bit */
+ #define GRCMBOX_INTERRUPT_3		0x00005818 /* 64-bit */
+ #define GRCMBOX_GENERAL_0		0x00005820 /* 64-bit */
+ #define GRCMBOX_GENERAL_1		0x00005828 /* 64-bit */
+ #define GRCMBOX_GENERAL_2		0x00005830 /* 64-bit */
+ #define GRCMBOX_GENERAL_3		0x00005838 /* 64-bit */
+ #define GRCMBOX_GENERAL_4		0x00005840 /* 64-bit */
+ #define GRCMBOX_GENERAL_5		0x00005848 /* 64-bit */
+ #define GRCMBOX_GENERAL_6		0x00005850 /* 64-bit */
+ #define GRCMBOX_GENERAL_7		0x00005858 /* 64-bit */
+ #define GRCMBOX_RELOAD_STAT		0x00005860 /* 64-bit */
+ #define GRCMBOX_RCVSTD_PROD_IDX		0x00005868 /* 64-bit */
+ #define GRCMBOX_RCVJUMBO_PROD_IDX	0x00005870 /* 64-bit */
+ #define GRCMBOX_RCVMINI_PROD_IDX	0x00005878 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_0	0x00005880 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_1	0x00005888 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_2	0x00005890 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_3	0x00005898 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_4	0x000058a0 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_5	0x000058a8 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_6	0x000058b0 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_7	0x000058b8 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_8	0x000058c0 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_9	0x000058c8 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_10	0x000058d0 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_11	0x000058d8 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_12	0x000058e0 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_13	0x000058e8 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_14	0x000058f0 /* 64-bit */
+ #define GRCMBOX_RCVRET_CON_IDX_15	0x000058f8 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_0	0x00005900 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_1	0x00005908 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_2	0x00005910 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_3	0x00005918 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_4	0x00005920 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_5	0x00005928 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_6	0x00005930 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_7	0x00005938 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_8	0x00005940 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_9	0x00005948 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_10	0x00005950 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_11	0x00005958 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_12	0x00005960 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_13	0x00005968 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_14	0x00005970 /* 64-bit */
+ #define GRCMBOX_SNDHOST_PROD_IDX_15	0x00005978 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_0	0x00005980 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_1	0x00005988 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_2	0x00005990 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_3	0x00005998 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_4	0x000059a0 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_5	0x000059a8 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_6	0x000059b0 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_7	0x000059b8 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_8	0x000059c0 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_9	0x000059c8 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_10	0x000059d0 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_11	0x000059d8 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_12	0x000059e0 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_13	0x000059e8 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_14	0x000059f0 /* 64-bit */
+ #define GRCMBOX_SNDNIC_PROD_IDX_15	0x000059f8 /* 64-bit */
+ #define GRCMBOX_HIGH_PRIO_EV_VECTOR	0x00005a00
+ #define GRCMBOX_HIGH_PRIO_EV_MASK	0x00005a04
+ #define GRCMBOX_LOW_PRIO_EV_VEC		0x00005a08
+ #define GRCMBOX_LOW_PRIO_EV_MASK	0x00005a0c
+ /* 0x5a10 --> 0x5c00 */
+ 
+ /* Flow Through queues */
+ #define FTQ_RESET			0x00005c00
+ /* 0x5c04 --> 0x5c10 unused */
+ #define FTQ_DMA_NORM_READ_CTL		0x00005c10
+ #define FTQ_DMA_NORM_READ_FULL_CNT	0x00005c14
+ #define FTQ_DMA_NORM_READ_FIFO_ENQDEQ	0x00005c18
+ #define FTQ_DMA_NORM_READ_WRITE_PEEK	0x00005c1c
+ #define FTQ_DMA_HIGH_READ_CTL		0x00005c20
+ #define FTQ_DMA_HIGH_READ_FULL_CNT	0x00005c24
+ #define FTQ_DMA_HIGH_READ_FIFO_ENQDEQ	0x00005c28
+ #define FTQ_DMA_HIGH_READ_WRITE_PEEK	0x00005c2c
+ #define FTQ_DMA_COMP_DISC_CTL		0x00005c30
+ #define FTQ_DMA_COMP_DISC_FULL_CNT	0x00005c34
+ #define FTQ_DMA_COMP_DISC_FIFO_ENQDEQ	0x00005c38
+ #define FTQ_DMA_COMP_DISC_WRITE_PEEK	0x00005c3c
+ #define FTQ_SEND_BD_COMP_CTL		0x00005c40
+ #define FTQ_SEND_BD_COMP_FULL_CNT	0x00005c44
+ #define FTQ_SEND_BD_COMP_FIFO_ENQDEQ	0x00005c48
+ #define FTQ_SEND_BD_COMP_WRITE_PEEK	0x00005c4c
+ #define FTQ_SEND_DATA_INIT_CTL		0x00005c50
+ #define FTQ_SEND_DATA_INIT_FULL_CNT	0x00005c54
+ #define FTQ_SEND_DATA_INIT_FIFO_ENQDEQ	0x00005c58
+ #define FTQ_SEND_DATA_INIT_WRITE_PEEK	0x00005c5c
+ #define FTQ_DMA_NORM_WRITE_CTL		0x00005c60
+ #define FTQ_DMA_NORM_WRITE_FULL_CNT	0x00005c64
+ #define FTQ_DMA_NORM_WRITE_FIFO_ENQDEQ	0x00005c68
+ #define FTQ_DMA_NORM_WRITE_WRITE_PEEK	0x00005c6c
+ #define FTQ_DMA_HIGH_WRITE_CTL		0x00005c70
+ #define FTQ_DMA_HIGH_WRITE_FULL_CNT	0x00005c74
+ #define FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ	0x00005c78
+ #define FTQ_DMA_HIGH_WRITE_WRITE_PEEK	0x00005c7c
+ #define FTQ_SWTYPE1_CTL			0x00005c80
+ #define FTQ_SWTYPE1_FULL_CNT		0x00005c84
+ #define FTQ_SWTYPE1_FIFO_ENQDEQ		0x00005c88
+ #define FTQ_SWTYPE1_WRITE_PEEK		0x00005c8c
+ #define FTQ_SEND_DATA_COMP_CTL		0x00005c90
+ #define FTQ_SEND_DATA_COMP_FULL_CNT	0x00005c94
+ #define FTQ_SEND_DATA_COMP_FIFO_ENQDEQ	0x00005c98
+ #define FTQ_SEND_DATA_COMP_WRITE_PEEK	0x00005c9c
+ #define FTQ_HOST_COAL_CTL		0x00005ca0
+ #define FTQ_HOST_COAL_FULL_CNT		0x00005ca4
+ #define FTQ_HOST_COAL_FIFO_ENQDEQ	0x00005ca8
+ #define FTQ_HOST_COAL_WRITE_PEEK	0x00005cac
+ #define FTQ_MAC_TX_CTL			0x00005cb0
+ #define FTQ_MAC_TX_FULL_CNT		0x00005cb4
+ #define FTQ_MAC_TX_FIFO_ENQDEQ		0x00005cb8
+ #define FTQ_MAC_TX_WRITE_PEEK		0x00005cbc
+ #define FTQ_MB_FREE_CTL			0x00005cc0
+ #define FTQ_MB_FREE_FULL_CNT		0x00005cc4
+ #define FTQ_MB_FREE_FIFO_ENQDEQ		0x00005cc8
+ #define FTQ_MB_FREE_WRITE_PEEK		0x00005ccc
+ #define FTQ_RCVBD_COMP_CTL		0x00005cd0
+ #define FTQ_RCVBD_COMP_FULL_CNT		0x00005cd4
+ #define FTQ_RCVBD_COMP_FIFO_ENQDEQ	0x00005cd8
+ #define FTQ_RCVBD_COMP_WRITE_PEEK	0x00005cdc
+ #define FTQ_RCVLST_PLMT_CTL		0x00005ce0
+ #define FTQ_RCVLST_PLMT_FULL_CNT	0x00005ce4
+ #define FTQ_RCVLST_PLMT_FIFO_ENQDEQ	0x00005ce8
+ #define FTQ_RCVLST_PLMT_WRITE_PEEK	0x00005cec
+ #define FTQ_RCVDATA_INI_CTL		0x00005cf0
+ #define FTQ_RCVDATA_INI_FULL_CNT	0x00005cf4
+ #define FTQ_RCVDATA_INI_FIFO_ENQDEQ	0x00005cf8
+ #define FTQ_RCVDATA_INI_WRITE_PEEK	0x00005cfc
+ #define FTQ_RCVDATA_COMP_CTL		0x00005d00
+ #define FTQ_RCVDATA_COMP_FULL_CNT	0x00005d04
+ #define FTQ_RCVDATA_COMP_FIFO_ENQDEQ	0x00005d08
+ #define FTQ_RCVDATA_COMP_WRITE_PEEK	0x00005d0c
+ #define FTQ_SWTYPE2_CTL			0x00005d10
+ #define FTQ_SWTYPE2_FULL_CNT		0x00005d14
+ #define FTQ_SWTYPE2_FIFO_ENQDEQ		0x00005d18
+ #define FTQ_SWTYPE2_WRITE_PEEK		0x00005d1c
+ /* 0x5d20 --> 0x6000 unused */
+ 
+ /* Message signaled interrupt registers */
+ #define MSGINT_MODE			0x00006000
+ #define  MSGINT_MODE_RESET		 0x00000001
+ #define  MSGINT_MODE_ENABLE		 0x00000002
+ #define MSGINT_STATUS			0x00006004
+ #define MSGINT_FIFO			0x00006008
+ /* 0x600c --> 0x6400 unused */
+ 
+ /* DMA completion registers */
+ #define DMAC_MODE			0x00006400
+ #define  DMAC_MODE_RESET		 0x00000001
+ #define  DMAC_MODE_ENABLE		 0x00000002
+ /* 0x6404 --> 0x6800 unused */
+ 
+ /* GRC registers */
+ #define GRC_MODE			0x00006800
+ #define  GRC_MODE_UPD_ON_COAL		0x00000001
+ #define  GRC_MODE_BSWAP_NONFRM_DATA	0x00000002
+ #define  GRC_MODE_WSWAP_NONFRM_DATA	0x00000004
+ #define  GRC_MODE_BSWAP_DATA		0x00000010
+ #define  GRC_MODE_WSWAP_DATA		0x00000020
+ #define  GRC_MODE_SPLITHDR		0x00000100
+ #define  GRC_MODE_NOFRM_CRACKING	0x00000200
+ #define  GRC_MODE_INCL_CRC		0x00000400
+ #define  GRC_MODE_ALLOW_BAD_FRMS	0x00000800
+ #define  GRC_MODE_NOIRQ_ON_SENDS	0x00002000
+ #define  GRC_MODE_NOIRQ_ON_RCV		0x00004000
+ #define  GRC_MODE_FORCE_PCI32BIT	0x00008000
+ #define  GRC_MODE_HOST_STACKUP		0x00010000
+ #define  GRC_MODE_HOST_SENDBDS		0x00020000
+ #define  GRC_MODE_NO_TX_PHDR_CSUM	0x00100000
+ #define  GRC_MODE_NO_RX_PHDR_CSUM	0x00800000
+ #define  GRC_MODE_IRQ_ON_TX_CPU_ATTN	0x01000000
+ #define  GRC_MODE_IRQ_ON_RX_CPU_ATTN	0x02000000
+ #define  GRC_MODE_IRQ_ON_MAC_ATTN	0x04000000
+ #define  GRC_MODE_IRQ_ON_DMA_ATTN	0x08000000
+ #define  GRC_MODE_IRQ_ON_FLOW_ATTN	0x10000000
+ #define  GRC_MODE_4X_NIC_SEND_RINGS	0x20000000
+ #define  GRC_MODE_MCAST_FRM_ENABLE	0x40000000
+ #define GRC_MISC_CFG			0x00006804
+ #define  GRC_MISC_CFG_CORECLK_RESET	0x00000001
+ #define  GRC_MISC_CFG_PRESCALAR_MASK	0x000000fe
+ #define  GRC_MISC_CFG_PRESCALAR_SHIFT	1
+ #define  GRC_MISC_CFG_BOARD_ID_MASK	0x0001e000
+ #define  GRC_MISC_CFG_BOARD_ID_5700	0x0001e000
+ #define  GRC_MISC_CFG_BOARD_ID_5701	0x00000000
+ #define  GRC_MISC_CFG_BOARD_ID_5702FE	0x00004000
+ #define  GRC_MISC_CFG_BOARD_ID_5703	0x00000000
+ #define  GRC_MISC_CFG_BOARD_ID_5703S	0x00002000
+ #define  GRC_MISC_CFG_BOARD_ID_5704	0x00000000
+ #define  GRC_MISC_CFG_BOARD_ID_5704CIOBE 0x00004000
+ #define  GRC_MISC_CFG_BOARD_ID_5704_A2	0x00008000
+ #define  GRC_MISC_CFG_BOARD_ID_5788	0x00010000
+ #define  GRC_MISC_CFG_BOARD_ID_5788M	0x00018000
+ #define  GRC_MISC_CFG_BOARD_ID_AC91002A1 0x00018000
+ #define  GRC_MISC_CFG_KEEP_GPHY_POWER	0x04000000
+ #define GRC_LOCAL_CTRL			0x00006808
+ #define  GRC_LCLCTRL_INT_ACTIVE		0x00000001
+ #define  GRC_LCLCTRL_CLEARINT		0x00000002
+ #define  GRC_LCLCTRL_SETINT		0x00000004
+ #define  GRC_LCLCTRL_INT_ON_ATTN	0x00000008
+ #define  GRC_LCLCTRL_GPIO_INPUT0	0x00000100
+ #define  GRC_LCLCTRL_GPIO_INPUT1	0x00000200
+ #define  GRC_LCLCTRL_GPIO_INPUT2	0x00000400
+ #define  GRC_LCLCTRL_GPIO_OE0		0x00000800
+ #define  GRC_LCLCTRL_GPIO_OE1		0x00001000
+ #define  GRC_LCLCTRL_GPIO_OE2		0x00002000
+ #define  GRC_LCLCTRL_GPIO_OUTPUT0	0x00004000
+ #define  GRC_LCLCTRL_GPIO_OUTPUT1	0x00008000
+ #define  GRC_LCLCTRL_GPIO_OUTPUT2	0x00010000
+ #define  GRC_LCLCTRL_EXTMEM_ENABLE	0x00020000
+ #define  GRC_LCLCTRL_MEMSZ_MASK		0x001c0000
+ #define  GRC_LCLCTRL_MEMSZ_256K		0x00000000
+ #define  GRC_LCLCTRL_MEMSZ_512K		0x00040000
+ #define  GRC_LCLCTRL_MEMSZ_1M		0x00080000
+ #define  GRC_LCLCTRL_MEMSZ_2M		0x000c0000
+ #define  GRC_LCLCTRL_MEMSZ_4M		0x00100000
+ #define  GRC_LCLCTRL_MEMSZ_8M		0x00140000
+ #define  GRC_LCLCTRL_MEMSZ_16M		0x00180000
+ #define  GRC_LCLCTRL_BANK_SELECT	0x00200000
+ #define  GRC_LCLCTRL_SSRAM_TYPE		0x00400000
+ #define  GRC_LCLCTRL_AUTO_SEEPROM	0x01000000
+ #define GRC_TIMER			0x0000680c
+ #define GRC_RX_CPU_EVENT		0x00006810
+ #define GRC_RX_TIMER_REF		0x00006814
+ #define GRC_RX_CPU_SEM			0x00006818
+ #define GRC_REMOTE_RX_CPU_ATTN		0x0000681c
+ #define GRC_TX_CPU_EVENT		0x00006820
+ #define GRC_TX_TIMER_REF		0x00006824
+ #define GRC_TX_CPU_SEM			0x00006828
+ #define GRC_REMOTE_TX_CPU_ATTN		0x0000682c
+ #define GRC_MEM_POWER_UP		0x00006830 /* 64-bit */
+ #define GRC_EEPROM_ADDR			0x00006838
+ #define  EEPROM_ADDR_WRITE		0x00000000
+ #define  EEPROM_ADDR_READ		0x80000000
+ #define  EEPROM_ADDR_COMPLETE		0x40000000
+ #define  EEPROM_ADDR_FSM_RESET		0x20000000
+ #define  EEPROM_ADDR_DEVID_MASK		0x1c000000
+ #define  EEPROM_ADDR_DEVID_SHIFT	26
+ #define  EEPROM_ADDR_START		0x02000000
+ #define  EEPROM_ADDR_CLKPERD_SHIFT	16
+ #define  EEPROM_ADDR_ADDR_MASK		0x0000ffff
+ #define  EEPROM_ADDR_ADDR_SHIFT		0
+ #define  EEPROM_DEFAULT_CLOCK_PERIOD	0x60
+ #define  EEPROM_CHIP_SIZE		(64 * 1024)
+ #define GRC_EEPROM_DATA			0x0000683c
+ #define GRC_EEPROM_CTRL			0x00006840
+ #define GRC_MDI_CTRL			0x00006844
+ #define GRC_SEEPROM_DELAY		0x00006848
+ /* 0x684c --> 0x6c00 unused */
+ 
+ /* 0x6c00 --> 0x7000 unused */
+ 
+ /* NVRAM Control registers */
+ #define NVRAM_CMD			0x00007000
+ #define  NVRAM_CMD_RESET		 0x00000001
+ #define  NVRAM_CMD_DONE			 0x00000008
+ #define  NVRAM_CMD_GO			 0x00000010
+ #define  NVRAM_CMD_WR			 0x00000020
+ #define  NVRAM_CMD_RD			 0x00000000
+ #define  NVRAM_CMD_ERASE		 0x00000040
+ #define  NVRAM_CMD_FIRST		 0x00000080
+ #define  NVRAM_CMD_LAST			 0x00000100
+ #define NVRAM_STAT			0x00007004
+ #define NVRAM_WRDATA			0x00007008
+ #define NVRAM_ADDR			0x0000700c
+ #define  NVRAM_ADDR_MSK			0x00ffffff
+ #define NVRAM_RDDATA			0x00007010
+ #define NVRAM_CFG1			0x00007014
+ #define  NVRAM_CFG1_FLASHIF_ENAB	 0x00000001
+ #define  NVRAM_CFG1_BUFFERED_MODE	 0x00000002
+ #define  NVRAM_CFG1_PASS_THRU		 0x00000004
+ #define  NVRAM_CFG1_BIT_BANG		 0x00000008
+ #define  NVRAM_CFG1_COMPAT_BYPASS	 0x80000000
+ #define NVRAM_CFG2			0x00007018
+ #define NVRAM_CFG3			0x0000701c
+ #define NVRAM_SWARB			0x00007020
+ #define  SWARB_REQ_SET0			 0x00000001
+ #define  SWARB_REQ_SET1			 0x00000002
+ #define  SWARB_REQ_SET2			 0x00000004
+ #define  SWARB_REQ_SET3			 0x00000008
+ #define  SWARB_REQ_CLR0			 0x00000010
+ #define  SWARB_REQ_CLR1			 0x00000020
+ #define  SWARB_REQ_CLR2			 0x00000040
+ #define  SWARB_REQ_CLR3			 0x00000080
+ #define  SWARB_GNT0			 0x00000100
+ #define  SWARB_GNT1			 0x00000200
+ #define  SWARB_GNT2			 0x00000400
+ #define  SWARB_GNT3			 0x00000800
+ #define  SWARB_REQ0			 0x00001000
+ #define  SWARB_REQ1			 0x00002000
+ #define  SWARB_REQ2			 0x00004000
+ #define  SWARB_REQ3			 0x00008000
+ #define    NVRAM_BUFFERED_PAGE_SIZE	   264
+ #define    NVRAM_BUFFERED_PAGE_POS	   9
+ /* 0x7024 --> 0x7400 unused */
+ 
+ /* 0x7400 --> 0x8000 unused */
+ 
+ /* 32K Window into NIC internal memory */
+ #define NIC_SRAM_WIN_BASE		0x00008000
+ 
+ /* Offsets into first 32k of NIC internal memory. */
+ #define NIC_SRAM_PAGE_ZERO		0x00000000
+ #define NIC_SRAM_SEND_RCB		0x00000100 /* 16 * TG3_BDINFO_... */
+ #define NIC_SRAM_RCV_RET_RCB		0x00000200 /* 16 * TG3_BDINFO_... */
+ #define NIC_SRAM_STATS_BLK		0x00000300
+ #define NIC_SRAM_STATUS_BLK		0x00000b00
+ 
+ #define NIC_SRAM_FIRMWARE_MBOX		0x00000b50
+ #define  NIC_SRAM_FIRMWARE_MBOX_MAGIC1	 0x4B657654
+ #define  NIC_SRAM_FIRMWARE_MBOX_MAGIC2	 0x4861764b /* !dma on linkchg */
+ 
+ #define NIC_SRAM_DATA_SIG		0x00000b54
+ #define  NIC_SRAM_DATA_SIG_MAGIC	 0x4b657654 /* ascii for 'KevT' */
+ 
+ #define NIC_SRAM_DATA_CFG			0x00000b58
+ #define  NIC_SRAM_DATA_CFG_LED_MODE_MASK	 0x0000000c
+ #define  NIC_SRAM_DATA_CFG_LED_MODE_UNKNOWN	 0x00000000
+ #define  NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD	 0x00000004
+ #define  NIC_SRAM_DATA_CFG_LED_OPEN_DRAIN	 0x00000004
+ #define  NIC_SRAM_DATA_CFG_LED_LINK_SPD		 0x00000008
+ #define  NIC_SRAM_DATA_CFG_LED_OUTPUT		 0x00000008
+ #define  NIC_SRAM_DATA_CFG_PHY_TYPE_MASK	 0x00000030
+ #define  NIC_SRAM_DATA_CFG_PHY_TYPE_UNKNOWN	 0x00000000
+ #define  NIC_SRAM_DATA_CFG_PHY_TYPE_COPPER	 0x00000010
+ #define  NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER	 0x00000020
+ #define  NIC_SRAM_DATA_CFG_WOL_ENABLE		 0x00000040
+ #define  NIC_SRAM_DATA_CFG_ASF_ENABLE		 0x00000080
+ #define  NIC_SRAM_DATA_CFG_EEPROM_WP		 0x00000100
+ #define  NIC_SRAM_DATA_CFG_MINI_PCI		 0x00001000
+ #define  NIC_SRAM_DATA_CFG_FIBER_WOL		 0x00004000
+ 
+ #define NIC_SRAM_DATA_PHY_ID		0x00000b74
+ #define  NIC_SRAM_DATA_PHY_ID1_MASK	 0xffff0000
+ #define  NIC_SRAM_DATA_PHY_ID2_MASK	 0x0000ffff
+ 
+ #define NIC_SRAM_FW_CMD_MBOX		0x00000b78
+ #define  FWCMD_NICDRV_ALIVE		 0x00000001
+ #define  FWCMD_NICDRV_PAUSE_FW		 0x00000002
+ #define  FWCMD_NICDRV_IPV4ADDR_CHG	 0x00000003
+ #define  FWCMD_NICDRV_IPV6ADDR_CHG	 0x00000004
+ #define  FWCMD_NICDRV_FIX_DMAR		 0x00000005
+ #define  FWCMD_NICDRV_FIX_DMAW		 0x00000006
+ #define NIC_SRAM_FW_CMD_LEN_MBOX	0x00000b7c
+ #define NIC_SRAM_FW_CMD_DATA_MBOX	0x00000b80
+ #define NIC_SRAM_FW_ASF_STATUS_MBOX	0x00000c00
+ #define NIC_SRAM_FW_DRV_STATE_MBOX	0x00000c04
+ #define  DRV_STATE_START		 0x00000001
+ #define  DRV_STATE_UNLOAD		 0x00000002
+ #define  DRV_STATE_WOL			 0x00000003
+ #define  DRV_STATE_SUSPEND		 0x00000004
+ 
+ #define NIC_SRAM_FW_RESET_TYPE_MBOX	0x00000c08
+ 
+ #define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
+ #define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
+ 
+ #define NIC_SRAM_RX_MINI_BUFFER_DESC	0x00001000
+ 
+ #define NIC_SRAM_DMA_DESC_POOL_BASE	0x00002000
+ #define  NIC_SRAM_DMA_DESC_POOL_SIZE	 0x00002000
+ #define NIC_SRAM_TX_BUFFER_DESC		0x00004000 /* 512 entries */
+ #define NIC_SRAM_RX_BUFFER_DESC		0x00006000 /* 256 entries */
+ #define NIC_SRAM_RX_JUMBO_BUFFER_DESC	0x00007000 /* 256 entries */
+ #define NIC_SRAM_MBUF_POOL_BASE		0x00008000
+ #define  NIC_SRAM_MBUF_POOL_SIZE96	 0x00018000
+ #define  NIC_SRAM_MBUF_POOL_SIZE64	 0x00010000
+ #define  NIC_SRAM_MBUF_POOL_BASE5705	0x00010000
+ #define  NIC_SRAM_MBUF_POOL_SIZE5705	0x0000e000
+ 
+ /* Currently this is fixed. */
+ #define PHY_ADDR		0x01
+ 
+ /* Tigon3 specific PHY MII registers. */
+ #define  TG3_BMCR_SPEED1000		0x0040
+ 
+ #define MII_TG3_CTRL			0x09 /* 1000-baseT control register */
+ #define  MII_TG3_CTRL_ADV_1000_HALF	0x0100
+ #define  MII_TG3_CTRL_ADV_1000_FULL	0x0200
+ #define  MII_TG3_CTRL_AS_MASTER		0x0800
+ #define  MII_TG3_CTRL_ENABLE_AS_MASTER	0x1000
+ 
+ #define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
+ #define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+ #define  MII_TG3_EXT_CTRL_TBI		0x8000
+ 
+ #define MII_TG3_EXT_STAT		0x11 /* Extended status register */
+ #define  MII_TG3_EXT_STAT_LPASS		0x0100
+ 
+ #define MII_TG3_DSP_RW_PORT		0x15 /* DSP coefficient read/write port */
+ 
+ #define MII_TG3_DSP_ADDRESS		0x17 /* DSP address register */
+ 
+ #define MII_TG3_AUX_CTRL		0x18 /* auxilliary control register */
+ 
+ #define MII_TG3_AUX_STAT		0x19 /* auxilliary status register */
+ #define MII_TG3_AUX_STAT_LPASS		0x0004
+ #define MII_TG3_AUX_STAT_SPDMASK	0x0700
+ #define MII_TG3_AUX_STAT_10HALF		0x0100
+ #define MII_TG3_AUX_STAT_10FULL		0x0200
+ #define MII_TG3_AUX_STAT_100HALF	0x0300
+ #define MII_TG3_AUX_STAT_100_4		0x0400
+ #define MII_TG3_AUX_STAT_100FULL	0x0500
+ #define MII_TG3_AUX_STAT_1000HALF	0x0600
+ #define MII_TG3_AUX_STAT_1000FULL	0x0700
+ 
+ #define MII_TG3_ISTAT			0x1a /* IRQ status register */
+ #define MII_TG3_IMASK			0x1b /* IRQ mask register */
+ 
+ /* ISTAT/IMASK event bits */
+ #define MII_TG3_INT_LINKCHG		0x0002
+ #define MII_TG3_INT_SPEEDCHG		0x0004
+ #define MII_TG3_INT_DUPLEXCHG		0x0008
+ #define MII_TG3_INT_ANEG_PAGE_RX	0x0400
+ 
+ /* XXX Add this to mii.h */
+ #ifndef ADVERTISE_PAUSE
+ #define ADVERTISE_PAUSE_CAP		0x0400
+ #endif
+ #ifndef ADVERTISE_PAUSE_ASYM
+ #define ADVERTISE_PAUSE_ASYM		0x0800
+ #endif
+ #ifndef LPA_PAUSE
+ #define LPA_PAUSE_CAP			0x0400
+ #endif
+ #ifndef LPA_PAUSE_ASYM
+ #define LPA_PAUSE_ASYM			0x0800
+ #endif
+ 
+ /* There are two ways to manage the TX descriptors on the tigon3.
+  * Either the descriptors are in host DMA'able memory, or they
+  * exist only in the cards on-chip SRAM.  All 16 send bds are under
+  * the same mode, they may not be configured individually.
+  *
+  * The mode we use is controlled by TG3_FLAG_HOST_TXDS in tp->tg3_flags.
+  *
+  * To use host memory TX descriptors:
+  *	1) Set GRC_MODE_HOST_SENDBDS in GRC_MODE register.
+  *	   Make sure GRC_MODE_4X_NIC_SEND_RINGS is clear.
+  *	2) Allocate DMA'able memory.
+  *	3) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+  *	   a) Set TG3_BDINFO_HOST_ADDR to DMA address of memory
+  *	      obtained in step 2
+  *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC.
+  *	   c) Set len field of TG3_BDINFO_MAXLEN_FLAGS to number
+  *            of TX descriptors.  Leave flags field clear.
+  *	4) Access TX descriptors via host memory.  The chip
+  *	   will refetch into local SRAM as needed when producer
+  *	   index mailboxes are updated.
+  *
+  * To use on-chip TX descriptors:
+  *	1) Set GRC_MODE_4X_NIC_SEND_RINGS in GRC_MODE register.
+  *	   Make sure GRC_MODE_HOST_SENDBDS is clear.
+  *	2) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+  *	   a) Set TG3_BDINFO_HOST_ADDR to zero.
+  *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC
+  *	   c) TG3_BDINFO_MAXLEN_FLAGS is don't care.
+  *	3) Access TX descriptors directly in on-chip SRAM
+  *	   using normal {read,write}l().  (and not using
+  *         pointer dereferencing of ioremap()'d memory like
+  *	   the broken Broadcom driver does)
+  *
+  * Note that BDINFO_FLAGS_DISABLED should be set in the flags field of
+  * TG3_BDINFO_MAXLEN_FLAGS of all unused SEND_RCB indices.
+  */
+ struct tg3_tx_buffer_desc {
+ 	uint32_t			addr_hi;
+ 	uint32_t			addr_lo;
+ 
+ 	uint32_t			len_flags;
+ #define TXD_FLAG_TCPUDP_CSUM		0x0001
+ #define TXD_FLAG_IP_CSUM		0x0002
+ #define TXD_FLAG_END			0x0004
+ #define TXD_FLAG_IP_FRAG		0x0008
+ #define TXD_FLAG_IP_FRAG_END		0x0010
+ #define TXD_FLAG_VLAN			0x0040
+ #define TXD_FLAG_COAL_NOW		0x0080
+ #define TXD_FLAG_CPU_PRE_DMA		0x0100
+ #define TXD_FLAG_CPU_POST_DMA		0x0200
+ #define TXD_FLAG_ADD_SRC_ADDR		0x1000
+ #define TXD_FLAG_CHOOSE_SRC_ADDR	0x6000
+ #define TXD_FLAG_NO_CRC			0x8000
+ #define TXD_LEN_SHIFT			16
+ 
+ 	uint32_t			vlan_tag;
+ #define TXD_VLAN_TAG_SHIFT		0
+ #define TXD_MSS_SHIFT			16
+ };
+ 
+ #define TXD_ADDR			0x00UL /* 64-bit */
+ #define TXD_LEN_FLAGS			0x08UL /* 32-bit (upper 16-bits are len) */
+ #define TXD_VLAN_TAG			0x0cUL /* 32-bit (upper 16-bits are tag) */
+ #define TXD_SIZE			0x10UL
+ 
+ struct tg3_rx_buffer_desc {
+ 	uint32_t			addr_hi;
+ 	uint32_t			addr_lo;
+ 
+ 	uint32_t			idx_len;
+ #define RXD_IDX_MASK	0xffff0000
+ #define RXD_IDX_SHIFT	16
+ #define RXD_LEN_MASK	0x0000ffff
+ #define RXD_LEN_SHIFT	0
+ 
+ 	uint32_t			type_flags;
+ #define RXD_TYPE_SHIFT	16
+ #define RXD_FLAGS_SHIFT	0
+ 
+ #define RXD_FLAG_END			0x0004
+ #define RXD_FLAG_MINI			0x0800
+ #define RXD_FLAG_JUMBO			0x0020
+ #define RXD_FLAG_VLAN			0x0040
+ #define RXD_FLAG_ERROR			0x0400
+ #define RXD_FLAG_IP_CSUM		0x1000
+ #define RXD_FLAG_TCPUDP_CSUM		0x2000
+ #define RXD_FLAG_IS_TCP			0x4000
+ 
+ 	uint32_t			ip_tcp_csum;
+ #define RXD_IPCSUM_MASK		0xffff0000
+ #define RXD_IPCSUM_SHIFT	16
+ #define RXD_TCPCSUM_MASK	0x0000ffff
+ #define RXD_TCPCSUM_SHIFT	0
+ 
+ 	uint32_t			err_vlan;
+ 
+ #define RXD_VLAN_MASK			0x0000ffff
+ 
+ #define RXD_ERR_BAD_CRC			0x00010000
+ #define RXD_ERR_COLLISION		0x00020000
+ #define RXD_ERR_LINK_LOST		0x00040000
+ #define RXD_ERR_PHY_DECODE		0x00080000
+ #define RXD_ERR_ODD_NIBBLE_RCVD_MII	0x00100000
+ #define RXD_ERR_MAC_ABRT		0x00200000
+ #define RXD_ERR_TOO_SMALL		0x00400000
+ #define RXD_ERR_NO_RESOURCES		0x00800000
+ #define RXD_ERR_HUGE_FRAME		0x01000000
+ #define RXD_ERR_MASK			0xffff0000
+ 
+ 	uint32_t			reserved;
+ 	uint32_t			opaque;
+ #define RXD_OPAQUE_INDEX_MASK		0x0000ffff
+ #define RXD_OPAQUE_INDEX_SHIFT		0
+ #define RXD_OPAQUE_RING_STD		0x00010000
+ #define RXD_OPAQUE_RING_JUMBO		0x00020000
+ #define RXD_OPAQUE_RING_MINI		0x00040000
+ #define RXD_OPAQUE_RING_MASK		0x00070000
+ };
+ 
+ struct tg3_ext_rx_buffer_desc {
+ 	struct {
+ 		uint32_t		addr_hi;
+ 		uint32_t		addr_lo;
+ 	}				addrlist[3];
+ 	uint32_t			len2_len1;
+ 	uint32_t			resv_len3;
+ 	struct tg3_rx_buffer_desc	std;
+ };
+ 
+ /* We only use this when testing out the DMA engine
+  * at probe time.  This is the internal format of buffer
+  * descriptors used by the chip at NIC_SRAM_DMA_DESCS.
+  */
+ struct tg3_internal_buffer_desc {
+ 	uint32_t			addr_hi;
+ 	uint32_t			addr_lo;
+ 	uint32_t			nic_mbuf;
+ 	/* XXX FIX THIS */
+ #if __BYTE_ORDER == __BIG_ENDIAN
+ 	uint16_t			cqid_sqid;
+ 	uint16_t			len;
+ #else
+ 	uint16_t			len;
+ 	uint16_t			cqid_sqid;
+ #endif
+ 	uint32_t			flags;
+ 	uint32_t			__cookie1;
+ 	uint32_t			__cookie2;
+ 	uint32_t			__cookie3;
+ };
+ 
+ #define TG3_HW_STATUS_SIZE		0x50
+ struct tg3_hw_status {
+ 	uint32_t			status;
+ #define SD_STATUS_UPDATED		0x00000001
+ #define SD_STATUS_LINK_CHG		0x00000002
+ #define SD_STATUS_ERROR			0x00000004
+ 
+ 	uint32_t			status_tag;
+ 
+ #if __BYTE_ORDER == __BIG_ENDIAN
+ 	uint16_t			rx_consumer;
+ 	uint16_t			rx_jumbo_consumer;
+ #else
+ 	uint16_t			rx_jumbo_consumer;
+ 	uint16_t			rx_consumer;
+ #endif
+ 
+ #if __BYTE_ORDER ==  __BIG_ENDIAN
+ 	uint16_t			reserved;
+ 	uint16_t			rx_mini_consumer;
+ #else
+ 	uint16_t			rx_mini_consumer;
+ 	uint16_t			reserved;
+ #endif
+ 	struct {
+ #if __BYTE_ORDER ==  __BIG_ENDIAN
+ 		uint16_t		tx_consumer;
+ 		uint16_t		rx_producer;
+ #else
+ 		uint16_t		rx_producer;
+ 		uint16_t		tx_consumer;
+ #endif
+ 	}				idx[16];
+ };
+ 
+ typedef struct {
+ 	uint32_t high, low;
+ } tg3_stat64_t;
+ 
+ struct tg3_hw_stats {
+ 	uint8_t				__reserved0[0x400-0x300];
+ 
+ 	/* Statistics maintained by Receive MAC. */
+ 	tg3_stat64_t			rx_octets;
+ 	uint64_t			__reserved1;
+ 	tg3_stat64_t			rx_fragments;
+ 	tg3_stat64_t			rx_ucast_packets;
+ 	tg3_stat64_t			rx_mcast_packets;
+ 	tg3_stat64_t			rx_bcast_packets;
+ 	tg3_stat64_t			rx_fcs_errors;
+ 	tg3_stat64_t			rx_align_errors;
+ 	tg3_stat64_t			rx_xon_pause_rcvd;
+ 	tg3_stat64_t			rx_xoff_pause_rcvd;
+ 	tg3_stat64_t			rx_mac_ctrl_rcvd;
+ 	tg3_stat64_t			rx_xoff_entered;
+ 	tg3_stat64_t			rx_frame_too_long_errors;
+ 	tg3_stat64_t			rx_jabbers;
+ 	tg3_stat64_t			rx_undersize_packets;
+ 	tg3_stat64_t			rx_in_length_errors;
+ 	tg3_stat64_t			rx_out_length_errors;
+ 	tg3_stat64_t			rx_64_or_less_octet_packets;
+ 	tg3_stat64_t			rx_65_to_127_octet_packets;
+ 	tg3_stat64_t			rx_128_to_255_octet_packets;
+ 	tg3_stat64_t			rx_256_to_511_octet_packets;
+ 	tg3_stat64_t			rx_512_to_1023_octet_packets;
+ 	tg3_stat64_t			rx_1024_to_1522_octet_packets;
+ 	tg3_stat64_t			rx_1523_to_2047_octet_packets;
+ 	tg3_stat64_t			rx_2048_to_4095_octet_packets;
+ 	tg3_stat64_t			rx_4096_to_8191_octet_packets;
+ 	tg3_stat64_t			rx_8192_to_9022_octet_packets;
+ 
+ 	uint64_t			__unused0[37];
+ 
+ 	/* Statistics maintained by Transmit MAC. */
+ 	tg3_stat64_t			tx_octets;
+ 	uint64_t			__reserved2;
+ 	tg3_stat64_t			tx_collisions;
+ 	tg3_stat64_t			tx_xon_sent;
+ 	tg3_stat64_t			tx_xoff_sent;
+ 	tg3_stat64_t			tx_flow_control;
+ 	tg3_stat64_t			tx_mac_errors;
+ 	tg3_stat64_t			tx_single_collisions;
+ 	tg3_stat64_t			tx_mult_collisions;
+ 	tg3_stat64_t			tx_deferred;
+ 	uint64_t			__reserved3;
+ 	tg3_stat64_t			tx_excessive_collisions;
+ 	tg3_stat64_t			tx_late_collisions;
+ 	tg3_stat64_t			tx_collide_2times;
+ 	tg3_stat64_t			tx_collide_3times;
+ 	tg3_stat64_t			tx_collide_4times;
+ 	tg3_stat64_t			tx_collide_5times;
+ 	tg3_stat64_t			tx_collide_6times;
+ 	tg3_stat64_t			tx_collide_7times;
+ 	tg3_stat64_t			tx_collide_8times;
+ 	tg3_stat64_t			tx_collide_9times;
+ 	tg3_stat64_t			tx_collide_10times;
+ 	tg3_stat64_t			tx_collide_11times;
+ 	tg3_stat64_t			tx_collide_12times;
+ 	tg3_stat64_t			tx_collide_13times;
+ 	tg3_stat64_t			tx_collide_14times;
+ 	tg3_stat64_t			tx_collide_15times;
+ 	tg3_stat64_t			tx_ucast_packets;
+ 	tg3_stat64_t			tx_mcast_packets;
+ 	tg3_stat64_t			tx_bcast_packets;
+ 	tg3_stat64_t			tx_carrier_sense_errors;
+ 	tg3_stat64_t			tx_discards;
+ 	tg3_stat64_t			tx_errors;
+ 
+ 	uint64_t			__unused1[31];
+ 
+ 	/* Statistics maintained by Receive List Placement. */
+ 	tg3_stat64_t			COS_rx_packets[16];
+ 	tg3_stat64_t			COS_rx_filter_dropped;
+ 	tg3_stat64_t			dma_writeq_full;
+ 	tg3_stat64_t			dma_write_prioq_full;
+ 	tg3_stat64_t			rxbds_empty;
+ 	tg3_stat64_t			rx_discards;
+ 	tg3_stat64_t			rx_errors;
+ 	tg3_stat64_t			rx_threshold_hit;
+ 
+ 	uint64_t			__unused2[9];
+ 
+ 	/* Statistics maintained by Send Data Initiator. */
+ 	tg3_stat64_t			COS_out_packets[16];
+ 	tg3_stat64_t			dma_readq_full;
+ 	tg3_stat64_t			dma_read_prioq_full;
+ 	tg3_stat64_t			tx_comp_queue_full;
+ 
+ 	/* Statistics maintained by Host Coalescing. */
+ 	tg3_stat64_t			ring_set_send_prod_index;
+ 	tg3_stat64_t			ring_status_update;
+ 	tg3_stat64_t			nic_irqs;
+ 	tg3_stat64_t			nic_avoided_irqs;
+ 	tg3_stat64_t			nic_tx_threshold_hit;
+ 
+ 	uint8_t				__reserved4[0xb00-0x9c0];
+ };
+ 
+ enum phy_led_mode {
+ 	led_mode_auto,
+ 	led_mode_three_link,
+ 	led_mode_link10
+ };
+ 
+ #if 0
+ /* 'mapping' is superfluous as the chip does not write into
+  * the tx/rx post rings so we could just fetch it from there.
+  * But the cache behavior is better how we are doing it now.
+  */
+ struct ring_info {
+ 	struct sk_buff			*skb;
+ 	DECLARE_PCI_UNMAP_ADDR(mapping)
+ };
+ 
+ struct tx_ring_info {
+ 	struct sk_buff			*skb;
+ 	DECLARE_PCI_UNMAP_ADDR(mapping)
+ 	uint32_t			prev_vlan_tag;
+ };
+ #endif
+ 
+ struct tg3_config_info {
+ 	uint32_t			flags;
+ };
+ 
+ struct tg3_link_config {
+ 	/* Describes what we're trying to get. */
+ 	uint32_t			advertising;
+ #if 0
+ 	uint16_t			speed;
+ 	uint8_t				duplex;
+ 	uint8_t				autoneg;
+ #define SPEED_INVALID		0xffff
+ #define DUPLEX_INVALID		0xff
+ #define AUTONEG_INVALID		0xff
+ #endif
+ 
+ 	/* Describes what we actually have. */
+ 	uint8_t				active_speed;
+ 	uint8_t				active_duplex;
+ 
+ 	/* When we go in and out of low power mode we need
+ 	 * to swap with this state.
+ 	 */
+ #if 0
+ 	int				phy_is_low_power;
+ 	uint16_t			orig_speed;
+ 	uint8_t				orig_duplex;
+ 	uint8_t				orig_autoneg;
+ #endif
+ };
+ 
+ struct tg3_bufmgr_config {
+ 	uint32_t		mbuf_read_dma_low_water;
+ 	uint32_t		mbuf_mac_rx_low_water;
+ 	uint32_t		mbuf_high_water;
+ 
+ 	uint32_t		mbuf_read_dma_low_water_jumbo;
+ 	uint32_t		mbuf_mac_rx_low_water_jumbo;
+ 	uint32_t		mbuf_high_water_jumbo;
+ 
+ 	uint32_t		dma_low_water;
+ 	uint32_t		dma_high_water;
+ };
+ 
+ struct tg3 {
+ #if 0
+ 	/* SMP locking strategy:
+ 	 *
+ 	 * lock: Held during all operations except TX packet
+ 	 *       processing.
+ 	 *
+ 	 * tx_lock: Held during tg3_start_xmit{,_4gbug} and tg3_tx
+ 	 *
+ 	 * If you want to shut up all asynchronous processing you must
+ 	 * acquire both locks, 'lock' taken before 'tx_lock'.  IRQs must
+ 	 * be disabled to take 'lock' but only softirq disabling is
+ 	 * necessary for acquisition of 'tx_lock'.
+ 	 */
+ 	spinlock_t			lock;
+ 	spinlock_t			tx_lock;
+ #endif
+ 
+ 	uint32_t			tx_prod;
+ #if 0
+ 	uint32_t			tx_cons;
+ #endif
+ 	uint32_t			rx_rcb_ptr;
+ 	uint32_t			rx_std_ptr;
+ #if 0
+ 	uint32_t			rx_jumbo_ptr;
+ 	spinlock_t			indirect_lock;
+ 
+ 	struct net_device_stats		net_stats;
+ 	struct net_device_stats		net_stats_prev;
+ #endif
+ 	unsigned long			phy_crc_errors;
+ 
+ #if 0
+ 	uint32_t			rx_offset;
+ #endif
+ 	uint32_t			tg3_flags;
+ #if 0
+ #define TG3_FLAG_HOST_TXDS		0x00000001
+ #endif
+ #define TG3_FLAG_TXD_MBOX_HWBUG		0x00000002
+ #define TG3_FLAG_RX_CHECKSUMS		0x00000004
+ #define TG3_FLAG_USE_LINKCHG_REG	0x00000008
+ #define TG3_FLAG_USE_MI_INTERRUPT	0x00000010
+ #define TG3_FLAG_ENABLE_ASF		0x00000020
+ #define TG3_FLAG_POLL_SERDES		0x00000080
+ #define TG3_FLAG_MBOX_WRITE_REORDER	0x00000100
+ #define TG3_FLAG_PCIX_TARGET_HWBUG	0x00000200
+ #define TG3_FLAG_WOL_SPEED_100MB	0x00000400
+ #define TG3_FLAG_WOL_ENABLE		0x00000800
+ #define TG3_FLAG_EEPROM_WRITE_PROT	0x00001000
+ #define TG3_FLAG_NVRAM			0x00002000
+ #define TG3_FLAG_NVRAM_BUFFERED		0x00004000
+ #define TG3_FLAG_RX_PAUSE		0x00008000
+ #define TG3_FLAG_TX_PAUSE		0x00010000
+ #define TG3_FLAG_PCIX_MODE		0x00020000
+ #define TG3_FLAG_PCI_HIGH_SPEED		0x00040000
+ #define TG3_FLAG_PCI_32BIT		0x00080000
+ #define TG3_FLAG_NO_TX_PSEUDO_CSUM	0x00100000
+ #define TG3_FLAG_NO_RX_PSEUDO_CSUM	0x00200000
+ #define TG3_FLAG_SERDES_WOL_CAP		0x00400000
+ #define TG3_FLAG_JUMBO_ENABLE		0x00800000
+ #define TG3_FLAG_10_100_ONLY		0x01000000
+ #define TG3_FLAG_PAUSE_AUTONEG		0x02000000
+ #define TG3_FLAG_PAUSE_RX		0x04000000
+ #define TG3_FLAG_PAUSE_TX		0x08000000
+ #define TG3_FLAG_BROKEN_CHECKSUMS	0x10000000
+ #define TG3_FLAG_GOT_SERDES_FLOWCTL	0x20000000
+ #define TG3_FLAG_SPLIT_MODE		0x40000000
+ #define TG3_FLAG_INIT_COMPLETE		0x80000000
+ 
+ 	uint32_t			tg3_flags2;
+ #define TG3_FLG2_RESTART_TIMER		0x00000001
+ #define TG3_FLG2_SUN_5704		0x00000002
+ #define TG3_FLG2_NO_ETH_WIRE_SPEED	0x00000004
+ #define TG3_FLG2_IS_5788		0x00000008
+ #define TG3_FLG2_MAX_RXPEND_64		0x00000010
+ #define TG3_FLG2_TSO_CAPABLE		0x00000020
+ 
+ 
+ 
+ 	uint32_t			split_mode_max_reqs;
+ #define SPLIT_MODE_5704_MAX_REQ		3
+ 
+ #if 0
+ 	struct timer_list		timer;
+ 	uint16_t			timer_counter;
+ 	uint16_t			timer_multiplier;
+ 	uint32_t			timer_offset;
+ 	uint16_t			asf_counter;
+ 	uint16_t			asf_multiplier;
+ #endif
+ 
+ 	struct tg3_link_config		link_config;
+ 	struct tg3_bufmgr_config	bufmgr_config;
+ 
+ #if 0
+ 	uint32_t			rx_pending;
+ 	uint32_t			rx_jumbo_pending;
+ 	uint32_t			tx_pending;
+ #endif
+ 
+ 	/* cache h/w values, often passed straight to h/w */
+ 	uint32_t			rx_mode;
+ 	uint32_t			tx_mode;
+ 	uint32_t			mac_mode;
+ 	uint32_t			mi_mode;
+ 	uint32_t			misc_host_ctrl;
+ 	uint32_t			grc_mode;
+ 	uint32_t			grc_local_ctrl;
+ 	uint32_t			dma_rwctrl;
+ #if 0
+ 	uint32_t			coalesce_mode;
+ #endif
+ 
+ 	/* PCI block */
+ 	uint16_t			pci_chip_rev_id;
+ #if 0
+ 	uint8_t				pci_cacheline_sz;
+ 	uint8_t				pci_lat_timer;
+ 	uint8_t				pci_hdr_type;
+ 	uint8_t				pci_bist;
+ #endif
+ 	uint32_t			pci_cfg_state[64 / sizeof(uint32_t)];
+ 
+ 	int				pm_cap;
+ 
+ 	/* PHY info */
+ 	uint32_t			phy_id;
+ #define PHY_ID_MASK			0xfffffff0
+ #define PHY_ID_BCM5400			0x60008040
+ #define PHY_ID_BCM5401			0x60008050
+ #define PHY_ID_BCM5411			0x60008070
+ #define PHY_ID_BCM5701			0x60008110
+ #define PHY_ID_BCM5703			0x60008160
+ #define PHY_ID_BCM5704			0x60008190
+ #define PHY_ID_BCM5705			0x600081a0
+ #define PHY_ID_BCM8002			0x60010140
+ #define PHY_ID_SERDES			0xfeedbee0
+ #define PHY_ID_INVALID			0xffffffff
+ #define PHY_ID_REV_MASK			0x0000000f
+ #define PHY_REV_BCM5401_B0		0x1
+ #define PHY_REV_BCM5401_B2		0x3
+ #define PHY_REV_BCM5401_C0		0x6
+ #define PHY_REV_BCM5411_X0		0x1 /* Found on Netgear GA302T */
+ 
+ 	enum phy_led_mode		led_mode;
+ 
+ 	char				board_part_number[24];
+ 	uint32_t			nic_sram_data_cfg;
+ 	uint32_t			pci_clock_ctrl;
+ #if 0
+ 	struct pci_device		*pdev_peer;
+ #endif
+ 
+ 	/* This macro assumes the passed PHY ID is already masked
+ 	 * with PHY_ID_MASK.
+ 	 */
+ #define KNOWN_PHY_ID(X)		\
+ 	((X) == PHY_ID_BCM5400 || (X) == PHY_ID_BCM5401 || \
+ 	 (X) == PHY_ID_BCM5411 || (X) == PHY_ID_BCM5701 || \
+ 	 (X) == PHY_ID_BCM5703 || (X) == PHY_ID_BCM5704 || \
+ 	 (X) == PHY_ID_BCM5705 || \
+ 	 (X) == PHY_ID_BCM8002 || (X) == PHY_ID_SERDES)
+ 
+ 	unsigned long			regs;
+ 	struct pci_device		*pdev;
+ 	struct nic			*nic;
+ #if 0
+ 	struct net_device		*dev;
+ #endif
+ #if TG3_VLAN_TAG_USED
+ 	struct vlan_group		*vlgrp;
+ #endif
+ 
+ 	struct tg3_rx_buffer_desc	*rx_std;
+ #if 0
+ 	struct ring_info		*rx_std_buffers;
+ 	dma_addr_t			rx_std_mapping;
+ 	struct tg3_rx_buffer_desc	*rx_jumbo;
+ 	struct ring_info		*rx_jumbo_buffers;
+ 	dma_addr_t			rx_jumbo_mapping;
+ #endif
+ 
+ 	struct tg3_rx_buffer_desc	*rx_rcb;
+ #if 0
+ 	dma_addr_t			rx_rcb_mapping;
+ #endif
+ 
+ 	/* TX descs are only used if TG3_FLAG_HOST_TXDS is set. */
+ 	struct tg3_tx_buffer_desc	*tx_ring;
+ #if 0
+ 	struct tx_ring_info		*tx_buffers;
+ 	dma_addr_t			tx_desc_mapping;
+ #endif
+ 
+ 	struct tg3_hw_status		*hw_status;
+ #if 0
+ 	dma_addr_t			status_mapping;
+ #endif
+ #if 0
+ 	uint32_t			msg_enable;
+ #endif
+ 
+ 	struct tg3_hw_stats		*hw_stats;
+ #if 0
+ 	dma_addr_t			stats_mapping;
+ #endif
+ 
+ 	int				carrier_ok;
+ 	uint16_t			subsystem_vendor;
+ 	uint16_t			subsystem_device;
+ };
+ 
+ #endif /* !(_T3_H) */
Only in GRUB_0.94/netboot: tiara.c
diff -rc2P -x CVS GRUB_0.94/netboot/timer.c GRUB/netboot/timer.c
*** GRUB_0.94/netboot/timer.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/timer.c	2003-11-17 10:51:59.000000000 +0800
***************
*** 7,127 ****
   * your option) any later version.
   */
! 
! #include	"etherboot.h"
  #include	"timer.h"
  
! void load_timer2(unsigned int ticks)
! {
! 	/* Set up the timer gate, turn off the speaker */
! 	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
! 	outb(TIMER2_SEL|WORD_ACCESS|MODE0|BINARY_COUNT, TIMER_MODE_PORT);
! 	outb(ticks & 0xFF, TIMER2_PORT);
! 	outb(ticks >> 8, TIMER2_PORT);
! }
! 
! #if defined(CONFIG_TSC_CURRTICKS)
! #define rdtsc(low,high) \
!      __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
! 
! #define rdtscll(val) \
!      __asm__ __volatile__ ("rdtsc" : "=A" (val))
! 
! 
! #define HZ TICKS_PER_SEC
! #define CLOCK_TICK_RATE	1193180U /* Underlying HZ */
! /* LATCH is used in the interval timer and ftape setup. */
! #define LATCH  ((CLOCK_TICK_RATE + HZ/2) / HZ)	/* For divider */
  
! 
! /* ------ Calibrate the TSC ------- 
!  * Return 2^32 * (1 / (TSC clocks per usec)) for do_fast_gettimeoffset().
!  * Too much 64-bit arithmetic here to do this cleanly in C, and for
!  * accuracy's sake we want to keep the overhead on the CTC speaker (channel 2)
!  * output busy loop as low as possible. We avoid reading the CTC registers
!  * directly because of the awkward 8-bit access mechanism of the 82C54
!  * device.
!  */
! 
! #define CALIBRATE_LATCH	(5 * LATCH)
! 
! static unsigned long long calibrate_tsc(void)
  {
! 	/* Set the Gate high, disable speaker */
! 	outb((inb(0x61) & ~0x02) | 0x01, 0x61);
! 
! 	/*
! 	 * Now let's take care of CTC channel 2
! 	 *
! 	 * Set the Gate high, program CTC channel 2 for mode 0,
! 	 * (interrupt on terminal count mode), binary count,
! 	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.
! 	 */
! 	outb(0xb0, 0x43);			/* binary, mode 0, LSB/MSB, Ch 2 */
! 	outb(CALIBRATE_LATCH & 0xff, 0x42);	/* LSB of count */
! 	outb(CALIBRATE_LATCH >> 8, 0x42);	/* MSB of count */
! 
! 	{
! 		unsigned long startlow, starthigh;
! 		unsigned long endlow, endhigh;
! 		unsigned long count;
! 
! 		rdtsc(startlow,starthigh);
! 		count = 0;
! 		do {
! 			count++;
! 		} while ((inb(0x61) & 0x20) == 0);
! 		rdtsc(endlow,endhigh);
! 
! 		/* Error: ECTCNEVERSET */
! 		if (count <= 1)
! 			goto bad_ctc;
! 
! 		/* 64-bit subtract - gcc just messes up with long longs */
! 		__asm__("subl %2,%0\n\t"
! 			"sbbl %3,%1"
! 			:"=a" (endlow), "=d" (endhigh)
! 			:"g" (startlow), "g" (starthigh),
! 			 "0" (endlow), "1" (endhigh));
! 
! 		/* Error: ECPUTOOFAST */
! 		if (endhigh)
! 			goto bad_ctc;
! 
! 		endlow /= 5;
! 		return endlow;
  	}
- 
- 	/*
- 	 * The CTC wasn't reliable: we got a hit on the very first read,
- 	 * or the CPU was so fast/slow that the quotient wouldn't fit in
- 	 * 32 bits..
- 	 */
- bad_ctc:
- 	printf("bad_ctc\n");
- 	return 0;
  }
  
! 
! unsigned long currticks(void)
  {
! 	static unsigned long clocks_per_tick;
! 	unsigned long clocks_high, clocks_low;
! 	unsigned long currticks;
! 	if (!clocks_per_tick) {
! 		clocks_per_tick = calibrate_tsc();
! 		printf("clocks_per_tick = %d\n", clocks_per_tick);
  	}
- 
- 	/* Read the Time Stamp Counter */
- 	rdtsc(clocks_low, clocks_high);
- 
- 	/* currticks = clocks / clocks_per_tick; */
- 	__asm__("divl %1"
- 		:"=a" (currticks)
- 		:"r" (clocks_per_tick), "0" (clocks_low), "d" (clocks_high));
- 
- 
- 	return currticks;
  }
- 
- #endif /* RTC_CURRTICKS */
--- 7,29 ----
   * your option) any later version.
   */
! #include        "grub.h"
  #include	"timer.h"
  
! /* Machine Independant timer helper functions */
  
! void mdelay(unsigned int msecs)
  {
! 	unsigned int i;
! 	for(i = 0; i < msecs; i++) {
! 		udelay(1000);
! 		poll_interruptions();
  	}
  }
  
! void waiton_timer2(unsigned int ticks)
  {
! 	load_timer2(ticks);
! 	while(timer2_running()) {
! 		poll_interruptions();
  	}
  }
diff -rc2P -x CVS GRUB_0.94/netboot/timer.h GRUB/netboot/timer.h
*** GRUB_0.94/netboot/timer.h	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/timer.h	2003-11-17 10:51:59.000000000 +0800
***************
*** 37,41 ****
  
  /* Timers tick over at this rate */
! #define	TICKS_PER_MS	1193
  
  /* Parallel Peripheral Controller Port B */
--- 37,42 ----
  
  /* Timers tick over at this rate */
! #define CLOCK_TICK_RATE	1193180U
! #define	TICKS_PER_MS	(CLOCK_TICK_RATE/1000)
  
  /* Parallel Peripheral Controller Port B */
***************
*** 50,64 ****
     because it is a 16 bit counter */
  extern void load_timer2(unsigned int ticks);
! extern inline int timer2_running(void)
! {
! 	return ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
! }
! 
! extern inline void waiton_timer2(unsigned int ticks)
! {
! 	load_timer2(ticks);
! 	while ((inb(PPC_PORTB) & PPCB_T2OUT) == 0)
! 		;
! }
  
  #endif	/* TIMER_H */
--- 51,63 ----
     because it is a 16 bit counter */
  extern void load_timer2(unsigned int ticks);
! extern inline int timer2_running(void);
! extern void waiton_timer2(unsigned int ticks);
! extern void __load_timer2(unsigned int ticks);
! 
! extern void setup_timers(void);
! extern void ndelay(unsigned int nsecs);
! extern void udelay(unsigned int usecs);
! extern void mdelay(unsigned int msecs);
! //extern unsigned long currticks(void);
  
  #endif	/* TIMER_H */
diff -rc2P -x CVS GRUB_0.94/netboot/tlan.c GRUB/netboot/tlan.c
*** GRUB_0.94/netboot/tlan.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/tlan.c	2003-11-20 11:46:08.000000000 +0800
***************
*** 1,14 ****
  /**************************************************************************
! Etherboot -  BOOTP/TFTP Bootstrap Program
! TLAN driver for Etherboot
  ***************************************************************************/
  
- /*
-  * This program is free software; you can redistribute it and/or
-  * modify it under the terms of the GNU General Public License as
-  * published by the Free Software Foundation; either version 2, or (at
-  * your option) any later version.
-  */
- 
  /* to get some global routines like printf */
  #include "etherboot.h"
--- 1,51 ----
+ #define EB51
+ 
+ #ifdef EB50
+ #define __unused __attribute__((unused))
+ #endif
+ 
  /**************************************************************************
! *
! *    tlan.c -- Etherboot device driver for the Texas Instruments ThunderLAN
! *    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
! *
! *    This program is free software; you can redistribute it and/or modify
! *    it under the terms of the GNU General Public License as published by
! *    the Free Software Foundation; either version 2 of the License, or
! *    (at your option) any later version.
! *
! *    This program is distributed in the hope that it will be useful,
! *    but WITHOUT ANY WARRANTY; without even the implied warranty of
! *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *    GNU General Public License for more details.
! *
! *    You should have received a copy of the GNU General Public License
! *    along with this program; if not, write to the Free Software
! *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
! *
! *    Portions of this code based on:
! *	lan.c: Linux ThunderLan Driver:
! *
! *	by James Banks
! *
! *  	(C) 1997-1998 Caldera, Inc.
! *	(C) 1998 James Banks
! *	(C) 1999-2001 Torben Mathiasen
! *	(C) 2002 Samuel Chessman
! *
! *    $Revision$
! *    $Author$
! *    $Date 2003/07/18 $
! *
! *    REVISION HISTORY:
! *    ================
! *    v1.0	07-08-2003	timlegge	Initial not quite working version
! *    v1.1	07-27-2003	timlegge	Sync 5.0 and 5.1 versions
! *    v1.2	08-19-2003	timlegge	Implement Multicast Support
! *    v1.3	08-23-2003	timlegge	Fix the transmit Function
! *    
! *    Indent Options: indent -kr -i8
  ***************************************************************************/
  
  /* to get some global routines like printf */
  #include "etherboot.h"
***************
*** 17,3443 ****
  /* to get the PCI support functions, if this is a PCI NIC */
  #include "pci.h"
! /* to get our own prototype */
! #include "cards.h"
! 
! 	/*****************************************************************
! 	 * TLan Definitions
! 	 *
! 	 ****************************************************************/
  
! #define TLAN_MIN_FRAME_SIZE	64
! #define TLAN_MAX_FRAME_SIZE	1600
  
! #define TLAN_NUM_RX_LISTS	32
! #define TLAN_NUM_TX_LISTS	64
  
! #define TLAN_IGNORE		0
! #define TLAN_RECORD		1
  
! #define TLAN_DBG(lvl, format, args...)	if (debug&lvl) printf("TLAN: " format, ##args );
! #define TLAN_DEBUG_GNRL		0x0001
! #define TLAN_DEBUG_TX		0x0002
! #define TLAN_DEBUG_RX		0x0004 
! #define TLAN_DEBUG_LIST		0x0008
! #define TLAN_DEBUG_PROBE	0x0010
  
- #define MAX_TLAN_BOARDS		8	 /* Max number of boards installed at a time */
  
! 	/*****************************************************************
! 	 * Device Identification Definitions
! 	 *
! 	 ****************************************************************/
! 		
! #define PCI_DEVICE_ID_NETELLIGENT_10_T2			0xB012
! #define PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100	0xB030
! #ifndef PCI_DEVICE_ID_OLICOM_OC2183
! #define PCI_DEVICE_ID_OLICOM_OC2183			0x0013
! #endif
! #ifndef PCI_DEVICE_ID_OLICOM_OC2325
! #define PCI_DEVICE_ID_OLICOM_OC2325			0x0012
! #endif
! #ifndef PCI_DEVICE_ID_OLICOM_OC2326
! #define PCI_DEVICE_ID_OLICOM_OC2326			0x0014
! #endif
! #define TLAN_ADAPTER_NONE		0x00000000
! #define TLAN_ADAPTER_UNMANAGED_PHY	0x00000001
! #define TLAN_ADAPTER_BIT_RATE_PHY	0x00000002
! #define TLAN_ADAPTER_USE_INTERN_10	0x00000004
! #define TLAN_ADAPTER_ACTIVITY_LED	0x00000008
! #define TLAN_SPEED_DEFAULT	0
! #define TLAN_SPEED_10		10
! #define TLAN_SPEED_100		100
! #define TLAN_DUPLEX_DEFAULT	0
! #define TLAN_DUPLEX_HALF	1
! #define TLAN_DUPLEX_FULL	2
! #define TLAN_BUFFERS_PER_LIST	10
! #define TLAN_LAST_BUFFER	0x80000000
! #define TLAN_CSTAT_UNUSED	0x8000
! #define TLAN_CSTAT_FRM_CMP	0x4000
! #define TLAN_CSTAT_READY	0x3000
! #define TLAN_CSTAT_EOC		0x0800
! #define TLAN_CSTAT_RX_ERROR	0x0400
! #define TLAN_CSTAT_PASS_CRC	0x0200
! #define TLAN_CSTAT_DP_PR	0x0100
! 
! 	/*****************************************************************
! 	 * PHY definitions
! 	 *
! 	 ****************************************************************/
! 
! #define TLAN_PHY_MAX_ADDR	0x1F
! #define TLAN_PHY_NONE		0x20
! 
! 	/*****************************************************************
! 	 * TLan Driver Timer Definitions
! 	 *
! 	 ****************************************************************/
! 
! #define TLAN_TIMER_LINK_BEAT		1
! #define TLAN_TIMER_ACTIVITY		2
! #define TLAN_TIMER_PHY_PDOWN		3
! #define TLAN_TIMER_PHY_PUP		4
! #define TLAN_TIMER_PHY_RESET		5
! #define TLAN_TIMER_PHY_START_LINK	6
! #define TLAN_TIMER_PHY_FINISH_AN	7
! #define TLAN_TIMER_FINISH_RESET		8
! #define TLAN_TIMER_ACT_DELAY		(HZ/10)
! 
! 	/*****************************************************************
! 	 * TLan Driver Eeprom Definitions
! 	 *
! 	 ****************************************************************/
! 
! #define TLAN_EEPROM_ACK		0
! #define TLAN_EEPROM_STOP	1
! 
! 	/*****************************************************************
! 	 * Host Register Offsets and Contents
! 	 *
! 	 ****************************************************************/
! 
! #define TLAN_HOST_CMD			0x00
! #define 	TLAN_HC_GO		0x80000000
! #define		TLAN_HC_STOP		0x40000000
! #define		TLAN_HC_ACK		0x20000000
! #define		TLAN_HC_CS_MASK		0x1FE00000
! #define		TLAN_HC_EOC		0x00100000
! #define		TLAN_HC_RT		0x00080000
! #define		TLAN_HC_NES		0x00040000
! #define		TLAN_HC_AD_RST		0x00008000
! #define		TLAN_HC_LD_TMR		0x00004000
! #define		TLAN_HC_LD_THR		0x00002000
! #define		TLAN_HC_REQ_INT		0x00001000
! #define		TLAN_HC_INT_OFF		0x00000800
! #define		TLAN_HC_INT_ON		0x00000400
! #define		TLAN_HC_AC_MASK		0x000000FF
! #define TLAN_CH_PARM			0x04
! #define TLAN_DIO_ADR			0x08
! #define		TLAN_DA_ADR_INC		0x8000
! #define		TLAN_DA_RAM_ADR		0x4000
! #define TLAN_HOST_INT			0x0A
! #define		TLAN_HI_IV_MASK		0x1FE0
! #define		TLAN_HI_IT_MASK		0x001C
! #define TLAN_DIO_DATA			0x0C
! 
! /* ThunderLAN Internal Register DIO Offsets */
! 
! #define TLAN_NET_CMD			0x00
! #define		TLAN_NET_CMD_NRESET	0x80
! #define		TLAN_NET_CMD_NWRAP	0x40
! #define		TLAN_NET_CMD_CSF	0x20
! #define		TLAN_NET_CMD_CAF	0x10
! #define		TLAN_NET_CMD_NOBRX	0x08
! #define		TLAN_NET_CMD_DUPLEX	0x04
! #define		TLAN_NET_CMD_TRFRAM	0x02
! #define		TLAN_NET_CMD_TXPACE	0x01
! #define TLAN_NET_SIO			0x01
! #define 	TLAN_NET_SIO_MINTEN	0x80
! #define		TLAN_NET_SIO_ECLOK	0x40
! #define		TLAN_NET_SIO_ETXEN	0x20
! #define		TLAN_NET_SIO_EDATA	0x10
! #define		TLAN_NET_SIO_NMRST	0x08
! #define		TLAN_NET_SIO_MCLK	0x04
! #define		TLAN_NET_SIO_MTXEN	0x02
! #define		TLAN_NET_SIO_MDATA	0x01
! #define TLAN_NET_STS			0x02
! #define		TLAN_NET_STS_MIRQ	0x80
! #define		TLAN_NET_STS_HBEAT	0x40
! #define		TLAN_NET_STS_TXSTOP	0x20
! #define		TLAN_NET_STS_RXSTOP	0x10
! #define		TLAN_NET_STS_RSRVD	0x0F
! #define TLAN_NET_MASK			0x03
! #define		TLAN_NET_MASK_MASK7	0x80
! #define		TLAN_NET_MASK_MASK6	0x40
! #define		TLAN_NET_MASK_MASK5	0x20
! #define		TLAN_NET_MASK_MASK4	0x10
! #define		TLAN_NET_MASK_RSRVD	0x0F
! #define TLAN_NET_CONFIG			0x04
! #define 	TLAN_NET_CFG_RCLK	0x8000
! #define		TLAN_NET_CFG_TCLK	0x4000
! #define		TLAN_NET_CFG_BIT	0x2000
! #define		TLAN_NET_CFG_RXCRC	0x1000
! #define		TLAN_NET_CFG_PEF	0x0800
! #define		TLAN_NET_CFG_1FRAG	0x0400
! #define		TLAN_NET_CFG_1CHAN	0x0200
! #define		TLAN_NET_CFG_MTEST	0x0100
! #define		TLAN_NET_CFG_PHY_EN	0x0080
! #define		TLAN_NET_CFG_MSMASK	0x007F
! #define TLAN_MAN_TEST			0x06
! #define TLAN_DEF_VENDOR_ID		0x08
! #define TLAN_DEF_DEVICE_ID		0x0A
! #define TLAN_DEF_REVISION		0x0C
! #define TLAN_DEF_SUBCLASS		0x0D
! #define TLAN_DEF_MIN_LAT		0x0E
! #define TLAN_DEF_MAX_LAT		0x0F
! #define TLAN_AREG_0			0x10
! #define TLAN_AREG_1			0x16
! #define TLAN_AREG_2			0x1C
! #define TLAN_AREG_3			0x22
! #define TLAN_HASH_1			0x28
! #define TLAN_HASH_2			0x2C
! #define TLAN_GOOD_TX_FRMS		0x30
! #define TLAN_TX_UNDERUNS		0x33
! #define TLAN_GOOD_RX_FRMS		0x34
! #define TLAN_RX_OVERRUNS		0x37
! #define TLAN_DEFERRED_TX		0x38
! #define TLAN_CRC_ERRORS			0x3A
! #define TLAN_CODE_ERRORS		0x3B
! #define TLAN_MULTICOL_FRMS		0x3C
! #define TLAN_SINGLECOL_FRMS		0x3E
! #define TLAN_EXCESSCOL_FRMS		0x40
! #define TLAN_LATE_COLS			0x41
! #define TLAN_CARRIER_LOSS		0x42
! #define TLAN_ACOMMIT			0x43
! #define TLAN_LED_REG			0x44
! #define		TLAN_LED_ACT		0x10
! #define		TLAN_LED_LINK		0x01
! #define TLAN_BSIZE_REG			0x45
! #define TLAN_MAX_RX			0x46
! #define TLAN_INT_DIS			0x48
! #define		TLAN_ID_TX_EOC		0x04
! #define		TLAN_ID_RX_EOF		0x02
! #define		TLAN_ID_RX_EOC		0x01
! 
! /* ThunderLAN Interrupt Codes */
! 
! #define TLAN_INT_NUMBER_OF_INTS	8
! 
! #define TLAN_INT_NONE			0x0000
! #define TLAN_INT_TX_EOF			0x0001
! #define TLAN_INT_STAT_OVERFLOW		0x0002
! #define TLAN_INT_RX_EOF			0x0003
! #define TLAN_INT_DUMMY			0x0004
! #define TLAN_INT_TX_EOC			0x0005
! #define TLAN_INT_STATUS_CHECK		0x0006
! #define TLAN_INT_RX_EOC			0x0007
! #define TLAN_TLPHY_ID			0x10
! #define TLAN_TLPHY_CTL			0x11
! #define 	TLAN_TC_IGLINK		0x8000
! #define		TLAN_TC_SWAPOL		0x4000
! #define		TLAN_TC_AUISEL		0x2000
! #define		TLAN_TC_SQEEN		0x1000
! #define		TLAN_TC_MTEST		0x0800
! #define		TLAN_TC_RESERVED	0x07F8
! #define		TLAN_TC_NFEW		0x0004
! #define		TLAN_TC_INTEN		0x0002
! #define		TLAN_TC_TINT		0x0001
! #define TLAN_TLPHY_STS			0x12
! #define		TLAN_TS_MINT		0x8000
! #define		TLAN_TS_PHOK		0x4000
! #define		TLAN_TS_POLOK		0x2000
! #define		TLAN_TS_TPENERGY	0x1000
! #define		TLAN_TS_RESERVED	0x0FFF
! #define TLAN_TLPHY_PAR			0x19
! #define		TLAN_PHY_CIM_STAT	0x0020
! #define		TLAN_PHY_SPEED_100	0x0040
! #define		TLAN_PHY_DUPLEX_FULL	0x0080
! #define		TLAN_PHY_AN_EN_STAT     0x0400
! 
! 
! /* ThunderLAN MII Registers */
! 
! /* Generic MII/PHY Registers */
! 
! #define MII_GEN_CTL			0x00
! #define 	MII_GC_RESET		0x8000
! #define		MII_GC_LOOPBK		0x4000
! #define		MII_GC_SPEEDSEL		0x2000
! #define		MII_GC_AUTOENB		0x1000
! #define		MII_GC_PDOWN		0x0800
! #define		MII_GC_ISOLATE		0x0400
! #define		MII_GC_AUTORSRT		0x0200
! #define		MII_GC_DUPLEX		0x0100
! #define		MII_GC_COLTEST		0x0080
! #define		MII_GC_RESERVED		0x007F
! #define MII_GEN_STS			0x01
! #define		MII_GS_100BT4		0x8000
! #define		MII_GS_100BTXFD		0x4000
! #define		MII_GS_100BTXHD		0x2000
! #define		MII_GS_10BTFD		0x1000
! #define		MII_GS_10BTHD		0x0800
! #define		MII_GS_RESERVED		0x07C0
! #define		MII_GS_AUTOCMPLT	0x0020
! #define		MII_GS_RFLT		0x0010
! #define		MII_GS_AUTONEG		0x0008
! #define		MII_GS_LINK		0x0004
! #define		MII_GS_JABBER		0x0002
! #define		MII_GS_EXTCAP		0x0001
! #define MII_GEN_ID_HI			0x02
! #define MII_GEN_ID_LO			0x03
! #define 	MII_GIL_OUI		0xFC00
! #define 	MII_GIL_MODEL		0x03F0
! #define 	MII_GIL_REVISION	0x000F
! #define MII_AN_ADV			0x04
! #define MII_AN_LPA			0x05
! #define MII_AN_EXP			0x06
! 
! /* ThunderLAN Specific MII/PHY Registers */
! 
! #define 	TLAN_TC_IGLINK		0x8000
! #define		TLAN_TC_SWAPOL		0x4000
! #define		TLAN_TC_AUISEL		0x2000
! #define		TLAN_TC_SQEEN		0x1000
! #define		TLAN_TC_MTEST		0x0800
! #define		TLAN_TC_RESERVED	0x07F8
! #define		TLAN_TC_NFEW		0x0004
! #define		TLAN_TC_INTEN		0x0002
! #define		TLAN_TC_TINT		0x0001
! #define		TLAN_TS_MINT		0x8000
! #define		TLAN_TS_PHOK		0x4000
! #define		TLAN_TS_POLOK		0x2000
! #define		TLAN_TS_TPENERGY	0x1000
! #define		TLAN_TS_RESERVED	0x0FFF
! #define		TLAN_PHY_CIM_STAT	0x0020
! #define		TLAN_PHY_SPEED_100	0x0040
! #define		TLAN_PHY_DUPLEX_FULL	0x0080
! #define		TLAN_PHY_AN_EN_STAT     0x0400
! 
! /* National Sem. & Level1 PHY id's */
! #define NAT_SEM_ID1			0x2000
! #define NAT_SEM_ID2			0x5C01
! #define LEVEL1_ID1			0x7810
! #define LEVEL1_ID2			0x0000
! 
! #define TLan_ClearBit( bit, port )	outb_p(inb_p(port) & ~bit, port)
! #define TLan_GetBit( bit, port )	((int) (inb_p(port) & bit))
! #define TLan_SetBit( bit, port )	outb_p(inb_p(port) | bit, port)
! 
! typedef	unsigned int	u32;
! typedef	unsigned short	u16;
! typedef	unsigned char	u8;
  
! /* Routines to access internal registers. */
  
! inline u8 TLan_DioRead8(u16 base_addr, u16 internal_addr)
! {
! 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
! 	return (inb((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x3)));
! 	
! } /* TLan_DioRead8 */
  
- inline u16 TLan_DioRead16(u16 base_addr, u16 internal_addr)
- {
- 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
- 	return (inw((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x2)));
  
! } /* TLan_DioRead16 */
  
! inline u32 TLan_DioRead32(u16 base_addr, u16 internal_addr)
! {
! 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
! 	return (inl(base_addr + TLAN_DIO_DATA));
  
! } /* TLan_DioRead32 */
  
- inline void TLan_DioWrite8(u16 base_addr, u16 internal_addr, u8 data)
- {
- 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
- 	outb(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x3));
  
! }
  
! inline void TLan_DioWrite16(u16 base_addr, u16 internal_addr, u16 data)
! {
! 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
! 	outw(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
  
- }
  
! inline void TLan_DioWrite32(u16 base_addr, u16 internal_addr, u32 data)
! {
! 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
! 	outl(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
  
! }
  
! /* NIC specific static variables go here */
  
! /*****************************************************************************
! ******************************************************************************
  
- 	ThunderLAN Driver Eeprom routines
  
! 	The Compaq Netelligent 10 and 10/100 cards use a Microchip 24C02A
! 	EEPROM.  These functions are based on information in Microchip's
! 	data sheet.  I don't know how well this functions will work with
! 	other EEPROMs.
  
- ******************************************************************************
- *****************************************************************************/
  
- 	/***************************************************************
- 	 *	TLan_EeSendStart
- 	 *
- 	 *	Returns:
- 	 *		Nothing
- 	 *	Parms:	
- 	 *		io_base		The IO port base address for the
- 	 *				TLAN device with the EEPROM to
- 	 *				use.
- 	 *
- 	 *	This function sends a start cycle to an EEPROM attached
- 	 *	to a TLAN chip.
- 	 *
- 	 **************************************************************/
  
! static void TLan_EeSendStart( u16 io_base )
! {
! 	u16	sio;
  
! 	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
! 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
  
! 	TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 	TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
! 	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
! 	TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );
! 	TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
  
- } /* TLan_EeSendStart */
  
! 	/***************************************************************
! 	 *	TLan_EeSendByte
! 	 *
! 	 *	Returns:
! 	 *		If the correct ack was received, 0, otherwise 1
! 	 *	Parms:	io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *		data		The 8 bits of information to
! 	 *				send to the EEPROM.
! 	 *		stop		If TLAN_EEPROM_STOP is passed, a
! 	 *				stop cycle is sent after the
! 	 *				byte is sent after the ack is
! 	 *				read.
! 	 *
! 	 *	This function sends a byte on the serial EEPROM line,
! 	 *	driving the clock to send each bit. The function then
! 	 *	reverses transmission direction and reads an acknowledge
! 	 *	bit.
! 	 *
! 	 **************************************************************/
  
- static int TLan_EeSendByte( u16 io_base, u8 data, int stop )
- {
- 	int	err;
- 	u8	place;
- 	u16	sio;
  
! 	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
! 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
  
! 	/* Assume clock is low, tx is enabled; */
! 	for ( place = 0x80; place != 0; place >>= 1 ) {
! 		if ( place & data )
! 			TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
! 		else
! 			TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );
! 		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
! 	}
! 	TLan_ClearBit( TLAN_NET_SIO_ETXEN, sio );
! 	TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 	err = TLan_GetBit( TLAN_NET_SIO_EDATA, sio );
! 	TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
! 	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
  
! 	if ( ( ! err ) && stop ) {
! 		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* STOP, raise data while clock is high */
! 		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
! 	}
  
- 	return ( err );
  
- } /* TLan_EeSendByte */
  
! 	/***************************************************************
! 	 *	TLan_EeReceiveByte
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *		data		An address to a char to hold the
! 	 *				data sent from the EEPROM.
! 	 *		stop		If TLAN_EEPROM_STOP is passed, a
! 	 *				stop cycle is sent after the
! 	 *				byte is received, and no ack is
! 	 *				sent.
! 	 *
! 	 *	This function receives 8 bits of data from the EEPROM
! 	 *	over the serial link.  It then sends and ack bit, or no
! 	 *	ack and a stop bit.  This function is used to retrieve
! 	 *	data after the address of a byte in the EEPROM has been
! 	 *	sent.
! 	 *
! 	 **************************************************************/
  
! static void TLan_EeReceiveByte( u16 io_base, u8 *data, int stop )
  {
- 	u8  place;
- 	u16 sio;
  
! 	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
! 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	*data = 0;
  
! 	/* Assume clock is low, tx is enabled; */
! 	TLan_ClearBit( TLAN_NET_SIO_ETXEN, sio );
! 	for ( place = 0x80; place; place >>= 1 ) {
! 		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 		if ( TLan_GetBit( TLAN_NET_SIO_EDATA, sio ) )
! 			*data |= place;
! 		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
  	}
  
! 	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
! 	if ( ! stop ) {
! 		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* Ack = 0 */
! 		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
! 	} else {
! 		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );		/* No ack = 1 (?) */
! 		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
! 		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* STOP, raise data while clock is high */
! 		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
! 		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
! 	}
  
! } /* TLan_EeReceiveByte */
  
! 	/***************************************************************
! 	 *	TLan_EeReadByte
! 	 *
! 	 *	Returns:
! 	 *		No error = 0, else, the stage at which the error
! 	 *		occurred.
! 	 *	Parms:
! 	 *		io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *		ee_addr		The address of the byte in the
! 	 *				EEPROM whose contents are to be
! 	 *				retrieved.
! 	 *		data		An address to a char to hold the
! 	 *				data obtained from the EEPROM.
! 	 *
! 	 *	This function reads a byte of information from an byte
! 	 *	cell in the EEPROM.
! 	 *
! 	 **************************************************************/
  
! static int TLan_EeReadByte( u16 io_base, u8 ee_addr, u8 *data )
  {
! 	int err;
! 	unsigned long flags = 0;
! 	int ret=0;
  
! 	TLan_EeSendStart( io_base );
! 	err = TLan_EeSendByte( io_base, 0xA0, TLAN_EEPROM_ACK );
! 	if (err)
! 	{
! 		ret=1;
! 		goto fail;
! 	}
! 	err = TLan_EeSendByte( io_base, ee_addr, TLAN_EEPROM_ACK );
! 	if (err)
! 	{
! 		ret=2;
! 		goto fail;
! 	}
! 	TLan_EeSendStart( io_base );
! 	err = TLan_EeSendByte( io_base, 0xA1, TLAN_EEPROM_ACK );
! 	if (err)
! 	{
! 		ret=3;
! 		goto fail;
! 	}
! 	TLan_EeReceiveByte( io_base, data, TLAN_EEPROM_STOP );
! fail:
  
! 	return ret;
  
! } /* TLan_EeReadByte */
  
! #if	0
! /* Not yet converted from Linux driver */
! /*****************************************************************************
! ******************************************************************************
  
! 	ThunderLAN Driver PHY Layer Routines
  
! ******************************************************************************
! *****************************************************************************/
  
! 	/*********************************************************************
! 	 *	TLan_PhyPrint
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		dev	A pointer to the device structure of the
! 	 *			TLAN device having the PHYs to be detailed.
! 	 *				
! 	 *	This function prints the registers a PHY (aka tranceiver).
! 	 *
! 	 ********************************************************************/
  
! void TLan_PhyPrint( struct net_device *dev )
! {
! 	TLanPrivateInfo *priv = dev->priv;
! 	u16 i, data0, data1, data2, data3, phy;
  
! 	phy = priv->phy[priv->phyNum];
  
! 	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
! 		printk( "TLAN:   Device %s, Unmanaged PHY.\n", dev->name );
! 	} else if ( phy <= TLAN_PHY_MAX_ADDR ) {
! 		printk( "TLAN:   Device %s, PHY 0x%02x.\n", dev->name, phy );
! 		printk( "TLAN:      Off.  +0     +1     +2     +3 \n" );
!                 for ( i = 0; i < 0x20; i+= 4 ) {
! 			printk( "TLAN:      0x%02x", i );
! 			TLan_MiiReadReg( dev, phy, i, &data0 );
! 			printk( " 0x%04hx", data0 );
! 			TLan_MiiReadReg( dev, phy, i + 1, &data1 );
! 			printk( " 0x%04hx", data1 );
! 			TLan_MiiReadReg( dev, phy, i + 2, &data2 );
! 			printk( " 0x%04hx", data2 );
! 			TLan_MiiReadReg( dev, phy, i + 3, &data3 );
! 			printk( " 0x%04hx\n", data3 );
! 		}
! 	} else {
! 		printk( "TLAN:   Device %s, Invalid PHY.\n", dev->name );
! 	}
  
! } /* TLan_PhyPrint */
  
! 	/*********************************************************************
! 	 *	TLan_PhyDetect
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		dev	A pointer to the device structure of the adapter
! 	 *			for which the PHY needs determined.
! 	 *
! 	 *	So far I've found that adapters which have external PHYs
! 	 *	may also use the internal PHY for part of the functionality.
! 	 *	(eg, AUI/Thinnet).  This function finds out if this TLAN
! 	 *	chip has an internal PHY, and then finds the first external
! 	 *	PHY (starting from address 0) if it exists).
! 	 *
! 	 ********************************************************************/
  
! void TLan_PhyDetect( struct net_device *dev )
! {
! 	TLanPrivateInfo *priv = dev->priv;
! 	u16		control;
! 	u16		hi;
! 	u16		lo;
! 	u32		phy;
  
! 	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
! 		priv->phyNum = 0xFFFF;
! 		return;
  	}
  
! 	TLan_MiiReadReg( dev, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi );
! 	
! 	if ( hi != 0xFFFF ) {
! 		priv->phy[0] = TLAN_PHY_MAX_ADDR;
! 	} else {
! 		priv->phy[0] = TLAN_PHY_NONE;
  	}
  
! 	priv->phy[1] = TLAN_PHY_NONE;
! 	for ( phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++ ) {
! 		TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &control );
! 		TLan_MiiReadReg( dev, phy, MII_GEN_ID_HI, &hi );
! 		TLan_MiiReadReg( dev, phy, MII_GEN_ID_LO, &lo );
! 		if ( ( control != 0xFFFF ) || ( hi != 0xFFFF ) || ( lo != 0xFFFF ) ) {
! 			TLAN_DBG( TLAN_DEBUG_GNRL, "PHY found at %02x %04x %04x %04x\n", phy, control, hi, lo );
! 			if ( ( priv->phy[1] == TLAN_PHY_NONE ) && ( phy != TLAN_PHY_MAX_ADDR ) ) {
! 				priv->phy[1] = phy;
! 			}
! 		}
  	}
  
! 	if ( priv->phy[1] != TLAN_PHY_NONE ) {
! 		priv->phyNum = 1;
! 	} else if ( priv->phy[0] != TLAN_PHY_NONE ) {
! 		priv->phyNum = 0;
  	} else {
! 		printk( "TLAN:  Cannot initialize device, no PHY was found!\n" );
  	}
  
! } /* TLan_PhyDetect */
  
! void TLan_PhyPowerDown( struct net_device *dev )
  {
- 	TLanPrivateInfo	*priv = dev->priv;
- 	u16		value;
  
! 	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Powering down PHY(s).\n", dev->name );
! 	value = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;
! 	TLan_MiiSync( dev->base_addr );
! 	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
! 	if ( ( priv->phyNum == 0 ) && ( priv->phy[1] != TLAN_PHY_NONE ) && ( ! ( priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10 ) ) ) {
! 		TLan_MiiSync( dev->base_addr );
! 		TLan_MiiWriteReg( dev, priv->phy[1], MII_GEN_CTL, value );
  	}
  
! 	/* Wait for 50 ms and powerup
! 	 * This is abitrary.  It is intended to make sure the
! 	 * tranceiver settles.
! 	 */
! 	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP );
  
! } /* TLan_PhyPowerDown */
  
! void TLan_PhyPowerUp( struct net_device *dev )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u16		value;
  
! 	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Powering up PHY.\n", dev->name );
! 	TLan_MiiSync( dev->base_addr );
! 	value = MII_GC_LOOPBK;
! 	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
! 	TLan_MiiSync(dev->base_addr);
! 	/* Wait for 500 ms and reset the
! 	 * tranceiver.  The TLAN docs say both 50 ms and
! 	 * 500 ms, so do the longer, just in case.
! 	 */
! 	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET );
  
! } /* TLan_PhyPowerUp */
  
! void TLan_PhyReset( struct net_device *dev )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u16		phy;
! 	u16		value;
  
! 	phy = priv->phy[priv->phyNum];
  
! 	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Reseting PHY.\n", dev->name );
! 	TLan_MiiSync( dev->base_addr );
! 	value = MII_GC_LOOPBK | MII_GC_RESET;
! 	TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, value );
! 	TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &value );
! 	while ( value & MII_GC_RESET ) {
! 		TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &value );
! 	}
! 
! 	/* Wait for 500 ms and initialize.
! 	 * I don't remember why I wait this long.
! 	 * I've changed this to 50ms, as it seems long enough.
! 	 */
! 	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_START_LINK );
! 
! } /* TLan_PhyReset */
! 
! void TLan_PhyStartLink( struct net_device *dev )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u16		ability;
! 	u16		control;
! 	u16		data;
! 	u16		phy;
! 	u16		status;
! 	u16		tctl;
! 
! 	phy = priv->phy[priv->phyNum];
! 	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Trying to activate link.\n", dev->name );
! 	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
! 	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &ability );
! 
! 	if ( ( status & MII_GS_AUTONEG ) && 
! 	     ( ! priv->aui ) ) {
! 		ability = status >> 11;
! 		if ( priv->speed  == TLAN_SPEED_10 && 
! 		     priv->duplex == TLAN_DUPLEX_HALF) {
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x0000);
! 		} else if ( priv->speed == TLAN_SPEED_10 &&
! 			    priv->duplex == TLAN_DUPLEX_FULL) {
! 			priv->tlanFullDuplex = TRUE;
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x0100);
! 		} else if ( priv->speed == TLAN_SPEED_100 &&
! 			    priv->duplex == TLAN_DUPLEX_HALF) {
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x2000);
! 		} else if ( priv->speed == TLAN_SPEED_100 &&
! 			    priv->duplex == TLAN_DUPLEX_FULL) {
! 			priv->tlanFullDuplex = TRUE;
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x2100);
! 		} else {
! 	
! 			/* Set Auto-Neg advertisement */
! 			TLan_MiiWriteReg( dev, phy, MII_AN_ADV, (ability << 5) | 1);
! 			/* Enablee Auto-Neg */
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x1000 );
! 			/* Restart Auto-Neg */
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x1200 );
! 			/* Wait for 4 sec for autonegotiation
! 		 	* to complete.  The max spec time is less than this
! 		 	* but the card need additional time to start AN.
! 		 	* .5 sec should be plenty extra.
! 		 	*/
! 			printk( "TLAN: %s: Starting autonegotiation.\n", dev->name );
! 			TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN );
! 			return;
! 		}
! 		
! 	}	
! 	
! 	if ( ( priv->aui ) && ( priv->phyNum != 0 ) ) {
! 		priv->phyNum = 0;
! 		data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
! 		TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, data );
! 		TLan_SetTimer( dev, (40*HZ/1000), TLAN_TIMER_PHY_PDOWN );
! 		return;
! 	}  else if ( priv->phyNum == 0 ) {
!         	TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tctl );
! 		if ( priv->aui ) {
!                 	tctl |= TLAN_TC_AUISEL;
! 		} else { 
!                 	tctl &= ~TLAN_TC_AUISEL;
! 			control = 0;
! 			if ( priv->duplex == TLAN_DUPLEX_FULL ) {
! 				control |= MII_GC_DUPLEX;
! 				priv->tlanFullDuplex = TRUE;
! 			}
! 			if ( priv->speed == TLAN_SPEED_100 ) {
! 				control |= MII_GC_SPEEDSEL;
! 			}
!        			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, control );
! 		}
!         	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tctl );
! 	}
! 
! 	/* Wait for 2 sec to give the tranceiver time
! 	 * to establish link.
! 	 */
! 	TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET );
! 
! } /* TLan_PhyStartLink */
! 
! void TLan_PhyFinishAutoNeg( struct net_device *dev )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u16		an_adv;
! 	u16		an_lpa;
! 	u16		data;
! 	u16		mode;
! 	u16		phy;
! 	u16		status;
! 	
! 	phy = priv->phy[priv->phyNum];
! 
! 	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
! 	udelay( 1000 );
! 	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
! 
! 	if ( ! ( status & MII_GS_AUTOCMPLT ) ) {
! 		/* Wait for 8 sec to give the process
! 		 * more time.  Perhaps we should fail after a while.
! 		 */
! 		 if (!priv->neg_be_verbose++) {
! 			 printk(KERN_INFO "TLAN:  Giving autonegotiation more time.\n");
! 		 	 printk(KERN_INFO "TLAN:  Please check that your adapter has\n");
! 		 	 printk(KERN_INFO "TLAN:  been properly connected to a HUB or Switch.\n");
! 			 printk(KERN_INFO "TLAN:  Trying to establish link in the background...\n");
! 		 }
! 		TLan_SetTimer( dev, (8*HZ), TLAN_TIMER_PHY_FINISH_AN );
! 		return;
! 	}
! 
! 	printk( "TLAN: %s: Autonegotiation complete.\n", dev->name );
! 	TLan_MiiReadReg( dev, phy, MII_AN_ADV, &an_adv );
! 	TLan_MiiReadReg( dev, phy, MII_AN_LPA, &an_lpa );
! 	mode = an_adv & an_lpa & 0x03E0;
! 	if ( mode & 0x0100 ) {
! 		priv->tlanFullDuplex = TRUE;
! 	} else if ( ! ( mode & 0x0080 ) && ( mode & 0x0040 ) ) {
! 		priv->tlanFullDuplex = TRUE;
! 	}
! 
! 	if ( ( ! ( mode & 0x0180 ) ) && ( priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10 ) && ( priv->phyNum != 0 ) ) {
! 		priv->phyNum = 0;
! 		data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
! 		TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, data );
! 		TLan_SetTimer( dev, (400*HZ/1000), TLAN_TIMER_PHY_PDOWN );
! 		return;
! 	}
! 
! 	if ( priv->phyNum == 0 ) {
! 		if ( ( priv->duplex == TLAN_DUPLEX_FULL ) || ( an_adv & an_lpa & 0x0040 ) ) {
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, MII_GC_AUTOENB | MII_GC_DUPLEX );
! 			printk( "TLAN:  Starting internal PHY with FULL-DUPLEX\n" );
! 		} else {
! 			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, MII_GC_AUTOENB );
! 			printk( "TLAN:  Starting internal PHY with HALF-DUPLEX\n" );
! 		}
! 	}
! 
! 	/* Wait for 100 ms.  No reason in partiticular.
! 	 */
! 	TLan_SetTimer( dev, (HZ/10), TLAN_TIMER_FINISH_RESET );
! 		
! } /* TLan_PhyFinishAutoNeg */
! 
! #ifdef MONITOR
! 
!         /*********************************************************************
!         *
!         *      TLan_phyMonitor
!         *
!         *      Returns: 
!         *              None
!         *
!         *      Params:
!         *              dev             The device structure of this device.
!         *
!         *      
!         *      This function monitors PHY condition by reading the status
!         *      register via the MII bus. This can be used to give info
!         *      about link changes (up/down), and possible switch to alternate
!         *      media.
!         *
!         * ******************************************************************/
! 
! void TLan_PhyMonitor( struct net_device *dev )
! {
! 	TLanPrivateInfo *priv = dev->priv;
! 	u16     phy;
! 	u16     phy_status;
! 
! 	phy = priv->phy[priv->phyNum];
! 
!         /* Get PHY status register */
!         TLan_MiiReadReg( dev, phy, MII_GEN_STS, &phy_status );
! 
!         /* Check if link has been lost */
!         if (!(phy_status & MII_GS_LINK)) { 
!  	       if (priv->link) {
! 		      priv->link = 0;
! 	              printk(KERN_DEBUG "TLAN: %s has lost link\n", dev->name);
! 	              dev->flags &= ~IFF_RUNNING;
! 		      TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT );
! 		      return;
! 		}
! 	}
! 
!         /* Link restablished? */
!         if ((phy_status & MII_GS_LINK) && !priv->link) {
!  		priv->link = 1;
!         	printk(KERN_DEBUG "TLAN: %s has reestablished link\n", dev->name);
!         	dev->flags |= IFF_RUNNING;
!         }
! 
! 	/* Setup a new monitor */
! 	TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT );
! }	
! 
! #endif /* MONITOR */
! 
! /*****************************************************************************
! ******************************************************************************
! 
! 	ThunderLAN Driver MII Routines
! 
! 	These routines are based on the information in Chap. 2 of the
! 	"ThunderLAN Programmer's Guide", pp. 15-24.
! 
! ******************************************************************************
! *****************************************************************************/
! 
! 	/***************************************************************
! 	 *	TLan_MiiReadReg
! 	 *
! 	 *	Returns:
! 	 *		0	if ack received ok
! 	 *		1	otherwise.
! 	 *
! 	 *	Parms:
! 	 *		dev		The device structure containing
! 	 *				The io address and interrupt count
! 	 *				for this device.
! 	 *		phy		The address of the PHY to be queried.
! 	 *		reg		The register whose contents are to be
! 	 *				retreived.
! 	 *		val		A pointer to a variable to store the
! 	 *				retrieved value.
! 	 *
! 	 *	This function uses the TLAN's MII bus to retreive the contents
! 	 *	of a given register on a PHY.  It sends the appropriate info
! 	 *	and then reads the 16-bit register value from the MII bus via
! 	 *	the TLAN SIO register.
! 	 *
! 	 **************************************************************/
! 
! int TLan_MiiReadReg( struct net_device *dev, u16 phy, u16 reg, u16 *val )
! {
! 	u8	nack;
! 	u16	sio, tmp;
!  	u32	i;
! 	int	err;
! 	int	minten;
! 	TLanPrivateInfo *priv = dev->priv;
! 	unsigned long flags = 0;
! 
! 	err = FALSE;
! 	outw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);
! 	sio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	
! 	if (!in_irq())
! 		spin_lock_irqsave(&priv->lock, flags);
! 
! 	TLan_MiiSync(dev->base_addr);
! 
! 	minten = TLan_GetBit( TLAN_NET_SIO_MINTEN, sio );
! 	if ( minten )
! 		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
! 
! 	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Start ( 01b ) */
! 	TLan_MiiSendData( dev->base_addr, 0x2, 2 );	/* Read  ( 10b ) */
! 	TLan_MiiSendData( dev->base_addr, phy, 5 );	/* Device #      */
! 	TLan_MiiSendData( dev->base_addr, reg, 5 );	/* Register #    */
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);		/* Change direction */
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Clock Idle bit */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Wait 300ns */
! 
! 	nack = TLan_GetBit(TLAN_NET_SIO_MDATA, sio);	/* Check for ACK */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);		/* Finish ACK */
! 	if (nack) {					/* No ACK, so fake it */
! 		for (i = 0; i < 16; i++) {
! 			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
! 			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 		}
! 		tmp = 0xffff;
! 		err = TRUE;
! 	} else {					/* ACK, so read data */
! 		for (tmp = 0, i = 0x8000; i; i >>= 1) {
! 			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
! 			if (TLan_GetBit(TLAN_NET_SIO_MDATA, sio))
! 				tmp |= i;
! 			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 		}
! 	}
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Idle cycle */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 
! 	if ( minten )
! 		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
! 
! 	*val = tmp;
! 	
! 	if (!in_irq())
! 		spin_unlock_irqrestore(&priv->lock, flags);
! 
! 	return err;
! 
! } /* TLan_MiiReadReg */
! 
! 	/***************************************************************
! 	 *	TLan_MiiSendData
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		base_port	The base IO port of the adapter	in
! 	 *				question.
! 	 *		dev		The address of the PHY to be queried.
! 	 *		data		The value to be placed on the MII bus.
! 	 *		num_bits	The number of bits in data that are to
! 	 *				be placed on the MII bus.
! 	 *
! 	 *	This function sends on sequence of bits on the MII
! 	 *	configuration bus.
! 	 *
! 	 **************************************************************/
! 
! void TLan_MiiSendData( u16 base_port, u32 data, unsigned num_bits )
! {
! 	u16 sio;
! 	u32 i;
! 
! 	if ( num_bits == 0 )
! 		return;
! 
! 	outw( TLAN_NET_SIO, base_port + TLAN_DIO_ADR );
! 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	TLan_SetBit( TLAN_NET_SIO_MTXEN, sio );
! 
! 	for ( i = ( 0x1 << ( num_bits - 1 ) ); i; i >>= 1 ) {
! 		TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );
! 		(void) TLan_GetBit( TLAN_NET_SIO_MCLK, sio );
! 		if ( data & i )
! 			TLan_SetBit( TLAN_NET_SIO_MDATA, sio );
! 		else
! 			TLan_ClearBit( TLAN_NET_SIO_MDATA, sio );
! 		TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
! 		(void) TLan_GetBit( TLAN_NET_SIO_MCLK, sio );
! 	}
! 
! } /* TLan_MiiSendData */
! 
! 	/***************************************************************
! 	 *	TLan_MiiSync
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		base_port	The base IO port of the adapter in
! 	 *				question.
! 	 *
! 	 *	This functions syncs all PHYs in terms of the MII configuration
! 	 *	bus.
! 	 *
! 	 **************************************************************/
! 
! void TLan_MiiSync( u16 base_port )
! {
! 	int i;
! 	u16 sio;
! 
! 	outw( TLAN_NET_SIO, base_port + TLAN_DIO_ADR );
! 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
! 
! 	TLan_ClearBit( TLAN_NET_SIO_MTXEN, sio );
! 	for ( i = 0; i < 32; i++ ) {
! 		TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );
! 		TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
! 	}
! 
! } /* TLan_MiiSync */
! 
! 	/***************************************************************
! 	 *	TLan_MiiWriteReg
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		dev		The device structure for the device
! 	 *				to write to.
! 	 *		phy		The address of the PHY to be written to.
! 	 *		reg		The register whose contents are to be
! 	 *				written.
! 	 *		val		The value to be written to the register.
! 	 *
! 	 *	This function uses the TLAN's MII bus to write the contents of a
! 	 *	given register on a PHY.  It sends the appropriate info and then
! 	 *	writes the 16-bit register value from the MII configuration bus
! 	 *	via the TLAN SIO register.
! 	 *
! 	 **************************************************************/
! 
! void TLan_MiiWriteReg( struct net_device *dev, u16 phy, u16 reg, u16 val )
! {
! 	u16	sio;
! 	int	minten;
! 	unsigned long flags = 0;
! 	TLanPrivateInfo *priv = dev->priv;
! 
! 	outw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);
! 	sio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	
! 	if (!in_irq())
! 		spin_lock_irqsave(&priv->lock, flags);
! 
! 	TLan_MiiSync( dev->base_addr );
! 
! 	minten = TLan_GetBit( TLAN_NET_SIO_MINTEN, sio );
! 	if ( minten )
! 		TLan_ClearBit( TLAN_NET_SIO_MINTEN, sio );
! 
! 	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Start ( 01b ) */
! 	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Write ( 01b ) */
! 	TLan_MiiSendData( dev->base_addr, phy, 5 );	/* Device #      */
! 	TLan_MiiSendData( dev->base_addr, reg, 5 );	/* Register #    */
! 
! 	TLan_MiiSendData( dev->base_addr, 0x2, 2 );	/* Send ACK */
! 	TLan_MiiSendData( dev->base_addr, val, 16 );	/* Send Data */
! 
! 	TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );	/* Idle cycle */
! 	TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
! 
! 	if ( minten )
! 		TLan_SetBit( TLAN_NET_SIO_MINTEN, sio );
! 	
! 	if (!in_irq())
! 		spin_unlock_irqrestore(&priv->lock, flags);
! 
! } /* TLan_MiiWriteReg */
! #endif
! 
! /**************************************************************************
! RESET - Reset adapter
! ***************************************************************************/
! static void skel_reset(struct nic *nic)
! {
! 	/* put the card in its initial state */
! }
! 
! /**************************************************************************
! POLL - Wait for a frame
! ***************************************************************************/
! static int skel_poll(struct nic *nic)
! {
! 	/* return true if there's an ethernet packet ready to read */
! 	/* nic->packet should contain data on return */
! 	/* nic->packetlen should contain length of data */
! 	return (0);	/* initially as this is called to flush the input */
! }
! 
! /**************************************************************************
! TRANSMIT - Transmit a frame
! ***************************************************************************/
! static void skel_transmit(
! 	struct nic *nic,
! 	const char *d,			/* Destination */
! 	unsigned int t,			/* Type */
! 	unsigned int s,			/* size */
! 	const char *p)			/* Packet */
! {
! 	/* send the packet to destination */
! }
! 
! /**************************************************************************
! DISABLE - Turn off ethernet interface
! ***************************************************************************/
! static void skel_disable(struct nic *nic)
! {
! }
! 
! /**************************************************************************
! PROBE - Look for an adapter, this routine's visible to the outside
! You should omit the last argument struct pci_device * for a non-PCI NIC
! ***************************************************************************/
! struct nic *tlan_probe(struct nic *nic, unsigned short *probe_addrs,
! 	struct pci_device *p)
! {
! 	/* if probe_addrs is 0, then routine can use a hardwired default */
! 	/* if board found */
! 	{
! 		/* point to NIC specific routines */
! 		nic->reset = skel_reset;
! 		nic->poll = skel_poll;
! 		nic->transmit = skel_transmit;
! 		nic->disable = skel_disable;
! 		return nic;
! 	}
! 	/* else */
! 	return 0;
! }
! 
! #if	0
! #ifndef TLAN_H
! #define TLAN_H
! /********************************************************************
!  *
!  *  Linux ThunderLAN Driver
!  *
!  *  tlan.h
!  *  by James Banks
!  *
!  *  (C) 1997-1998 Caldera, Inc.
!  *  (C) 1999-2001 Torben Mathiasen
!  * 
!  *  This software may be used and distributed according to the terms
!  *  of the GNU General Public License, incorporated herein by reference.
!  *
!  ** This file is best viewed/edited with tabstop=4, colums>=132
!  *
!  *  
!  *  Dec 10, 1999	Torben Mathiasen <torben.mathiasen@compaq.com>
!  *			New Maintainer
!  *
!  ********************************************************************/
! 
! #include <asm/io.h>
! #include <asm/types.h>
! #include <linux/netdevice.h>
! 
! #define FALSE			0
! #define TRUE			1
! 
! #define TX_TIMEOUT		(10*HZ)	 /* We need time for auto-neg */
! 
! typedef struct tlan_adapter_entry {
! 	u16	vendorId;
! 	u16	deviceId;
! 	char	*deviceLabel;
! 	u32	flags;
! 	u16	addrOfs;
! } TLanAdapterEntry;
! 
! 	/*****************************************************************
! 	 * EISA Definitions
! 	 *
! 	 ****************************************************************/
! 
! #define EISA_ID      0xc80   /* EISA ID Registers */ 
! #define EISA_ID0     0xc80   /* EISA ID Register 0 */ 
! #define EISA_ID1     0xc81   /* EISA ID Register 1 */ 
! #define EISA_ID2     0xc82   /* EISA ID Register 2 */ 
! #define EISA_ID3     0xc83   /* EISA ID Register 3 */ 
! #define EISA_CR      0xc84   /* EISA Control Register */
! #define EISA_REG0    0xc88   /* EISA Configuration Register 0 */
! #define EISA_REG1    0xc89   /* EISA Configuration Register 1 */
! #define EISA_REG2    0xc8a   /* EISA Configuration Register 2 */
! #define EISA_REG3    0xc8f   /* EISA Configuration Register 3 */
! #define EISA_APROM   0xc90   /* Ethernet Address PROM */
! 
! 	/*****************************************************************
! 	 * Rx/Tx List Definitions
! 	 *
! 	 ****************************************************************/
! 
! typedef struct tlan_buffer_ref_tag {
! 	u32	count;
! 	u32	address;
! } TLanBufferRef;
! 
! typedef struct tlan_list_tag {
! 	u32		forward;
! 	u16		cStat;
! 	u16		frameSize;
! 	TLanBufferRef	buffer[TLAN_BUFFERS_PER_LIST];
! } TLanList;
! 
! typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZE];
! 
! 	/*****************************************************************
! 	 * TLAN Private Information Structure
! 	 *
! 	 ****************************************************************/
! 
! typedef struct tlan_private_tag {
! 	struct net_device       *nextDevice;
! 	void			*dmaStorage;
! 	u8			*padBuffer;
! 	TLanList                *rxList;
! 	u8			*rxBuffer;
! 	u32                     rxHead;
! 	u32                     rxTail;
! 	u32			rxEocCount;
! 	TLanList                *txList;
! 	u8			*txBuffer;
! 	u32                     txHead;
! 	u32                     txInProgress;
! 	u32                     txTail;
! 	u32			txBusyCount;
! 	u32                     phyOnline;
! 	u32			timerSetAt;
! 	u32			timerType;
! 	struct timer_list	timer;
! 	struct net_device_stats	stats;
! 	struct board		*adapter;
! 	u32			adapterRev;
! 	u32			aui;
! 	u32			debug;
! 	u32			duplex;
! 	u32			phy[2];
! 	u32			phyNum;
! 	u32			speed;
! 	u8			tlanRev;
! 	u8			tlanFullDuplex;
! 	char                    devName[8];
! 	spinlock_t		lock;
! 	u8			link;
! 	u8			is_eisa;
! 	struct tq_struct	tlan_tqueue;
! 	u8			neg_be_verbose;
! } TLanPrivateInfo;
! 
! #define 	TLAN_HC_GO		0x80000000
! #define		TLAN_HC_STOP		0x40000000
! #define		TLAN_HC_ACK		0x20000000
! #define		TLAN_HC_CS_MASK		0x1FE00000
! #define		TLAN_HC_EOC		0x00100000
! #define		TLAN_HC_RT		0x00080000
! #define		TLAN_HC_NES		0x00040000
! #define		TLAN_HC_AD_RST		0x00008000
! #define		TLAN_HC_LD_TMR		0x00004000
! #define		TLAN_HC_LD_THR		0x00002000
! #define		TLAN_HC_REQ_INT		0x00001000
! #define		TLAN_HC_INT_OFF		0x00000800
! #define		TLAN_HC_INT_ON		0x00000400
! #define		TLAN_HC_AC_MASK		0x000000FF
! #define		TLAN_DA_ADR_INC		0x8000
! #define		TLAN_DA_RAM_ADR		0x4000
! #define		TLAN_HI_IV_MASK		0x1FE0
! #define		TLAN_HI_IT_MASK		0x001C
! 
! #define		TLAN_NET_CMD_NRESET	0x80
! #define		TLAN_NET_CMD_NWRAP	0x40
! #define		TLAN_NET_CMD_CSF	0x20
! #define		TLAN_NET_CMD_CAF	0x10
! #define		TLAN_NET_CMD_NOBRX	0x08
! #define		TLAN_NET_CMD_DUPLEX	0x04
! #define		TLAN_NET_CMD_TRFRAM	0x02
! #define		TLAN_NET_CMD_TXPACE	0x01
! #define 	TLAN_NET_SIO_MINTEN	0x80
! #define		TLAN_NET_SIO_ECLOK	0x40
! #define		TLAN_NET_SIO_ETXEN	0x20
! #define		TLAN_NET_SIO_EDATA	0x10
! #define		TLAN_NET_SIO_NMRST	0x08
! #define		TLAN_NET_SIO_MCLK	0x04
! #define		TLAN_NET_SIO_MTXEN	0x02
! #define		TLAN_NET_SIO_MDATA	0x01
! #define		TLAN_NET_STS_MIRQ	0x80
! #define		TLAN_NET_STS_HBEAT	0x40
! #define		TLAN_NET_STS_TXSTOP	0x20
! #define		TLAN_NET_STS_RXSTOP	0x10
! #define		TLAN_NET_STS_RSRVD	0x0F
! #define		TLAN_NET_MASK_MASK7	0x80
! #define		TLAN_NET_MASK_MASK6	0x40
! #define		TLAN_NET_MASK_MASK5	0x20
! #define		TLAN_NET_MASK_MASK4	0x10
! #define		TLAN_NET_MASK_RSRVD	0x0F
! #define 	TLAN_NET_CFG_RCLK	0x8000
! #define		TLAN_NET_CFG_TCLK	0x4000
! #define		TLAN_NET_CFG_BIT	0x2000
! #define		TLAN_NET_CFG_RXCRC	0x1000
! #define		TLAN_NET_CFG_PEF	0x0800
! #define		TLAN_NET_CFG_1FRAG	0x0400
! #define		TLAN_NET_CFG_1CHAN	0x0200
! #define		TLAN_NET_CFG_MTEST	0x0100
! #define		TLAN_NET_CFG_PHY_EN	0x0080
! #define		TLAN_NET_CFG_MSMASK	0x007F
! #define		TLAN_LED_ACT		0x10
! #define		TLAN_LED_LINK		0x01
! #define		TLAN_ID_TX_EOC		0x04
! #define		TLAN_ID_RX_EOF		0x02
! #define		TLAN_ID_RX_EOC		0x01
! 
! #define CIRC_INC( a, b ) if ( ++a >= b ) a = 0
! 
! #ifdef I_LIKE_A_FAST_HASH_FUNCTION
! /* given 6 bytes, view them as 8 6-bit numbers and return the XOR of those */
! /* the code below is about seven times as fast as the original code */
! inline u32 TLan_HashFunc( u8 *a )
! {
!         u8     hash;
! 
!         hash = (a[0]^a[3]);             /* & 077 */
!         hash ^= ((a[0]^a[3])>>6);       /* & 003 */
!         hash ^= ((a[1]^a[4])<<2);       /* & 074 */
!         hash ^= ((a[1]^a[4])>>4);       /* & 017 */
!         hash ^= ((a[2]^a[5])<<4);       /* & 060 */
!         hash ^= ((a[2]^a[5])>>2);       /* & 077 */
! 
!         return (hash & 077);
! }
! 
! #else /* original code */
! 
! inline	u32	xor( u32 a, u32 b )
! {
! 	return ( ( a && ! b ) || ( ! a && b ) );
! }
! #define XOR8( a, b, c, d, e, f, g, h )	xor( a, xor( b, xor( c, xor( d, xor( e, xor( f, xor( g, h ) ) ) ) ) ) )
! #define DA( a, bit )					( ( (u8) a[bit/8] ) & ( (u8) ( 1 << bit%8 ) ) )
! 
! inline u32 TLan_HashFunc( u8 *a )
! {
! 	u32	hash;
! 
! 	hash  = XOR8( DA(a,0), DA(a, 6), DA(a,12), DA(a,18), DA(a,24), DA(a,30), DA(a,36), DA(a,42) );
! 	hash |= XOR8( DA(a,1), DA(a, 7), DA(a,13), DA(a,19), DA(a,25), DA(a,31), DA(a,37), DA(a,43) ) << 1;
! 	hash |= XOR8( DA(a,2), DA(a, 8), DA(a,14), DA(a,20), DA(a,26), DA(a,32), DA(a,38), DA(a,44) ) << 2;
! 	hash |= XOR8( DA(a,3), DA(a, 9), DA(a,15), DA(a,21), DA(a,27), DA(a,33), DA(a,39), DA(a,45) ) << 3;
! 	hash |= XOR8( DA(a,4), DA(a,10), DA(a,16), DA(a,22), DA(a,28), DA(a,34), DA(a,40), DA(a,46) ) << 4;
! 	hash |= XOR8( DA(a,5), DA(a,11), DA(a,17), DA(a,23), DA(a,29), DA(a,35), DA(a,41), DA(a,47) ) << 5;
! 
! 	return hash;
! 
! } 
! 
! #endif /* I_LIKE_A_FAST_HASH_FUNCTION */
! #endif
! /*******************************************************************************
!  *
!  *  Linux ThunderLAN Driver
!  *
!  *  tlan.c
!  *  by James Banks
!  *
!  *  (C) 1997-1998 Caldera, Inc.
!  *  (C) 1998 James Banks
!  *  (C) 1999-2001 Torben Mathiasen
!  *
!  *  This software may be used and distributed according to the terms
!  *  of the GNU General Public License, incorporated herein by reference.
!  *
!  ** This file is best viewed/edited with columns>=132.
!  *
!  ** Useful (if not required) reading:
!  *
!  *		Texas Instruments, ThunderLAN Programmer's Guide,
!  *			TI Literature Number SPWU013A
!  *			available in PDF format from www.ti.com
!  *		Level One, LXT901 and LXT970 Data Sheets
!  *			available in PDF format from www.level1.com
!  *		National Semiconductor, DP83840A Data Sheet
!  *			available in PDF format from www.national.com
!  *		Microchip Technology, 24C01A/02A/04A Data Sheet
!  *			available in PDF format from www.microchip.com
!  *
!  * Change History
!  *
!  *	Tigran Aivazian <tigran@sco.com>:	TLan_PciProbe() now uses
!  *						new PCI BIOS interface.
!  *	Alan Cox	<alan@redhat.com>:	Fixed the out of memory
!  *						handling.
!  *      
!  *	Torben Mathiasen <torben.mathiasen@compaq.com> New Maintainer!
!  *
!  *	v1.1 Dec 20, 1999    - Removed linux version checking
!  *			       Patch from Tigran Aivazian. 
!  *			     - v1.1 includes Alan's SMP updates.
!  *			     - We still have problems on SMP though,
!  *			       but I'm looking into that. 
!  *			
!  *	v1.2 Jan 02, 2000    - Hopefully fixed the SMP deadlock.
!  *			     - Removed dependency of HZ being 100.
!  *			     - We now allow higher priority timers to 
!  *			       overwrite timers like TLAN_TIMER_ACTIVITY
!  *			       Patch from John Cagle <john.cagle@compaq.com>.
!  *			     - Fixed a few compiler warnings.
!  *
!  *	v1.3 Feb 04, 2000    - Fixed the remaining HZ issues.
!  *			     - Removed call to pci_present(). 
!  *			     - Removed SA_INTERRUPT flag from irq handler.
!  *			     - Added __init and __initdata to reduce resisdent 
!  *			       code size.
!  *			     - Driver now uses module_init/module_exit.
!  *			     - Rewrote init_module and tlan_probe to
!  *			       share a lot more code. We now use tlan_probe
!  *			       with builtin and module driver.
!  *			     - Driver ported to new net API. 
!  *			     - tlan.txt has been reworked to reflect current 
!  *			       driver (almost)
!  *			     - Other minor stuff
!  *
!  *	v1.4 Feb 10, 2000    - Updated with more changes required after Dave's
!  *	                       network cleanup in 2.3.43pre7 (Tigran & myself)
!  *	                     - Minor stuff.
!  *
!  *	v1.5 March 22, 2000  - Fixed another timer bug that would hang the driver
!  *			       if no cable/link were present.
!  *			     - Cosmetic changes.
!  *			     - TODO: Port completely to new PCI/DMA API
!  *			     	     Auto-Neg fallback.
!  *
!  * 	v1.6 April 04, 2000  - Fixed driver support for kernel-parameters. Haven't
!  * 			       tested it though, as the kernel support is currently 
!  * 			       broken (2.3.99p4p3).
!  * 			     - Updated tlan.txt accordingly.
!  * 			     - Adjusted minimum/maximum frame length.
!  * 			     - There is now a TLAN website up at 
!  * 			       http://tlan.kernel.dk
!  *
!  * 	v1.7 April 07, 2000  - Started to implement custom ioctls. Driver now
!  * 			       reports PHY information when used with Donald
!  * 			       Beckers userspace MII diagnostics utility.
!  *
!  * 	v1.8 April 23, 2000  - Fixed support for forced speed/duplex settings.
!  * 			     - Added link information to Auto-Neg and forced
!  * 			       modes. When NIC operates with auto-neg the driver
!  * 			       will report Link speed & duplex modes as well as
!  * 			       link partner abilities. When forced link is used,
!  * 			       the driver will report status of the established
!  * 			       link.
!  * 			       Please read tlan.txt for additional information. 
!  * 			     - Removed call to check_region(), and used 
!  * 			       return value of request_region() instead.
!  *	
!  *	v1.8a May 28, 2000   - Minor updates.
!  *
!  *	v1.9 July 25, 2000   - Fixed a few remaining Full-Duplex issues.
!  *	                     - Updated with timer fixes from Andrew Morton.
!  *	                     - Fixed module race in TLan_Open.
!  *	                     - Added routine to monitor PHY status.
!  *	                     - Added activity led support for Proliant devices.
!  *
!  *	v1.10 Aug 30, 2000   - Added support for EISA based tlan controllers 
!  *			       like the Compaq NetFlex3/E. 
!  *			     - Rewrote tlan_probe to better handle multiple
!  *			       bus probes. Probing and device setup is now
!  *			       done through TLan_Probe and TLan_init_one. Actual
!  *			       hardware probe is done with kernel API and 
!  *			       TLan_EisaProbe.
!  *			     - Adjusted debug information for probing.
!  *			     - Fixed bug that would cause general debug information 
!  *			       to be printed after driver removal. 
!  *			     - Added transmit timeout handling.
!  *			     - Fixed OOM return values in tlan_probe. 
!  *			     - Fixed possible mem leak in tlan_exit 
!  *			       (now tlan_remove_one).
!  *			     - Fixed timer bug in TLan_phyMonitor.
!  *			     - This driver version is alpha quality, please
!  *			       send me any bug issues you may encounter.
!  *
!  *	v1.11 Aug 31, 2000   - Do not try to register irq 0 if no irq line was 
!  *			       set for EISA cards.
!  *			     - Added support for NetFlex3/E with nibble-rate
!  *			       10Base-T PHY. This is untestet as I haven't got
!  *			       one of these cards.
!  *			     - Fixed timer being added twice.
!  *			     - Disabled PhyMonitoring by default as this is
!  *			       work in progress. Define MONITOR to enable it.
!  *			     - Now we don't display link info with PHYs that
!  *			       doesn't support it (level1).
!  *			     - Incresed tx_timeout beacuse of auto-neg.
!  *			     - Adjusted timers for forced speeds.
!  *
!  *	v1.12 Oct 12, 2000   - Minor fixes (memleak, init, etc.)
!  *
!  * 	v1.13 Nov 28, 2000   - Stop flooding console with auto-neg issues
!  * 			       when link can't be established.
!  *			     - Added the bbuf option as a kernel parameter.
!  *			     - Fixed ioaddr probe bug.
!  *			     - Fixed stupid deadlock with MII interrupts.
!  *			     - Added support for speed/duplex selection with 
!  *			       multiple nics.
!  *			     - Added partly fix for TX Channel lockup with
!  *			       TLAN v1.0 silicon. This needs to be investigated
!  *			       further.
!  *
!  * 	v1.14 Dec 16, 2000   - Added support for servicing multiple frames per.
!  * 			       interrupt. Thanks goes to
!  * 			       Adam Keys <adam@ti.com>
!  * 			       Denis Beaudoin <dbeaudoin@ti.com>
!  * 			       for providing the patch.
!  * 			     - Fixed auto-neg output when using multiple
!  * 			       adapters.
!  * 			     - Converted to use new taskq interface.
!  *
!  * 	v1.14a Jan 6, 2001   - Minor adjustments (spinlocks, etc.)
!  *
!  *******************************************************************************/
! 
!                                                                                 
! #include <linux/module.h>
! 
! #include "tlan.h"
! 
! #include <linux/init.h>
! #include <linux/ioport.h>
! #include <linux/pci.h>
! #include <linux/etherdevice.h>
! #include <linux/delay.h>
! #include <linux/spinlock.h>
! #include <linux/mii.h>
! 
! typedef u32 (TLanIntVectorFunc)( struct net_device *, u16 );
! 
! /* For removing EISA devices */
! static	struct net_device	*TLan_Eisa_Devices;
! 
! static	int		TLanDevicesInstalled;
! 
! /* Set speed, duplex and aui settings */
! static  int aui[MAX_TLAN_BOARDS];
! static  int duplex[MAX_TLAN_BOARDS];
! static  int speed[MAX_TLAN_BOARDS];
! static  int boards_found;
! 
! MODULE_AUTHOR("Maintainer: Torben Mathiasen <torben.mathiasen@compaq.com>");
! MODULE_DESCRIPTION("Driver for TI ThunderLAN based ethernet PCI adapters");
! MODULE_LICENSE("GPL");
! 
! MODULE_PARM(aui, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
! MODULE_PARM(duplex, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
! MODULE_PARM(speed, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
! MODULE_PARM(debug, "i");
! MODULE_PARM(bbuf, "i");
! MODULE_PARM_DESC(aui, "ThunderLAN use AUI port(s) (0-1)");
! MODULE_PARM_DESC(duplex, "ThunderLAN duplex setting(s) (0-default, 1-half, 2-full)");
! MODULE_PARM_DESC(speed, "ThunderLAN port speen setting(s) (0,10,100)");
! MODULE_PARM_DESC(debug, "ThunderLAN debug mask");
! MODULE_PARM_DESC(bbuf, "ThunderLAN use big buffer (0-1)");
! EXPORT_NO_SYMBOLS;
! 
! /* Define this to enable Link beat monitoring */
! #undef MONITOR
! 
! /* Turn on debugging. See linux/Documentation/networking/tlan.txt for details */
! static  int		debug;
! 
! static	int		bbuf;
! static	u8		*TLanPadBuffer;
! static	char		TLanSignature[] = "TLAN";
! static const char tlan_banner[] = "ThunderLAN driver v1.14a\n";
! static int tlan_have_pci;
! static int tlan_have_eisa;
! 
! const char *media[] = {
! 	"10BaseT-HD ", "10BaseT-FD ","100baseTx-HD ", 
! 	"100baseTx-FD", "100baseT4", 0
! };
! 
! int media_map[] = { 0x0020, 0x0040, 0x0080, 0x0100, 0x0200,};
! 
! static struct board {
! 	const char	*deviceLabel;
! 	u32	   	flags;
! 	u16	   	addrOfs;
! } board_info[] __devinitdata = {
! 	{ "Compaq Netelligent 10 T PCI UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
! 	{ "Compaq Netelligent 10/100 TX PCI UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
! 	{ "Compaq Integrated NetFlex-3/P", TLAN_ADAPTER_NONE, 0x83 },
! 	{ "Compaq NetFlex-3/P", TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },
! 	{ "Compaq NetFlex-3/P", TLAN_ADAPTER_NONE, 0x83 },
! 	{ "Compaq Netelligent Integrated 10/100 TX UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
! 	{ "Compaq Netelligent Dual 10/100 TX PCI UTP", TLAN_ADAPTER_NONE, 0x83 },
! 	{ "Compaq Netelligent 10/100 TX Embedded UTP", TLAN_ADAPTER_NONE, 0x83 },
! 	{ "Olicom OC-2183/2185", TLAN_ADAPTER_USE_INTERN_10, 0x83 },
! 	{ "Olicom OC-2325", TLAN_ADAPTER_UNMANAGED_PHY, 0xF8 },
! 	{ "Olicom OC-2326", TLAN_ADAPTER_USE_INTERN_10, 0xF8 },
! 	{ "Compaq Netelligent 10/100 TX UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
! 	{ "Compaq Netelligent 10 T/2 PCI UTP/Coax", TLAN_ADAPTER_NONE, 0x83 },
! 	{ "Compaq NetFlex-3/E", TLAN_ADAPTER_ACTIVITY_LED | 	/* EISA card */
! 	                        TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },	
! 	{ "Compaq NetFlex-3/E", TLAN_ADAPTER_ACTIVITY_LED, 0x83 }, /* EISA card */
! };
! 
! static struct pci_device_id tlan_pci_tbl[] __devinitdata = {
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL10,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3I,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_THUNDER,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3B,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100PI,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100D,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 6 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100I,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 7 },
! 	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2183,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8 },
! 	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2325,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 9 },
! 	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2326,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 10 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 11 },
! 	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_T2,
! 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 12 },
! 	{ 0,}
! };
! MODULE_DEVICE_TABLE(pci, tlan_pci_tbl);		
! 
! static void	TLan_EisaProbe( void );
! static void	TLan_Eisa_Cleanup( void );
! static int      TLan_Init( struct net_device * );
! static int	TLan_Open( struct net_device *dev );
! static int	TLan_StartTx( struct sk_buff *, struct net_device *);
! static void	TLan_HandleInterrupt( int, void *, struct pt_regs *);
! static int	TLan_Close( struct net_device *);
! static struct	net_device_stats *TLan_GetStats( struct net_device *);
! static void	TLan_SetMulticastList( struct net_device *);
! static int	TLan_ioctl( struct net_device *dev, struct ifreq *rq, int cmd);
! static int      TLan_probe1( struct pci_dev *pdev, long ioaddr, int irq, int rev, const struct pci_device_id *ent);
! static void	TLan_tx_timeout( struct net_device *dev);
! static int 	tlan_init_one( struct pci_dev *pdev, const struct pci_device_id *ent);
! 
! static u32	TLan_HandleInvalid( struct net_device *, u16 );
! static u32	TLan_HandleTxEOF( struct net_device *, u16 );
! static u32	TLan_HandleStatOverflow( struct net_device *, u16 );
! static u32	TLan_HandleRxEOF( struct net_device *, u16 );
! static u32	TLan_HandleDummy( struct net_device *, u16 );
! static u32	TLan_HandleTxEOC( struct net_device *, u16 );
! static u32	TLan_HandleStatusCheck( struct net_device *, u16 );
! static u32	TLan_HandleRxEOC( struct net_device *, u16 );
! 
! static void	TLan_Timer( unsigned long );
! 
! static void	TLan_ResetLists( struct net_device * );
! static void	TLan_FreeLists( struct net_device * );
! static void	TLan_PrintDio( u16 );
! static void	TLan_PrintList( TLanList *, char *, int );
! static void	TLan_ReadAndClearStats( struct net_device *, int );
! static void	TLan_ResetAdapter( struct net_device * );
! static void	TLan_FinishReset( struct net_device * );
! static void	TLan_SetMac( struct net_device *, int areg, char *mac );
! 
! static void	TLan_PhyPrint( struct net_device * );
! static void	TLan_PhyDetect( struct net_device * );
! static void	TLan_PhyPowerDown( struct net_device * );
! static void	TLan_PhyPowerUp( struct net_device * );
! static void	TLan_PhyReset( struct net_device * );
! static void	TLan_PhyStartLink( struct net_device * );
! static void	TLan_PhyFinishAutoNeg( struct net_device * );
! #ifdef MONITOR
! static void     TLan_PhyMonitor( struct net_device * );
! #endif
! 
! /*
! static int	TLan_PhyNop( struct net_device * );
! static int	TLan_PhyInternalCheck( struct net_device * );
! static int	TLan_PhyInternalService( struct net_device * );
! static int	TLan_PhyDp83840aCheck( struct net_device * );
! */
! 
! static int	TLan_MiiReadReg( struct net_device *, u16, u16, u16 * );
! static void	TLan_MiiSendData( u16, u32, unsigned );
! static void	TLan_MiiSync( u16 );
! static void	TLan_MiiWriteReg( struct net_device *, u16, u16, u16 );
! 
! static void	TLan_EeSendStart( u16 );
! static int	TLan_EeSendByte( u16, u8, int );
! static void	TLan_EeReceiveByte( u16, u8 *, int );
! static int	TLan_EeReadByte( struct net_device *, u8, u8 * );
! 
! static TLanIntVectorFunc *TLanIntVector[TLAN_INT_NUMBER_OF_INTS] = {
! 	TLan_HandleInvalid,
! 	TLan_HandleTxEOF,
! 	TLan_HandleStatOverflow,
! 	TLan_HandleRxEOF,
! 	TLan_HandleDummy,
! 	TLan_HandleTxEOC,
! 	TLan_HandleStatusCheck,
! 	TLan_HandleRxEOC
! };
! 
! static inline void
! TLan_SetTimer( struct net_device *dev, u32 ticks, u32 type )
! {
! 	TLanPrivateInfo *priv = dev->priv;
! 	unsigned long flags = 0;
! 	
! 	if (!in_irq())
! 		spin_lock_irqsave(&priv->lock, flags);
! 	if ( priv->timer.function != NULL &&
! 		priv->timerType != TLAN_TIMER_ACTIVITY ) { 
! 		if (!in_irq())
! 			spin_unlock_irqrestore(&priv->lock, flags);
! 		return;
! 	}
! 	priv->timer.function = &TLan_Timer;
! 	if (!in_irq())
! 		spin_unlock_irqrestore(&priv->lock, flags);
! 
! 	priv->timer.data = (unsigned long) dev;
! 	priv->timerSetAt = jiffies;
! 	priv->timerType = type;
! 	mod_timer(&priv->timer, jiffies + ticks);
! 	
! } /* TLan_SetTimer */
! 
! /*****************************************************************************
! ******************************************************************************
! 
! 	ThunderLAN Driver Primary Functions
! 
! 	These functions are more or less common to all Linux network drivers.
! 
! ******************************************************************************
! *****************************************************************************/
! 
! 	/***************************************************************
! 	 *	tlan_remove_one
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		None
! 	 *
! 	 *	Goes through the TLanDevices list and frees the device
! 	 *	structs and memory associated with each device (lists
! 	 *	and buffers).  It also ureserves the IO port regions
! 	 *	associated with this device.
! 	 *
! 	 **************************************************************/
! 
! static void __devexit tlan_remove_one( struct pci_dev *pdev)
! {
! 	struct net_device *dev = pci_get_drvdata( pdev );
! 	TLanPrivateInfo	*priv = dev->priv;
! 	
! 	unregister_netdev( dev );
! 
! 	if ( priv->dmaStorage ) {
! 		kfree( priv->dmaStorage );
! 	}
! 
! 	release_region( dev->base_addr, 0x10 );
! 	
! 	kfree( dev );
! 		
! 	pci_set_drvdata( pdev, NULL );
! } 
! 
! static struct pci_driver tlan_driver = {
! 	name:		"tlan",
! 	id_table:	tlan_pci_tbl,
! 	probe:		tlan_init_one,
! 	remove:		tlan_remove_one,	
! };
! 
! static int __init tlan_probe(void)
! {
! 	static int	pad_allocated;
! 	
! 	printk(KERN_INFO "%s", tlan_banner);
! 	
! 	TLanPadBuffer = (u8 *) kmalloc(TLAN_MIN_FRAME_SIZE, 
! 					GFP_KERNEL);
! 
! 	if (TLanPadBuffer == NULL) {
! 		printk(KERN_ERR "TLAN: Could not allocate memory for pad buffer.\n");
! 		return -ENOMEM;
! 	}
! 
! 	memset(TLanPadBuffer, 0, TLAN_MIN_FRAME_SIZE);
! 	pad_allocated = 1;
! 
! 	TLAN_DBG(TLAN_DEBUG_PROBE, "Starting PCI Probe....\n");
! 	
! 	/* Use new style PCI probing. Now the kernel will
! 	   do most of this for us */
! 	pci_register_driver(&tlan_driver);
! 
! 	TLAN_DBG(TLAN_DEBUG_PROBE, "Starting EISA Probe....\n");
! 	TLan_EisaProbe();
! 		
! 	printk(KERN_INFO "TLAN: %d device%s installed, PCI: %d  EISA: %d\n", 
! 		 TLanDevicesInstalled, TLanDevicesInstalled == 1 ? "" : "s",
! 		 tlan_have_pci, tlan_have_eisa);
! 
! 	if (TLanDevicesInstalled == 0) {
! 		pci_unregister_driver(&tlan_driver);
! 		kfree(TLanPadBuffer);
! 		return -ENODEV;
! 	}
! 	return 0;
! }
! 	
! 
! static int __devinit tlan_init_one( struct pci_dev *pdev,
! 				    const struct pci_device_id *ent)
! {
! 	return TLan_probe1( pdev, -1, -1, 0, ent);
! }
! 
! /*
! 	***************************************************************
! 	 *	tlan_probe1
! 	 *
! 	 *	Returns:
! 	 *		0 on success, error code on error
! 	 *	Parms: 
! 	 *		none
! 	 *
! 	 *	The name is lower case to fit in with all the rest of
! 	 *	the netcard_probe names.  This function looks for 
! 	 *	another TLan based adapter, setting it up with the
! 	 *	allocated device struct if one is found.
! 	 *	tlan_probe has been ported to the new net API and
! 	 *	now allocates its own device structure. This function
! 	 *	is also used by modules.
! 	 *
! 	 **************************************************************/
! 
! static int __devinit TLan_probe1(struct pci_dev *pdev, 
! 				long ioaddr, int irq, int rev, const struct pci_device_id *ent )
! {
! 
! 	struct net_device  *dev;
! 	TLanPrivateInfo    *priv;
! 	u8		   pci_rev;
! 	u16		   device_id;
! 	int		   reg;
! 
! 	if (pdev && pci_enable_device(pdev))
! 		return -EIO;
! 
! 	dev = init_etherdev(NULL, sizeof(TLanPrivateInfo));
! 	if (dev == NULL) {
! 		printk(KERN_ERR "TLAN: Could not allocate memory for device.\n");
! 		return -ENOMEM;
! 	}
! 	SET_MODULE_OWNER(dev);
! 	
! 	priv = dev->priv;
! 
! 	/* Is this a PCI device? */
! 	if (pdev) {
! 		u32 		   pci_io_base = 0;
! 
! 		priv->adapter = &board_info[ent->driver_data];
! 
! 		pci_read_config_byte ( pdev, PCI_REVISION_ID, &pci_rev);
! 
! 		for ( reg= 0; reg <= 5; reg ++ ) {
! 			if (pci_resource_flags(pdev, reg) & IORESOURCE_IO) {
! 				pci_io_base = pci_resource_start(pdev, reg);
! 				TLAN_DBG( TLAN_DEBUG_GNRL, "IO mapping is available at %x.\n",
! 						pci_io_base);
! 				break;
! 			}
! 		}
! 		if (!pci_io_base) {
! 			printk(KERN_ERR "TLAN: No IO mappings available\n");
! 			unregister_netdev(dev);
! 			kfree(dev);
! 			return -ENODEV;
! 		}
! 		
! 		dev->base_addr = pci_io_base;
! 		dev->irq = pdev->irq;
! 		priv->adapterRev = pci_rev; 
! 		pci_set_master(pdev);
! 		pci_set_drvdata(pdev, dev);
! 
! 	} else	{     /* EISA card */
! 		/* This is a hack. We need to know which board structure
! 		 * is suited for this adapter */
! 		device_id = inw(ioaddr + EISA_ID2);
! 		priv->is_eisa = 1;
! 		if (device_id == 0x20F1) {
! 			priv->adapter = &board_info[13]; 	/* NetFlex-3/E */
! 			priv->adapterRev = 23;			/* TLAN 2.3 */
! 		} else {
! 			priv->adapter = &board_info[14];
! 			priv->adapterRev = 10;			/* TLAN 1.0 */
! 		}
! 		dev->base_addr = ioaddr;
! 		dev->irq = irq;
! 	}
! 
! 	/* Kernel parameters */
! 	if (dev->mem_start) {
! 		priv->aui    = dev->mem_start & 0x01;
! 		priv->duplex = ((dev->mem_start & 0x06) == 0x06) ? 0 : (dev->mem_start & 0x06) >> 1;
! 		priv->speed  = ((dev->mem_start & 0x18) == 0x18) ? 0 : (dev->mem_start & 0x18) >> 3;
! 	
! 		if (priv->speed == 0x1) {
! 			priv->speed = TLAN_SPEED_10;
! 		} else if (priv->speed == 0x2) {
! 			priv->speed = TLAN_SPEED_100;
! 		}
! 		debug = priv->debug = dev->mem_end;
! 	} else {
! 		priv->aui    = aui[boards_found];
! 		priv->speed  = speed[boards_found];
! 		priv->duplex = duplex[boards_found];
! 		priv->debug = debug;
! 	}
! 	
! 	/* This will be used when we get an adapter error from
! 	 * within our irq handler */
! 	INIT_LIST_HEAD(&priv->tlan_tqueue.list);
! 	priv->tlan_tqueue.sync = 0;
! 	priv->tlan_tqueue.routine = (void *)(void*)TLan_tx_timeout;
! 	priv->tlan_tqueue.data = dev;
! 
! 	spin_lock_init(&priv->lock);
! 	
! 	if (TLan_Init(dev)) {
! 		printk(KERN_ERR "TLAN: Could not register device.\n");
! 		unregister_netdev(dev);
! 		kfree(dev);
! 		return -EAGAIN;
! 	} else {
! 	
! 	TLanDevicesInstalled++;
! 	boards_found++;
! 	
! 	/* pdev is NULL if this is an EISA device */
! 	if (pdev)
! 		tlan_have_pci++;
! 	else {
! 		priv->nextDevice = TLan_Eisa_Devices;
! 		TLan_Eisa_Devices = dev;
! 		tlan_have_eisa++;
! 	}
! 	
! 	printk(KERN_INFO "TLAN: %s irq=%2d, io=%04x, %s, Rev. %d\n",
! 			dev->name,
! 			(int) dev->irq,
! 			(int) dev->base_addr,
! 			priv->adapter->deviceLabel,
! 			priv->adapterRev);
! 	return 0;
! 	}
! 
! }
! 
! static void TLan_Eisa_Cleanup(void)
! {
! 	struct net_device *dev;
! 	TLanPrivateInfo *priv;
! 	
! 	while( tlan_have_eisa ) {
! 		dev = TLan_Eisa_Devices;
! 		priv = dev->priv;
! 		if (priv->dmaStorage) {
! 			kfree(priv->dmaStorage);
! 		}
! 		release_region( dev->base_addr, 0x10);
! 		unregister_netdev( dev );
! 		TLan_Eisa_Devices = priv->nextDevice;
! 		kfree( dev );
! 		tlan_have_eisa--;
! 	}
! }
! 	
! 		
! static void __exit tlan_exit(void)
! {
! 	pci_unregister_driver(&tlan_driver);
! 
! 	if (tlan_have_eisa)
! 		TLan_Eisa_Cleanup();
! 
! 	kfree( TLanPadBuffer );
! 
! }
! 
! /* Module loading/unloading */
! module_init(tlan_probe);
! module_exit(tlan_exit);
! 
! 	/**************************************************************
! 	 * 	TLan_EisaProbe
! 	 *
! 	 *  	Returns: 0 on success, 1 otherwise
! 	 *
! 	 *  	Parms:	 None
! 	 *
! 	 *
! 	 *  	This functions probes for EISA devices and calls 
! 	 *  	TLan_probe1 when one is found. 
! 	 *
! 	 *************************************************************/
  
! static void  __init TLan_EisaProbe (void) 
  {
! 	long 	ioaddr;
! 	int 	rc = -ENODEV;
! 	int 	irq;
! 	u16	device_id;
! 
! 	if (!EISA_bus) {	
! 		TLAN_DBG(TLAN_DEBUG_PROBE, "No EISA bus present\n");
! 		return;
! 	}
  	
! 	/* Loop through all slots of the EISA bus */
! 	for (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {
! 		
! 	TLAN_DBG(TLAN_DEBUG_PROBE,"EISA_ID 0x%4x: 0x%4x\n", (int) ioaddr + 0xC80, inw(ioaddr + EISA_ID));	
! 	TLAN_DBG(TLAN_DEBUG_PROBE,"EISA_ID 0x%4x: 0x%4x\n", (int) ioaddr + 0xC82, inw(ioaddr + EISA_ID2));
! 
! 		TLAN_DBG(TLAN_DEBUG_PROBE, "Probing for EISA adapter at IO: 0x%4x : ",
! 				   	(int) ioaddr);
! 		if (request_region(ioaddr, 0x10, TLanSignature) == NULL) 
! 			goto out;
! 
! 		if (inw(ioaddr + EISA_ID) != 0x110E) {		
! 			release_region(ioaddr, 0x10);
! 			goto out;
! 		}
! 		
! 		device_id = inw(ioaddr + EISA_ID2);
! 		if (device_id !=  0x20F1 && device_id != 0x40F1) { 		
! 			release_region (ioaddr, 0x10);
! 			goto out;
! 		}
! 		
! 	 	if (inb(ioaddr + EISA_CR) != 0x1) { 	/* Check if adapter is enabled */
! 			release_region (ioaddr, 0x10);
! 			goto out2;
! 		}
! 		
! 		if (debug == 0x10)		
! 			printk("Found one\n");
! 
! 		/* Get irq from board */
! 		switch (inb(ioaddr + 0xCC0)) {
! 			case(0x10):
! 				irq=5;
! 				break;
! 			case(0x20):
! 				irq=9;
! 				break;
! 			case(0x40):
! 				irq=10;
! 				break;
! 			case(0x80):
! 				irq=11;
! 				break;
! 			default:
! 				goto out;
! 		}               
! 		
! 		
! 		/* Setup the newly found eisa adapter */
! 		rc = TLan_probe1( NULL, ioaddr, irq,
! 					12, NULL);
! 		continue;
! 		
! 		out:
! 			if (debug == 0x10)
! 				printk("None found\n");
! 			continue;
! 
! 		out2:	if (debug == 0x10)
! 				printk("Card found but it is not enabled, skipping\n");
! 			continue;
! 		
! 	}
  
! } /* TLan_EisaProbe */
  
! 	
  
! 	/***************************************************************
! 	 *	TLan_Init
! 	 *
! 	 *	Returns:
! 	 *		0 on success, error code otherwise.
! 	 *	Parms:
! 	 *		dev	The structure of the device to be
! 	 *			init'ed.
! 	 *
! 	 *	This function completes the initialization of the
! 	 *	device structure and driver.  It reserves the IO
! 	 *	addresses, allocates memory for the lists and bounce
! 	 *	buffers, retrieves the MAC address from the eeprom
! 	 *	and assignes the device's methods.
! 	 *	
! 	 **************************************************************/
  
! static int TLan_Init( struct net_device *dev )
! {
! 	int		dma_size;
! 	int 		err;
! 	int		i;
! 	TLanPrivateInfo	*priv;
  
! 	priv = dev->priv;
! 	
! 	if (!priv->is_eisa)	/* EISA devices have already requested IO */
! 		if (!request_region( dev->base_addr, 0x10, TLanSignature )) {
! 			printk(KERN_ERR "TLAN: %s: IO port region 0x%lx size 0x%x in use.\n",
! 				dev->name,
! 				dev->base_addr,
! 				0x10 );
! 			return -EIO;
  		}
- 	
- 	if ( bbuf ) {
- 		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
- 	           * ( sizeof(TLanList) + TLAN_MAX_FRAME_SIZE );
  	} else {
! 		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
! 	           * ( sizeof(TLanList) );
! 	}
! 	priv->dmaStorage = kmalloc(dma_size, GFP_KERNEL | GFP_DMA);
! 	if ( priv->dmaStorage == NULL ) {
! 		printk(KERN_ERR "TLAN:  Could not allocate lists and buffers for %s.\n",
! 			dev->name );
! 		release_region( dev->base_addr, 0x10 );
! 		return -ENOMEM;
! 	}
! 	memset( priv->dmaStorage, 0, dma_size );
! 	priv->rxList = (TLanList *) 
! 		       ( ( ( (u32) priv->dmaStorage ) + 7 ) & 0xFFFFFFF8 );
! 	priv->txList = priv->rxList + TLAN_NUM_RX_LISTS;
! 	if ( bbuf ) {
! 		priv->rxBuffer = (u8 *) ( priv->txList + TLAN_NUM_TX_LISTS );
! 		priv->txBuffer = priv->rxBuffer
! 				 + ( TLAN_NUM_RX_LISTS * TLAN_MAX_FRAME_SIZE );
! 	}
! 
! 	err = 0;
! 	for ( i = 0;  i < 6 ; i++ )
! 		err |= TLan_EeReadByte( dev,
! 					(u8) priv->adapter->addrOfs + i,
! 					(u8 *) &dev->dev_addr[i] );
! 	if ( err ) {
! 		printk(KERN_ERR "TLAN: %s: Error reading MAC from eeprom: %d\n",
! 			dev->name,
! 			err );
! 	}
! 	dev->addr_len = 6;
! 	
! 	/* Device methods */
! 	dev->open = &TLan_Open;
! 	dev->hard_start_xmit = &TLan_StartTx;
! 	dev->stop = &TLan_Close;
! 	dev->get_stats = &TLan_GetStats;
! 	dev->set_multicast_list = &TLan_SetMulticastList;
! 	dev->do_ioctl = &TLan_ioctl;
! 	dev->tx_timeout = &TLan_tx_timeout;
! 	dev->watchdog_timeo = TX_TIMEOUT;
! 
! 	return 0;
! 
! } /* TLan_Init */
! 
! 	/***************************************************************
! 	 *	TLan_Open
! 	 *
! 	 *	Returns:
! 	 *		0 on success, error code otherwise.
! 	 *	Parms:
! 	 *		dev	Structure of device to be opened.
! 	 *
! 	 *	This routine puts the driver and TLAN adapter in a
! 	 *	state where it is ready to send and receive packets.
! 	 *	It allocates the IRQ, resets and brings the adapter
! 	 *	out of reset, and allows interrupts.  It also delays
! 	 *	the startup for autonegotiation or sends a Rx GO
! 	 *	command to the adapter, as appropriate.
! 	 *
! 	 **************************************************************/
! 
! static int TLan_Open( struct net_device *dev )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	int		err;
! 	
! 	priv->tlanRev = TLan_DioRead8( dev->base_addr, TLAN_DEF_REVISION );
! 	err = request_irq( dev->irq, TLan_HandleInterrupt, SA_SHIRQ, TLanSignature, dev );
! 	
! 	if ( err ) {
! 		printk(KERN_ERR "TLAN:  Cannot open %s because IRQ %d is already in use.\n", dev->name, dev->irq );
! 		return err;
  	}
! 	
! 	init_timer(&priv->timer);
! 	netif_start_queue(dev);
! 	
! 	/* NOTE: It might not be necessary to read the stats before a
! 			 reset if you don't care what the values are.
! 	*/
! 	TLan_ResetLists( dev );
! 	TLan_ReadAndClearStats( dev, TLAN_IGNORE );
! 	TLan_ResetAdapter( dev );
! 
! 	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Opened.  TLAN Chip Rev: %x\n", dev->name, priv->tlanRev );
! 
! 	return 0;
! 
! } /* TLan_Open */
! 
! 	/**************************************************************
! 	 *	TLan_ioctl
! 	 *	
! 	 *	Returns:
! 	 *		0 on success, error code otherwise
! 	 *	Params:
! 	 *		dev	structure of device to receive ioctl.
! 	 *		
! 	 *		rq	ifreq structure to hold userspace data.
! 	 *
! 	 *		cmd	ioctl command.
! 	 *
! 	 *
! 	 *************************************************************/
  
! static int TLan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
  {
! 	TLanPrivateInfo *priv = dev->priv;
! 	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&rq->ifr_data;
! 	u32 phy   = priv->phy[priv->phyNum];
! 	
! 	if (!priv->phyOnline)
! 		return -EAGAIN;
! 
! 	switch(cmd) {
! 	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
! 	case SIOCDEVPRIVATE:		/* for binary compat, remove in 2.5 */
! 			data->phy_id = phy;
! 
! 	case SIOCGMIIREG:		/* Read MII PHY register. */
! 	case SIOCDEVPRIVATE+1:		/* for binary compat, remove in 2.5 */
! 			TLan_MiiReadReg(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, &data->val_out);
! 			return 0;
! 		
  
! 	case SIOCSMIIREG:		/* Write MII PHY register. */
! 	case SIOCDEVPRIVATE+2:		/* for binary compat, remove in 2.5 */
! 			if (!capable(CAP_NET_ADMIN))
! 				return -EPERM;
! 			TLan_MiiWriteReg(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);
! 			return 0;
! 		default:
! 			return -EOPNOTSUPP;
  	}
- } /* tlan_ioctl */
- 
- 	/***************************************************************
- 	 * 	TLan_tx_timeout
- 	 *
- 	 * 	Returns: nothing
- 	 *
- 	 * 	Params:
- 	 * 		dev	structure of device which timed out 
- 	 * 			during transmit.
- 	 *
- 	 **************************************************************/
- 
- static void TLan_tx_timeout(struct net_device *dev)
- {
- 	
- 	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Transmit timed out.\n", dev->name);
- 	
- 	/* Ok so we timed out, lets see what we can do about it...*/
- 	TLan_FreeLists( dev );
- 	TLan_ResetLists( dev );		
- 	TLan_ReadAndClearStats( dev, TLAN_IGNORE );
- 	TLan_ResetAdapter( dev );
- 	dev->trans_start = jiffies;
- 	netif_wake_queue( dev );	
  
  }
- 	
  
! 	/***************************************************************
! 	 *	TLan_StartTx
! 	 *  
! 	 *	Returns:
! 	 *		0 on success, non-zero on failure.
! 	 *	Parms:
! 	 *		skb	A pointer to the sk_buff containing the
! 	 *			frame to be sent.
! 	 *		dev	The device to send the data on.
! 	 *
! 	 *	This function adds a frame to the Tx list to be sent
! 	 *	ASAP.  First it	verifies that the adapter is ready and
! 	 *	there is room in the queue.  Then it sets up the next
! 	 *	available list, copies the frame to the	corresponding
! 	 *	buffer.  If the adapter Tx channel is idle, it gives
! 	 *	the adapter a Tx Go command on the list, otherwise it
! 	 *	sets the forward address of the previous list to point
! 	 *	to this one.  Then it frees the sk_buff.
! 	 *
! 	 **************************************************************/
  
! static int TLan_StartTx( struct sk_buff *skb, struct net_device *dev )
! {
! 	TLanPrivateInfo *priv = dev->priv;
! 	TLanList	*tail_list;
! 	u8		*tail_buffer;
! 	int		pad;
! 	unsigned long	flags;
! 
! 	if ( ! priv->phyOnline ) {
! 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s PHY is not ready\n", dev->name );
! 		dev_kfree_skb_any(skb);
! 		return 0;
  	}
  
  	tail_list = priv->txList + priv->txTail;
! 	
! 	if ( tail_list->cStat != TLAN_CSTAT_UNUSED ) {
! 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s is busy (Head=%d Tail=%d)\n", dev->name, priv->txHead, priv->txTail );
! 		netif_stop_queue(dev);
  		priv->txBusyCount++;
! 		return 1;
  	}
  
  	tail_list->forward = 0;
  
! 	if ( bbuf ) {
! 		tail_buffer = priv->txBuffer + ( priv->txTail * TLAN_MAX_FRAME_SIZE );
! 		memcpy( tail_buffer, skb->data, skb->len );
! 	} else {
! 		tail_list->buffer[0].address = virt_to_bus( skb->data );
! 		tail_list->buffer[9].address = (u32) skb;
! 	}
! 
! 	pad = TLAN_MIN_FRAME_SIZE - skb->len;
  
! 	if ( pad > 0 ) {
! 		tail_list->frameSize = (u16) skb->len + pad;
! 		tail_list->buffer[0].count = (u32) skb->len;
! 		tail_list->buffer[1].count = TLAN_LAST_BUFFER | (u32) pad;
! 		tail_list->buffer[1].address = virt_to_bus( TLanPadBuffer );
! 	} else {
! 		tail_list->frameSize = (u16) skb->len;
! 		tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) skb->len;
! 		tail_list->buffer[1].count = 0;
! 		tail_list->buffer[1].address = 0;
! 	}
  
- 	spin_lock_irqsave(&priv->lock, flags);
  	tail_list->cStat = TLAN_CSTAT_READY;
- 	if ( ! priv->txInProgress ) {
- 		priv->txInProgress = 1;
- 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Starting TX on buffer %d\n", priv->txTail );
- 		outl( virt_to_bus( tail_list ), dev->base_addr + TLAN_CH_PARM );
- 		outl( TLAN_HC_GO, dev->base_addr + TLAN_HOST_CMD );
- 	} else {
- 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Adding buffer %d to TX channel\n", priv->txTail );
- 		if ( priv->txTail == 0 ) {
- 			( priv->txList + ( TLAN_NUM_TX_LISTS - 1 ) )->forward = virt_to_bus( tail_list );
- 		} else {
- 			( priv->txList + ( priv->txTail - 1 ) )->forward = virt_to_bus( tail_list );
- 		}
- 	}
- 	spin_unlock_irqrestore(&priv->lock, flags);
- 
- 	CIRC_INC( priv->txTail, TLAN_NUM_TX_LISTS );
- 
- 	if ( bbuf )
- 		dev_kfree_skb_any(skb);
- 		
- 	dev->trans_start = jiffies;
- 	return 0;
- 
- } /* TLan_StartTx */
- 
- 	/***************************************************************
- 	 *	TLan_HandleInterrupt
- 	 *  
- 	 *	Returns:	
- 	 *		Nothing
- 	 *	Parms:
- 	 *		irq	The line on which the interrupt
- 	 *			occurred.
- 	 *		dev_id	A pointer to the device assigned to
- 	 *			this irq line.
- 	 *		regs	???
- 	 *
- 	 *	This function handles an interrupt generated by its
- 	 *	assigned TLAN adapter.  The function deactivates
- 	 *	interrupts on its adapter, records the type of
- 	 *	interrupt, executes the appropriate subhandler, and
- 	 *	acknowdges the interrupt to the adapter (thus
- 	 *	re-enabling adapter interrupts.
- 	 *
- 	 **************************************************************/
- 
- static void TLan_HandleInterrupt(int irq, void *dev_id, struct pt_regs *regs)
- {
- 	u32		ack;
- 	struct net_device	*dev;
- 	u32		host_cmd;
- 	u16		host_int;
- 	int		type;
- 	TLanPrivateInfo *priv;
- 
- 	dev = dev_id;
- 	priv = dev->priv;
- 
- 	spin_lock(&priv->lock);
- 
- 	host_int = inw( dev->base_addr + TLAN_HOST_INT );
- 	outw( host_int, dev->base_addr + TLAN_HOST_INT );
- 
- 	type = ( host_int & TLAN_HI_IT_MASK ) >> 2;
- 
- 	ack = TLanIntVector[type]( dev, host_int );
- 
- 	if ( ack ) {
- 		host_cmd = TLAN_HC_ACK | ack | ( type << 18 );
- 		outl( host_cmd, dev->base_addr + TLAN_HOST_CMD );
- 	}
- 
- 	spin_unlock(&priv->lock);
- 
- } /* TLan_HandleInterrupts */
- 
- 	/***************************************************************
- 	 *	TLan_Close
- 	 *  
- 	 * 	Returns:
- 	 *		An error code.
- 	 *	Parms:
- 	 *		dev	The device structure of the device to
- 	 *			close.
- 	 *
- 	 *	This function shuts down the adapter.  It records any
- 	 *	stats, puts the adapter into reset state, deactivates
- 	 *	its time as needed, and	frees the irq it is using.
- 	 *
- 	 **************************************************************/
- 
- static int TLan_Close(struct net_device *dev)
- {
- 	TLanPrivateInfo *priv = dev->priv;
- 
- 	netif_stop_queue(dev);
- 	priv->neg_be_verbose = 0;
  
! 	TLan_ReadAndClearStats( dev, TLAN_RECORD );
! 	outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
! 	if ( priv->timer.function != NULL ) {
! 		del_timer_sync( &priv->timer );
! 		priv->timer.function = NULL;
! 	}
! 	
! 	free_irq( dev->irq, dev );
! 	TLan_FreeLists( dev );
! 	TLAN_DBG( TLAN_DEBUG_GNRL, "Device %s closed.\n", dev->name );
! 
! 	return 0;
! 
! } /* TLan_Close */
! 
! 	/***************************************************************
! 	 *	TLan_GetStats
! 	 *  
! 	 *	Returns:
! 	 *		A pointer to the device's statistics structure.
! 	 *	Parms:
! 	 *		dev	The device structure to return the
! 	 *			stats for.
! 	 *
! 	 *	This function updates the devices statistics by reading
! 	 *	the TLAN chip's onboard registers.  Then it returns the
! 	 *	address of the statistics structure.
! 	 *
! 	 **************************************************************/
! 
! static struct net_device_stats *TLan_GetStats( struct net_device *dev )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	int i;
! 
! 	/* Should only read stats if open ? */
! 	TLan_ReadAndClearStats( dev, TLAN_RECORD );
! 
! 	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  %s EOC count = %d\n", dev->name, priv->rxEocCount );
! 	TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s Busy count = %d\n", dev->name, priv->txBusyCount );
! 	if ( debug & TLAN_DEBUG_GNRL ) {
! 		TLan_PrintDio( dev->base_addr );
! 		TLan_PhyPrint( dev );		
! 	}
! 	if ( debug & TLAN_DEBUG_LIST ) {
! 		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ )
! 			TLan_PrintList( priv->rxList + i, "RX", i );
! 		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ )
! 			TLan_PrintList( priv->txList + i, "TX", i );
! 	}
! 	
! 	return ( &( (TLanPrivateInfo *) dev->priv )->stats );
! 
! } /* TLan_GetStats */
! 
! 	/***************************************************************
! 	 *	TLan_SetMulticastList
! 	 *  
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		dev	The device structure to set the
! 	 *			multicast list for.
! 	 *
! 	 *	This function sets the TLAN adaptor to various receive
! 	 *	modes.  If the IFF_PROMISC flag is set, promiscuous
! 	 *	mode is acitviated.  Otherwise,	promiscuous mode is
! 	 *	turned off.  If the IFF_ALLMULTI flag is set, then
! 	 *	the hash table is set to receive all group addresses.
! 	 *	Otherwise, the first three multicast addresses are
! 	 *	stored in AREG_1-3, and the rest are selected via the
! 	 *	hash table, as necessary.
! 	 *
! 	 **************************************************************/
  
! static void TLan_SetMulticastList( struct net_device *dev )
! {	
! 	struct dev_mc_list	*dmi = dev->mc_list;
! 	u32			hash1 = 0;
! 	u32			hash2 = 0;
! 	int			i;
! 	u32			offset;
! 	u8			tmp;
! 
! 	if ( dev->flags & IFF_PROMISC ) {
! 		tmp = TLan_DioRead8( dev->base_addr, TLAN_NET_CMD );
! 		TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, tmp | TLAN_NET_CMD_CAF );
  	} else {
! 		tmp = TLan_DioRead8( dev->base_addr, TLAN_NET_CMD );
! 		TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF );
! 		if ( dev->flags & IFF_ALLMULTI ) {
! 			for ( i = 0; i < 3; i++ ) 
! 				TLan_SetMac( dev, i + 1, NULL );
! 			TLan_DioWrite32( dev->base_addr, TLAN_HASH_1, 0xFFFFFFFF );
! 			TLan_DioWrite32( dev->base_addr, TLAN_HASH_2, 0xFFFFFFFF );
  		} else {
! 			for ( i = 0; i < dev->mc_count; i++ ) {
! 				if ( i < 3 ) {
! 					TLan_SetMac( dev, i + 1, (char *) &dmi->dmi_addr );
! 				} else {
! 					offset = TLan_HashFunc( (u8 *) &dmi->dmi_addr );
! 					if ( offset < 32 ) 
! 						hash1 |= ( 1 << offset );
! 					else
! 						hash2 |= ( 1 << ( offset - 32 ) );
! 				}
! 				dmi = dmi->next;
! 			}
! 			for ( ; i < 3; i++ ) 
! 				TLan_SetMac( dev, i + 1, NULL );
! 			TLan_DioWrite32( dev->base_addr, TLAN_HASH_1, hash1 );
! 			TLan_DioWrite32( dev->base_addr, TLAN_HASH_2, hash2 );
  		}
  	}
  
! } /* TLan_SetMulticastList */
! 
! /*****************************************************************************
! ******************************************************************************
! 
!         ThunderLAN Driver Interrupt Vectors and Table
! 
! 	Please see Chap. 4, "Interrupt Handling" of the "ThunderLAN
! 	Programmer's Guide" for more informations on handling interrupts
! 	generated by TLAN based adapters.  
! 
! ******************************************************************************
! *****************************************************************************/
! 
! 	/***************************************************************
! 	 *	TLan_HandleInvalid
! 	 *
! 	 *	Returns:
! 	 *		0
! 	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This function handles invalid interrupts.  This should
! 	 *	never happen unless some other adapter is trying to use
! 	 *	the IRQ line assigned to the device.
! 	 *
! 	 **************************************************************/
! 
! u32 TLan_HandleInvalid( struct net_device *dev, u16 host_int )
! {
! 	/* printk( "TLAN:  Invalid interrupt on %s.\n", dev->name ); */
! 	return 0;
! 
! } /* TLan_HandleInvalid */
  
! 	/***************************************************************
! 	 *	TLan_HandleTxEOF
! 	 *
! 	 *	Returns:
! 	 *		1
! 	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This function handles Tx EOF interrupts which are raised
! 	 *	by the adapter when it has completed sending the
! 	 *	contents of a buffer.  If detemines which list/buffer
! 	 *	was completed and resets it.  If the buffer was the last
! 	 *	in the channel (EOC), then the function checks to see if
! 	 *	another buffer is ready to send, and if so, sends a Tx
! 	 *	Go command.  Finally, the driver activates/continues the
! 	 *	activity LED.
! 	 *
! 	 **************************************************************/
  
- u32 TLan_HandleTxEOF( struct net_device *dev, u16 host_int )
- {
- 	TLanPrivateInfo	*priv = dev->priv;
- 	int		eoc = 0;
- 	TLanList	*head_list;
- 	u32		ack = 0;
- 	u16		tmpCStat;
- 	
- 	TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOF (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
  	head_list = priv->txList + priv->txHead;
! 
! 	while (((tmpCStat = head_list->cStat ) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
  		ack++;
! 		if ( ! bbuf ) {
! 			dev_kfree_skb_any( (struct sk_buff *) head_list->buffer[9].address );
! 			head_list->buffer[9].address = 0;
! 		}
! 	
! 		if ( tmpCStat & TLAN_CSTAT_EOC )
! 			eoc = 1;
! 			
! 		priv->stats.tx_bytes += head_list->frameSize;
! 
  		head_list->cStat = TLAN_CSTAT_UNUSED;
! 		netif_start_queue(dev);		
! 		CIRC_INC( priv->txHead, TLAN_NUM_TX_LISTS ); 
  		head_list = priv->txList + priv->txHead;
  	}
  
! 	if (!ack)
! 		printk(KERN_INFO "TLAN: Received interrupt for uncompleted TX frame.\n");
  	
! 	if ( eoc ) {
! 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
  		head_list = priv->txList + priv->txHead;
! 		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
! 			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
  			ack |= TLAN_HC_GO;
  		} else {
  			priv->txInProgress = 0;
  		}
  	}
  	
! 	if ( priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED ) {
! 		TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT );
! 		if ( priv->timer.function == NULL ) {
! 			 priv->timer.function = &TLan_Timer;
! 			 priv->timer.data = (unsigned long) dev;
! 			 priv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;
! 			 priv->timerSetAt = jiffies;
! 			 priv->timerType = TLAN_TIMER_ACTIVITY;
! 			 add_timer(&priv->timer);
! 		} else if ( priv->timerType == TLAN_TIMER_ACTIVITY ) {
! 			priv->timerSetAt = jiffies;
  		}
  	}
  
! 	return ack;
  
! } /* TLan_HandleTxEOF */
  
! 	/***************************************************************
! 	 *	TLan_HandleStatOverflow
! 	 *
! 	 *	Returns:
! 	 *		1
! 	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This function handles the Statistics Overflow interrupt
! 	 *	which means that one or more of the TLAN statistics
! 	 *	registers has reached 1/2 capacity and needs to be read.
! 	 *
! 	 **************************************************************/
  
! u32 TLan_HandleStatOverflow( struct net_device *dev, u16 host_int )
! {
! 	TLan_ReadAndClearStats( dev, TLAN_RECORD );
  
  	return 1;
  
- } /* TLan_HandleStatOverflow */
  
  	/***************************************************************
! 	 *	TLan_HandleRxEOF
  	 *
  	 *	Returns:
! 	 *		1
  	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This function handles the Rx EOF interrupt which
! 	 *	indicates a frame has been received by the adapter from
! 	 *	the net and the frame has been transferred to memory.
! 	 *	The function determines the bounce buffer the frame has
! 	 *	been loaded into, creates a new sk_buff big enough to
! 	 *	hold the frame, and sends it to protocol stack.  It
! 	 *	then resets the used buffer and appends it to the end
! 	 *	of the list.  If the frame was the last in the Rx
! 	 *	channel (EOC), the function restarts the receive channel
! 	 *	by sending an Rx Go command to the adapter.  Then it
! 	 *	activates/continues the activity LED.
  	 *
  	 **************************************************************/
  
! u32 TLan_HandleRxEOF( struct net_device *dev, u16 host_int )
  {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u32		ack = 0;
! 	int		eoc = 0;
! 	u8		*head_buffer;
! 	TLanList	*head_list;
! 	struct sk_buff	*skb;
! 	TLanList	*tail_list;
! 	void		*t;
! 	u32		frameSize;
! 	u16		tmpCStat;
! 
! 	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOF (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
! 	head_list = priv->rxList + priv->rxHead;
! 	
! 	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
! 		frameSize = head_list->frameSize;
! 		ack++;
! 		if (tmpCStat & TLAN_CSTAT_EOC)
! 			eoc = 1;
! 		
! 		if (bbuf) {
! 			skb = dev_alloc_skb(frameSize + 7);
! 			if (skb == NULL)
! 				printk(KERN_INFO "TLAN: Couldn't allocate memory for received data.\n");
! 			else {
! 				head_buffer = priv->rxBuffer + (priv->rxHead * TLAN_MAX_FRAME_SIZE);
! 				skb->dev = dev;
! 				skb_reserve(skb, 2);
! 				t = (void *) skb_put(skb, frameSize);
! 		
! 				priv->stats.rx_bytes += head_list->frameSize;
! 
! 				memcpy( t, head_buffer, frameSize );
! 				skb->protocol = eth_type_trans( skb, dev );
! 				netif_rx( skb );
! 			}
! 		} else {
! 			struct sk_buff *new_skb;
! 		
! 			/*
! 		 	*	I changed the algorithm here. What we now do
! 		 	*	is allocate the new frame. If this fails we
! 		 	*	simply recycle the frame.
! 		 	*/
! 		
! 			new_skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
! 			
! 			if ( new_skb != NULL ) {
! 				/* If this ever happened it would be a problem */
! 				/* not any more - ac */
! 				skb = (struct sk_buff *) head_list->buffer[9].address;
! 				skb_trim( skb, frameSize );
! 
! 				priv->stats.rx_bytes += frameSize;
  
! 				skb->protocol = eth_type_trans( skb, dev );
! 				netif_rx( skb );
! 	
! 				new_skb->dev = dev;
! 				skb_reserve( new_skb, 2 );
! 				t = (void *) skb_put( new_skb, TLAN_MAX_FRAME_SIZE );
! 				head_list->buffer[0].address = virt_to_bus( t );
! 				head_list->buffer[8].address = (u32) t;
! 				head_list->buffer[9].address = (u32) new_skb;
! 			} else 
! 				printk(KERN_WARNING "TLAN:  Couldn't allocate memory for received data.\n" );
! 		}
  
! 		head_list->forward = 0;
! 		head_list->cStat = 0;
! 		tail_list = priv->rxList + priv->rxTail;
! 		tail_list->forward = virt_to_bus( head_list );
! 
! 		CIRC_INC( priv->rxHead, TLAN_NUM_RX_LISTS );
! 		CIRC_INC( priv->rxTail, TLAN_NUM_RX_LISTS );
! 		head_list = priv->rxList + priv->rxHead;
! 	}
  
! 	if (!ack)
! 		printk(KERN_INFO "TLAN: Received interrupt for uncompleted RX frame.\n");
! 	
  
- 	if ( eoc ) { 
- 		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
- 		head_list = priv->rxList + priv->rxHead;
- 		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
- 		ack |= TLAN_HC_GO | TLAN_HC_RT;
- 		priv->rxEocCount++;
- 	}
- 
- 	if ( priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED ) {
- 		TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT );
- 		if ( priv->timer.function == NULL )  {
- 			priv->timer.function = &TLan_Timer;
- 			priv->timer.data = (unsigned long) dev;
- 			priv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;
- 			priv->timerSetAt = jiffies;
- 			priv->timerType = TLAN_TIMER_ACTIVITY;
- 			add_timer(&priv->timer);
- 		} else if ( priv->timerType == TLAN_TIMER_ACTIVITY ) {
- 			priv->timerSetAt = jiffies;
- 		}
- 	}
  
- 	dev->last_rx = jiffies;
- 	
- 	return ack;
  
- } /* TLan_HandleRxEOF */
  
  	/***************************************************************
! 	 *	TLan_HandleDummy
  	 *
  	 *	Returns:
! 	 *		1
! 	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This function handles the Dummy interrupt, which is
! 	 *	raised whenever a test interrupt is generated by setting
! 	 *	the Req_Int bit of HOST_CMD to 1.
  	 *
  	 **************************************************************/
  
! u32 TLan_HandleDummy( struct net_device *dev, u16 host_int )
  {
! 	printk( "TLAN:  Test interrupt on %s.\n", dev->name );
! 	return 1;
  
! } /* TLan_HandleDummy */
  
! 	/***************************************************************
! 	 *	TLan_HandleTxEOC
! 	 *
! 	 *	Returns:
! 	 *		1
! 	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This driver is structured to determine EOC occurances by
! 	 *	reading the CSTAT member of the list structure.  Tx EOC
! 	 *	interrupts are disabled via the DIO INTDIS register.
! 	 *	However, TLAN chips before revision 3.0 didn't have this
! 	 *	functionality, so process EOC events if this is the
! 	 *	case.
! 	 *
! 	 **************************************************************/
  
! u32 TLan_HandleTxEOC( struct net_device *dev, u16 host_int )
! {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	TLanList		*head_list;
! 	u32			ack = 1;
! 	
! 	host_int = 0;
! 	if ( priv->tlanRev < 0x30 ) {
! 		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d) -- IRQ\n", priv->txHead, priv->txTail );
! 		head_list = priv->txList + priv->txHead;
! 		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
! 			netif_stop_queue(dev);
! 			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
! 			ack |= TLAN_HC_GO;
! 		} else {
! 			priv->txInProgress = 0;
! 		}
  	}
  
! 	return ack;
  
- } /* TLan_HandleTxEOC */
  
  	/***************************************************************
! 	 *	TLan_HandleStatusCheck
  	 *
  	 *	Returns:
! 	 *		0 if Adapter check, 1 if Network Status check.
  	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This function handles Adapter Check/Network Status
! 	 *	interrupts generated by the adapter.  It checks the
! 	 *	vector in the HOST_INT register to determine if it is
! 	 *	an Adapter Check interrupt.  If so, it resets the
! 	 *	adapter.  Otherwise it clears the status registers
! 	 *	and services the PHY.
  	 *
  	 **************************************************************/
  
! u32 TLan_HandleStatusCheck( struct net_device *dev, u16 host_int )
! {	
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u32		ack;
! 	u32		error;
! 	u8		net_sts;
! 	u32		phy;
! 	u16		tlphy_ctl;
! 	u16		tlphy_sts;
! 	
! 	ack = 1;
! 	if ( host_int & TLAN_HI_IV_MASK ) {
! 		netif_stop_queue( dev );
! 		error = inl( dev->base_addr + TLAN_CH_PARM );
! 		printk( "TLAN:  %s: Adaptor Error = 0x%x\n", dev->name, error );
! 		TLan_ReadAndClearStats( dev, TLAN_RECORD );
! 		outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
! 		
! 		queue_task(&priv->tlan_tqueue, &tq_immediate);
! 		mark_bh(IMMEDIATE_BH);
! 		
! 		netif_wake_queue(dev);
! 		ack = 0;
! 	} else {
! 		TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Status Check\n", dev->name );
! 		phy = priv->phy[priv->phyNum];
  
! 		net_sts = TLan_DioRead8( dev->base_addr, TLAN_NET_STS );
! 		if ( net_sts ) {
! 			TLan_DioWrite8( dev->base_addr, TLAN_NET_STS, net_sts );
! 			TLAN_DBG( TLAN_DEBUG_GNRL, "%s:    Net_Sts = %x\n", dev->name, (unsigned) net_sts );
! 		}
! 		if ( ( net_sts & TLAN_NET_STS_MIRQ ) &&  ( priv->phyNum == 0 ) ) {
! 			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_STS, &tlphy_sts );
! 			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl );
!         		if ( ! ( tlphy_sts & TLAN_TS_POLOK ) && ! ( tlphy_ctl & TLAN_TC_SWAPOL ) ) {
!                 		tlphy_ctl |= TLAN_TC_SWAPOL;
!                 		TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);
!         		} else if ( ( tlphy_sts & TLAN_TS_POLOK ) && ( tlphy_ctl & TLAN_TC_SWAPOL ) ) {
!                 		tlphy_ctl &= ~TLAN_TC_SWAPOL;
!                 		TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);
!         		}
  
! 			if (debug) {
! 				TLan_PhyPrint( dev );		
! 			}
! 		}
  	}
  
! 	return ack;
  
- } /* TLan_HandleStatusCheck */
  
  	/***************************************************************
! 	 *	TLan_HandleRxEOC
  	 *
  	 *	Returns:
! 	 *		1
  	 *	Parms:
! 	 *		dev		Device assigned the IRQ that was
! 	 *				raised.
! 	 *		host_int	The contents of the HOST_INT
! 	 *				port.
! 	 *
! 	 *	This driver is structured to determine EOC occurances by
! 	 *	reading the CSTAT member of the list structure.  Rx EOC
! 	 *	interrupts are disabled via the DIO INTDIS register.
! 	 *	However, TLAN chips before revision 3.0 didn't have this
! 	 *	CSTAT member or a INTDIS register, so if this chip is
! 	 *	pre-3.0, process EOC interrupts normally.
  	 *
  	 **************************************************************/
  
! u32 TLan_HandleRxEOC( struct net_device *dev, u16 host_int )
  {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	TLanList	*head_list;
! 	u32		ack = 1;
  
! 	if (  priv->tlanRev < 0x30 ) {
! 		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d) -- IRQ\n", priv->rxHead, priv->rxTail );
! 		head_list = priv->rxList + priv->rxHead;
! 		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
! 		ack |= TLAN_HC_GO | TLAN_HC_RT;
! 		priv->rxEocCount++;
  	}
  
! 	return ack;
  
- } /* TLan_HandleRxEOC */
  
  /*****************************************************************************
  ******************************************************************************
  
! 	ThunderLAN Driver Timer Function
  
  ******************************************************************************
  *****************************************************************************/
  
  	/***************************************************************
! 	 *	TLan_Timer
  	 *
  	 *	Returns:
! 	 *		Nothing
  	 *	Parms:
! 	 *		data	A value given to add timer when
! 	 *			add_timer was called.
  	 *
! 	 *	This function handles timed functionality for the
! 	 *	TLAN driver.  The two current timer uses are for
! 	 *	delaying for autonegotionation and driving the ACT LED.
! 	 *	-	Autonegotiation requires being allowed about
! 	 *		2 1/2 seconds before attempting to transmit a
! 	 *		packet.  It would be a very bad thing to hang
! 	 *		the kernel this long, so the driver doesn't
! 	 *		allow transmission 'til after this time, for
! 	 *		certain PHYs.  It would be much nicer if all
! 	 *		PHYs were interrupt-capable like the internal
! 	 *		PHY.
! 	 *	-	The ACT LED, which shows adapter activity, is
! 	 *		driven by the driver, and so must be left on
! 	 *		for a short period to power up the LED so it
! 	 *		can be seen.  This delay can be changed by
! 	 *		changing the TLAN_TIMER_ACT_DELAY in tlan.h,
! 	 *		if desired.  100 ms  produces a slightly
! 	 *		sluggish response.
  	 *
  	 **************************************************************/
  
! void TLan_Timer( unsigned long data )
  {
! 	struct net_device	*dev = (struct net_device *) data;
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u32		elapsed;
! 	unsigned long	flags = 0;
! 
! 	priv->timer.function = NULL;
! 
! 	switch ( priv->timerType ) {
! #ifdef MONITOR		
! 		case TLAN_TIMER_LINK_BEAT:
! 			TLan_PhyMonitor( dev );
! 			break;
! #endif
! 		case TLAN_TIMER_PHY_PDOWN:
! 			TLan_PhyPowerDown( dev );
! 			break;
! 		case TLAN_TIMER_PHY_PUP:
! 			TLan_PhyPowerUp( dev );
! 			break;
! 		case TLAN_TIMER_PHY_RESET:
! 			TLan_PhyReset( dev );
! 			break;
! 		case TLAN_TIMER_PHY_START_LINK:
! 			TLan_PhyStartLink( dev );
! 			break;
! 		case TLAN_TIMER_PHY_FINISH_AN:
! 			TLan_PhyFinishAutoNeg( dev );
! 			break;
! 		case TLAN_TIMER_FINISH_RESET:
! 			TLan_FinishReset( dev );
! 			break;
! 		case TLAN_TIMER_ACTIVITY:
! 			spin_lock_irqsave(&priv->lock, flags);
! 			if ( priv->timer.function == NULL ) {
! 				elapsed = jiffies - priv->timerSetAt;
! 				if ( elapsed >= TLAN_TIMER_ACT_DELAY ) {
! 					TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
! 				} else  {
! 					priv->timer.function = &TLan_Timer;
! 					priv->timer.expires = priv->timerSetAt + TLAN_TIMER_ACT_DELAY;
! 					spin_unlock_irqrestore(&priv->lock, flags);
! 					add_timer( &priv->timer );
! 					break;
! 				}
! 			}
! 			spin_unlock_irqrestore(&priv->lock, flags);
! 			break;
! 		default:
! 			break;
  	}
  
- } /* TLan_Timer */
  
! /*****************************************************************************
! ******************************************************************************
  
! 	ThunderLAN Driver Adapter Related Routines
  
! ******************************************************************************
! *****************************************************************************/
  
  	/***************************************************************
! 	 *	TLan_ResetLists
! 	 *  
  	 *	Returns:
  	 *		Nothing
  	 *	Parms:
! 	 *		dev	The device structure with the list
! 	 *			stuctures to be reset.
  	 *
! 	 *	This routine sets the variables associated with managing
! 	 *	the TLAN lists to their initial values.
  	 *
  	 **************************************************************/
  
! void TLan_ResetLists( struct net_device *dev )
  {
! 	TLanPrivateInfo *priv = dev->priv;
! 	int		i;
! 	TLanList	*list;
! 	struct sk_buff	*skb;
! 	void		*t = NULL;
  
! 	priv->txHead = 0;
! 	priv->txTail = 0;
! 	for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
! 		list = priv->txList + i;
! 		list->cStat = TLAN_CSTAT_UNUSED;
! 		if ( bbuf ) {
! 			list->buffer[0].address = virt_to_bus( priv->txBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
! 		} else {
! 			list->buffer[0].address = 0;
! 		}
! 		list->buffer[2].count = 0;
! 		list->buffer[2].address = 0;
! 		list->buffer[9].address = 0;
! 	}
  
! 	priv->rxHead = 0;
! 	priv->rxTail = TLAN_NUM_RX_LISTS - 1;
! 	for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
! 		list = priv->rxList + i;
! 		list->cStat = TLAN_CSTAT_READY;
! 		list->frameSize = TLAN_MAX_FRAME_SIZE;
! 		list->buffer[0].count = TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
! 		if ( bbuf ) {
! 			list->buffer[0].address = virt_to_bus( priv->rxBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
! 		} else {
! 			skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
! 			if ( skb == NULL ) {
! 				printk( "TLAN:  Couldn't allocate memory for received data.\n" );
! 				/* If this ever happened it would be a problem */
! 			} else {
! 				skb->dev = dev;
! 				skb_reserve( skb, 2 );
! 				t = (void *) skb_put( skb, TLAN_MAX_FRAME_SIZE );
! 			}
! 			list->buffer[0].address = virt_to_bus( t );
! 			list->buffer[8].address = (u32) t;
! 			list->buffer[9].address = (u32) skb;
! 		}
! 		list->buffer[1].count = 0;
! 		list->buffer[1].address = 0;
! 		if ( i < TLAN_NUM_RX_LISTS - 1 )
! 			list->forward = virt_to_bus( list + 1 );
  		else
! 			list->forward = 0;
  	}
  
! } /* TLan_ResetLists */
  
- void TLan_FreeLists( struct net_device *dev )
- {
- 	TLanPrivateInfo *priv = dev->priv;
- 	int		i;
- 	TLanList	*list;
- 	struct sk_buff	*skb;
- 
- 	if ( ! bbuf ) {
- 		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
- 			list = priv->txList + i;
- 			skb = (struct sk_buff *) list->buffer[9].address;
- 			if ( skb ) {
- 				dev_kfree_skb_any( skb );
- 				list->buffer[9].address = 0;
- 			}
- 		}
  
- 		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
- 			list = priv->rxList + i;
- 			skb = (struct sk_buff *) list->buffer[9].address;
- 			if ( skb ) {
- 				dev_kfree_skb_any( skb );
- 				list->buffer[9].address = 0;
- 			}
- 		}
- 	}
  
- } /* TLan_FreeLists */
  
  	/***************************************************************
! 	 *	TLan_PrintDio
! 	 *  
  	 *	Returns:
  	 *		Nothing
  	 *	Parms:
! 	 *		io_base		Base IO port of the device of
! 	 *				which to print DIO registers.
  	 *
! 	 *	This function prints out all the internal (DIO)
! 	 *	registers of a TLAN chip.
  	 *
  	 **************************************************************/
  
! void TLan_PrintDio( u16 io_base )
  {
! 	u32 data0, data1;
! 	int	i;
  
! 	printk( "TLAN:   Contents of internal registers for io base 0x%04hx.\n", io_base );
! 	printk( "TLAN:      Off.  +0         +4\n" );
! 	for ( i = 0; i < 0x4C; i+= 8 ) {
! 		data0 = TLan_DioRead32( io_base, i );
! 		data1 = TLan_DioRead32( io_base, i + 0x4 );
! 		printk( "TLAN:      0x%02x  0x%08x 0x%08x\n", i, data0, data1 );
  	}
  
! } /* TLan_PrintDio */
  
  	/***************************************************************
! 	 *	TLan_PrintList
! 	 *  
  	 *	Returns:
  	 *		Nothing
  	 *	Parms:
! 	 *		list	A pointer to the TLanList structure to
! 	 *			be printed.
! 	 *		type	A string to designate type of list,
! 	 *			"Rx" or "Tx".
! 	 *		num	The index of the list.
  	 *
! 	 *	This function prints out the contents of the list
! 	 *	pointed to by the list parameter.
  	 *
  	 **************************************************************/
  
! void TLan_PrintList( TLanList *list, char *type, int num)
  {
! 	int i;
  
- 	printk( "TLAN:   %s List %d at 0x%08x\n", type, num, (u32) list );
- 	printk( "TLAN:      Forward    = 0x%08x\n",  list->forward );
- 	printk( "TLAN:      CSTAT      = 0x%04hx\n", list->cStat );
- 	printk( "TLAN:      Frame Size = 0x%04hx\n", list->frameSize );
- 	/* for ( i = 0; i < 10; i++ ) { */
- 	for ( i = 0; i < 2; i++ ) {
- 		printk( "TLAN:      Buffer[%d].count, addr = 0x%08x, 0x%08x\n", i, list->buffer[i].count, list->buffer[i].address );
- 	}
  
! } /* TLan_PrintList */
  
  	/***************************************************************
! 	 *	TLan_ReadAndClearStats
  	 *
  	 *	Returns:
--- 54,1361 ----
  /* to get the PCI support functions, if this is a PCI NIC */
  #include "pci.h"
! /* to get the ISA support functions, if this is an ISA NIC */
! /* #include "isa.h" */
! #include "timer.h"
! #include "tlan.h"
  
! #define drv_version "v1.3"
! #define drv_date "08-23-2003"
  
! /* NIC specific static variables go here */
! #define HZ 100
! #define TX_TIME_OUT	  (6*HZ)
  
! #ifdef EB50
! #define	cpu_to_le32(val) (val)
! #define	le32_to_cpu(val) (val)
! #define	virt_to_bus(x) ((unsigned long) x)
! #define	bus_to_virt(x) ((unsigned long) x)
! #endif
  
! /* Condensed operations for readability. */
! #define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
! #define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
  
  
! static void TLan_ResetLists(struct nic *nic __unused);
! static void TLan_ResetAdapter(struct nic *nic __unused);
! static void TLan_FinishReset(struct nic *nic __unused);
  
! static void TLan_EeSendStart(u16);
! static int TLan_EeSendByte(u16, u8, int);
! static void TLan_EeReceiveByte(u16, u8 *, int);
! static int TLan_EeReadByte(u16 io_base, u8, u8 *);
  
! static void TLan_PhyDetect(struct nic *nic);
! static void TLan_PhyPowerDown(struct nic *nic);
! static void TLan_PhyPowerUp(struct nic *nic);
  
  
! static void TLan_SetMac(struct nic *nic __unused, int areg, char *mac);
  
! static void TLan_PhyReset(struct nic *nic);
! static void TLan_PhyStartLink(struct nic *nic);
! static void TLan_PhyFinishAutoNeg(struct nic *nic);
  
! #ifdef MONITOR
! static void TLan_PhyMonitor(struct nic *nic);
! #endif
  
  
! static void refill_rx(struct nic *nic __unused);
  
! static int TLan_MiiReadReg(struct nic *nic __unused, u16, u16, u16 *);
! static void TLan_MiiSendData(u16, u32, unsigned);
! static void TLan_MiiSync(u16);
! static void TLan_MiiWriteReg(struct nic *nic __unused, u16, u16, u16);
  
  
! const char *media[] = {
! 	"10BaseT-HD ", "10BaseT-FD ", "100baseTx-HD ",
! 	"100baseTx-FD", "100baseT4", 0
! };
  
! /* This much match tlan_pci_tbl[]!  */
! enum tlan_nics {
! 	NETEL10 = 0, NETEL100 = 1, NETFLEX3I = 2, THUNDER = 3, NETFLEX3B =
! 	    4, NETEL100PI = 5,
! 	NETEL100D = 6, NETEL100I = 7, OC2183 = 8, OC2325 = 9, OC2326 =
! 	    10, NETELLIGENT_10_100_WS_5100 = 11,
! 	NETELLIGENT_10_T2 = 12
! };
  
! struct pci_id_info {
! 	const char *name;
! 	int nic_id;
! 	struct match_info {
! 		u32 pci, pci_mask, subsystem, subsystem_mask;
! 		u32 revision, revision_mask;	/* Only 8 bits. */
! 	} id;
! 	u32 flags;
! 	u16 addrOfs;		/* Address Offset */
! };
  
! static struct pci_id_info tlan_pci_tbl[] = {
! 	{"Compaq Netelligent 10 T PCI UTP", NETEL10,
! 	 {0xae340e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
! 	{"Compaq Netelligent 10/100 TX PCI UTP", NETEL100,
! 	 {0xae320e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
! 	{"Compaq Integrated NetFlex-3/P", NETFLEX3I,
! 	 {0xae350e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_NONE, 0x83},
! 	{"Compaq NetFlex-3/P", THUNDER,
! 	 {0xf1300e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83},
! 	{"Compaq NetFlex-3/P", NETFLEX3B,
! 	 {0xf1500e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_NONE, 0x83},
! 	{"Compaq Netelligent Integrated 10/100 TX UTP", NETEL100PI,
! 	 {0xae430e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
! 	{"Compaq Netelligent Dual 10/100 TX PCI UTP", NETEL100D,
! 	 {0xae400e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_NONE, 0x83},
! 	{"Compaq Netelligent 10/100 TX Embedded UTP", NETEL100I,
! 	 {0xb0110e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_NONE, 0x83},
! 	{"Olicom OC-2183/2185", OC2183,
! 	 {0x0013108d, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_USE_INTERN_10, 0x83},
! 	{"Olicom OC-2325", OC2325,
! 	 {0x0012108d, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_UNMANAGED_PHY, 0xF8},
! 	{"Olicom OC-2326", OC2326,
! 	 {0x0014108d, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_USE_INTERN_10, 0xF8},
! 	{"Compaq Netelligent 10/100 TX UTP", NETELLIGENT_10_100_WS_5100,
! 	 {0xb0300e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
! 	{"Compaq Netelligent 10 T/2 PCI UTP/Coax", NETELLIGENT_10_T2,
! 	 {0xb0120e11, 0xffffffff, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_NONE, 0x83},
! 	{"Compaq NetFlex-3/E", 0,	/* EISA card */
! 	 {0, 0, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_ACTIVITY_LED | TLAN_ADAPTER_UNMANAGED_PHY |
! 	 TLAN_ADAPTER_BIT_RATE_PHY, 0x83},
! 	{"Compaq NetFlex-3/E", 0,	/* EISA card */
! 	 {0, 0, 0, 0, 0, 0},
! 	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
! 	{0, 0,
! 	 {0, 0, 0, 0, 0, 0},
! 	 0, 0},
! };
  
  
! struct TLanList {
! 	u32 forward;
! 	u16 cStat;
! 	u16 frameSize;
! 	struct {
! 		u32 count;
! 		u32 address;
! 	} buffer[TLAN_BUFFERS_PER_LIST];
! };
  
  
  
! struct TLanList tx_ring[TLAN_NUM_TX_LISTS];
! static unsigned char txb[TLAN_MAX_FRAME_SIZE * TLAN_NUM_TX_LISTS];
  
! struct TLanList rx_ring[TLAN_NUM_RX_LISTS];
! static unsigned char rxb[TLAN_MAX_FRAME_SIZE * TLAN_NUM_RX_LISTS];
  
! typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZE];
  
  
! int chip_idx;
  
  
! /*****************************************************************
! * TLAN Private Information Structure
! *
! ****************************************************************/
! struct tlan_private {
! 	unsigned short vendor_id;	/* PCI Vendor code */
! 	unsigned short dev_id;	/* PCI Device code */
! 	const char *nic_name;
! 	u8 *padBuffer;
! 	u8 *rxBuffer;
! 	struct TLanList *rx_head_desc;
! 	u32 rxHead;
! 	u32 rxTail;
! 	u32 rxEocCount;
! 	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indicies */
! 	unsigned int cur_tx, dirty_tx;
! 	unsigned rx_buf_sz;	/* Based on mtu + Slack */
! 	struct TLanList *txList;
! 	struct TLanList *rxList;
! 	u8 *txBuffer;
! 	u32 txHead;
! 	u32 txInProgress;
! 	u32 txTail;
! 	int eoc;
! 	u32 txBusyCount;
! 	u32 phyOnline;
! 	u32 timerSetAt;
! 	u32 timerType;
! 	u32 adapterRev;
! 	u32 aui;
! 	u32 debug;
! 	u32 duplex;
! 	u32 phy[2];
! 	u32 phyNum;
! 	u32 speed;
! 	u8 tlanRev;
! 	u8 tlanFullDuplex;
! 	char devName[8];
! 	u8 link;
! 	u8 is_eisa;
! 	u8 neg_be_verbose;
! } TLanPrivateInfo;
  
! static struct tlan_private *priv;
  
! u32 BASE;
  
  
  
! /***************************************************************
! *	TLan_ResetLists
! *
! *	Returns:
! *		Nothing
! *	Parms:
! *		dev	The device structure with the list
! *			stuctures to be reset.
! *
! *	This routine sets the variables associated with managing
! *	the TLAN lists to their initial values.
! *
! **************************************************************/
  
! void TLan_ResetLists(struct nic *nic __unused)
  {
  
! 	int i;
! 	struct TLanList *list;
! 	priv->txHead = 0;
! 	priv->txTail = 0;
  
! 	for (i = 0; i < TLAN_NUM_TX_LISTS; i++) {
! 		list = &tx_ring[i];
! 		list->cStat = TLAN_CSTAT_UNUSED;
! /*		list->buffer[0].address = 0; */
! 		list->buffer[0].address = virt_to_bus(txb + 
! 				(i * TLAN_MAX_FRAME_SIZE)); 
! 		list->buffer[2].count = 0;
! 		list->buffer[2].address = 0;
! 		list->buffer[9].address = 0;
! /*		list->forward = 0; */
  	}
  
! 	priv->cur_rx = 0;
! 	priv->rx_buf_sz = (TLAN_MAX_FRAME_SIZE);
! 	priv->rx_head_desc = &rx_ring[0];
! 
! 	/* Initialize all the Rx descriptors */
! 	for (i = 0; i < TLAN_NUM_RX_LISTS; i++) {
! 		rx_ring[i].forward = virt_to_le32desc(&rx_ring[i + 1]);
! 		rx_ring[i].cStat = TLAN_CSTAT_READY;
! 		rx_ring[i].frameSize = TLAN_MAX_FRAME_SIZE;
! 		rx_ring[i].buffer[0].count =
! 		    TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
! 		rx_ring[i].buffer[0].address =
! 		    virt_to_le32desc(&rxb[i * TLAN_MAX_FRAME_SIZE]);
! 		rx_ring[i].buffer[1].count = 0;
! 		rx_ring[i].buffer[1].address = 0;
! 	}
! 
! 	/* Mark the last entry as wrapping the ring */
! 	rx_ring[i - 1].forward = virt_to_le32desc(&rx_ring[0]);
! 	priv->dirty_rx = (unsigned int) (i - TLAN_NUM_RX_LISTS);
  
! } /* TLan_ResetLists */
  
! /***************************************************************
! *	TLan_Reset
! *
! *	Returns:
! *		0
! *	Parms:
! *		dev	Pointer to device structure of adapter
! *			to be reset.
! *
! *	This function resets the adapter and it's physical
! *	device.  See Chap. 3, pp. 9-10 of the "ThunderLAN
! *	Programmer's Guide" for details.  The routine tries to
! *	implement what is detailed there, though adjustments
! *	have been made.
! *
! **************************************************************/
  
! void TLan_ResetAdapter(struct nic *nic __unused)
  {
! 	int i;
! 	u32 addr;
! 	u32 data;
! 	u8 data8;
  
! 	priv->tlanFullDuplex = FALSE;
! 	priv->phyOnline = 0;
! /*  1.	Assert reset bit. */
  
! 	data = inl(BASE + TLAN_HOST_CMD);
! 	data |= TLAN_HC_AD_RST;
! 	outl(data, BASE + TLAN_HOST_CMD);
  
! 	udelay(1000);
  
! /*  2.	Turn off interrupts. ( Probably isn't necessary ) */
  
! 	data = inl(BASE + TLAN_HOST_CMD);
! 	data |= TLAN_HC_INT_OFF;
! 	outl(data, BASE + TLAN_HOST_CMD);
! /*  3.	Clear AREGs and HASHs. */
  
! 	for (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4) {
! 		TLan_DioWrite32(BASE, (u16) i, 0);
! 	}
  
! /*  4.	Setup NetConfig register. */
  
! 	data =
! 	    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
! 	TLan_DioWrite16(BASE, TLAN_NET_CONFIG, (u16) data);
  
! /*  5.	Load Ld_Tmr and Ld_Thr in HOST_CMD. */
  
! 	outl(TLAN_HC_LD_TMR | 0x3f, BASE + TLAN_HOST_CMD);
! 	outl(TLAN_HC_LD_THR | 0x0, BASE + TLAN_HOST_CMD);
  
! /*  6.	Unreset the MII by setting NMRST (in NetSio) to 1. */
  
! 	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
! 	addr = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	TLan_SetBit(TLAN_NET_SIO_NMRST, addr);
  
! /*  7.	Setup the remaining registers. */
  
! 	if (priv->tlanRev >= 0x30) {
! 		data8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;
! 		TLan_DioWrite8(BASE, TLAN_INT_DIS, data8);
  	}
+ 	TLan_PhyDetect(nic);
+ 	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;
  
! 	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_BIT_RATE_PHY) {
! 		data |= TLAN_NET_CFG_BIT;
! 		if (priv->aui == 1) {
! 			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x0a);
! 		} else if (priv->duplex == TLAN_DUPLEX_FULL) {
! 			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x00);
! 			priv->tlanFullDuplex = TRUE;
! 		} else {
! 			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x08);
! 		}
  	}
  
! 	if (priv->phyNum == 0) {
! 		data |= TLAN_NET_CFG_PHY_EN;
  	}
+ 	TLan_DioWrite16(BASE, TLAN_NET_CONFIG, (u16) data);
  
! 	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY) {
! 		TLan_FinishReset(nic);
  	} else {
! 		TLan_PhyPowerDown(nic);
  	}
  
! }	/* TLan_ResetAdapter */
  
! void TLan_FinishReset(struct nic *nic)
  {
  
! 	u8 data;
! 	u32 phy;
! 	u8 sio;
! 	u16 status;
! 	u16 partner;
! 	u16 tlphy_ctl;
! 	u16 tlphy_par;
! 	u16 tlphy_id1, tlphy_id2;
! 	int i;
! 
! 	phy = priv->phy[priv->phyNum];
! 
! 	data = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;
! 	if (priv->tlanFullDuplex) {
! 		data |= TLAN_NET_CMD_DUPLEX;
  	}
+ 	TLan_DioWrite8(BASE, TLAN_NET_CMD, data);
+ 	data = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5;
+ 	if (priv->phyNum == 0) {
+ 		data |= TLAN_NET_MASK_MASK7;
+ 	}
+ 	TLan_DioWrite8(BASE, TLAN_NET_MASK, data);
+ 	TLan_DioWrite16(BASE, TLAN_MAX_RX, ((1536) + 7) & ~7);
+ 	TLan_MiiReadReg(nic, phy, MII_GEN_ID_HI, &tlphy_id1);
+ 	TLan_MiiReadReg(nic, phy, MII_GEN_ID_LO, &tlphy_id2);
  
! 	if ((tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY)
! 	    || (priv->aui)) {
! 		status = MII_GS_LINK;
! 		printf("TLAN:  %s: Link forced.\n", priv->nic_name);
! 	} else {
! 		TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
! 		udelay(1000);
! 		TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
! 		if ((status & MII_GS_LINK) &&	/* We only support link info on Nat.Sem. PHY's */
! 		    (tlphy_id1 == NAT_SEM_ID1)
! 		    && (tlphy_id2 == NAT_SEM_ID2)) {
! 			TLan_MiiReadReg(nic, phy, MII_AN_LPA, &partner);
! 			TLan_MiiReadReg(nic, phy, TLAN_TLPHY_PAR,
! 					&tlphy_par);
  
! 			printf("TLAN: %s: Link active with ",
! 			       priv->nic_name);
! 			if (!(tlphy_par & TLAN_PHY_AN_EN_STAT)) {
! 				printf("forced 10%sMbps %s-Duplex\n",
! 				       tlphy_par & TLAN_PHY_SPEED_100 ? ""
! 				       : "0",
! 				       tlphy_par & TLAN_PHY_DUPLEX_FULL ?
! 				       "Full" : "Half");
! 			} else {
! 				printf
! 				    ("AutoNegotiation enabled, at 10%sMbps %s-Duplex\n",
! 				     tlphy_par & TLAN_PHY_SPEED_100 ? "" :
! 				     "0",
! 				     tlphy_par & TLAN_PHY_DUPLEX_FULL ?
! 				     "Full" : "Half");
! 				printf("TLAN: Partner capability: ");
! 				for (i = 5; i <= 10; i++)
! 					if (partner & (1 << i))
! 						printf("%s", media[i - 5]);
! 				printf("\n");
! 			}
  
! 			TLan_DioWrite8(BASE, TLAN_LED_REG, TLAN_LED_LINK);
! #ifdef MONITOR
! 			/* We have link beat..for now anyway */
! 			priv->link = 1;
! 			/*Enabling link beat monitoring */
! 			/* TLan_SetTimer( nic, (10*HZ), TLAN_TIMER_LINK_BEAT ); */
! 			mdelay(10000);
! 			TLan_PhyMonitor(nic);
! #endif
! 		} else if (status & MII_GS_LINK) {
! 			printf("TLAN: %s: Link active\n", priv->nic_name);
! 			TLan_DioWrite8(BASE, TLAN_LED_REG, TLAN_LED_LINK);
! 		}
! 	}
  
! 	if (priv->phyNum == 0) {
! 		TLan_MiiReadReg(nic, phy, TLAN_TLPHY_CTL, &tlphy_ctl);
! 		tlphy_ctl |= TLAN_TC_INTEN;
! 		TLan_MiiWriteReg(nic, phy, TLAN_TLPHY_CTL, tlphy_ctl);
! 		sio = TLan_DioRead8(BASE, TLAN_NET_SIO);
! 		sio |= TLAN_NET_SIO_MINTEN;
! 		TLan_DioWrite8(BASE, TLAN_NET_SIO, sio);
! 	}
  
! 	if (status & MII_GS_LINK) {
! 		TLan_SetMac(nic, 0, nic->node_addr);
! 		priv->phyOnline = 1;
! 		outb((TLAN_HC_INT_ON >> 8), BASE + TLAN_HOST_CMD + 1);
! /*		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
! 			outb( ( TLAN_HC_REQ_INT >> 8 ), BASE + TLAN_HOST_CMD + 1 );
! 		}
  
! 		*/
! 		outl(virt_to_bus(&rx_ring), BASE + TLAN_CH_PARM);
! 		outl(TLAN_HC_GO | TLAN_HC_RT, BASE + TLAN_HOST_CMD);
! 	} else {
! 		printf
! 		    ("TLAN: %s: Link inactive, will retry in 10 secs...\n",
! 		     priv->nic_name);
! 		/* TLan_SetTimer( nic, (10*HZ), TLAN_TIMER_FINISH_RESET ); */
! 		mdelay(10000);
! 		TLan_FinishReset(nic);
! 		return;
  
! 	}
  
! }	/* TLan_FinishReset */
  
! /**************************************************************************
! POLL - Wait for a frame
! ***************************************************************************/
! static int tlan_poll(struct nic *nic)
  {
! 	/* return true if there's an ethernet packet ready to read */
! 	/* nic->packet should contain data on return */
! 	/* nic->packetlen should contain length of data */
! 	u32 framesize;
! 	u32 host_cmd = 0;
! 	u32 ack = 1;
! 	int eoc = 0;
! 	int entry = priv->cur_rx % TLAN_NUM_RX_LISTS;
! 	u16 tmpCStat = le32_to_cpu(rx_ring[entry].cStat);
  	
! 	u16 host_int = inw(BASE + TLAN_HOST_INT);
! 	outw(host_int, BASE + TLAN_HOST_INT);
  
! 	if (!(tmpCStat & TLAN_CSTAT_FRM_CMP))
! 		return 0;
  
! 	/* printf("PI-1: 0x%hX\n", host_int); */
! 	if (tmpCStat & TLAN_CSTAT_EOC)
! 		eoc = 1;
  
! 	framesize = rx_ring[entry].frameSize;
  
! 	nic->packetlen = framesize;
  
! #ifdef EBDEBUG
!      printf(".%d.", framesize); 
! #endif
!      
! 	memcpy(nic->packet, rxb +
! 	       (priv->cur_rx * TLAN_MAX_FRAME_SIZE), nic->packetlen);
! 
! 	rx_ring[entry].cStat = 0;
! #ifdef EBDEBUG
! 	hex_dump(nic->packet, nic->packetlen);
! 	printf("%d", entry);  
! #endif
! 	entry = (entry + 1) % TLAN_NUM_RX_LISTS;
! 	priv->cur_rx = entry;
! 	if (eoc) {
! 		if ((rx_ring[entry].cStat & TLAN_CSTAT_READY) ==
! 		    TLAN_CSTAT_READY) {
! 			ack |= TLAN_HC_GO | TLAN_HC_RT;
! 			host_cmd = TLAN_HC_ACK | ack | 0x001C0000;
! 			outl(host_cmd, BASE + TLAN_HOST_CMD);
  		}
  	} else {
! 		host_cmd = TLAN_HC_ACK | ack | (0x000C0000);
! 		outl(host_cmd, BASE + TLAN_HOST_CMD);
! #ifdef EBDEBUG
! 		printf("AC: 0x%hX\n", inw(BASE + TLAN_CH_PARM)); 
! 		host_int = inw(BASE + TLAN_HOST_INT);
! 		printf("PI-2: 0x%hX\n", host_int); 
! #endif
  	}
! 	refill_rx(nic);
! 	return (1);		/* initially as this is called to flush the input */
! }
  
! static void refill_rx(struct nic *nic __unused)
  {
! 	int entry = 0;
  
! 	for (;
! 	     (priv->cur_rx - priv->dirty_rx +
! 	      TLAN_NUM_RX_LISTS) % TLAN_NUM_RX_LISTS > 0;
! 	     priv->dirty_rx = (priv->dirty_rx + 1) % TLAN_NUM_RX_LISTS) {
! 		entry = priv->dirty_rx % TLAN_NUM_TX_LISTS;
! 		rx_ring[entry].frameSize = TLAN_MAX_FRAME_SIZE;
! 		rx_ring[entry].cStat = TLAN_CSTAT_READY;
  	}
  
  }
  
! /* #define EBDEBUG */
! /**************************************************************************
! TRANSMIT - Transmit a frame
! ***************************************************************************/
! static void tlan_transmit(struct nic *nic, const char *d,	/* Destination */
! 			  unsigned int t,	/* Type */
! 			  unsigned int s,	/* size */
! 			  const char *p)
! {				/* Packet */
! 	u16 nstype;
! 	u32 to;
! 	struct TLanList *tail_list;
! 	struct TLanList *head_list;
! 	u8 *tail_buffer;
! 	u32 ack = 0;
! 	u32 host_cmd;
! 	int eoc = 0;
! 	u16 tmpCStat;
! #ifdef EBDEBUG
! 	u16 host_int = inw(BASE + TLAN_HOST_INT);
! #endif
! 	int entry = 0;
  
! #ifdef EBDEBUG
! 	printf("INT0-0x%hX\n", host_int);
! #endif
! 
! 	if (!priv->phyOnline) {
! 		printf("TRANSMIT:  %s PHY is not ready\n", priv->nic_name);
! 		return;
  	}
  
  	tail_list = priv->txList + priv->txTail;
! 
! 	if (tail_list->cStat != TLAN_CSTAT_UNUSED) {
! 		printf("TRANSMIT: %s is busy (Head=%d Tail=%d)\n",
! 		       priv->nic_name, priv->txList, priv->txTail);
! 		tx_ring[entry].cStat = TLAN_CSTAT_UNUSED;
  		priv->txBusyCount++;
! 		return;
  	}
  
  	tail_list->forward = 0;
  
! 	tail_buffer = txb + (priv->txTail * TLAN_MAX_FRAME_SIZE);
  
! 	/* send the packet to destination */
! 	memcpy(tail_buffer, d, ETH_ALEN);
! 	memcpy(tail_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
! 	nstype = htons((u16) t);
! 	memcpy(tail_buffer + 2 * ETH_ALEN, (u8 *) & nstype, 2);
! 	memcpy(tail_buffer + ETH_HLEN, p, s);
! 
! 	s += ETH_HLEN;
! 	s &= 0x0FFF;
! 	while (s < ETH_ZLEN)
! 		tail_buffer[s++] = '\0';
! 
! 	/*=====================================================*/
! 	/* Receive
! 	 * 0000 0000 0001 1100
! 	 * 0000 0000 0000 1100
! 	 * 0000 0000 0000 0011 = 0x0003
! 	 *
! 	 * 0000 0000 0000 0000 0000 0000 0000 0011
! 	 * 0000 0000 0000 1100 0000 0000 0000 0000 = 0x000C0000
! 	 *
! 	 * Transmit
! 	 * 0000 0000 0001 1100
! 	 * 0000 0000 0000 0100
! 	 * 0000 0000 0000 0001 = 0x0001
! 	 *
! 	 * 0000 0000 0000 0000 0000 0000 0000 0001
! 	 * 0000 0000 0000 0100 0000 0000 0000 0000 = 0x00040000
! 	 * */
! 
! 	/* Setup the transmit descriptor */
! 	tail_list->frameSize = (u16) s;
! 	tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) s;
! 	tail_list->buffer[1].count = 0;
! 	tail_list->buffer[1].address = 0;
  
  	tail_list->cStat = TLAN_CSTAT_READY;
  
! #ifdef EBDEBUG
! 	host_int = inw(BASE + TLAN_HOST_INT);
! 	printf("INT1-0x%hX\n", host_int);
! #endif
  
! 	if (!priv->txInProgress) {
! 		priv->txInProgress = 1;
! 		outl(virt_to_le32desc(tail_list), BASE + TLAN_CH_PARM);
! 		outl(TLAN_HC_GO, BASE + TLAN_HOST_CMD);
  	} else {
! 		if (priv->txTail == 0) {
! #ifdef EBDEBUG
! 			printf("Out buffer\n");
! #endif
! 			(priv->txList + (TLAN_NUM_TX_LISTS - 1))->forward =
! 			    virt_to_le32desc(tail_list);
  		} else {
! #ifdef EBDEBUG
! 			printf("Fix this \n");
! #endif
! 			(priv->txList + (priv->txTail - 1))->forward =
! 			    virt_to_le32desc(tail_list);
  		}
  	}
+ 	
+ 	CIRC_INC(priv->txTail, TLAN_NUM_TX_LISTS);
  
! #ifdef EBDEBUG
! 	host_int = inw(BASE + TLAN_HOST_INT);
! 	printf("INT2-0x%hX\n", host_int);
! #endif
  
! 	to = currticks() + TX_TIME_OUT;
! 	while ((tail_list->cStat == TLAN_CSTAT_READY) && currticks() < to);
  
  	head_list = priv->txList + priv->txHead;
! 	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) 
! 			&& (ack < 255)) {
  		ack++;
! 		if(tmpCStat & TLAN_CSTAT_EOC)
! 			eoc =1;
  		head_list->cStat = TLAN_CSTAT_UNUSED;
! 		CIRC_INC(priv->txHead, TLAN_NUM_TX_LISTS);
  		head_list = priv->txList + priv->txHead;
+ 		
  	}
+ 	if(!ack)
+ 		printf("Incomplete TX Frame\n");
  
! 	if(eoc) {
! 		head_list = priv->txList + priv->txHead;
! 		if ((head_list->cStat & TLAN_CSTAT_READY) == TLAN_CSTAT_READY) {
! 			outl(virt_to_le32desc(head_list), BASE + TLAN_CH_PARM);
! 			ack |= TLAN_HC_GO;
! 		} else {
! 			priv->txInProgress = 0;
! 		}
! 	}
! 	if(ack) {
! 		host_cmd = TLAN_HC_ACK | ack;
! 		outl(host_cmd, BASE + TLAN_HOST_CMD);
! 	}
  	
! 	if(priv->tlanRev < 0x30 ) {
! 		ack = 1;
  		head_list = priv->txList + priv->txHead;
! 		if ((head_list->cStat & TLAN_CSTAT_READY) == TLAN_CSTAT_READY) {
! 			outl(virt_to_le32desc(head_list), BASE + TLAN_CH_PARM);
  			ack |= TLAN_HC_GO;
  		} else {
  			priv->txInProgress = 0;
  		}
+ 		host_cmd = TLAN_HC_ACK | ack | 0x00140000;
+ 		outl(host_cmd, BASE + TLAN_HOST_CMD);
+ 		
+ 	}
+ 			
+ 	if (currticks() >= to) {
+ 		printf("TX Time Out");
  	}
+ }
+ 
+ /**************************************************************************
+ DISABLE - Turn off ethernet interface
+ ***************************************************************************/
+ #ifdef EB51
+ static void tlan_disable(struct dev *dev __unused)
+ #else
+ static void tlan_disable(struct nic *nic __unused)
+ #endif
+ {
+ 	/* put the card in its initial state */
+ 	/* This function serves 3 purposes.
+ 	 * This disables DMA and interrupts so we don't receive
+ 	 *  unexpected packets or interrupts from the card after
+ 	 *  etherboot has finished.
+ 	 * This frees resources so etherboot may use
+ 	 *  this driver on another interface
+ 	 * This allows etherboot to reinitialize the interface
+ 	 *  if something is something goes wrong.
+ 	 *
+ 	 */
+ 	outl(TLAN_HC_AD_RST, BASE + TLAN_HOST_CMD);
+ }
+ 
+ static void TLan_SetMulticastList(struct nic *nic) {
+ 	int i;
+ 	u8 tmp;
+ 
+ 	/* !IFF_PROMISC */
+ 	tmp = TLan_DioRead8(BASE, TLAN_NET_CMD);
+ 	TLan_DioWrite8(BASE, TLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF);
+ 
+ 	/* IFF_ALLMULTI */
+ 	for(i = 0; i< 3; i++)
+ 		TLan_SetMac(nic, i + 1, NULL);
+ 	TLan_DioWrite32(BASE, TLAN_HASH_1, 0xFFFFFFFF);
+ 	TLan_DioWrite32(BASE, TLAN_HASH_2, 0xFFFFFFFF);
+ 
  	
! }
! /**************************************************************************
! PROBE - Look for an adapter, this routine's visible to the outside
! ***************************************************************************/
! 
! #define board_found 1
! #define valid_link 0
! #ifdef EB51
! static int tlan_probe(struct dev *dev, struct pci_device *pci)
! {
! 	struct nic *nic = (struct nic *) dev;
! #else
! struct nic *tlan_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
! {
! #endif
! 		u16 data = 0;
! 	int err;
! 	int i;
! 
! 	if (pci->ioaddr == 0)
! 		return 0;
! 
! 	BASE = pci->ioaddr;
! 	printf("\n");
! 	printf("tlan.c: %s, %s Written by Timothy Legge (tlegge@rogers.com)\n", drv_version, drv_date);
! 	printf("%s: Probing for Vendor 0x%hX, Device 0x%hX",
! 	       pci->name, pci->vendor, pci->dev_id);
! 
! 
! 	/* I really must find out what this does */
! 	adjust_pci_device(pci);
! 
! 	/* Point to private storage */
! 	priv = &TLanPrivateInfo;
! 	/* Figure out which chip we're dealing with */
! 	i = 0;
! 	chip_idx = -1;
! 
! 	while (tlan_pci_tbl[i].name) {
! 		if ((((u32) pci->dev_id << 16) | pci->vendor) ==
! 		    (tlan_pci_tbl[i].id.pci & 0xffffffff)) {
! 			chip_idx = i;
! 			break;
  		}
+ 		i++;
  	}
  
! 	priv->vendor_id = pci->vendor;
! 	priv->dev_id = pci->dev_id;
! 	priv->nic_name = pci->name;
! 	priv->eoc = 0;
  
! 	err = 0;
! 	for (i = 0; i < 6; i++)
! 		err |= TLan_EeReadByte(BASE,
! 				       (u8) tlan_pci_tbl[chip_idx].
! 				       addrOfs + i,
! 				       (u8 *) & nic->node_addr[i]);
! 	if (err) {
! 		printf("TLAN: %s: Error reading MAC from eeprom: %d\n",
! 		       pci->name, err);
! 	} else
! 		printf("\nAddress: %!\n", nic->node_addr);
  
! 	priv->tlanRev = TLan_DioRead8(BASE, TLAN_DEF_REVISION);
! 	printf("\nRevision = 0x%hX\n", priv->tlanRev);
  
! 	TLan_ResetLists(nic);
! 	TLan_ResetAdapter(nic);
! /*
! 	data = inl(BASE + TLAN_HOST_CMD);
! 	data |= TLAN_HC_EOC;
! 	outw(data, BASE + TLAN_HOST_CMD);
! */
! 
! 	data = inl(BASE + TLAN_HOST_CMD);
! 	data |= TLAN_HC_INT_OFF;
! 	outw(data, BASE + TLAN_HOST_CMD);
  
+ 	TLan_SetMulticastList(nic);
+ 	udelay(100); 
+ 	priv->txList = tx_ring;
+ 	priv->rxList = rx_ring;
+ /*	if (board_found && valid_link)
+ 	{*/
+ 	/* point to NIC specific routines */
+ #ifdef EB51
+ 	dev->disable = tlan_disable;
+ 	nic->poll = tlan_poll;
+ 	nic->transmit = tlan_transmit;
  	return 1;
+ #else
+ 	nic->disable = tlan_disable;
+ 	nic->poll = tlan_poll;
+ 	nic->transmit = tlan_transmit;
+ 	return nic;
+ #endif
+ }
+ 
+ 
+ /*****************************************************************************
+ ******************************************************************************
+ 
+ 	ThunderLAN Driver Eeprom routines
+ 
+ 	The Compaq Netelligent 10 and 10/100 cards use a Microchip 24C02A
+ 	EEPROM.  These functions are based on information in Microchip's
+ 	data sheet.  I don't know how well this functions will work with
+ 	other EEPROMs.
+ 
+ ******************************************************************************
+ *****************************************************************************/
  
  
  	/***************************************************************
! 	 *	TLan_EeSendStart
  	 *
  	 *	Returns:
! 	 *		Nothing
  	 *	Parms:
! 	 *		io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *
! 	 *	This function sends a start cycle to an EEPROM attached
! 	 *	to a TLAN chip.
  	 *
  	 **************************************************************/
  
! void TLan_EeSendStart(u16 io_base)
  {
! 	u16 sio;
  
! 	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
! 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
  
! 	TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 	TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
! 	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
! 	TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);
! 	TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
  
! }				/* TLan_EeSendStart */
  
  
  
  
  	/***************************************************************
! 	 *	TLan_EeSendByte
  	 *
  	 *	Returns:
! 	 *		If the correct ack was received, 0, otherwise 1
! 	 *	Parms:	io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *		data		The 8 bits of information to
! 	 *				send to the EEPROM.
! 	 *		stop		If TLAN_EEPROM_STOP is passed, a
! 	 *				stop cycle is sent after the
! 	 *				byte is sent after the ack is
! 	 *				read.
! 	 *
! 	 *	This function sends a byte on the serial EEPROM line,
! 	 *	driving the clock to send each bit. The function then
! 	 *	reverses transmission direction and reads an acknowledge
! 	 *	bit.
  	 *
  	 **************************************************************/
  
! int TLan_EeSendByte(u16 io_base, u8 data, int stop)
  {
! 	int err;
! 	u8 place;
! 	u16 sio;
  
! 	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
! 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
  
! 	/* Assume clock is low, tx is enabled; */
! 	for (place = 0x80; place != 0; place >>= 1) {
! 		if (place & data)
! 			TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
! 		else
! 			TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);
! 		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
! 	}
! 	TLan_ClearBit(TLAN_NET_SIO_ETXEN, sio);
! 	TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 	err = TLan_GetBit(TLAN_NET_SIO_EDATA, sio);
! 	TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
! 	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
  
! 	if ((!err) && stop) {
! 		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* STOP, raise data while clock is high */
! 		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
  	}
  
! 	return (err);
! 
! }				/* TLan_EeSendByte */
! 
! 
  
  
  	/***************************************************************
! 	 *	TLan_EeReceiveByte
  	 *
  	 *	Returns:
! 	 *		Nothing
  	 *	Parms:
! 	 *		io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *		data		An address to a char to hold the
! 	 *				data sent from the EEPROM.
! 	 *		stop		If TLAN_EEPROM_STOP is passed, a
! 	 *				stop cycle is sent after the
! 	 *				byte is received, and no ack is
! 	 *				sent.
! 	 *
! 	 *	This function receives 8 bits of data from the EEPROM
! 	 *	over the serial link.  It then sends and ack bit, or no
! 	 *	ack and a stop bit.  This function is used to retrieve
! 	 *	data after the address of a byte in the EEPROM has been
! 	 *	sent.
  	 *
  	 **************************************************************/
  
! void TLan_EeReceiveByte(u16 io_base, u8 * data, int stop)
! {
! 	u8 place;
! 	u16 sio;
  
! 	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
! 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	*data = 0;
  
! 	/* Assume clock is low, tx is enabled; */
! 	TLan_ClearBit(TLAN_NET_SIO_ETXEN, sio);
! 	for (place = 0x80; place; place >>= 1) {
! 		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 		if (TLan_GetBit(TLAN_NET_SIO_EDATA, sio))
! 			*data |= place;
! 		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
! 	}
! 
! 	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
! 	if (!stop) {
! 		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* Ack = 0 */
! 		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
! 	} else {
! 		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);	/* No ack = 1 (?) */
! 		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
! 		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* STOP, raise data while clock is high */
! 		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
! 		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
  	}
  
! }				/* TLan_EeReceiveByte */
! 
  
  
  	/***************************************************************
! 	 *	TLan_EeReadByte
  	 *
  	 *	Returns:
! 	 *		No error = 0, else, the stage at which the error
! 	 *		occurred.
  	 *	Parms:
! 	 *		io_base		The IO port base address for the
! 	 *				TLAN device with the EEPROM to
! 	 *				use.
! 	 *		ee_addr		The address of the byte in the
! 	 *				EEPROM whose contents are to be
! 	 *				retrieved.
! 	 *		data		An address to a char to hold the
! 	 *				data obtained from the EEPROM.
! 	 *
! 	 *	This function reads a byte of information from an byte
! 	 *	cell in the EEPROM.
  	 *
  	 **************************************************************/
  
! int TLan_EeReadByte(u16 io_base, u8 ee_addr, u8 * data)
  {
! 	int err;
! 	int ret = 0;
  
! 
! 	TLan_EeSendStart(io_base);
! 	err = TLan_EeSendByte(io_base, 0xA0, TLAN_EEPROM_ACK);
! 	if (err) {
! 		ret = 1;
! 		goto fail;
! 	}
! 	err = TLan_EeSendByte(io_base, ee_addr, TLAN_EEPROM_ACK);
! 	if (err) {
! 		ret = 2;
! 		goto fail;
! 	}
! 	TLan_EeSendStart(io_base);
! 	err = TLan_EeSendByte(io_base, 0xA1, TLAN_EEPROM_ACK);
! 	if (err) {
! 		ret = 3;
! 		goto fail;
  	}
+ 	TLan_EeReceiveByte(io_base, data, TLAN_EEPROM_STOP);
+       fail:
  
! 	return ret;
! 
! }				/* TLan_EeReadByte */
  
  
  /*****************************************************************************
  ******************************************************************************
  
! 	ThunderLAN Driver MII Routines
! 
! 	These routines are based on the information in Chap. 2 of the
! 	"ThunderLAN Programmer's Guide", pp. 15-24.
  
  ******************************************************************************
  *****************************************************************************/
  
+ 
  	/***************************************************************
! 	 *	TLan_MiiReadReg
  	 *
  	 *	Returns:
! 	 *		0	if ack received ok
! 	 *		1	otherwise.
! 	 *
  	 *	Parms:
! 	 *		dev		The device structure containing
! 	 *				The io address and interrupt count
! 	 *				for this device.
! 	 *		phy		The address of the PHY to be queried.
! 	 *		reg		The register whose contents are to be
! 	 *				retreived.
! 	 *		val		A pointer to a variable to store the
! 	 *				retrieved value.
  	 *
! 	 *	This function uses the TLAN's MII bus to retreive the contents
! 	 *	of a given register on a PHY.  It sends the appropriate info
! 	 *	and then reads the 16-bit register value from the MII bus via
! 	 *	the TLAN SIO register.
  	 *
  	 **************************************************************/
  
! int TLan_MiiReadReg(struct nic *nic __unused, u16 phy, u16 reg, u16 * val)
  {
! 	u8 nack;
! 	u16 sio, tmp;
! 	u32 i;
! 	int err;
! 	int minten;
! 
! 	err = FALSE;
! 	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
! 	sio = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
! 
! 	TLan_MiiSync(BASE);
! 
! 	minten = TLan_GetBit(TLAN_NET_SIO_MINTEN, sio);
! 	if (minten)
! 		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
! 
! 	TLan_MiiSendData(BASE, 0x1, 2);	/* Start ( 01b ) */
! 	TLan_MiiSendData(BASE, 0x2, 2);	/* Read  ( 10b ) */
! 	TLan_MiiSendData(BASE, phy, 5);	/* Device #      */
! 	TLan_MiiSendData(BASE, reg, 5);	/* Register #    */
! 
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);	/* Change direction */
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Clock Idle bit */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Wait 300ns */
! 
! 	nack = TLan_GetBit(TLAN_NET_SIO_MDATA, sio);	/* Check for ACK */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);	/* Finish ACK */
! 	if (nack) {		/* No ACK, so fake it */
! 		for (i = 0; i < 16; i++) {
! 			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
! 			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 		}
! 		tmp = 0xffff;
! 		err = TRUE;
! 	} else {		/* ACK, so read data */
! 		for (tmp = 0, i = 0x8000; i; i >>= 1) {
! 			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
! 			if (TLan_GetBit(TLAN_NET_SIO_MDATA, sio))
! 				tmp |= i;
! 			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 		}
  	}
  
  
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Idle cycle */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
  
! 	if (minten)
! 		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
  
! 	*val = tmp;
! 
! 	return err;
! 
! }				/* TLan_MiiReadReg */
  
  	/***************************************************************
! 	 *	TLan_MiiSendData
! 	 *
  	 *	Returns:
  	 *		Nothing
  	 *	Parms:
! 	 *		base_port	The base IO port of the adapter	in
! 	 *				question.
! 	 *		dev		The address of the PHY to be queried.
! 	 *		data		The value to be placed on the MII bus.
! 	 *		num_bits	The number of bits in data that are to
! 	 *				be placed on the MII bus.
  	 *
! 	 *	This function sends on sequence of bits on the MII
! 	 *	configuration bus.
  	 *
  	 **************************************************************/
  
! void TLan_MiiSendData(u16 base_port, u32 data, unsigned num_bits)
  {
! 	u16 sio;
! 	u32 i;
  
! 	if (num_bits == 0)
! 		return;
! 
! 	outw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);
! 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	TLan_SetBit(TLAN_NET_SIO_MTXEN, sio);
  
! 	for (i = (0x1 << (num_bits - 1)); i; i >>= 1) {
! 		TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
! 		(void) TLan_GetBit(TLAN_NET_SIO_MCLK, sio);
! 		if (data & i)
! 			TLan_SetBit(TLAN_NET_SIO_MDATA, sio);
  		else
! 			TLan_ClearBit(TLAN_NET_SIO_MDATA, sio);
! 		TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 		(void) TLan_GetBit(TLAN_NET_SIO_MCLK, sio);
  	}
  
! }				/* TLan_MiiSendData */
  
  
  
  
  	/***************************************************************
! 	 *	TLan_MiiSync
! 	 *
  	 *	Returns:
  	 *		Nothing
  	 *	Parms:
! 	 *		base_port	The base IO port of the adapter in
! 	 *				question.
  	 *
! 	 *	This functions syncs all PHYs in terms of the MII configuration
! 	 *	bus.
  	 *
  	 **************************************************************/
  
! void TLan_MiiSync(u16 base_port)
  {
! 	int i;
! 	u16 sio;
  
! 	outw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);
! 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);
! 	for (i = 0; i < 32; i++) {
! 		TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
! 		TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
  	}
  
! }				/* TLan_MiiSync */
! 
! 
! 
  
  	/***************************************************************
! 	 *	TLan_MiiWriteReg
! 	 *
  	 *	Returns:
  	 *		Nothing
  	 *	Parms:
! 	 *		dev		The device structure for the device
! 	 *				to write to.
! 	 *		phy		The address of the PHY to be written to.
! 	 *		reg		The register whose contents are to be
! 	 *				written.
! 	 *		val		The value to be written to the register.
  	 *
! 	 *	This function uses the TLAN's MII bus to write the contents of a
! 	 *	given register on a PHY.  It sends the appropriate info and then
! 	 *	writes the 16-bit register value from the MII configuration bus
! 	 *	via the TLAN SIO register.
  	 *
  	 **************************************************************/
  
! void TLan_MiiWriteReg(struct nic *nic __unused, u16 phy, u16 reg, u16 val)
  {
! 	u16 sio;
! 	int minten;
! 
! 	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
! 	sio = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
! 
! 	TLan_MiiSync(BASE);
! 
! 	minten = TLan_GetBit(TLAN_NET_SIO_MINTEN, sio);
! 	if (minten)
! 		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
! 
! 	TLan_MiiSendData(BASE, 0x1, 2);	/* Start ( 01b ) */
! 	TLan_MiiSendData(BASE, 0x1, 2);	/* Write ( 01b ) */
! 	TLan_MiiSendData(BASE, phy, 5);	/* Device #      */
! 	TLan_MiiSendData(BASE, reg, 5);	/* Register #    */
! 
! 	TLan_MiiSendData(BASE, 0x2, 2);	/* Send ACK */
! 	TLan_MiiSendData(BASE, val, 16);	/* Send Data */
! 
! 	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Idle cycle */
! 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
! 
! 	if (minten)
! 		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
  
  
! }				/* TLan_MiiWriteReg */
  
  	/***************************************************************
! 	 *	TLan_SetMac
  	 *
  	 *	Returns:
***************
*** 3445,3746 ****
  	 *	Parms:
  	 *		dev	Pointer to device structure of adapter
! 	 *			to which to read stats.
! 	 *		record	Flag indicating whether to add 
  	 *
! 	 *	This functions reads all the internal status registers
! 	 *	of the TLAN chip, which clears them as a side effect.
! 	 *	It then either adds the values to the device's status
! 	 *	struct, or discards them, depending on whether record
! 	 *	is TLAN_RECORD (!=0)  or TLAN_IGNORE (==0).
  	 *
  	 **************************************************************/
  
! void TLan_ReadAndClearStats( struct net_device *dev, int record )
  {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u32		tx_good, tx_under;
! 	u32		rx_good, rx_over;
! 	u32		def_tx, crc, code;
! 	u32		multi_col, single_col;
! 	u32		excess_col, late_col, loss;
! 
! 	outw( TLAN_GOOD_TX_FRMS, dev->base_addr + TLAN_DIO_ADR );
! 	tx_good  = inb( dev->base_addr + TLAN_DIO_DATA );
! 	tx_good += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
! 	tx_good += inb( dev->base_addr + TLAN_DIO_DATA + 2 ) << 16;
! 	tx_under = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
! 
! 	outw( TLAN_GOOD_RX_FRMS, dev->base_addr + TLAN_DIO_ADR );
! 	rx_good  = inb( dev->base_addr + TLAN_DIO_DATA );
! 	rx_good += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
! 	rx_good += inb( dev->base_addr + TLAN_DIO_DATA + 2 ) << 16;
! 	rx_over  = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
! 		
! 	outw( TLAN_DEFERRED_TX, dev->base_addr + TLAN_DIO_ADR );
! 	def_tx  = inb( dev->base_addr + TLAN_DIO_DATA );
! 	def_tx += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
! 	crc     = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
! 	code    = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
! 	
! 	outw( TLAN_MULTICOL_FRMS, dev->base_addr + TLAN_DIO_ADR );
! 	multi_col   = inb( dev->base_addr + TLAN_DIO_DATA );
! 	multi_col  += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
! 	single_col  = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
! 	single_col += inb( dev->base_addr + TLAN_DIO_DATA + 3 ) << 8;
! 
! 	outw( TLAN_EXCESSCOL_FRMS, dev->base_addr + TLAN_DIO_ADR );
! 	excess_col = inb( dev->base_addr + TLAN_DIO_DATA );
! 	late_col   = inb( dev->base_addr + TLAN_DIO_DATA + 1 );
! 	loss       = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
! 
! 	if ( record ) {
! 		priv->stats.rx_packets += rx_good;
! 		priv->stats.rx_errors  += rx_over + crc + code;
! 		priv->stats.tx_packets += tx_good;
! 		priv->stats.tx_errors  += tx_under + loss;
! 		priv->stats.collisions += multi_col + single_col + excess_col + late_col;
! 
! 		priv->stats.rx_over_errors    += rx_over;
! 		priv->stats.rx_crc_errors     += crc;
! 		priv->stats.rx_frame_errors   += code;
  
! 		priv->stats.tx_aborted_errors += tx_under;
! 		priv->stats.tx_carrier_errors += loss;
  	}
- 			
- } /* TLan_ReadAndClearStats */
  
! 	/***************************************************************
! 	 *	TLan_Reset
  	 *
  	 *	Returns:
! 	 *		0
  	 *	Parms:
! 	 *		dev	Pointer to device structure of adapter
! 	 *			to be reset.
  	 *
! 	 *	This function resets the adapter and it's physical
! 	 *	device.  See Chap. 3, pp. 9-10 of the "ThunderLAN
! 	 *	Programmer's Guide" for details.  The routine tries to
! 	 *	implement what is detailed there, though adjustments
! 	 *	have been made.
  	 *
! 	 **************************************************************/
  
! void
! TLan_ResetAdapter( struct net_device *dev )
  {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	int		i;
! 	u32		addr;
! 	u32		data;
! 	u8		data8;
  
! 	priv->tlanFullDuplex = FALSE;
! 	priv->phyOnline=0;
! /*  1.	Assert reset bit. */
  
! 	data = inl(dev->base_addr + TLAN_HOST_CMD);
! 	data |= TLAN_HC_AD_RST;
! 	outl(data, dev->base_addr + TLAN_HOST_CMD);
! 	
! 	udelay(1000);
  
! /*  2.	Turn off interrupts. ( Probably isn't necessary ) */
  
! 	data = inl(dev->base_addr + TLAN_HOST_CMD);
! 	data |= TLAN_HC_INT_OFF;
! 	outl(data, dev->base_addr + TLAN_HOST_CMD);
  
! /*  3.	Clear AREGs and HASHs. */
  
!  	for ( i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4 ) {
! 		TLan_DioWrite32( dev->base_addr, (u16) i, 0 );
  	}
  
! /*  4.	Setup NetConfig register. */
  
! 	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
! 	TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, (u16) data );
  
- /*  5.	Load Ld_Tmr and Ld_Thr in HOST_CMD. */
  
!  	outl( TLAN_HC_LD_TMR | 0x3f, dev->base_addr + TLAN_HOST_CMD );
!  	outl( TLAN_HC_LD_THR | 0x9, dev->base_addr + TLAN_HOST_CMD );
  
! /*  6.	Unreset the MII by setting NMRST (in NetSio) to 1. */
  
! 	outw( TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR );
! 	addr = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
! 	TLan_SetBit( TLAN_NET_SIO_NMRST, addr );
  
! /*  7.	Setup the remaining registers. */
  
! 	if ( priv->tlanRev >= 0x30 ) {
! 		data8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;
! 		TLan_DioWrite8( dev->base_addr, TLAN_INT_DIS, data8 );
  	}
! 	TLan_PhyDetect( dev );
! 	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;
! 	
! 	if ( priv->adapter->flags & TLAN_ADAPTER_BIT_RATE_PHY ) {
! 		data |= TLAN_NET_CFG_BIT;
! 		if ( priv->aui == 1 ) {
! 			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x0a );
! 		} else if ( priv->duplex == TLAN_DUPLEX_FULL ) {
! 			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x00 );
  			priv->tlanFullDuplex = TRUE;
  		} else {
! 			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x08 );
  		}
- 	}
  
- 	if ( priv->phyNum == 0 ) {
- 		data |= TLAN_NET_CFG_PHY_EN;
  	}
- 	TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, (u16) data );
  
! 	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
! 		TLan_FinishReset( dev );
! 	} else {
! 		TLan_PhyPowerDown( dev );
  	}
  
! } /* TLan_ResetAdapter */
  
! void
! TLan_FinishReset( struct net_device *dev )
  {
! 	TLanPrivateInfo	*priv = dev->priv;
! 	u8		data;
! 	u32		phy;
! 	u8		sio;
! 	u16		status;
! 	u16		partner;
! 	u16		tlphy_ctl;
! 	u16 		tlphy_par;
! 	u16		tlphy_id1, tlphy_id2;
! 	int 		i;
  
  	phy = priv->phy[priv->phyNum];
  
! 	data = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;
! 	if ( priv->tlanFullDuplex ) {
! 		data |= TLAN_NET_CMD_DUPLEX;
  	}
- 	TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, data );
- 	data = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5; 
- 	if ( priv->phyNum == 0 ) {
- 		data |= TLAN_NET_MASK_MASK7; 
- 	}
- 	TLan_DioWrite8( dev->base_addr, TLAN_NET_MASK, data );
- 	TLan_DioWrite16( dev->base_addr, TLAN_MAX_RX, ((1536)+7)&~7 );
- 	TLan_MiiReadReg( dev, phy, MII_GEN_ID_HI, &tlphy_id1 );
- 	TLan_MiiReadReg( dev, phy, MII_GEN_ID_LO, &tlphy_id2 );
- 	
- 	if ( ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) || ( priv->aui ) ) {
- 		status = MII_GS_LINK;
- 		printk( "TLAN:  %s: Link forced.\n", dev->name );
- 	} else {
- 		TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
- 		udelay( 1000 );
- 		TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
- 		if ( (status & MII_GS_LINK) &&	 /* We only support link info on Nat.Sem. PHY's */ 
- 			(tlphy_id1 == NAT_SEM_ID1) &&
- 			(tlphy_id2 == NAT_SEM_ID2) ) {
- 			TLan_MiiReadReg( dev, phy, MII_AN_LPA, &partner );
- 			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_PAR, &tlphy_par );
- 			
- 			printk( "TLAN: %s: Link active with ", dev->name );
- 			if (!(tlphy_par & TLAN_PHY_AN_EN_STAT)) {
- 			      	 printk( "forced 10%sMbps %s-Duplex\n", 
- 						tlphy_par & TLAN_PHY_SPEED_100 ? "" : "0",
- 						tlphy_par & TLAN_PHY_DUPLEX_FULL ? "Full" : "Half");
- 			} else {
- 				printk( "AutoNegotiation enabled, at 10%sMbps %s-Duplex\n",
- 						tlphy_par & TLAN_PHY_SPEED_100 ? "" : "0",
- 						tlphy_par & TLAN_PHY_DUPLEX_FULL ? "Full" : "Half");
- 				printk("TLAN: Partner capability: ");
- 					for (i = 5; i <= 10; i++)
- 						if (partner & (1<<i))
- 							printk("%s", media[i-5]);
- 							printk("\n");
- 			}
  
! 			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
! #ifdef MONITOR			
! 			/* We have link beat..for now anyway */
! 	        	priv->link = 1;
! 	        	/*Enabling link beat monitoring */
! 			TLan_SetTimer( dev, (10*HZ), TLAN_TIMER_LINK_BEAT );
! #endif 
! 		} else if (status & MII_GS_LINK)  {
! 			printk( "TLAN: %s: Link active\n", dev->name );
! 			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
! 		}
  	}
  
! 	if ( priv->phyNum == 0 ) {
!         	TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl );
!         	tlphy_ctl |= TLAN_TC_INTEN;
!         	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl );
!         	sio = TLan_DioRead8( dev->base_addr, TLAN_NET_SIO );
!         	sio |= TLAN_NET_SIO_MINTEN;
!         	TLan_DioWrite8( dev->base_addr, TLAN_NET_SIO, sio );
  	}
  
! 	if ( status & MII_GS_LINK ) {
! 		TLan_SetMac( dev, 0, dev->dev_addr );
! 		priv->phyOnline = 1;
! 		outb( ( TLAN_HC_INT_ON >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
! 		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
! 			outb( ( TLAN_HC_REQ_INT >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
  		}
- 		outl( virt_to_bus( priv->rxList ), dev->base_addr + TLAN_CH_PARM );
- 		outl( TLAN_HC_GO | TLAN_HC_RT, dev->base_addr + TLAN_HOST_CMD );
- 	} else {
- 		printk( "TLAN: %s: Link inactive, will retry in 10 secs...\n", dev->name );
- 		TLan_SetTimer( dev, (10*HZ), TLAN_TIMER_FINISH_RESET );
- 		return;
  	}
  
! } /* TLan_FinishReset */
  
! 	/***************************************************************
! 	 *	TLan_SetMac
! 	 *
! 	 *	Returns:
! 	 *		Nothing
! 	 *	Parms:
! 	 *		dev	Pointer to device structure of adapter
! 	 *			on which to change the AREG.
! 	 *		areg	The AREG to set the address in (0 - 3).
! 	 *		mac	A pointer to an array of chars.  Each
! 	 *			element stores one byte of the address.
! 	 *			IE, it isn't in ascii.
! 	 *
! 	 *	This function transfers a MAC address to one of the
! 	 *	TLAN AREGs (address registers).  The TLAN chip locks
! 	 *	the register on writing to offset 0 and unlocks the
! 	 *	register after writing to offset 5.  If NULL is passed
! 	 *	in mac, then the AREG is filled with 0's.
! 	 *
! 	 **************************************************************/
  
! void TLan_SetMac( struct net_device *dev, int areg, char *mac )
  {
! 	int i;
! 			
! 	areg *= 6;
  
! 	if ( mac != NULL ) {
! 		for ( i = 0; i < 6; i++ )
! 			TLan_DioWrite8( dev->base_addr, TLAN_AREG_0 + areg + i, mac[i] );
! 	} else {
! 		for ( i = 0; i < 6; i++ )
! 			TLan_DioWrite8( dev->base_addr, TLAN_AREG_0 + areg + i, 0 );
  	}
  
! } /* TLan_SetMac */
  
  #endif
--- 1363,1796 ----
  	 *	Parms:
  	 *		dev	Pointer to device structure of adapter
! 	 *			on which to change the AREG.
! 	 *		areg	The AREG to set the address in (0 - 3).
! 	 *		mac	A pointer to an array of chars.  Each
! 	 *			element stores one byte of the address.
! 	 *			IE, it isn't in ascii.
  	 *
! 	 *	This function transfers a MAC address to one of the
! 	 *	TLAN AREGs (address registers).  The TLAN chip locks
! 	 *	the register on writing to offset 0 and unlocks the
! 	 *	register after writing to offset 5.  If NULL is passed
! 	 *	in mac, then the AREG is filled with 0's.
  	 *
  	 **************************************************************/
  
! void TLan_SetMac(struct nic *nic __unused, int areg, char *mac)
  {
! 	int i;
  
! 	areg *= 6;
! 
! 	if (mac != NULL) {
! 		for (i = 0; i < 6; i++)
! 			TLan_DioWrite8(BASE, TLAN_AREG_0 + areg + i,
! 				       mac[i]);
! 	} else {
! 		for (i = 0; i < 6; i++)
! 			TLan_DioWrite8(BASE, TLAN_AREG_0 + areg + i, 0);
  	}
  
! }				/* TLan_SetMac */
! 
! 	/*********************************************************************
! 	 *	TLan_PhyDetect
  	 *
  	 *	Returns:
! 	 *		Nothing
  	 *	Parms:
! 	 *		dev	A pointer to the device structure of the adapter
! 	 *			for which the PHY needs determined.
  	 *
! 	 *	So far I've found that adapters which have external PHYs
! 	 *	may also use the internal PHY for part of the functionality.
! 	 *	(eg, AUI/Thinnet).  This function finds out if this TLAN
! 	 *	chip has an internal PHY, and then finds the first external
! 	 *	PHY (starting from address 0) if it exists).
  	 *
! 	 ********************************************************************/
  
! void TLan_PhyDetect(struct nic *nic)
  {
! 	u16 control;
! 	u16 hi;
! 	u16 lo;
! 	u32 phy;
  
! 	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY) {
! 		priv->phyNum = 0xFFFF;
! 		return;
! 	}
  
! 	TLan_MiiReadReg(nic, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi);
  
! 	if (hi != 0xFFFF) {
! 		priv->phy[0] = TLAN_PHY_MAX_ADDR;
! 	} else {
! 		priv->phy[0] = TLAN_PHY_NONE;
! 	}
  
! 	priv->phy[1] = TLAN_PHY_NONE;
! 	for (phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++) {
! 		TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &control);
! 		TLan_MiiReadReg(nic, phy, MII_GEN_ID_HI, &hi);
! 		TLan_MiiReadReg(nic, phy, MII_GEN_ID_LO, &lo);
! 		if ((control != 0xFFFF) || (hi != 0xFFFF)
! 		    || (lo != 0xFFFF)) {
! 			printf("PHY found at %hX %hX %hX %hX\n", phy,
! 			       control, hi, lo);
! 			if ((priv->phy[1] == TLAN_PHY_NONE)
! 			    && (phy != TLAN_PHY_MAX_ADDR)) {
! 				priv->phy[1] = phy;
! 			}
! 		}
! 	}
  
! 	if (priv->phy[1] != TLAN_PHY_NONE) {
! 		priv->phyNum = 1;
! 	} else if (priv->phy[0] != TLAN_PHY_NONE) {
! 		priv->phyNum = 0;
! 	} else {
! 		printf
! 		    ("TLAN:  Cannot initialize device, no PHY was found!\n");
! 	}
! 
! }				/* TLan_PhyDetect */
  
! void TLan_PhyPowerDown(struct nic *nic)
! {
! 
! 	u16 value;
! 	printf("%s: Powering down PHY(s).\n", priv->nic_name);
! 	value = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;
! 	TLan_MiiSync(BASE);
! 	TLan_MiiWriteReg(nic, priv->phy[priv->phyNum], MII_GEN_CTL, value);
! 	if ((priv->phyNum == 0) && (priv->phy[1] != TLAN_PHY_NONE)
! 	    &&
! 	    (!(tlan_pci_tbl[chip_idx].
! 	       flags & TLAN_ADAPTER_USE_INTERN_10))) {
! 		TLan_MiiSync(BASE);
! 		TLan_MiiWriteReg(nic, priv->phy[1], MII_GEN_CTL, value);
  	}
  
! 	/* Wait for 50 ms and powerup
! 	 * This is abitrary.  It is intended to make sure the
! 	 * tranceiver settles.
! 	 */
! 	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP ); */
! 	mdelay(50);
! 	TLan_PhyPowerUp(nic);
  
! }				/* TLan_PhyPowerDown */
  
  
! void TLan_PhyPowerUp(struct nic *nic)
! {
! 	u16 value;
  
! 	printf("%s: Powering up PHY.\n", priv->nic_name);
! 	TLan_MiiSync(BASE);
! 	value = MII_GC_LOOPBK;
! 	TLan_MiiWriteReg(nic, priv->phy[priv->phyNum], MII_GEN_CTL, value);
! 	TLan_MiiSync(BASE);
! 	/* Wait for 500 ms and reset the
! 	 * tranceiver.  The TLAN docs say both 50 ms and
! 	 * 500 ms, so do the longer, just in case.
! 	 */
! 	mdelay(500);
! 	TLan_PhyReset(nic);
! 	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET ); */
  
! }				/* TLan_PhyPowerUp */
  
! void TLan_PhyReset(struct nic *nic)
! {
! 	u16 phy;
! 	u16 value;
  
! 	phy = priv->phy[priv->phyNum];
! 
! 	printf("%s: Reseting PHY.\n", priv->nic_name);
! 	TLan_MiiSync(BASE);
! 	value = MII_GC_LOOPBK | MII_GC_RESET;
! 	TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, value);
! 	TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &value);
! 	while (value & MII_GC_RESET) {
! 		TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &value);
  	}
! 
! 	/* Wait for 500 ms and initialize.
! 	 * I don't remember why I wait this long.
! 	 * I've changed this to 50ms, as it seems long enough.
! 	 */
! 	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_START_LINK ); */
! 	mdelay(50);
! 	TLan_PhyStartLink(nic);
! 
! }				/* TLan_PhyReset */
! 
! 
! void TLan_PhyStartLink(struct nic *nic)
! {
! 
! 	u16 ability;
! 	u16 control;
! 	u16 data;
! 	u16 phy;
! 	u16 status;
! 	u16 tctl;
! 
! 	phy = priv->phy[priv->phyNum];
! 	printf("%s: Trying to activate link.\n", priv->nic_name);
! 	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
! 	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &ability);
! 
! 	if ((status & MII_GS_AUTONEG) && (!priv->aui)) {
! 		ability = status >> 11;
! 		if (priv->speed == TLAN_SPEED_10 &&
! 		    priv->duplex == TLAN_DUPLEX_HALF) {
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x0000);
! 		} else if (priv->speed == TLAN_SPEED_10 &&
! 			   priv->duplex == TLAN_DUPLEX_FULL) {
! 			priv->tlanFullDuplex = TRUE;
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x0100);
! 		} else if (priv->speed == TLAN_SPEED_100 &&
! 			   priv->duplex == TLAN_DUPLEX_HALF) {
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x2000);
! 		} else if (priv->speed == TLAN_SPEED_100 &&
! 			   priv->duplex == TLAN_DUPLEX_FULL) {
  			priv->tlanFullDuplex = TRUE;
+ 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x2100);
  		} else {
! 
! 			/* Set Auto-Neg advertisement */
! 			TLan_MiiWriteReg(nic, phy, MII_AN_ADV,
! 					 (ability << 5) | 1);
! 			/* Enablee Auto-Neg */
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x1000);
! 			/* Restart Auto-Neg */
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x1200);
! 			/* Wait for 4 sec for autonegotiation
! 			 * to complete.  The max spec time is less than this
! 			 * but the card need additional time to start AN.
! 			 * .5 sec should be plenty extra.
! 			 */
! 			printf("TLAN: %s: Starting autonegotiation.\n",
! 			       priv->nic_name);
! 			mdelay(4000);
! 			TLan_PhyFinishAutoNeg(nic);
! 			/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN ); */
! 			return;
  		}
  
  	}
  
! 	if ((priv->aui) && (priv->phyNum != 0)) {
! 		priv->phyNum = 0;
! 		data =
! 		    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN |
! 		    TLAN_NET_CFG_PHY_EN;
! 		TLan_DioWrite16(BASE, TLAN_NET_CONFIG, data);
! 		mdelay(50);
! 		/* TLan_SetTimer( dev, (40*HZ/1000), TLAN_TIMER_PHY_PDOWN ); */
! 		TLan_PhyPowerDown(nic);
! 		return;
! 	} else if (priv->phyNum == 0) {
! 		control = 0;
! 		TLan_MiiReadReg(nic, phy, TLAN_TLPHY_CTL, &tctl);
! 		if (priv->aui) {
! 			tctl |= TLAN_TC_AUISEL;
! 		} else {
! 			tctl &= ~TLAN_TC_AUISEL;
! 			if (priv->duplex == TLAN_DUPLEX_FULL) {
! 				control |= MII_GC_DUPLEX;
! 				priv->tlanFullDuplex = TRUE;
! 			}
! 			if (priv->speed == TLAN_SPEED_100) {
! 				control |= MII_GC_SPEEDSEL;
! 			}
! 		}
! 		TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, control);
! 		TLan_MiiWriteReg(nic, phy, TLAN_TLPHY_CTL, tctl);
  	}
  
! 	/* Wait for 2 sec to give the tranceiver time
! 	 * to establish link.
! 	 */
! 	/* TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET ); */
! 	mdelay(2000);
! 	TLan_FinishReset(nic);
! 
! }				/* TLan_PhyStartLink */
  
! void TLan_PhyFinishAutoNeg(struct nic *nic)
  {
! 
! 	u16 an_adv;
! 	u16 an_lpa;
! 	u16 data;
! 	u16 mode;
! 	u16 phy;
! 	u16 status;
  
  	phy = priv->phy[priv->phyNum];
  
! 	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
! 	udelay(1000);
! 	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
! 
! 	if (!(status & MII_GS_AUTOCMPLT)) {
! 		/* Wait for 8 sec to give the process
! 		 * more time.  Perhaps we should fail after a while.
! 		 */
! 		if (!priv->neg_be_verbose++) {
! 			printf
! 			    ("TLAN:  Giving autonegotiation more time.\n");
! 			printf
! 			    ("TLAN:  Please check that your adapter has\n");
! 			printf
! 			    ("TLAN:  been properly connected to a HUB or Switch.\n");
! 			printf
! 			    ("TLAN:  Trying to establish link in the background...\n");
! 		}
! 		mdelay(8000);
! 		TLan_PhyFinishAutoNeg(nic);
! 		/* TLan_SetTimer( dev, (8*HZ), TLAN_TIMER_PHY_FINISH_AN ); */
! 		return;
  	}
  
! 	printf("TLAN: %s: Autonegotiation complete.\n", priv->nic_name);
! 	TLan_MiiReadReg(nic, phy, MII_AN_ADV, &an_adv);
! 	TLan_MiiReadReg(nic, phy, MII_AN_LPA, &an_lpa);
! 	mode = an_adv & an_lpa & 0x03E0;
! 	if (mode & 0x0100) {
! 		printf("Full Duplex\n");
! 		priv->tlanFullDuplex = TRUE;
! 	} else if (!(mode & 0x0080) && (mode & 0x0040)) {
! 		priv->tlanFullDuplex = TRUE;
! 		printf("Full Duplex\n");
  	}
  
! 	if ((!(mode & 0x0180))
! 	    && (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_USE_INTERN_10)
! 	    && (priv->phyNum != 0)) {
! 		priv->phyNum = 0;
! 		data =
! 		    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN |
! 		    TLAN_NET_CFG_PHY_EN;
! 		TLan_DioWrite16(BASE, TLAN_NET_CONFIG, data);
! 		/* TLan_SetTimer( nic, (400*HZ/1000), TLAN_TIMER_PHY_PDOWN ); */
! 		mdelay(400);
! 		TLan_PhyPowerDown(nic);
! 		return;
  	}
  
! 	if (priv->phyNum == 0) {
! 		if ((priv->duplex == TLAN_DUPLEX_FULL)
! 		    || (an_adv & an_lpa & 0x0040)) {
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL,
! 					 MII_GC_AUTOENB | MII_GC_DUPLEX);
! 			printf
! 			    ("TLAN:  Starting internal PHY with FULL-DUPLEX\n");
! 		} else {
! 			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL,
! 					 MII_GC_AUTOENB);
! 			printf
! 			    ("TLAN:  Starting internal PHY with HALF-DUPLEX\n");
  		}
  	}
  
! 	/* Wait for 100 ms.  No reason in partiticular.
! 	 */
! 	/* TLan_SetTimer( dev, (HZ/10), TLAN_TIMER_FINISH_RESET ); */
! 	mdelay(100);
! 	TLan_FinishReset(nic);
  
! }				/* TLan_PhyFinishAutoNeg */
! 
! #ifdef MONITOR
! 
! 	/*********************************************************************
!         *
!         *      TLan_phyMonitor
!         *
!         *      Returns:
!         *              None
!         *
!         *      Params:
!         *              dev             The device structure of this device.
!         *
!         *
!         *      This function monitors PHY condition by reading the status
!         *      register via the MII bus. This can be used to give info
!         *      about link changes (up/down), and possible switch to alternate
!         *      media.
!         *
!         * ******************************************************************/
  
! void TLan_PhyMonitor(struct net_device *dev)
  {
! 	TLanPrivateInfo *priv = dev->priv;
! 	u16 phy;
! 	u16 phy_status;
  
! 	phy = priv->phy[priv->phyNum];
! 
! 	/* Get PHY status register */
! 	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &phy_status);
! 
! 	/* Check if link has been lost */
! 	if (!(phy_status & MII_GS_LINK)) {
! 		if (priv->link) {
! 			priv->link = 0;
! 			printf("TLAN: %s has lost link\n", priv->nic_name);
! 			priv->flags &= ~IFF_RUNNING;
! 			mdelay(2000);
! 			TLan_PhyMonitor(nic);
! 			/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT ); */
! 			return;
! 		}
  	}
  
! 	/* Link restablished? */
! 	if ((phy_status & MII_GS_LINK) && !priv->link) {
! 		priv->link = 1;
! 		printf("TLAN: %s has reestablished link\n",
! 		       priv->nic_name);
! 		priv->flags |= IFF_RUNNING;
! 	}
! 
! 	/* Setup a new monitor */
! 	/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT ); */
! 	mdelay(2000);
! 	TLan_PhyMonitor(nic);
! }
  
+ #endif				/* MONITOR */
+ 
+ #ifdef EB51
+ static struct pci_id tlan_nics[] = {
+ 	PCI_ROM(0x0e11, 0xae34, "netel10", "Compaq Netelligent 10 T PCI UTP"),
+ 	PCI_ROM(0x0e11, 0xae32, "netel100","Compaq Netelligent 10/100 TX PCI UTP"),
+ 	PCI_ROM(0x0e11, 0xae35, "netflex3i", "Compaq Integrated NetFlex-3/P"),
+ 	PCI_ROM(0x0e11, 0xf130, "thunder", "Compaq NetFlex-3/P"),
+ 	PCI_ROM(0x0e11, 0xf150, "netflex3b", "Compaq NetFlex-3/P"),
+ 	PCI_ROM(0x0e11, 0xae43, "netel100pi", "Compaq Netelligent Integrated 10/100 TX UTP"),
+ 	PCI_ROM(0x0e11, 0xae40, "netel100d", "Compaq Netelligent Dual 10/100 TX PCI UTP"),
+ 	PCI_ROM(0x0e11, 0xb011, "netel100i", "Compaq Netelligent 10/100 TX Embedded UTP"),
+ 	PCI_ROM(0x108d, 0x0013, "oc2183", "Olicom OC-2183/2185"),
+ 	PCI_ROM(0x108d, 0x0012, "oc2325", "Olicom OC-2325"),
+ 	PCI_ROM(0x108d, 0x0014, "oc2326", "Olicom OC-2326"),
+ 	PCI_ROM(0x0e11, 0xb030, "netelligent_10_100_ws_5100", "Compaq Netelligent 10/100 TX UTP"),
+ 	PCI_ROM(0x0e11, 0xb012, "netelligent_10_t2", "Compaq Netelligent 10 T/2 PCI UTP/Coax"),
+ };
+ 
+ struct pci_driver tlan_driver = {
+ 	.type = NIC_DRIVER,
+ 	.name = "TLAN/PCI",
+ 	.probe = tlan_probe,
+ 	.ids = tlan_nics,
+ 	.id_count = sizeof(tlan_nics) / sizeof(tlan_nics[0]),
+ 	.class = 0,
+ };
  #endif
diff -rc2P -x CVS GRUB_0.94/netboot/tlan.h GRUB/netboot/tlan.h
*** GRUB_0.94/netboot/tlan.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/tlan.h	2003-11-04 05:24:55.000000000 +0800
***************
*** 0 ****
--- 1,540 ----
+ /**************************************************************************
+ *
+ *    tlan.c -- Etherboot device driver for the Texas Instruments ThunderLAN
+ *    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Portions of this code (almost all) based on:
+ *               tlan.c: Linux ThunderLan Driver:
+ *
+ *				by James Banks
+ *
+ *  				(C) 1997-1998 Caldera, Inc.
+ *			  	(C) 1998 James Banks
+ *				(C) 1999-2001 Torben Mathiasen
+ *				(C) 2002 Samuel Chessman
+ *
+ *    $Revision$
+ *    $Author$
+ *    $Date 2003/07/18 $
+ *
+ *    REVISION HISTORY:
+ *    ================
+ *    v1.0	07-08-2003	timlegge	Initial not quite working version
+ *
+ * Indent Style: indent -kr -i8
+ ***************************************************************************/
+ 
+ /*
+ #include <asm/io.h>
+ #include <asm/types.h>
+ #include <linux/netdevice.h>
+ */
+ 
+ typedef unsigned char u8;
+ typedef signed char s8;
+ typedef unsigned short u16;
+ typedef signed short s16;
+ typedef unsigned int u32;
+ typedef signed int s32;
+ 	/*****************************************************************
+ 	 * TLan Definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define FALSE			0
+ #define TRUE			1
+ 
+ #define TLAN_MIN_FRAME_SIZE	64
+ #define TLAN_MAX_FRAME_SIZE	1600
+ 
+ #define TLAN_NUM_RX_LISTS	4
+ #define TLAN_NUM_TX_LISTS	2
+ 
+ #define TLAN_IGNORE		0
+ #define TLAN_RECORD		1
+ /*
+ #define TLAN_DBG(lvl, format, args...)	if (debug&lvl) printf("TLAN: " format, ##args );
+ */
+ #define TLAN_DEBUG_GNRL		0x0001
+ #define TLAN_DEBUG_TX		0x0002
+ #define TLAN_DEBUG_RX		0x0004
+ #define TLAN_DEBUG_LIST		0x0008
+ #define TLAN_DEBUG_PROBE	0x0010
+ 
+ #define TX_TIMEOUT		(10*HZ)	/* We need time for auto-neg */
+ #define MAX_TLAN_BOARDS		8	/* Max number of boards installed at a time */
+ 
+ 
+ 	/*****************************************************************
+ 	 * Device Identification Definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define PCI_DEVICE_ID_NETELLIGENT_10_T2			0xB012
+ #define PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100	0xB030
+ #ifndef PCI_DEVICE_ID_OLICOM_OC2183
+ #define PCI_DEVICE_ID_OLICOM_OC2183			0x0013
+ #endif
+ #ifndef PCI_DEVICE_ID_OLICOM_OC2325
+ #define PCI_DEVICE_ID_OLICOM_OC2325			0x0012
+ #endif
+ #ifndef PCI_DEVICE_ID_OLICOM_OC2326
+ #define PCI_DEVICE_ID_OLICOM_OC2326			0x0014
+ #endif
+ 
+ typedef struct tlan_adapter_entry {
+ 	u16 vendorId;
+ 	u16 deviceId;
+ 	char *deviceLabel;
+ 	u32 flags;
+ 	u16 addrOfs;
+ } TLanAdapterEntry;
+ 
+ #define TLAN_ADAPTER_NONE		0x00000000
+ #define TLAN_ADAPTER_UNMANAGED_PHY	0x00000001
+ #define TLAN_ADAPTER_BIT_RATE_PHY	0x00000002
+ #define TLAN_ADAPTER_USE_INTERN_10	0x00000004
+ #define TLAN_ADAPTER_ACTIVITY_LED	0x00000008
+ 
+ #define TLAN_SPEED_DEFAULT	0
+ #define TLAN_SPEED_10		10
+ #define TLAN_SPEED_100		100
+ 
+ #define TLAN_DUPLEX_DEFAULT	0
+ #define TLAN_DUPLEX_HALF	1
+ #define TLAN_DUPLEX_FULL	2
+ 
+ 
+ 
+ 	/*****************************************************************
+ 	 * EISA Definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define EISA_ID      0xc80	/* EISA ID Registers */
+ #define EISA_ID0     0xc80	/* EISA ID Register 0 */
+ #define EISA_ID1     0xc81	/* EISA ID Register 1 */
+ #define EISA_ID2     0xc82	/* EISA ID Register 2 */
+ #define EISA_ID3     0xc83	/* EISA ID Register 3 */
+ #define EISA_CR      0xc84	/* EISA Control Register */
+ #define EISA_REG0    0xc88	/* EISA Configuration Register 0 */
+ #define EISA_REG1    0xc89	/* EISA Configuration Register 1 */
+ #define EISA_REG2    0xc8a	/* EISA Configuration Register 2 */
+ #define EISA_REG3    0xc8f	/* EISA Configuration Register 3 */
+ #define EISA_APROM   0xc90	/* Ethernet Address PROM */
+ 
+ 
+ 
+ 	/*****************************************************************
+ 	 * Rx/Tx List Definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define TLAN_BUFFERS_PER_LIST	10
+ #define TLAN_LAST_BUFFER	0x80000000
+ #define TLAN_CSTAT_UNUSED	0x8000
+ #define TLAN_CSTAT_FRM_CMP	0x4000
+ #define TLAN_CSTAT_READY	0x3000
+ #define TLAN_CSTAT_EOC		0x0800
+ #define TLAN_CSTAT_RX_ERROR	0x0400
+ #define TLAN_CSTAT_PASS_CRC	0x0200
+ #define TLAN_CSTAT_DP_PR	0x0100
+ 
+ 
+ 
+ 
+ 
+ 
+ 	/*****************************************************************
+ 	 * PHY definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define TLAN_PHY_MAX_ADDR	0x1F
+ #define TLAN_PHY_NONE		0x20
+ 
+ 
+ 
+ 	/*****************************************************************
+ 	 * TLan Driver Timer Definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define TLAN_TIMER_LINK_BEAT		1
+ #define TLAN_TIMER_ACTIVITY		2
+ #define TLAN_TIMER_PHY_PDOWN		3
+ #define TLAN_TIMER_PHY_PUP		4
+ #define TLAN_TIMER_PHY_RESET		5
+ #define TLAN_TIMER_PHY_START_LINK	6
+ #define TLAN_TIMER_PHY_FINISH_AN	7
+ #define TLAN_TIMER_FINISH_RESET		8
+ 
+ #define TLAN_TIMER_ACT_DELAY		(HZ/10)
+ 
+ 
+ 
+ 
+ 	/*****************************************************************
+ 	 * TLan Driver Eeprom Definitions
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define TLAN_EEPROM_ACK		0
+ #define TLAN_EEPROM_STOP	1
+ 
+ 
+ 
+ 
+ 	/*****************************************************************
+ 	 * Host Register Offsets and Contents
+ 	 *
+ 	 ****************************************************************/
+ 
+ #define TLAN_HOST_CMD			0x00
+ #define 	TLAN_HC_GO		0x80000000
+ #define		TLAN_HC_STOP		0x40000000
+ #define		TLAN_HC_ACK		0x20000000
+ #define		TLAN_HC_CS_MASK		0x1FE00000
+ #define		TLAN_HC_EOC		0x00100000
+ #define		TLAN_HC_RT		0x00080000
+ #define		TLAN_HC_NES		0x00040000
+ #define		TLAN_HC_AD_RST		0x00008000
+ #define		TLAN_HC_LD_TMR		0x00004000
+ #define		TLAN_HC_LD_THR		0x00002000
+ #define		TLAN_HC_REQ_INT		0x00001000
+ #define		TLAN_HC_INT_OFF		0x00000800
+ #define		TLAN_HC_INT_ON		0x00000400
+ #define		TLAN_HC_AC_MASK		0x000000FF
+ #define TLAN_CH_PARM			0x04
+ #define TLAN_DIO_ADR			0x08
+ #define		TLAN_DA_ADR_INC		0x8000
+ #define		TLAN_DA_RAM_ADR		0x4000
+ #define TLAN_HOST_INT			0x0A
+ #define		TLAN_HI_IV_MASK		0x1FE0
+ #define		TLAN_HI_IT_MASK		0x001C
+ #define TLAN_DIO_DATA			0x0C
+ 
+ 
+ /* ThunderLAN Internal Register DIO Offsets */
+ 
+ #define TLAN_NET_CMD			0x00
+ #define		TLAN_NET_CMD_NRESET	0x80
+ #define		TLAN_NET_CMD_NWRAP	0x40
+ #define		TLAN_NET_CMD_CSF	0x20
+ #define		TLAN_NET_CMD_CAF	0x10
+ #define		TLAN_NET_CMD_NOBRX	0x08
+ #define		TLAN_NET_CMD_DUPLEX	0x04
+ #define		TLAN_NET_CMD_TRFRAM	0x02
+ #define		TLAN_NET_CMD_TXPACE	0x01
+ #define TLAN_NET_SIO			0x01
+ #define 	TLAN_NET_SIO_MINTEN	0x80
+ #define		TLAN_NET_SIO_ECLOK	0x40
+ #define		TLAN_NET_SIO_ETXEN	0x20
+ #define		TLAN_NET_SIO_EDATA	0x10
+ #define		TLAN_NET_SIO_NMRST	0x08
+ #define		TLAN_NET_SIO_MCLK	0x04
+ #define		TLAN_NET_SIO_MTXEN	0x02
+ #define		TLAN_NET_SIO_MDATA	0x01
+ #define TLAN_NET_STS			0x02
+ #define		TLAN_NET_STS_MIRQ	0x80
+ #define		TLAN_NET_STS_HBEAT	0x40
+ #define		TLAN_NET_STS_TXSTOP	0x20
+ #define		TLAN_NET_STS_RXSTOP	0x10
+ #define		TLAN_NET_STS_RSRVD	0x0F
+ #define TLAN_NET_MASK			0x03
+ #define		TLAN_NET_MASK_MASK7	0x80
+ #define		TLAN_NET_MASK_MASK6	0x40
+ #define		TLAN_NET_MASK_MASK5	0x20
+ #define		TLAN_NET_MASK_MASK4	0x10
+ #define		TLAN_NET_MASK_RSRVD	0x0F
+ #define TLAN_NET_CONFIG			0x04
+ #define 	TLAN_NET_CFG_RCLK	0x8000
+ #define		TLAN_NET_CFG_TCLK	0x4000
+ #define		TLAN_NET_CFG_BIT	0x2000
+ #define		TLAN_NET_CFG_RXCRC	0x1000
+ #define		TLAN_NET_CFG_PEF	0x0800
+ #define		TLAN_NET_CFG_1FRAG	0x0400
+ #define		TLAN_NET_CFG_1CHAN	0x0200
+ #define		TLAN_NET_CFG_MTEST	0x0100
+ #define		TLAN_NET_CFG_PHY_EN	0x0080
+ #define		TLAN_NET_CFG_MSMASK	0x007F
+ #define TLAN_MAN_TEST			0x06
+ #define TLAN_DEF_VENDOR_ID		0x08
+ #define TLAN_DEF_DEVICE_ID		0x0A
+ #define TLAN_DEF_REVISION		0x0C
+ #define TLAN_DEF_SUBCLASS		0x0D
+ #define TLAN_DEF_MIN_LAT		0x0E
+ #define TLAN_DEF_MAX_LAT		0x0F
+ #define TLAN_AREG_0			0x10
+ #define TLAN_AREG_1			0x16
+ #define TLAN_AREG_2			0x1C
+ #define TLAN_AREG_3			0x22
+ #define TLAN_HASH_1			0x28
+ #define TLAN_HASH_2			0x2C
+ #define TLAN_GOOD_TX_FRMS		0x30
+ #define TLAN_TX_UNDERUNS		0x33
+ #define TLAN_GOOD_RX_FRMS		0x34
+ #define TLAN_RX_OVERRUNS		0x37
+ #define TLAN_DEFERRED_TX		0x38
+ #define TLAN_CRC_ERRORS			0x3A
+ #define TLAN_CODE_ERRORS		0x3B
+ #define TLAN_MULTICOL_FRMS		0x3C
+ #define TLAN_SINGLECOL_FRMS		0x3E
+ #define TLAN_EXCESSCOL_FRMS		0x40
+ #define TLAN_LATE_COLS			0x41
+ #define TLAN_CARRIER_LOSS		0x42
+ #define TLAN_ACOMMIT			0x43
+ #define TLAN_LED_REG			0x44
+ #define		TLAN_LED_ACT		0x10
+ #define		TLAN_LED_LINK		0x01
+ #define TLAN_BSIZE_REG			0x45
+ #define TLAN_MAX_RX			0x46
+ #define TLAN_INT_DIS			0x48
+ #define		TLAN_ID_TX_EOC		0x04
+ #define		TLAN_ID_RX_EOF		0x02
+ #define		TLAN_ID_RX_EOC		0x01
+ 
+ 
+ 
+ /* ThunderLAN Interrupt Codes */
+ 
+ #define TLAN_INT_NUMBER_OF_INTS	8
+ 
+ #define TLAN_INT_NONE			0x0000
+ #define TLAN_INT_TX_EOF			0x0001
+ #define TLAN_INT_STAT_OVERFLOW		0x0002
+ #define TLAN_INT_RX_EOF			0x0003
+ #define TLAN_INT_DUMMY			0x0004
+ #define TLAN_INT_TX_EOC			0x0005
+ #define TLAN_INT_STATUS_CHECK		0x0006
+ #define TLAN_INT_RX_EOC			0x0007
+ 
+ 
+ 
+ /* ThunderLAN MII Registers */
+ 
+ /* Generic MII/PHY Registers */
+ 
+ #define MII_GEN_CTL			0x00
+ #define 	MII_GC_RESET		0x8000
+ #define		MII_GC_LOOPBK		0x4000
+ #define		MII_GC_SPEEDSEL		0x2000
+ #define		MII_GC_AUTOENB		0x1000
+ #define		MII_GC_PDOWN		0x0800
+ #define		MII_GC_ISOLATE		0x0400
+ #define		MII_GC_AUTORSRT		0x0200
+ #define		MII_GC_DUPLEX		0x0100
+ #define		MII_GC_COLTEST		0x0080
+ #define		MII_GC_RESERVED		0x007F
+ #define MII_GEN_STS			0x01
+ #define		MII_GS_100BT4		0x8000
+ #define		MII_GS_100BTXFD		0x4000
+ #define		MII_GS_100BTXHD		0x2000
+ #define		MII_GS_10BTFD		0x1000
+ #define		MII_GS_10BTHD		0x0800
+ #define		MII_GS_RESERVED		0x07C0
+ #define		MII_GS_AUTOCMPLT	0x0020
+ #define		MII_GS_RFLT		0x0010
+ #define		MII_GS_AUTONEG		0x0008
+ #define		MII_GS_LINK		0x0004
+ #define		MII_GS_JABBER		0x0002
+ #define		MII_GS_EXTCAP		0x0001
+ #define MII_GEN_ID_HI			0x02
+ #define MII_GEN_ID_LO			0x03
+ #define 	MII_GIL_OUI		0xFC00
+ #define 	MII_GIL_MODEL		0x03F0
+ #define 	MII_GIL_REVISION	0x000F
+ #define MII_AN_ADV			0x04
+ #define MII_AN_LPA			0x05
+ #define MII_AN_EXP			0x06
+ 
+ /* ThunderLAN Specific MII/PHY Registers */
+ 
+ #define TLAN_TLPHY_ID			0x10
+ #define TLAN_TLPHY_CTL			0x11
+ #define 	TLAN_TC_IGLINK		0x8000
+ #define		TLAN_TC_SWAPOL		0x4000
+ #define		TLAN_TC_AUISEL		0x2000
+ #define		TLAN_TC_SQEEN		0x1000
+ #define		TLAN_TC_MTEST		0x0800
+ #define		TLAN_TC_RESERVED	0x07F8
+ #define		TLAN_TC_NFEW		0x0004
+ #define		TLAN_TC_INTEN		0x0002
+ #define		TLAN_TC_TINT		0x0001
+ #define TLAN_TLPHY_STS			0x12
+ #define		TLAN_TS_MINT		0x8000
+ #define		TLAN_TS_PHOK		0x4000
+ #define		TLAN_TS_POLOK		0x2000
+ #define		TLAN_TS_TPENERGY	0x1000
+ #define		TLAN_TS_RESERVED	0x0FFF
+ #define TLAN_TLPHY_PAR			0x19
+ #define		TLAN_PHY_CIM_STAT	0x0020
+ #define		TLAN_PHY_SPEED_100	0x0040
+ #define		TLAN_PHY_DUPLEX_FULL	0x0080
+ #define		TLAN_PHY_AN_EN_STAT     0x0400
+ 
+ /* National Sem. & Level1 PHY id's */
+ #define NAT_SEM_ID1			0x2000
+ #define NAT_SEM_ID2			0x5C01
+ #define LEVEL1_ID1			0x7810
+ #define LEVEL1_ID2			0x0000
+ 
+ #define CIRC_INC( a, b ) if ( ++a >= b ) a = 0
+ 
+ /* Routines to access internal registers. */
+ 
+ inline u8 TLan_DioRead8(u16 base_addr, u16 internal_addr)
+ {
+ 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+ 	return (inb((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x3)));
+ 
+ }				/* TLan_DioRead8 */
+ 
+ 
+ 
+ 
+ inline u16 TLan_DioRead16(u16 base_addr, u16 internal_addr)
+ {
+ 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+ 	return (inw((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x2)));
+ 
+ }				/* TLan_DioRead16 */
+ 
+ 
+ 
+ 
+ inline u32 TLan_DioRead32(u16 base_addr, u16 internal_addr)
+ {
+ 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+ 	return (inl(base_addr + TLAN_DIO_DATA));
+ 
+ }				/* TLan_DioRead32 */
+ 
+ 
+ 
+ 
+ inline void TLan_DioWrite8(u16 base_addr, u16 internal_addr, u8 data)
+ {
+ 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+ 	outb(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x3));
+ 
+ }
+ 
+ 
+ 
+ 
+ inline void TLan_DioWrite16(u16 base_addr, u16 internal_addr, u16 data)
+ {
+ 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+ 	outw(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+ 
+ }
+ 
+ 
+ 
+ 
+ inline void TLan_DioWrite32(u16 base_addr, u16 internal_addr, u32 data)
+ {
+ 	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+ 	outl(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+ 
+ }
+ 
+ 
+ 
+ #if 0
+ inline void TLan_ClearBit(u8 bit, u16 port)
+ {
+ 	outb_p(inb_p(port) & ~bit, port);
+ }
+ 
+ 
+ 
+ 
+ inline int TLan_GetBit(u8 bit, u16 port)
+ {
+ 	return ((int) (inb_p(port) & bit));
+ }
+ 
+ 
+ 
+ 
+ inline void TLan_SetBit(u8 bit, u16 port)
+ {
+ 	outb_p(inb_p(port) | bit, port);
+ }
+ #endif
+ 
+ #define TLan_ClearBit( bit, port )	outb_p(inb_p(port) & ~bit, port)
+ #define TLan_GetBit( bit, port )	((int) (inb_p(port) & bit))
+ #define TLan_SetBit( bit, port )	outb_p(inb_p(port) | bit, port)
+ 
+ #ifdef I_LIKE_A_FAST_HASH_FUNCTION
+ /* given 6 bytes, view them as 8 6-bit numbers and return the XOR of those */
+ /* the code below is about seven times as fast as the original code */
+ inline u32 TLan_HashFunc(u8 * a)
+ {
+ 	u8 hash;
+ 
+ 	hash = (a[0] ^ a[3]);	/* & 077 */
+ 	hash ^= ((a[0] ^ a[3]) >> 6);	/* & 003 */
+ 	hash ^= ((a[1] ^ a[4]) << 2);	/* & 074 */
+ 	hash ^= ((a[1] ^ a[4]) >> 4);	/* & 017 */
+ 	hash ^= ((a[2] ^ a[5]) << 4);	/* & 060 */
+ 	hash ^= ((a[2] ^ a[5]) >> 2);	/* & 077 */
+ 
+ 	return (hash & 077);
+ }
+ 
+ #else				/* original code */
+ 
+ inline u32 xor(u32 a, u32 b)
+ {
+ 	return ((a && !b) || (!a && b));
+ }
+ 
+ #define XOR8( a, b, c, d, e, f, g, h )	xor( a, xor( b, xor( c, xor( d, xor( e, xor( f, xor( g, h ) ) ) ) ) ) )
+ #define DA( a, bit )					( ( (u8) a[bit/8] ) & ( (u8) ( 1 << bit%8 ) ) )
+ 
+ inline u32 TLan_HashFunc(u8 * a)
+ {
+ 	u32 hash;
+ 
+ 	hash =
+ 	    XOR8(DA(a, 0), DA(a, 6), DA(a, 12), DA(a, 18), DA(a, 24),
+ 		 DA(a, 30), DA(a, 36), DA(a, 42));
+ 	hash |=
+ 	    XOR8(DA(a, 1), DA(a, 7), DA(a, 13), DA(a, 19), DA(a, 25),
+ 		 DA(a, 31), DA(a, 37), DA(a, 43)) << 1;
+ 	hash |=
+ 	    XOR8(DA(a, 2), DA(a, 8), DA(a, 14), DA(a, 20), DA(a, 26),
+ 		 DA(a, 32), DA(a, 38), DA(a, 44)) << 2;
+ 	hash |=
+ 	    XOR8(DA(a, 3), DA(a, 9), DA(a, 15), DA(a, 21), DA(a, 27),
+ 		 DA(a, 33), DA(a, 39), DA(a, 45)) << 3;
+ 	hash |=
+ 	    XOR8(DA(a, 4), DA(a, 10), DA(a, 16), DA(a, 22), DA(a, 28),
+ 		 DA(a, 34), DA(a, 40), DA(a, 46)) << 4;
+ 	hash |=
+ 	    XOR8(DA(a, 5), DA(a, 11), DA(a, 17), DA(a, 23), DA(a, 29),
+ 		 DA(a, 35), DA(a, 41), DA(a, 47)) << 5;
+ 
+ 	return hash;
+ 
+ }
+ 
+ #endif				/* I_LIKE_A_FAST_HASH_FUNCTION */
diff -rc2P -x CVS GRUB_0.94/netboot/tulip.c GRUB/netboot/tulip.c
*** GRUB_0.94/netboot/tulip.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/tulip.c	2003-11-08 22:47:39.000000000 +0800
***************
*** 49,52 ****
--- 49,53 ----
  
  /*
+   07 Sep 2003  timlegge	Multicast Support Added
    11 Apr 2001  mdc     [patch to etherboot 4.7.24]
       Major rewrite to include Linux tulip driver media detection
***************
*** 107,135 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  
  /* User settable parameters */
  
! #undef   TULIP_DEBUG
! #undef   TULIP_DEBUG_WHERE
  static int tulip_debug = 2;             /* 1 normal messages, 0 quiet .. 7 verbose. */
  
  #define TX_TIME_OUT       2*TICKS_PER_SEC
  
! typedef unsigned char  u8;
! typedef   signed char  s8;
! typedef unsigned short u16;
! typedef   signed short s16;
! typedef unsigned int   u32;
! typedef   signed int   s32;
  
  /* helpful macros if on a big_endian machine for changing byte order.
     not strictly needed on Intel */
- #define le16_to_cpu(val) (val)
- #define cpu_to_le32(val) (val)
  #define get_unaligned(ptr) (*(ptr))
  #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
  #define get_u16(ptr) (*(u16 *)(ptr))
- #define virt_to_bus(x) ((unsigned long)x)
  #define virt_to_le32desc(addr)  virt_to_bus(addr)
  
--- 108,134 ----
  #include "nic.h"
  #include "pci.h"
  
  /* User settable parameters */
  
! #undef	TULIP_DEBUG
! #undef	TULIP_DEBUG_WHERE
! #ifdef	TULIP_DEBUG
  static int tulip_debug = 2;             /* 1 normal messages, 0 quiet .. 7 verbose. */
+ #endif
  
  #define TX_TIME_OUT       2*TICKS_PER_SEC
  
! typedef uint8_t    u8;
! typedef  int8_t    s8;
! typedef uint16_t   u16;
! typedef  int16_t   s16;
! typedef uint32_t   u32;
! typedef  int32_t   s32;
  
  /* helpful macros if on a big_endian machine for changing byte order.
     not strictly needed on Intel */
  #define get_unaligned(ptr) (*(ptr))
  #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
  #define get_u16(ptr) (*(u16 *)(ptr))
  #define virt_to_le32desc(addr)  virt_to_bus(addr)
  
***************
*** 213,216 ****
--- 212,217 ----
      { "ADMtek AN981 Comet", { 0x09811317, 0xffffffff, 0, 0, 0, 0 },
        TULIP_IOTYPE, 256, COMET },
+     { "ADMTek AN983 Comet", { 0x12161113, 0xffffffff, 0, 0, 0, 0 },
+       TULIP_IOTYPE, 256, COMET },
      { "ADMtek Centaur-P", { 0x09851317, 0xffffffff, 0, 0, 0, 0 },
        TULIP_IOTYPE, 256, COMET },
***************
*** 281,287 ****
--- 282,292 ----
  static u16 t21041_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
  
+ /* not used
  static u16 t21142_csr13[] = { 0x0001, 0x0009, 0x0009, 0x0000, 0x0001, };
+ */
  static u16 t21142_csr14[] = { 0xFFFF, 0x0705, 0x0705, 0x0000, 0x7F3D, };
+ /* not used
  static u16 t21142_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
+ */
  
  /* Offsets to the Command and Status Registers, "CSRs".  All accesses
***************
*** 301,304 ****
--- 306,317 ----
  };
  
+ /* The configuration bits in CSR6. */
+ enum csr6_mode_bits {
+ 	TxOn=0x2000, RxOn=0x0002, FullDuplex=0x0200,
+ 	AcceptBroadcast=0x0100, AcceptAllMulticast=0x0080,
+ 	AcceptAllPhys=0x0040, AcceptRunt=0x0008,
+ };
+ 
+ 
  enum desc_status_bits {
      DescOwnded=0x80000000, RxDescFatalErr=0x8000, RxWholePkt=0x0300,
***************
*** 385,403 ****
  #define TX_RING_SIZE	2
  static struct tulip_tx_desc tx_ring[TX_RING_SIZE] __attribute__ ((aligned(4)));
- 
- #ifdef USE_LOWMEM_BUFFER
- #define txb ((char *)0x10000 - BUFLEN)
- #else
  static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
- #endif
  
  #define RX_RING_SIZE	4
  static struct tulip_rx_desc rx_ring[RX_RING_SIZE] __attribute__ ((aligned(4)));
- 
- #ifdef USE_LOWMEM_BUFFER
- #define rxb ((char *)0x10000 - RX_RING_SIZE * BUFLEN - BUFLEN)
- #else
  static unsigned char rxb[RX_RING_SIZE * BUFLEN] __attribute__ ((aligned(4)));
- #endif
  
  static struct tulip_private {
--- 398,406 ----
***************
*** 480,485 ****
  static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
  static void parse_eeprom(struct nic *nic);
! struct nic *tulip_probe(struct nic *nic, unsigned short *io_addrs,
!                         struct pci_device *pci);
  static void tulip_init_ring(struct nic *nic);
  static void tulip_reset(struct nic *nic);
--- 483,487 ----
  static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
  static void parse_eeprom(struct nic *nic);
! static int tulip_probe(struct dev *dev, struct pci_device *pci);
  static void tulip_init_ring(struct nic *nic);
  static void tulip_reset(struct nic *nic);
***************
*** 487,491 ****
                             unsigned int s, const char *p);
  static int tulip_poll(struct nic *nic);
! static void tulip_disable(struct nic *nic);
  static void nway_start(struct nic *nic);
  static void pnic_do_nway(struct nic *nic);
--- 489,493 ----
                             unsigned int s, const char *p);
  static int tulip_poll(struct nic *nic);
! static void tulip_disable(struct dev *dev);
  static void nway_start(struct nic *nic);
  static void pnic_do_nway(struct nic *nic);
***************
*** 566,570 ****
     for details. */
  
! int mdio_read(struct nic *nic, int phy_id, int location)
  {
      int i;
--- 568,572 ----
     for details. */
  
! int mdio_read(struct nic *nic __unused, int phy_id, int location)
  {
      int i;
***************
*** 627,631 ****
  }
  
! void mdio_write(struct nic *nic, int phy_id, int location, int value)
  {
      int i;
--- 629,633 ----
  }
  
! void mdio_write(struct nic *nic __unused, int phy_id, int location, int value)
  {
      int i;
***************
*** 900,904 ****
  /* tulip_init_ring - setup the tx and rx descriptors                */
  /*********************************************************************/
! static void tulip_init_ring(struct nic *nic)
  {
      int i;
--- 902,906 ----
  /* tulip_init_ring - setup the tx and rx descriptors                */
  /*********************************************************************/
! static void tulip_init_ring(struct nic *nic __unused)
  {
      int i;
***************
*** 937,940 ****
--- 939,958 ----
  }
  
+ 
+ static void set_rx_mode(struct nic *nic __unused) {
+ 	int csr6 = inl(ioaddr + CSR6) & ~0x00D5;
+ 
+ 	tp->csr6 &= ~0x00D5;
+  
+ 	/* !IFF_PROMISC */
+ 	tp->csr6 |= AcceptAllMulticast;
+ 	csr6 |= AcceptAllMulticast;
+ 
+ 	outl(csr6, ioaddr + CSR6);
+ 
+ 	
+ 	
+ }
+ 
  /*********************************************************************/
  /* eth_reset - Reset adapter                                         */
***************
*** 944,948 ****
      int i;
      unsigned long to;
-     u32 addr_low, addr_high;
  
  #ifdef TULIP_DEBUG_WHERE
--- 962,965 ----
***************
*** 957,961 ****
  	outl(0x814C0000, ioaddr + CSR6);
      }
!   
      /* Reset the chip, holding bit 0 set at least 50 PCI cycles. */
      outl(0x00000001, ioaddr + CSR0);
--- 974,978 ----
  	outl(0x814C0000, ioaddr + CSR6);
      }
!  
      /* Reset the chip, holding bit 0 set at least 50 PCI cycles. */
      outl(0x00000001, ioaddr + CSR0);
***************
*** 1023,1028 ****
  
      /* Point to rx and tx descriptors */
!     outl((unsigned long)&rx_ring[0], ioaddr + CSR3);
!     outl((unsigned long)&tx_ring[0], ioaddr + CSR4);
  
      init_media(nic);
--- 1040,1045 ----
  
      /* Point to rx and tx descriptors */
!     outl(virt_to_le32desc(&rx_ring[0]), ioaddr + CSR3);
!     outl(virt_to_le32desc(&tx_ring[0]), ioaddr + CSR4);
  
      init_media(nic);
***************
*** 1050,1053 ****
--- 1067,1072 ----
  	tulip_check_duplex(nic);
  
+     set_rx_mode(nic); 	
+         
      /* enable transmit and receive */
      outl(tp->csr6 | 0x00002002, ioaddr + CSR6);
***************
*** 1096,1100 ****
  
      /* Point to transmit descriptor */
!     outl((u32)&tx_ring[0], ioaddr + CSR4);
  
      /* Enable Tx */
--- 1115,1119 ----
  
      /* Point to transmit descriptor */
!     outl(virt_to_le32desc(&tx_ring[0]), ioaddr + CSR4);
  
      /* Enable Tx */
***************
*** 1156,1166 ****
  /* eth_disable - Disable the interface                               */
  /*********************************************************************/
! static void tulip_disable(struct nic *nic)
  {
! 
  #ifdef TULIP_DEBUG_WHERE
      whereami("tulip_disable\n");
  #endif
  
      /* disable interrupts */
      outl(0x00000000, ioaddr + CSR7);
--- 1175,1188 ----
  /* eth_disable - Disable the interface                               */
  /*********************************************************************/
! static void tulip_disable(struct dev *dev)
  {
!     struct nic *nic = (struct nic *)dev;
  #ifdef TULIP_DEBUG_WHERE
      whereami("tulip_disable\n");
  #endif
  
+     /* merge reset and disable */
+     tulip_reset(nic);
+ 
      /* disable interrupts */
      outl(0x00000000, ioaddr + CSR7);
***************
*** 1176,1183 ****
  /* eth_probe - Look for an adapter                                   */
  /*********************************************************************/
! struct nic *tulip_probe(struct nic *nic, unsigned short *io_addrs,
!                         struct pci_device *pci)
  {
!     u32 i, l1, l2;
      u8  chip_rev;
      u8 ee_data[EEPROM_SIZE];
--- 1198,1205 ----
  /* eth_probe - Look for an adapter                                   */
  /*********************************************************************/
! static int tulip_probe(struct dev *dev, struct pci_device *pci)
  {
!     struct nic *nic = (struct nic *)dev;
!     u32 i;
      u8  chip_rev;
      u8 ee_data[EEPROM_SIZE];
***************
*** 1186,1193 ****
      static unsigned char last_phys_addr[ETH_ALEN] = {0x00, 'L', 'i', 'n', 'u', 'x'};
  
!     if (io_addrs == 0 || *io_addrs == 0)
          return 0;
  
!     ioaddr         = *io_addrs;
  
      /* point to private storage */
--- 1208,1215 ----
      static unsigned char last_phys_addr[ETH_ALEN] = {0x00, 'L', 'i', 'n', 'u', 'x'};
  
!     if (pci->ioaddr == 0)
          return 0;
  
!     ioaddr         = pci->ioaddr;
  
      /* point to private storage */
***************
*** 1379,1391 ****
      tulip_reset(nic);
  
!     nic->reset    = tulip_reset;
      nic->poll     = tulip_poll;
      nic->transmit = tulip_transmit;
-     nic->disable  = tulip_disable;
  
      /* give the board a chance to reset before returning */
      tulip_wait(4*TICKS_PER_SEC);
  
!     return nic;
  }
  
--- 1401,1412 ----
      tulip_reset(nic);
  
!     dev->disable  = tulip_disable;
      nic->poll     = tulip_poll;
      nic->transmit = tulip_transmit;
  
      /* give the board a chance to reset before returning */
      tulip_wait(4*TICKS_PER_SEC);
  
!     return 1;
  }
  
***************
*** 1509,1513 ****
  }
  
! static void nway_start(struct nic *nic)
  {
      int csr14 = ((tp->sym_advertise & 0x0780) << 9)  |
--- 1530,1534 ----
  }
  
! static void nway_start(struct nic *nic __unused)
  {
      int csr14 = ((tp->sym_advertise & 0x0780) << 9)  |
***************
*** 1663,1667 ****
  }
  
! static void pnic_do_nway(struct nic *nic)
  {
      u32 phy_reg = inl(ioaddr + 0xB8);
--- 1684,1688 ----
  }
  
! static void pnic_do_nway(struct nic *nic __unused)
  {
      u32 phy_reg = inl(ioaddr + 0xB8);
***************
*** 1988,1989 ****
--- 2009,2054 ----
          return 0;
  }
+ 
+ static struct pci_id tulip_nics[] = {
+ PCI_ROM(0x1011, 0x0002, "dc21040",     "Digital Tulip"),
+ PCI_ROM(0x1011, 0x0009, "ds21140",     "Digital Tulip Fast"),
+ PCI_ROM(0x1011, 0x0014, "dc21041",     "Digital Tulip+"),
+ PCI_ROM(0x1011, 0x0019, "ds21142",     "Digital Tulip 21142"),
+ PCI_ROM(0x10d9, 0x0512, "mx98713",     "Macronix MX987x3"),
+ PCI_ROM(0x10d9, 0x0531, "mx98715",     "Macronix MX987x5"),
+ PCI_ROM(0x1113, 0x1217, "mxic-98715",  "Macronix MX987x5"),
+ PCI_ROM(0x11ad, 0xc115, "lc82c115",    "LinkSys LNE100TX"),
+ PCI_ROM(0x11ad, 0x0002, "82c168",      "Netgear FA310TX"),
+ PCI_ROM(0x1282, 0x9100, "dm9100",      "Davicom 9100"),
+ PCI_ROM(0x1282, 0x9102, "dm9102",      "Davicom 9102"),
+ PCI_ROM(0x1282, 0x9009, "dm9009",      "Davicom 9009"),
+ PCI_ROM(0x1317, 0x0985, "centaur-p",   "ADMtek Centaur-P"),
+ PCI_ROM(0x1317, 0x0981, "an981",       "ADMtek AN981 Comet"),		/* ADMTek Centaur-P (stmicro) */
+ PCI_ROM(0x1113, 0x1216, "an983",       "ADMTek AN983 Comet"),
+ PCI_ROM(0x1317, 0x9511, "an983b",      "ADMTek Comet 983b"),
+ PCI_ROM(0x1317, 0x1985, "centaur-c",   "ADMTek Centaur-C"),
+ PCI_ROM(0x8086, 0x0039, "intel21145",  "Intel Tulip"),
+ PCI_ROM(0x125b, 0x1400, "ax88140",     "ASIX AX88140"),
+ PCI_ROM(0x11f6, 0x9881, "rl100tx",     "Compex RL100-TX"),
+ PCI_ROM(0x115d, 0x0003, "xircomtulip", "Xircom Tulip"),
+ PCI_ROM(0x104a, 0x0981, "tulip-0981",  "Tulip 0x104a 0x0981"),
+ PCI_ROM(0x104a, 0x2774, "tulip-2774",  "Tulip 0x104a 0x2774"),
+ PCI_ROM(0x1113, 0x9511, "tulip-9511",  "Tulip 0x1113 0x9511"),
+ PCI_ROM(0x1186, 0x1561, "tulip-1561",  "Tulip 0x1186 0x1561"),
+ PCI_ROM(0x1259, 0xa120, "tulip-a120",  "Tulip 0x1259 0xa120"),
+ PCI_ROM(0x13d1, 0xab02, "tulip-ab02",  "Tulip 0x13d1 0xab02"),
+ PCI_ROM(0x13d1, 0xab03, "tulip-ab03",  "Tulip 0x13d1 0xab03"),
+ PCI_ROM(0x13d1, 0xab08, "tulip-ab08",  "Tulip 0x13d1 0xab08"),
+ PCI_ROM(0x14f1, 0x1803, "lanfinity",   "Conexant LANfinity"),
+ PCI_ROM(0x1626, 0x8410, "tulip-8410",  "Tulip 0x1626 0x8410"),
+ PCI_ROM(0x1737, 0xab09, "tulip-ab09",  "Tulip 0x1737 0xab09"),
+ };
+ 
+ struct pci_driver tulip_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "Tulip",
+ 	.probe    = tulip_probe,
+ 	.ids      = tulip_nics,
+ 	.id_count = sizeof(tulip_nics)/sizeof(tulip_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/netboot/types.h GRUB/netboot/types.h
*** GRUB_0.94/netboot/types.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/types.h	2003-11-11 21:38:02.000000000 +0800
***************
*** 0 ****
--- 1,11 ----
+ #ifndef _TYPES_H
+ #define _TYPES_H
+ 
+ /* I'm architecture independed */
+ 
+ 
+ /* 
+  * It's architecture depended headers for common integer types
+  */
+ #include "stdint.h"
+ #endif /* _TYPES_H */
diff -rc2P -x CVS GRUB_0.94/netboot/udp.h GRUB/netboot/udp.h
*** GRUB_0.94/netboot/udp.h	1970-01-01 08:00:00.000000000 +0800
--- GRUB/netboot/udp.h	2003-11-07 22:35:16.000000000 +0800
***************
*** 0 ****
--- 1,30 ----
+ #ifndef	_UDP_H
+ #define	_UDP_H
+ 
+ /* We need 'uint16_t' and 'uint8_t'  */
+ #include "types.h"
+ /* We need 'in_addr' */
+ #include "in.h"
+ 
+ struct udp_pseudo_hdr {
+ 	in_addr  src;
+ 	in_addr  dest;
+ 	uint8_t  unused;
+ 	uint8_t  protocol;
+ 	uint16_t len;
+ };
+ struct udphdr {
+ 	uint16_t src;
+ 	uint16_t dest;
+ 	uint16_t len;
+ 	uint16_t chksum;
+ };
+ 
+ extern void build_udp_hdr(unsigned long __destip, unsigned int __srcsock, 
+ 	      unsigned int __destsock, int __ttl, int __len, 
+ 	      const void * __buf);
+ 
+ extern int udp_transmit(unsigned long __destip, unsigned int __srcsock,
+ 			unsigned int __destsock, int __len, const void * __buf);
+ 
+ #endif	/* _UDP_H */
diff -rc2P -x CVS GRUB_0.94/netboot/via-rhine.c GRUB/netboot/via-rhine.c
*** GRUB_0.94/netboot/via-rhine.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/via-rhine.c	2003-11-20 11:41:01.000000000 +0800
***************
*** 19,23 ****
  */
  
! static const char *version = "rhine.c v1.0.0 2000-01-07\n";
  
  /* A few user-configurable values. */
--- 19,23 ----
  */
  
! static const char *version = "rhine.c v1.0.1 2003-02-06\n";
  
  /* A few user-configurable values. */
***************
*** 47,51 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  
  /* define all ioaddr */
--- 47,50 ----
***************
*** 104,107 ****
--- 103,111 ----
  #define wTallyCntMPA			ioaddr + 0x7c
  #define wTallyCntCRC			ioaddr + 0x7d
+ #define bySTICKHW			ioaddr + 0x83
+ #define byWOLcrClr			ioaddr + 0xA4
+ #define byWOLcgClr			ioaddr + 0xA7
+ #define byPwrcsrClr			ioaddr + 0xAC
+ 
  /*---------------------  Exioaddr Definitions -------------------------*/
  
***************
*** 618,624 ****
  */
  
- #define PCI_VENDOR_ID_FET		0x1106
- #define PCI_DEVICE_ID_FET_3043		0x3043
- 
  /* The rest of these values should never change. */
  #define NUM_TX_DESC	2	/* Number of Tx descriptor registers. */
--- 622,625 ----
***************
*** 653,657 ****
  rhine;
  
! static struct nic *rhine_probe1 (struct nic *dev, int ioaddr,
  				 int chip_id, int options);
  static int QueryAuto (int);
--- 654,658 ----
  rhine;
  
! static void rhine_probe1 (struct nic *nic, int ioaddr,
  				 int chip_id, int options);
  static int QueryAuto (int);
***************
*** 660,664 ****
  static void MIIDelay (void);
  static void rhine_init_ring (struct nic *dev);
! static void rhine_disable (struct nic *nic);
  static void rhine_reset (struct nic *nic);
  static int rhine_poll (struct nic *nic);
--- 661,665 ----
  static void MIIDelay (void);
  static void rhine_init_ring (struct nic *dev);
! static void rhine_disable (struct dev *dev);
  static void rhine_reset (struct nic *nic);
  static int rhine_poll (struct nic *nic);
***************
*** 666,673 ****
  			    unsigned int s, const char *p);
  
- /* Linux support functions */
- #define virt_to_bus(x) ((unsigned long)x)
- #define bus_to_virt(x) ((void *)x)
- 
  /* Initialize the Rx and Tx rings, along with various 'dev' bits. */
  static void
--- 667,670 ----
***************
*** 855,878 ****
  }
  
! struct nic *
! rhine_probe (struct nic *nic, unsigned short *probeaddrs,
! 	       struct pci_device *pci)
  {
      if (!pci->ioaddr)
! 	return NULL;
!     nic = rhine_probe1 (nic, pci->ioaddr, 0, -1);
  
!     if (nic)
! 	adjust_pci_device(pci);
!     nic->poll = rhine_poll;
!     nic->transmit = rhine_transmit;
!     nic->reset = rhine_reset;
!     nic->disable = rhine_disable;
      rhine_reset (nic);
  
!     return nic;
  }
  
! static struct nic *
  rhine_probe1 (struct nic *nic, int ioaddr, int chip_id, int options)
  {
--- 852,887 ----
  }
  
! static int
! rhine_probe (struct dev *dev, struct pci_device *pci)
  {
+     struct nic *nic = (struct nic *)dev;
      if (!pci->ioaddr)
! 	return 0;
!     rhine_probe1 (nic, pci->ioaddr, pci->dev_id, -1);
  
!     adjust_pci_device(pci);
      rhine_reset (nic);
  
!     dev->disable  = rhine_disable;
!     nic->poll     = rhine_poll;
!     nic->transmit = rhine_transmit;
! 
!     return 1;
! }
! 
! static void set_rx_mode(struct nic *nic __unused) {
!     	struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
! 	unsigned char rx_mode;
!     	int ioaddr = tp->ioaddr;
! 
! 	/* ! IFF_PROMISC */
! 	outl(0xffffffff, byMAR0);
! 	outl(0xffffffff, byMAR4);
! 	rx_mode = 0x0C;
! 
! 	outb(0x60 /* thresh */ | rx_mode, byRCR );
  }
  
! static void
  rhine_probe1 (struct nic *nic, int ioaddr, int chip_id, int options)
  {
***************
*** 886,889 ****
--- 895,921 ----
      if (rhine_debug > 0 && did_version++ == 0)
  	printf (version);
+ 
+     /* D-Link provided reset code (with comment additions) */
+     if((chip_id != 0x3043) && (chip_id != 0x6100)) {
+ 	unsigned char byOrgValue;
+ 	
+ 	if(rhine_debug > 0)
+ 		printf("Enabling Sticky Bit Workaround for Chip_id: 0x%hX\n"
+ 				, chip_id);
+ 	/* clear sticky bit before reset & read ethernet address */
+ 	byOrgValue = inb(bySTICKHW);
+ 	byOrgValue = byOrgValue & 0xFC;
+ 	outb(byOrgValue, bySTICKHW);
+ 
+ 	/* (bits written are cleared?) */
+ 	/* disable force PME-enable */
+ 	outb(0x80, byWOLcgClr);
+ 	/* disable power-event config bit */
+ 	outb(0xFF, byWOLcrClr);
+ 	/* clear power status (undocumented in vt6102 docs?) */
+ 	outb(0xFF, byPwrcsrClr);
+ 	
+     }
+ 
      /* Perhaps this should be read from the EEPROM? */
      for (i = 0; i < ETH_ALEN; i++)
***************
*** 921,924 ****
--- 953,957 ----
  #endif
  
+     
      /* query MII to know LineSpeed,duplex mode */
      byMIIvalue = inb (ioaddr + 0x6d);
***************
*** 972,984 ****
  	    tp->medialock = 1;
      }
!     return nic;
  }
  
! static void
! rhine_disable (struct nic *nic)
  {
      struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
      int ioaddr = tp->ioaddr;
  
      printf ("rhine disable\n");
      /* Switch to loopback mode to avoid hardware races. */
--- 1005,1021 ----
  	    tp->medialock = 1;
      }
!     return;
  }
  
! static void 
! rhine_disable (struct dev *dev)
  {
+     struct nic *nic = (struct nic *)dev;
      struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
      int ioaddr = tp->ioaddr;
  
+     /* merge reset and disable */
+     rhine_reset(nic);
+ 
      printf ("rhine disable\n");
      /* Switch to loopback mode to avoid hardware races. */
***************
*** 1003,1017 ****
      int tx_bufs_tmp, tx_bufs_tmp1;
  
- #ifdef	USE_LOWMEM_BUFFER
- #define buf1 (0x10000 - (RX_RING_SIZE * PKT_BUF_SZ + 32))
- #define buf2 (buf1 - (RX_RING_SIZE * PKT_BUF_SZ + 32))
- #define desc1 (buf2 - (TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32))
- #define desc2 (desc1 - (TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32))
- #else
      static char buf1[RX_RING_SIZE * PKT_BUF_SZ + 32];
      static char buf2[RX_RING_SIZE * PKT_BUF_SZ + 32];
      static char desc1[TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32];
      static char desc2[TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32];
- #endif
  
      /* printf ("rhine_reset\n"); */
--- 1040,1047 ----
***************
*** 1070,1073 ****
--- 1100,1106 ----
      outl (virt_to_bus (tp->tx_ring), dwCurrentTxDescAddr);
  
+     /* Setup Multicast */	
+     set_rx_mode(nic);
+ 
      /* close IMR */
      outw (0x0000, byIMR0);
***************
*** 1171,1174 ****
--- 1204,1210 ----
  
      outb (CR1bak, byCR1);
+     /* Wait until transmit is finished */
+     while (tp->tx_ring[entry].tx_status.bits.own_bit != 0)
+ 	;
      tp->cur_tx++;
  
***************
*** 1178,1180 ****
--- 1214,1233 ----
  }
  
+ static struct pci_id rhine_nics[] = {
+ PCI_ROM(0x1106, 0x3065, "dlink-530tx",     "VIA 6102"),
+ PCI_ROM(0x1106, 0x3106, "via-rhine-6105",  "VIA 6105"),
+ PCI_ROM(0x1106, 0x3043, "dlink-530tx-old", "VIA 3043"),		/* Rhine-I 86c100a */
+ PCI_ROM(0x1106, 0x3053, "via6105m",        "VIA 6105M"),	
+ PCI_ROM(0x1106, 0x6100, "via-rhine-old",   "VIA 86C100A"),	/* Rhine-II */
+ };
+ 
+ struct pci_driver rhine_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "VIA 86C100",
+ 	.probe    = rhine_probe,
+ 	.ids      = rhine_nics,
+ 	.id_count = sizeof(rhine_nics)/sizeof(rhine_nics[0]),
+ 	.class    = 0,
+ };
+ 
  /* EOF via-rhine.c */
diff -rc2P -x CVS GRUB_0.94/netboot/w89c840.c GRUB/netboot/w89c840.c
*** GRUB_0.94/netboot/w89c840.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/netboot/w89c840.c	2003-11-08 22:47:40.000000000 +0800
***************
*** 1,2 ****
--- 1,5 ----
+ #ifdef ALLMULTI
+ #error multicast support is not yet implemented
+ #endif
  /*
   * Etherboot -  BOOTP/TFTP Bootstrap Program
***************
*** 78,82 ****
  #include "nic.h"
  #include "pci.h"
- #include "cards.h"
  #include "timer.h"
  
--- 81,84 ----
***************
*** 91,97 ****
  
  /* Linux support functions */
- #define virt_to_bus(x) ((unsigned long)x)
- #define bus_to_virt(x) ((void *)x)
- 
  #define virt_to_le32desc(addr)  virt_to_bus(addr)
  #define le32desc_to_virt(addr)  bus_to_virt(addr)
--- 93,96 ----
***************
*** 261,272 ****
  static int ioaddr;
  static unsigned short eeprom [0x40];
- 
- #ifdef    USE_LOWMEM_BUFFER
- #define rx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE)
- #define tx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE - PKT_BUF_SZ * TX_RING_SIZE)
- #else
  static char        rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
  static char        tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
- #endif
  
  static int  eeprom_read(long ioaddr, int location);
--- 260,265 ----
***************
*** 593,598 ****
  w89c840_disable - Turn off ethernet interface
  ***************************************************************************/
! static void w89c840_disable(struct nic *nic)
  {
      /* Don't know what to do to disable the board. Is this needed at all? */
      /* Yes, a live NIC can corrupt the loaded memory later [Ken] */
--- 586,595 ----
  w89c840_disable - Turn off ethernet interface
  ***************************************************************************/
! static void w89c840_disable(struct dev *dev)
  {
+     struct nic *nic = (struct nic *)dev;
+     /* merge reset and disable */
+     w89c840_reset(nic);
+ 
      /* Don't know what to do to disable the board. Is this needed at all? */
      /* Yes, a live NIC can corrupt the loaded memory later [Ken] */
***************
*** 604,619 ****
  w89c840_probe - Look for an adapter, this routine's visible to the outside
  ***************************************************************************/
! struct nic *w89c840_probe(struct nic *nic, unsigned short *probe_addrs, struct pci_device *p)
  {
      u16 sum = 0;
!     int i, j, to;
      unsigned short value;
-     int options;
-     int promisc;
  
!     if (probe_addrs == 0 || probe_addrs[0] == 0)
          return 0;
  
!     ioaddr = probe_addrs[0]; /* Mask the bit that says "this is an io addr" */
  
  #if defined(W89C840_DEBUG)
--- 601,615 ----
  w89c840_probe - Look for an adapter, this routine's visible to the outside
  ***************************************************************************/
! static int w89c840_probe(struct dev *dev, struct pci_device *p)
  {
+     struct nic *nic = (struct nic *)dev;
      u16 sum = 0;
!     int i, j;
      unsigned short value;
  
!     if (p->ioaddr == 0)
          return 0;
  
!     ioaddr = p->ioaddr;
  
  #if defined(W89C840_DEBUG)
***************
*** 623,628 ****
      ioaddr = ioaddr & ~3; /* Mask the bit that says "this is an io addr" */
  
-     /* if probe_addrs is 0, then routine can use a hardwired default */
- 
      /* From Matt Hortman <mbhortman@acpthinclient.com> */
      if (p->vendor == PCI_VENDOR_ID_WINBOND2
--- 619,622 ----
***************
*** 690,701 ****
  
      /* point to NIC specific routines */
!     nic->reset = w89c840_reset;
!     nic->poll = w89c840_poll;
      nic->transmit = w89c840_transmit;
-     nic->disable = w89c840_disable;
  
      w89c840_reset(nic);
  
!     return nic;
  }
  
--- 684,694 ----
  
      /* point to NIC specific routines */
!     dev->disable  = w89c840_disable;
!     nic->poll     = w89c840_poll;
      nic->transmit = w89c840_transmit;
  
      w89c840_reset(nic);
  
!     return 1;
  }
  
***************
*** 933,934 ****
--- 926,942 ----
      return;
  }
+ 
+ 
+ static struct pci_id w89c840_nics[] = {
+ PCI_ROM(0x1050, 0x0840, "winbond840",     "Winbond W89C840F"),
+ PCI_ROM(0x11f6, 0x2011, "compexrl100atx", "Compex RL100ATX"),
+ };
+ 
+ struct pci_driver w89c840_driver = {
+ 	.type     = NIC_DRIVER,
+ 	.name     = "W89C840F",
+ 	.probe    = w89c840_probe,
+ 	.ids      = w89c840_nics,
+ 	.id_count = sizeof(w89c840_nics)/sizeof(w89c840_nics[0]),
+ 	.class    = 0,
+ };
diff -rc2P -x CVS GRUB_0.94/stage2/builtins.c GRUB/stage2/builtins.c
*** GRUB_0.94/stage2/builtins.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/builtins.c	2003-11-17 11:14:26.000000000 +0800
***************
*** 30,35 ****
  
  #ifdef SUPPORT_NETBOOT
! # define GRUB	1
! # include <etherboot.h>
  #endif
  
--- 30,34 ----
  
  #ifdef SUPPORT_NETBOOT
! # include <grub.h>
  #endif
  
***************
*** 827,831 ****
  #endif /* GRUB_UTIL */
  
- 
  #ifdef SUPPORT_NETBOOT
  /* dhcp */
--- 826,829 ----
***************
*** 833,838 ****
  dhcp_func (char *arg, int flags)
  {
!   /* For now, this is an alias for bootp.  */
!   return bootp_func (arg, flags);
  }
  
--- 831,860 ----
  dhcp_func (char *arg, int flags)
  {
!   int with_configfile = 0;
! 
!   if (grub_memcmp (arg, "--with-configfile", sizeof ("--with-configfile") - 1)
!       == 0)
!     {
!       with_configfile = 1;
!       arg = skip_to (0, arg);
!     }
!   
!   if (! dhcp ())
!     {
!       if (errnum == ERR_NONE)
! 	errnum = ERR_DEV_VALUES;
! 
!       return 1;
!     }
! 
!   /* Notify the configuration.  */
!   print_network_configuration ();
! 
!   /* XXX: this can cause an endless loop, but there is no easy way to
!      detect such a loop unfortunately.  */
!   if (with_configfile)
!     configfile_func (config_file, flags);
!   
!   return 0;
  }
  
***************
*** 847,851 ****
  #endif /* SUPPORT_NETBOOT */
  
- 
  /* displayapm */
  static int
--- 869,872 ----
diff -rc2P -x CVS GRUB_0.94/stage2/cmdline.c GRUB/stage2/cmdline.c
*** GRUB_0.94/stage2/cmdline.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/cmdline.c	2003-11-17 11:14:26.000000000 +0800
***************
*** 22,27 ****
  
  #ifdef SUPPORT_DISKLESS
! # define GRUB	1
! # include <etherboot.h>
  #endif
  
--- 22,26 ----
  
  #ifdef SUPPORT_DISKLESS
! # include <grub.h>
  #endif
  
diff -rc2P -x CVS GRUB_0.94/stage2/common.c GRUB/stage2/common.c
*** GRUB_0.94/stage2/common.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/common.c	2003-11-17 11:14:26.000000000 +0800
***************
*** 22,27 ****
  
  #ifdef SUPPORT_DISKLESS
! # define GRUB	1
! # include <etherboot.h>
  #endif
  
--- 22,26 ----
  
  #ifdef SUPPORT_DISKLESS
! # include <grub.h>
  #endif
  
diff -rc2P -x CVS GRUB_0.94/stage2/disk_io.c GRUB/stage2/disk_io.c
*** GRUB_0.94/stage2/disk_io.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/disk_io.c	2003-11-17 11:14:26.000000000 +0800
***************
*** 24,29 ****
  
  #ifdef SUPPORT_NETBOOT
! # define GRUB	1
! # include <etherboot.h>
  #endif
  
--- 24,28 ----
  
  #ifdef SUPPORT_NETBOOT
! # include <grub.h>
  #endif
  
diff -rc2P -x CVS GRUB_0.94/stage2/Makefile.am GRUB/stage2/Makefile.am
*** GRUB_0.94/stage2/Makefile.am	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/Makefile.am	2003-11-05 18:10:24.000000000 +0800
***************
*** 93,97 ****
  
  if NETBOOT_SUPPORT
! pre_stage2_exec_LDADD = ../netboot/libdrivers.a
  endif
  
--- 93,97 ----
  
  if NETBOOT_SUPPORT
! pre_stage2_exec_LDADD = ../netboot/libdrivers.a 
  endif
  
diff -rc2P -x CVS GRUB_0.94/stage2/Makefile.in GRUB/stage2/Makefile.in
*** GRUB_0.94/stage2/Makefile.in	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/Makefile.in	2003-11-21 11:29:45.000000000 +0800
***************
*** 232,236 ****
  pre_stage2_exec_LDFLAGS = $(PRE_STAGE2_LINK)
  
! @NETBOOT_SUPPORT_TRUE@pre_stage2_exec_LDADD = ../netboot/libdrivers.a
  
  @DISKLESS_SUPPORT_TRUE@BUILT_SOURCES = stage2_size.h diskless_size.h
--- 232,236 ----
  pre_stage2_exec_LDFLAGS = $(PRE_STAGE2_LINK)
  
! @NETBOOT_SUPPORT_TRUE@pre_stage2_exec_LDADD = ../netboot/libdrivers.a 
  
  @DISKLESS_SUPPORT_TRUE@BUILT_SOURCES = stage2_size.h diskless_size.h
diff -rc2P -x CVS GRUB_0.94/stage2/stage2.c GRUB/stage2/stage2.c
*** GRUB_0.94/stage2/stage2.c	2003-11-20 10:04:59.000000000 +0800
--- GRUB/stage2/stage2.c	2003-11-11 13:51:38.000000000 +0800
***************
*** 29,33 ****
  # elif defined(SUPPORT_DISKLESS)
  /* Execute the command "bootp" automatically.  */
! static const char *preset_menu = "bootp\n";
  # endif /* SUPPORT_DISKLESS */
  
--- 29,33 ----
  # elif defined(SUPPORT_DISKLESS)
  /* Execute the command "bootp" automatically.  */
! static const char *preset_menu = "dhcp\n";
  # endif /* SUPPORT_DISKLESS */
  
