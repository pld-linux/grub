Index: debian/control
===================================================================
--- debian/control	(.../upstream/grub-0.97)	(revision 0)
+++ debian/control	(.../trunk)	(revision 112)
@@ -0,0 +1,16 @@
+Source: grub
+Section: admin
+Priority: optional
+Maintainer: GNU GRUB Maintainers <bug-grub@gnu.org>
+Standards-Version: 3.0.1
+
+Package: grub
+Architecture: i386 hurd-i386
+Depends: ${shlibs:Depends}
+Build-Depends: texi2html
+Description: GRand Unified Bootloader
+ GRUB is a GPLed bootloader intended to unify bootloading across x86
+ operating systems.  In addition to loading the Linux and *BSD kernels,
+ it implements the Multiboot standard, which allows for flexible loading
+ of multiple boot images (needed for modular kernels such as the GNU
+ Hurd).
Index: debian/postinst
===================================================================
--- debian/postinst	(.../upstream/grub-0.97)	(revision 0)
+++ debian/postinst	(.../trunk)	(revision 112)
@@ -0,0 +1,20 @@
+#! /bin/sh
+set -e
+
+# Provide a backward-compatibility symlink to the doc directory.
+package=grub
+case "$1" in
+configure)
+  if [ -d /usr/doc ]; then
+    if [ ! -e /usr/doc/$package -a -d /usr/share/doc/$package ]; then
+      ln -sf ../share/doc/$package /usr/doc/$package
+    fi
+  fi
+  ;;
+esac
+
+# Install our info pages.
+install-info --quiet --section Kernel Kernel \
+            /usr/share/info/grub.info.gz
+install-info --quiet --section Kernel Kernel \
+            /usr/share/info/multiboot.info.gz
Index: debian/prerm
===================================================================
--- debian/prerm	(.../upstream/grub-0.97)	(revision 0)
+++ debian/prerm	(.../trunk)	(revision 112)
@@ -0,0 +1,16 @@
+#! /bin/sh
+set -e
+
+# Delete our backward-compatibility symlink.
+package=grub
+case "$1" in
+remove | upgrade)
+  if [ -d /usr/doc -a -L /usr/doc/$package ]; then
+    rm -f /usr/doc/$package
+  fi
+  ;;
+esac
+
+# Install our info pages.
+install-info --quiet --remove /usr/share/info/grub.info.gz
+install-info --quiet --remove /usr/share/info/multiboot.info.gz
Index: debian/changelog
===================================================================
--- debian/changelog	(.../upstream/grub-0.97)	(revision 0)
+++ debian/changelog	(.../trunk)	(revision 112)
@@ -0,0 +1,314 @@
+grub (1:0.97-os.3) unstable; urgency=low
+
+  * New version, added PXE network card support.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Sat,  2 Sep 2006 22:55:44 +0200
+
+grub (1:0.97-os.2) unstable; urgency=low
+
+  * New version, merged grub-diskless-patch-3.tar.gz.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Tue, 22 Aug 2006 23:25:41 +0200
+
+grub (1:0.97-os.1) unstable; urgency=low
+
+  * New upstream release.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Wed, 18 May 2005 16:35:05 +0200
+
+grub (1:0.96-os.1) unstable; urgency=low
+
+  * New upstream release.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Fri, 11 Feb 2005 15:09:49 +0100
+
+grub (1:0.95-os.1) unstable; urgency=low
+
+  * New upstream version.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Mon, 19 Jul 2004 00:13:02 +0200
+
+grub (1:0.94-os.2a) unstable; urgency=low
+
+  * Add some older 3com drivers.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Sun,  9 May 2004 16:27:50 +0200
+
+grub (1:0.94-os.2) unstable; urgency=low
+
+  * Fix auto-bootp.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Wed, 28 Jan 2004 15:46:26 +0100
+
+grub (1:0.94-os.1) unstable; urgency=low
+
+  * New upstream
+  * Fancy clear screen (don't destroy screen contents on serial console
+    upon start of GRUB)
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Mon, 26 Jan 2004 13:21:18 +0100
+
+grub (1:0.93-os.11) unstable; urgency=low
+
+  * New version (new eepro100 PCI-ids, other things).
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Fri, 29 Aug 2003 22:55:51 +0200
+
+grub (1:0.93-os.10) unstable; urgency=low
+
+  * New version (varexpand features, bugfixes)
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Mon,  7 Jul 2003 13:43:54 +0200
+
+grub (1:0.93-os.9) unstable; urgency=low
+
+  * New version
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Tue,  6 May 2003 18:44:13 +0200
+
+grub (1:0.93-os.8) unstable; urgency=low
+
+  * New version (some new and hidden features).
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Fri, 25 Apr 2003 00:50:13 +0200
+
+grub (1:0.93-os.7) unstable; urgency=low
+
+  * Fix serious memory corruption bug (well, now I love the -W gcc switch...)
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Tue, 22 Apr 2003 00:57:46 +0200
+
+grub (1:0.93-os.6) unstable; urgency=low
+
+  * New version: a search feature was added.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Sun, 20 Apr 2003 23:20:03 +0200
+
+grub (1:0.93-os.5) unstable; urgency=low
+
+  * Modified toggle_print_status a bit.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Wed,  2 Apr 2003 14:44:55 +0200
+
+grub (1:0.93-os.4) unstable; urgency=low
+
+  * Modified semantics of toggles and added more variable stuff.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Tue, 18 Mar 2003 23:46:50 +0100
+
+grub (1:0.93-os.3) unstable; urgency=low
+
+  * Add toggle triggers and a detection for vmware.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Thu, 13 Feb 2003 22:21:00 +0100
+
+grub (1:0.93-os.2) unstable; urgency=low
+
+  * Fix missing colors with our extensions in the menu frame.
+  * And other hacks here added.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Mon, 10 Feb 2003 14:31:26 +0100
+
+grub (1:0.93-os.1) unstable; urgency=low
+
+  * Ported our stuff back to the 0.93 upstream version.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Sun, 26 Jan 2003 13:22:28 +0100
+
+grub (1:0.9.0-fm3.8) unstable; urgency=low
+
+  * Put an epoch in here because debian version follows upstream more
+    closely.
+
+ -- Adam Lackorzynski <adam@os.inf.tu-dresden.de>  Tue, 28 May 2002 19:28:55 +0200
+
+grub (0.9.0-fm3.7) unstable; urgency=low
+
+  * stolen from upstream:
+    - fix eepro100 support
+ 
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Wed,  10 Apr 2002 15:00:00 +0200
+
+grub (0.9.0-fm3.6) unstable; urgency=low
+
+  * stolen from upstream:
+    - APM fixes
+ 
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Wed,  04 Mar 2002 14:00:00 +0200
+
+grub (0.9.0-fm3.5) unstable; urgency=low
+
+  * stolen from upstream:
+    - Set the level of APM support to 1.1, before turning off the power state.
+    - If a serial device is not configured yet, restore the terminal and set
+      ERRNUM to ERR_NEED_SERIAL
+    - If USE_CURSES is true, ignore the signal SIGWINCH.
+
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Wed,  14 Nov 2001 13:00:00 +0200
+
+grub (0.9.0-fm3.4) unstable; urgency=low
+
+  * Added check for valid module load address
+
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Wed,  14 Nov 2001 13:00:00 +0200
+
+grub (0.9.0-fm3.3) unstable; urgency=low
+
+  * Fixed error when seeking back on tftp'd file
+
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Thu,  26 Jul 2001 18:00:00 +0200
+
+grub (0.9.0-fm3.2) unstable; urgency=low
+
+  * Disabled reading of shared symbols because it fails (machine reboot)
+    if kernel is loaded from network
+
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Thu,  26 Jul 2001 18:00:00 +0200
+
+grub (0.9.0-fm3.1) unstable; urgency=low
+
+  * Universal release for Tulip 21140/21143, VMware, 3c595, NE2000, EEPRO100
+
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Thu,  26 Jul 2001 18:00:00 +0200
+
+grub (0.5.97-tp.1) unstable; urgency=low
+
+  * Fixed eepro100 for our Thinkpads
+
+ -- Frank Mehnert <fm3@os.inf.tu-dresden.de>  Fri,  12 Jan 2001 10:00:00 +0200
+
+grub (0.5.96) unstable; urgency=low
+
+  * Many, many new features and bugfixes.  This is the final test release;
+    the next release will be version 1.0.
+  * Install HTML documentation in addition to Info pages.
+    (closes:bug#42242,bug#42273)
+  * Fix documentation to refer to /usr/sbin/grub as well as
+    /sbin/grub. (closes:bug#67132)
+  * Be more verbose about missing setup files. (closes:bug#71661)
+
+ -- Gordon Matzigkeit <gord@debian.org>  Wed,  4 Oct 2000 10:44:42 -0600
+
+grub (0.5.95) unstable; urgency=low
+
+  * ReiserFS support from Jochen Hoenicke.
+  * `--disable-lba-support-bitmap-check' is now a runtime option,
+    `--force-lba', which works with `install', `setup', and
+    `grub-install.' (closes:bug#61513)
+  * Fixed a bug in LBA support checking.  Please let us know if you
+    need to use `--force-lba' for Grub to work.
+  * NetBSD ELF kernel support is added.
+
+ -- Gordon Matzigkeit <gord@debian.org>  Tue, 27 Jun 2000 09:44:41 -0600
+
+grub (0.5.94) unstable; urgency=low
+
+  * Fix /usr/doc symlink. (closes:bug#50932)
+  * Better testing for BIOS LBA support. (closes:bug#53507)
+  * New installation script. (closes:bug#48755)
+  
+ -- Gordon Matzigkeit <gord@debian.org>  Fri, 10 Mar 2000 14:55:02 -0600
+
+grub (0.5.93.1) unstable; urgency=low
+
+  * Update to Standards-Version: 3.0.1, mainly for FHS support.
+  * Fix definition of ext2_dir_entry. (closes:bug#49017)
+  * Fix rules for cross-compiling. (closes:bug#49034)
+  * Update synopsis for grub(8). (closes:bug#48991)
+  * Don't clear the line when hitting enter in the GRUB shell.
+    (closes:bug#48989)
+
+ -- Gordon Matzigkeit <gord@debian.org>  Fri,  5 Nov 1999 22:31:30 -0600
+
+grub (0.5.93) unstable; urgency=low
+
+  * Updated example configurations. (closes:bug#42136)
+  * Highlight color set correctly when editing. (closes:bug#42549)
+  * dpkg-shlibdeps called on /usr/sbin/grub. (closes:bug#42704)
+  * Properly install Texinfo documentation. (closes:bug#42705,bug#42919)
+    (closes:bug#43080,bug#45150)
+  * Update file locations in README.debian. (closes:bug#42834)
+  * Upstream fixes for new binutils assembler syntax. (closes:bug#47946)
+  * FAT32 support. (closes:bug#47970)
+  * Password option fixed. (closes:bug#43798)
+  * Sample menu.lst included in doc directory. (closes:bug#47181)
+
+ -- Gordon Matzigkeit <gord@debian.org>  Sat, 30 Oct 1999 09:59:09 -0600
+
+grub (0.5.92) unstable; urgency=low
+
+  * Data files are now in /usr/lib/grub/$(HWARCH).
+  * Unix boot utility available as /usr/sbin/grub.
+  * Full Texinfo documentation.
+
+ -- GRUB Maintainers <bug-grub@gnu.org>  Mon, 26 Jul 1999 12:46:37 -0600
+
+grub (0.5.91) unstable; urgency=low
+
+  * Added support for LBA mode and preliminary AWARD/AMI hard disk BIOS
+    extensions.
+  * GRUB data now installed in /share/grub/$(host_cpu)-$(host_vendor).
+  * Preliminary Texinfo documentation.
+
+ -- Gordon Matzigkeit <gord@debian.org>  Sun, 14 Mar 1999 20:23:04 -0600
+
+grub (0.5.90) unstable; urgency=low
+
+  * Beta-testing release.
+  * GRUB is now officially part of the GNU Project, and the Debian package
+    is maintained by its upstream maintainers.
+  * LS-120 IDE floppy support should work now (fixes: #33720).
+
+ -- Gordon Matzigkeit <gord@debian.org>  Mon,  1 Mar 1999 12:59:06 -0600
+
+grub (0.5-3) unstable; urgency=low
+
+  * GRUB now understands symbolic links (fixes: #17306).
+
+ -- Gordon Matzigkeit <gord@debian.org>  Sun, 21 Feb 1999 05:13:25 -0600
+
+grub (0.5-2) unstable; urgency=low
+
+  * Assembly source cleanups.
+
+ -- Gordon Matzigkeit <gord@debian.org>  Sun, 14 Feb 1999 20:33:39 -0600
+
+grub (0.5-1) unstable; urgency=low
+
+  * Put everything in /lib/grub (not /boot/grub) and don't install during
+    postinst so that we can't accidentally wreck a working system.  This
+    means the package needn't be experimental anymore.
+  * Get rid of grubinst because it doesn't work with 0.5, and I'd rather
+    improve GRUB's builtin installation process.
+  * Use `e' rather than enter to edit.
+  * Minor bug fixes.
+
+ -- Gordon Matzigkeit <gord@debian.org>  Sun, 31 Jan 1998 14:11:32 -0600
+
+grub (0.4-2) experimental; urgency=low
+
+  * Make postinstall script
+  * Create manpage for grubinst
+  * Make grubinst more flexible
+  * Address bugs 15227 and 15163 (packaging and clue endowment)
+
+ -- Steve Dunham <dunham@debian.org>  Thu,  1 Jan 1998 00:38:22 -0500
+
+grub (0.4-2) experimental; urgency=low
+
+  * Make postinstall script
+  * Create manpage for grubinst
+  * Make grubinst more flexible
+  * Address bugs 15227 and 15163 (packaging and clue endowment)
+
+ -- Steve Dunham <dunham@debian.org>  Thu,  1 Jan 1998 00:38:22 -0500
+
+grub (0.4-1) unstable; urgency=low
+
+  * Initial Release.
+
+ -- Steve Dunham <dunham@debian.org>  Wed, 19 Nov 1997 23:42:47 -0500
+
+Local variables:
+mode: debian-changelog
+End:
Index: debian/copyright
===================================================================
--- debian/copyright	(.../upstream/grub-0.97)	(revision 0)
+++ debian/copyright	(.../trunk)	(revision 112)
@@ -0,0 +1,27 @@
+This package was debianized by Gordon Matzigkeit <gord@debian.org>.
+It was downloaded from ftp://alpha.gnu.org/gnu/grub/.
+
+Tom Lees implemented building the e2fs_stage1_5, Steve Dunham adapted
+it to fat_stage1_5.
+
+GRUB's copyright:
+
+   Copyright (C) 1996  Erich Boleyn <erich@uruk.org>
+   Copyright (C) 1999-2000  Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+On Debian GNU systems, the complete text of the GNU General Public
+License can be found in `/usr/share/common-licenses/GPL'.
Index: debian/rules
===================================================================
--- debian/rules	(.../upstream/grub-0.97)	(revision 0)
+++ debian/rules	(.../trunk)	(revision 112)
@@ -0,0 +1,112 @@
+#!/usr/bin/make -f
+# -*-makefile-*-
+# based on the sample debian/rules file for GNU hello by Ian Jackson.
+
+package:=grub
+
+# For cross-compilation.
+DEB_BUILD_ARCH := $(shell dpkg --print-installation-architecture)
+DEB_BUILD_GNU_CPU := $(patsubst hurd-%,%,$(DEB_BUILD_ARCH))
+ifeq ($(filter-out hurd-%,$(DEB_BUILD_ARCH)),)
+ DEB_BUILD_GNU_SYSTEM := gnu
+else
+ DEB_BUILD_GNU_SYSTEM := linux
+endif
+DEB_BUILD_GNU_TYPE := $(DEB_BUILD_GNU_CPU)-$(DEB_BUILD_GNU_SYSTEM)
+DEB_HOST_GNU_TYPE := $(DEB_BUILD_GNU_TYPE)
+
+INSTALL = install -c
+INSTALL_DATA = $(INSTALL) -m 644
+INSTALL_PROGRAM = $(INSTALL) -m 755
+
+build:
+	$(checkdir)
+	CC=gcc-3.4 ./configure \
+	  --enable-pcnet32 \
+	  --enable-ntulip \
+	  --enable-eepro100 \
+	  --enable-ne \
+	  --enable-ns8390 \
+	  --enable-3c509 \
+	  --enable-3c590 \
+	  --enable-3c595 \
+	  --enable-3c90x \
+	  --enable-3c509 \
+	  --enable-3c529 \
+	  --enable-via-rhine \
+	  --disable-auto-linux-mem-opt \
+	  --enable-diskless \
+	  --prefix=/usr \
+	  $(DEB_HOST_GNU_TYPE) --build=$(DEB_BUILD_GNU_TYPE) \
+	  --mandir='$${datadir}/man' --infodir='$${datadir}/info'
+#	./configure \
+#	  --disable-auto-linux-mem-opt \
+#	  --enable-rtl8139 \
+#	  --prefix=/usr \
+#	  $(DEB_HOST_GNU_TYPE) --build=$(DEB_BUILD_GNU_TYPE) \
+#	  --mandir='$${datadir}/man' --infodir='$${datadir}/info'
+	make
+	echo timestamp > build
+
+clean:
+	$(checkdir)
+	-rm -f build
+	-make distclean
+	-rm -f `find . -name "*~"`
+	-rm -rf debian/tmp debian/files* core debian/substvars conftestdir
+
+binary-indep:	checkroot build
+	$(checkdir)
+# There are no architecture-independent files to be uploaded
+# generated by this package.  If there were any they would be
+# made here.
+
+binary-arch:	checkroot build
+	$(checkdir)
+	-rm -rf debian/tmp
+## make dirs
+	install -d debian/tmp debian/tmp/usr/share/doc/grub debian/tmp/DEBIAN
+## install files
+
+	dir=`cd debian/tmp && pwd` && make install DESTDIR=$$dir
+
+	top=`pwd` && cd debian/tmp/usr/share/doc/grub && \
+	  ln -s $$top/docs/{grub,multiboot}.texi . && \
+	  texi2html -split_chapter -I $$top/docs grub.texi && \
+	  texi2html -split_chapter -I $$top/docs multiboot.texi && \
+	  rm -f grub.texi multiboot.texi
+
+	gzip -f9 debian/tmp/usr/share/info/* debian/tmp/usr/share/man/*/*
+	strip -s debian/tmp/usr/sbin/grub debian/tmp/usr/bin/mbchk
+
+	$(INSTALL_DATA)	TODO BUGS NEWS docs/menu.lst \
+	  debian/tmp/usr/share/doc/grub/
+
+	$(INSTALL_DATA) ChangeLog debian/tmp/usr/share/doc/grub/changelog
+	gzip -f9 debian/tmp/usr/share/doc/grub/changelog
+	$(INSTALL_DATA) debian/changelog debian/tmp/usr/share/doc/grub/changelog.Debian
+	gzip -f9 debian/tmp/usr/share/doc/grub/changelog.Debian
+	$(INSTALL_DATA) debian/copyright debian/tmp/usr/share/doc/grub/
+	$(INSTALL_DATA) debian/README.debian debian/tmp/usr/share/doc/grub/
+
+	# Install control files.
+	$(INSTALL_PROGRAM) debian/postinst debian/prerm debian/tmp/DEBIAN
+	dpkg-shlibdeps debian/tmp/usr/sbin/grub
+	dpkg-gencontrol -isp
+	chown -R root.root debian/tmp
+	chmod -R go=rX debian/tmp
+	dpkg --build debian/tmp ..
+
+define checkdir
+	test -f debian/rules -a -f stage2/fsys_ext2fs.c
+endef
+
+# Below here is fairly generic really
+
+binary:		binary-indep binary-arch
+
+checkroot:
+	$(checkdir)
+	test root = "`whoami`"
+
+.PHONY: binary binary-arch binary-indep clean checkroot
Index: debian/README.debian
===================================================================
--- debian/README.debian	(.../upstream/grub-0.97)	(revision 0)
+++ debian/README.debian	(.../trunk)	(revision 112)
@@ -0,0 +1,24 @@
+GRUB for Debian GNU
+-------------------
+
+GRUB is a GPLed bootloader intended to unify bootloading across x86
+operating systems.  In addition to loading Linux and FreeBSD, it
+implements the Multiboot standard, which allows for flexible loading
+of multiple boot images (needed for modular kernels such as the GNU
+Hurd).
+
+One unique featue of GRUB is that it can understand filesystems at
+boot time, rather than just simple blocklists.  Hence, you can load
+any kernel in the file system from the boot prompt without having to
+edit configuration files or rerun a special installation program.
+
+NOTE: GRUB does not yet have a simple installation mechanism, but
+we're working on this, so please don't report it as a bug.  Until
+then, do `info grub', and copy the binary files in
+/usr/share/grub/$(HWARCH) to /boot/grub.
+
+WARNING: Never use the binary files in /usr/share/grub directly
+(i.e. without first copying them to /boot/grub), or else your system
+will break the next time you upgrade.
+
+Gordon Matzigkeit <gord@debian.org>, Sat, 13 Mar 1999 17:30:29 -0600

Property changes on: debian
___________________________________________________________________
Name: svn:ignore
   + tmp
files
substvars


Index: acinclude.m4
===================================================================
--- acinclude.m4	(.../upstream/grub-0.97)	(revision 117)
+++ acinclude.m4	(.../trunk)	(revision 117)
@@ -56,12 +56,12 @@
   AC_MSG_ERROR([${CC-cc} cannot compile C source code])
 fi
 grub_cv_prog_objcopy_absolute=yes
-for link_addr in 2000 8000 7C00; do
-  if AC_TRY_COMMAND([${CC-cc} ${CFLAGS} -nostdlib -Wl,-N -Wl,-Ttext -Wl,$link_addr conftest.o -o conftest.exec]); then :
+for link_addr in 0x2000 0x8000 0x7C00; do
+  if AC_TRY_COMMAND([${CC-cc} ${CFLAGS} -nostdlib -Wl,-N -Wl,-Ttext, -Wl,-Ttext -Wl,$link_addr conftest.o -o conftest.exec]); then :
   else
     AC_MSG_ERROR([${CC-cc} cannot link at address $link_addr])
   fi
-  if AC_TRY_COMMAND([${OBJCOPY-objcopy} -O binary conftest.exec conftest]); then :
+  if AC_TRY_COMMAND([${OBJCOPY-objcopy} --only-section=.text -O binary conftest.exec conftest]); then :
   else
     AC_MSG_ERROR([${OBJCOPY-objcopy} cannot create binary files])
   fi
Index: configure.ac
===================================================================
--- configure.ac	(.../upstream/grub-0.97)	(revision 112)
+++ configure.ac	(.../trunk)	(revision 112)
@@ -58,6 +58,8 @@
 AC_PROG_CC
 # We need this for older versions of Autoconf.
 _AM_DEPENDENCIES(CC)
+AM_PROG_CC_C_O
+AM_PROG_AS
 
 dnl Because recent automake complains about AS, set it here.
 CCAS="$CC"
@@ -86,13 +88,13 @@
     fi
     STAGE1_CFLAGS="-O2"
     GRUB_CFLAGS="-O2"
-    AC_CACHE_CHECK([whether optimization for size works], size_flag, [
+    AC_CACHE_CHECK([whether optimization for size works], grub_cv_size_flag, [
       saved_CFLAGS=$CFLAGS
       CFLAGS="-Os -g"
-      AC_TRY_COMPILE(, , size_flag=yes, size_flag=no)
+      AC_TRY_COMPILE(, , grub_cv_size_flag=yes, grub_cv_size_flag=no)
       CFLAGS=$saved_CFLAGS
     ])
-    if test "x$size_flag" = xyes; then
+    if test "x$grub_cv_size_flag" = xyes; then
       STAGE2_CFLAGS="-Os -g2 -fno-strict-aliasing"
     else
       STAGE2_CFLAGS="-O2 -g2 -fno-strict-aliasing -fno-strength-reduce -fno-unroll-loops"
@@ -100,17 +102,17 @@
     # OpenBSD has a GCC extension for protecting applications from
     # stack smashing attacks, but GRUB doesn't want this feature.
     AC_CACHE_CHECK([whether gcc has -fno-stack-protector],
-		   no_stack_protector_flag, [
+		   grub_cv_no_stack_protector_flag, [
       saved_CFLAGS=$CFLAGS
       CFLAGS="-fno-stack-protector"
       AC_TRY_COMPILE(,
 		     ,
-		     no_stack_protector_flag=yes,
-		     no_stack_protector_flag=no)
+		     grub_cv_no_stack_protector_flag=yes,
+		     grub_cv_no_stack_protector_flag=no)
       CFLAGS=$saved_CFLAGS
     ])
-    if test "x$no_stack_protector_flag" = xyes; then
-      STAGE2_CFLAGS="$STAGE2_CFLAGS -fno-stack-protector"
+    if test "x$grub_cv_no_stack_protector_flag" = xyes; then
+      CFLAGS="$CFLAGS -fno-stack-protector"
     fi
   fi
 fi
@@ -123,30 +125,30 @@
 CPPFLAGS="$CPPFLAGS -Wall -Wmissing-prototypes -Wunused -Wshadow"
 CPPFLAGS="$CPPFLAGS -Wpointer-arith"
 
-AC_CACHE_CHECK([whether -Wundef works], undef_flag, [
+AC_CACHE_CHECK([whether -Wundef works], grub_cv_undef_flag, [
   saved_CPPFLAGS="$CPPFLAGS"
   CPPFLAGS="-Wundef"
-  AC_TRY_COMPILE(, , undef_flag=yes, undef_flag=no)
+  AC_TRY_COMPILE(, , grub_cv_undef_flag=yes, grub_cv_undef_flag=no)
   CPPFLAGS="$saved_CPPFLAGS"
 ])
 
 # The options `-falign-*' are supported by gcc 3.0 or later.
 # Probably it is sufficient to only check for -falign-loops.
-AC_CACHE_CHECK([whether -falign-loops works], [falign_loop_flag], [
+AC_CACHE_CHECK([whether -falign-loops works], [grub_cv_falign_loop_flag], [
   saved_CPPFLAGS="$CPPFLAGS"
   CPPFLAGS="-falign-loops=1"
-  AC_TRY_COMPILE(, , [falign_loop_flag=yes], [falign_loop_flag=no])
+  AC_TRY_COMPILE(, , [grub_cv_falign_loop_flag=yes], [grub_cv_falign_loop_flag=no])
   CPPFLAGS="$saved_CPPFLAGS"
 ])
 
 # Force no alignment to save space.
-if test "x$falign_loop_flag" = xyes; then
+if test "x$grub_cv_falign_loop_flag" = xyes; then
   CPPFLAGS="$CPPFLAGS -falign-jumps=1 -falign-loops=1 -falign-functions=1"
 else
   CPPFLAGS="$CPPFLAGS -malign-jumps=1 -malign-loops=1 -malign-functions=1"
 fi
 
-if test "x$undef_flag" = xyes; then
+if test "x$grub_cv_undef_flag" = xyes; then
   CPPFLAGS="$CPPFLAGS -Wundef"
 fi
 
@@ -317,7 +317,7 @@
   [  --disable-packet-retransmission
                           turn off packet retransmission])
 if test "x$enable_packet_retransmission" != xno; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1"
+  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCONGESTED=1 -DCONFIG_PCI"
 fi
 
 AC_ARG_ENABLE(pci-direct,
@@ -327,20 +327,6 @@
 fi
 
 dnl Device drivers.
-AC_ARG_ENABLE(3c509,
-  [  --enable-3c509          enable 3Com509 driver])
-if test "x$enable_3c509" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C509"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c509.o"
-fi
-
-AC_ARG_ENABLE(3c529,
-  [  --enable-3c529          enable 3Com529 driver])
-if test "x$enable_3c529" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C529=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c529.o"
-fi
-
 AC_ARG_ENABLE(3c595,
   [  --enable-3c595          enable 3Com595 driver])
 if test "x$enable_3c595" = xyes; then
@@ -355,13 +341,6 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c90x.o"
 fi
 
-AC_ARG_ENABLE(cs89x0,
-  [  --enable-cs89x0         enable CS89x0 driver])
-if test "x$enable_cs89x0" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_CS89X0=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS cs89x0.o"
-fi
-
 AC_ARG_ENABLE(davicom,
   [  --enable-davicom        enable Davicom driver])
 if test "x$enable_davicom" = xyes; then
@@ -369,20 +348,13 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS davicom.o"
 fi
 
-AC_ARG_ENABLE(depca,
-  [  --enable-depca          enable DEPCA and EtherWORKS driver])
-if test "x$enable_depca" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_DEPCA=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS depca.o"
+AC_ARG_ENABLE(e1000,
+  [  --enable-e1000          enable Etherexpress Pro/1000 driver])
+if test "x$enable_e1000" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_E1000=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS e1000.o"
 fi
 
-AC_ARG_ENABLE(eepro,
-  [  --enable-eepro          enable Etherexpress Pro/10 driver])
-if test "x$enable_eepro" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EEPRO=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS eepro.o"
-fi
-
 AC_ARG_ENABLE(eepro100,
   [  --enable-eepro100       enable Etherexpress Pro/100 driver])
 if test "x$enable_eepro100" = xyes; then
@@ -397,48 +369,13 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS epic100.o"
 fi
 
-AC_ARG_ENABLE(3c507,
-  [  --enable-3c507          enable 3Com507 driver])
-if test "x$enable_3c507" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C507=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c507.o"
+AC_ARG_ENABLE(ntulip,
+  [  --enable-ntulip         enable Dresden Tulip driver])
+if test "x$enable_ntulip" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NTULIP=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ntulip.o"
 fi
 
-AC_ARG_ENABLE(exos205,
-  [  --enable-exos205        enable EXOS205 driver])
-if test "x$enable_exos205" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_EXOS205=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS exos205.o"
-fi
-
-AC_ARG_ENABLE(ni5210,
-  [  --enable-ni5210         enable Racal-Interlan NI5210 driver])
-if test "x$enable_ni5210" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5210=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5210.o"
-fi
-
-AC_ARG_ENABLE(lance,
-  [  --enable-lance          enable Lance PCI PCNet/32 driver])
-if test "x$enable_lance" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_LANCE=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS lance.o"
-fi
-
-AC_ARG_ENABLE(ne2100,
-  [  --enable-ne2100         enable Novell NE2100 driver])
-if test "x$enable_ne2100" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE2100=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne2100.o"
-fi
-
-AC_ARG_ENABLE(ni6510,
-  [  --enable-ni6510         enable Racal-Interlan NI6510 driver])
-if test "x$enable_ni6510" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI6510=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni6510.o"
-fi
-
 AC_ARG_ENABLE(natsemi,
   [  --enable-natsemi        enable NatSemi DP8381x driver])
 if test "x$enable_natsemi" = xyes; then
@@ -446,27 +383,6 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS natsemi.o"
 fi
 
-AC_ARG_ENABLE(ni5010,
-  [  --enable-ni5010         enable Racal-Interlan NI5010 driver])
-if test "x$enable_ni5010" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NI5010=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ni5010.o"
-fi
-
-AC_ARG_ENABLE(3c503,
-  [  --enable-3c503          enable 3Com503 driver])
-if test "x$enable_3c503" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_3C503=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS 3c503.o"
-fi
-
-AC_ARG_ENABLE(ne,
-  [  --enable-ne             enable NE1000/2000 ISA driver])
-if test "x$enable_ne" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_NE=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS ne.o"
-fi
-
 AC_ARG_ENABLE(ns8390,
   [  --enable-ns8390         enable NE2000 PCI driver])
 if test "x$enable_ns8390" = xyes; then
@@ -474,18 +390,18 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS ns8390.o"
 fi
 
-AC_ARG_ENABLE(wd,
-  [  --enable-wd             enable WD8003/8013, SMC8216/8416 driver])
-if test "x$enable_wd" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_WD=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS wd.o"
+AC_ARG_ENABLE(pcnet32,
+  [  --enable-pcnet32        enable AMD Lance/PCI PCNet/32 driver])
+if test "x$enable_pcnet32" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PCNET32=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS pcnet32.o"
 fi
 
-AC_ARG_ENABLE(otulip,
-  [  --enable-otulip         enable old Tulip driver])
-if test "x$enable_otulip" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_OTULIP=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS otulip.o"
+AC_ARG_ENABLE(pxe,
+  [  --enable-pxe            enable PXE driver])
+if test "x$enable_pxe" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_PXE_TFTP=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS pxe_tftp.o"
 fi
 
 AC_ARG_ENABLE(rtl8139,
@@ -495,6 +411,13 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS rtl8139.o"
 fi
 
+AC_ARG_ENABLE(r8169,
+  [  --enable-r8169          enable Realtek 8169 driver])
+if test "x$enable_r8169" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_R8169=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS r8169.o"
+fi
+
 AC_ARG_ENABLE(sis900,
   [  --enable-sis900         enable SIS 900 and SIS 7016 driver])
 if test "x$enable_sis900" = xyes; then
@@ -502,27 +425,13 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS sis900.o"
 fi
 
-AC_ARG_ENABLE(sk-g16,
-  [  --enable-sk-g16         enable Schneider and Koch G16 driver])
-if test "x$enable_sk_g16" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SK_G16=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS sk_g16.o"
+AC_ARG_ENABLE(tg3,
+  [  --enable-tg3            enable Broadcom Tigon3 driver])
+if test "x$enable_tg3" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TG3=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tg3.o"
 fi
 
-AC_ARG_ENABLE(smc9000,
-  [  --enable-smc9000        enable SMC9000 driver])
-if test "x$enable_smc9000" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SMC9000=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS smc9000.o"
-fi
-
-AC_ARG_ENABLE(tiara,
-  [  --enable-tiara          enable Tiara driver])
-if test "x$enable_tiara" = xyes; then
-  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TIARA=1"
-  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tiara.o"
-fi
-
 AC_ARG_ENABLE(tulip,
   [  --enable-tulip          enable Tulip driver])
 if test "x$enable_tulip" = xyes; then
@@ -530,6 +439,20 @@
   NETBOOT_DRIVERS="$NETBOOT_DRIVERS tulip.o"
 fi
 
+AC_ARG_ENABLE(tlan,
+  [  --enable-tlan           enable  TI ThunderLAN driver])
+if test "x$enable_tlan" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_TLAN=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS tlan.o"
+fi
+
+AC_ARG_ENABLE(sundance,
+  [  --enable-sundance       enable Sundance ST201 driver])
+if test "x$enable_sundance" = xyes; then
+  NET_CFLAGS="$NET_CFLAGS -DINCLUDE_SUNDANCE=1"
+  NETBOOT_DRIVERS="$NETBOOT_DRIVERS sundance.o"
+fi
+
 AC_ARG_ENABLE(via-rhine,
   [  --enable-via-rhine      enable Rhine-I/II driver])
 if test "x$enable_via_rhine" = xyes; then
@@ -550,19 +473,7 @@
   FSYS_CFLAGS="$FSYS_CFLAGS -DFSYS_TFTP=1"
 fi
 
-dnl Extra options.
-AC_ARG_ENABLE(3c503-shmem,
-  [  --enable-3c503-shmem    use 3c503 shared memory mode])
-if test "x$enable_3c503_shmem" = xyes; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_SHMEM=1"
-fi
-
-AC_ARG_ENABLE(3c503-aui,
-  [  --enable-3c503-aui      use AUI by default on 3c503 cards])
-if test "x$enable_3c503_aui" = xyes; then
-  NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DT503_AUI=1"
-fi
-
+dnl extra flag for ns8390.c
 AC_ARG_ENABLE(compex-rl2000-fix,
   [  --enable-compex-rl2000-fix
                           specify this if you have a Compex RL2000 PCI])
@@ -570,11 +481,6 @@
   NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCOMPEX_RL2000_FIX=1"
 fi
 
-AC_ARG_ENABLE(smc9000-scan,
-  [  --enable-smc9000-scan=LIST
-                          probe for SMC9000 I/O addresses using LIST],
-  [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DSMC9000_SCAN=$enable_smc9000_scan"])
-
 AC_ARG_ENABLE(ne-scan,
   [  --enable-ne-scan=LIST   probe for NE base address using LIST],
   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DNE_SCAN=$enable_ne_scan"],
@@ -586,10 +492,6 @@
   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DWD_DEFAULT_MEM=$enable_wd_default_mem"],
   [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DWD_DEFAULT_MEM=0xCC000"])
 
-AC_ARG_ENABLE(cs-scan,
-  [  --enable-cs-scan=LIST   probe for CS89x0 base address using LIST],
-  [NET_EXTRAFLAGS="$NET_EXTRAFLAGS -DCS_SCAN=$enable_cs_scan"])
-
 dnl Diskless
 AC_ARG_ENABLE(diskless,
   [  --enable-diskless       enable diskless support])
Index: stage2/cmdline.c
===================================================================
--- stage2/cmdline.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/cmdline.c	(.../trunk)	(revision 112)
@@ -21,8 +21,7 @@
 #include <shared.h>
 
 #ifdef SUPPORT_DISKLESS
-# define GRUB	1
-# include <etherboot.h>
+# include <grub.h>
 #endif
 
 grub_jmp_buf restart_cmdline_env;
@@ -58,7 +57,7 @@
 
 /* Find the builtin whose command name is COMMAND and return the
    pointer. If not found, return 0.  */
-struct builtin *
+static struct builtin *
 find_command (char *command)
 {
   char *ptr;
@@ -94,6 +93,26 @@
   return 0;
 }
 
+struct builtin *
+find_command_parse (char *command)
+{
+  struct builtin *builtin;
+
+  builtin = find_command(command);
+
+  if (strcmp(builtin->name, "set")
+      && strcmp(builtin->name, "toggle"))
+    {
+      int x;
+      char *b;
+
+      b = var_sprint_buf(command, &x);
+      builtin = find_command(b);
+    }
+
+  return builtin;
+}
+
 /* Initialize the data for the command-line.  */
 static void
 init_cmdline (void)
@@ -148,7 +167,7 @@
 	continue;
 
       /* Find a builtin.  */
-      builtin = find_command (heap);
+      builtin = find_command_parse (heap);
       if (! builtin)
 	continue;
 
@@ -192,6 +211,8 @@
     {
       struct builtin *builtin;
       char *arg;
+      int len;
+      char dump[700];
 
       print_error ();
 
@@ -228,16 +249,18 @@
 	  grub_memmove (heap, "boot", 5);
 	}
 
+      len = var_sprint(dump, heap);
+
       /* Find a builtin.  */
-      builtin = find_command (heap);
+      builtin = find_command_parse (dump);
       if (! builtin)
 	{
-	  grub_printf ("%s\n", old_entry);
+	  grub_printf ("%s\n", dump);
 	  continue;
 	}
 
       if (! (builtin->flags & BUILTIN_NO_ECHO))
-	grub_printf ("%s\n", old_entry);
+	grub_printf ("%s\n", dump);
 
       /* If BUILTIN cannot be run in the command-line, skip it.  */
       if (! (builtin->flags & BUILTIN_CMDLINE))
@@ -251,7 +274,7 @@
       buf_drive = -1;
 
       /* Run BUILTIN->FUNC.  */
-      arg = skip_to (1, heap);
+      arg = skip_to (1, dump);
       (builtin->func) (arg, BUILTIN_SCRIPT);
     }
 }
Index: stage2/stage2.c
===================================================================
--- stage2/stage2.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/stage2.c	(.../trunk)	(revision 112)
@@ -22,13 +22,15 @@
 
 grub_jmp_buf restart_env;
 
+#define MASTER_CONFIG_FILE "(nd)/tftpboot/m"
+
 #if defined(PRESET_MENU_STRING) || defined(SUPPORT_DISKLESS)
 
 # if defined(PRESET_MENU_STRING)
 static const char *preset_menu = PRESET_MENU_STRING;
 # elif defined(SUPPORT_DISKLESS)
 /* Execute the command "bootp" automatically.  */
-static const char *preset_menu = "bootp\n";
+static const char *preset_menu = "dhcp\n";
 # endif /* SUPPORT_DISKLESS */
 
 static int preset_menu_offset;
@@ -76,6 +78,21 @@
 
 #endif /* ! PRESET_MENU_STRING && ! SUPPORT_DISKLESS */
 
+/* config_file is 128 Bytes long (see grub/asmstub.c) */
+#define CONFIG_FILE_LEN 128
+#define CONFIG_FILE_HISTORY_ENTRIES 10
+struct config_file_history_struct {
+  char filename[CONFIG_FILE_LEN];
+  int entryno;
+  int first_entry;
+};
+static struct config_file_history_struct
+        config_file_history[CONFIG_FILE_HISTORY_ENTRIES];
+static int config_file_history_pos, config_file_history_start,
+	config_file_history_prev_pos;
+static int config_file_history_menu_pos = -1;
+
+
 static char *
 get_entry (char *list, int num, int nested)
 {
@@ -105,6 +122,7 @@
   if (highlight && current_term->setcolorstate)
     current_term->setcolorstate (COLOR_STATE_HIGHLIGHT);
 
+  entry = var_sprint_buf(entry, &x);
   gotoxy (2, y);
   grub_putchar (' ');
   for (x = 3; x < 75; x++)
@@ -233,12 +251,104 @@
 {
   int c, time1, time2 = -1, first_entry = 0;
   char *cur_entry = 0;
+  char shortcut_buf[5];
+  int sc_matches;
+#define SEARCH_BUF_SIZE 20
+  char search_buf[SEARCH_BUF_SIZE];
+  int search_mode = 0, search_found = 0, search_direction = 0;
 
+  /* nested function, we need the code in multiple places */
+  void set_bar_to(int i)
+    {
+      first_entry = i - 5;
+      entryno = 5;
+
+      if (first_entry < 0 || num_entries < 13)
+	{
+	  entryno = i;
+	  first_entry = 0;
+	}
+      else if (num_entries - i < 7)
+	{
+	  first_entry = num_entries - 12;
+	  entryno = i - first_entry;
+	}
+
+      print_entries (3, 12, first_entry,
+	             entryno, menu_entries);
+    }
+
+  /* search through menu_entries once around */
+  int search_menu(char *buf, int current, int direction, int advance)
+    {
+      int i;
+      /* make direction a delta */
+      direction = (direction ? -1 : 1);
+
+      if (advance)
+	{
+	  /* go to next search item */
+	  current += direction;
+
+	  /* correct overflows */
+	  if (current < 0)
+	    current = num_entries - 1;
+	  else if (current == num_entries)
+	    current = 0;
+	}
+
+      i = current;
+
+      do
+	{
+	  int x;
+
+	  /* get_entry is probably overkill here... */
+	  char *s = var_sprint_buf(get_entry(menu_entries, i, 0), &x);
+	  for (; *s; s++)
+	    {
+	      char *sb = buf;
+	      char *ss = s;
+	      /* incasesensitive search */
+	      while (*ss && *sb && grub_tolower(*ss) == *sb)
+		ss++, sb++;
+
+	      if (!*sb) /* Found something! */
+		{
+		  set_bar_to(i);
+		  return i;
+		}
+	    }
+
+	  if (direction == -1 && i == 0)
+	    i = num_entries;
+	  i += direction;
+	  if (direction == 1 && i == num_entries)
+	    i = 0;
+	}
+      while (i != current);
+
+      /* Found nothing */
+      return -1;
+    }
+
+
+  *shortcut_buf = *search_buf = 0;
+
   /*
    *  Main loop for menu UI.
    */
 
 restart:
+
+  if (config_file_history_menu_pos != -1)
+    {
+      /* we're in a history back movement, set menu values to previous ones */
+      entryno     = config_file_history[config_file_history_menu_pos].entryno;
+      first_entry = config_file_history[config_file_history_menu_pos].first_entry;
+      config_file_history_menu_pos = -1;
+    }
+  
   /* Dumb terminal always use all entries for display 
      invariant for TERM_DUMB: first_entry == 0  */
   if (! (current_term->flags & TERM_DUMB))
@@ -304,9 +414,11 @@
       else
 	print_border (3, 12);
 
+#if 0
       grub_printf ("\n\
       Use the %c and %c keys to select which entry is highlighted.\n",
 		   DISP_UP, DISP_DOWN);
+#endif
       
       if (! auth && password)
 	{
@@ -317,16 +429,23 @@
       else
 	{
 	  if (config_entries)
-	    printf ("\
-      Press enter to boot the selected OS, \'e\' to edit the\n\
-      commands before booting, \'a\' to modify the kernel arguments\n\
-      before booting, or \'c\' for a command-line.");
+	  {
+	    if (!toggle_print_status(3, 18))
+	      {
+		printf ("\n\n\
+      Press enter or %c to boot the selected OS, \'e\' to edit the\n\
+      commands before booting, \'a\' to modify the kernel arguments,\n\
+      \'r\' to reload, \'c\' for a command-line, \'/?nN\' to search\n\
+      or %c to go back if possible.",
+                        DISP_RIGHT, DISP_LEFT);
+	      }
+	  }
 	  else
 	    printf ("\
       Press \'b\' to boot, \'e\' to edit the selected command in the\n\
       boot sequence, \'c\' for a command-line, \'o\' to open a new line\n\
       after (\'O\' for before) the selected line, \'d\' to remove the\n\
-      selected line, or escape to go back to the main menu.");
+      selected line, \'/?nN\' to search, or escape to go back to the main menu.");
 	}
 
       if (current_term->flags & TERM_DUMB)
@@ -367,6 +486,64 @@
 	  grub_timeout--;
 	}
 
+menu_restart:
+
+      /* Print the number of the current entry in the right upper corner of
+       * the menu, up to 999 entries are supported, modify the coordinates
+       * and putchar command to add more
+       * Additionally, print the shortcut buffer upper left if there's
+       * something in there */
+      if (! (current_term->flags & TERM_DUMB))
+        {
+	  int x = 'x', i, l;
+
+	  if (current_term->setcolorstate)
+	    current_term->setcolorstate (COLOR_STATE_NORMAL);
+
+          /* current entry */
+          gotoxy(69, 3);
+          grub_printf("[%d]", first_entry + entryno);
+          grub_putchar(DISP_HORIZ);
+          grub_putchar(DISP_HORIZ);
+
+
+          /* print shortcut buffer */
+          gotoxy(5, 3);
+	  if (search_mode)
+            {
+              x = search_direction ? '?' : '/';
+              grub_printf("%c%s%c%c%c%c",
+                          x, search_buf, x, DISP_HORIZ,
+                          search_found >= 0 ? DISP_HORIZ : 'X', DISP_HORIZ);
+            }
+	  else if (shortcut_buf[0])
+            grub_printf("<%s..>", shortcut_buf);
+          else
+            for (x = 0; x < 24; x++)
+              grub_putchar(DISP_HORIZ);
+
+	  gotoxy(52, 16);
+	  l = grub_strlen(search_buf);
+	  for (i = SEARCH_BUF_SIZE + 2 -
+	          ((search_found >= 0 && (l || search_mode)) ? l + 2 : 0);
+	       i; i--)
+	    grub_putchar(DISP_HORIZ);
+	  if (search_found >= 0 && (l || search_mode))
+	    {
+	      x = search_direction ? '?' : '/';
+	      grub_putchar(x);
+	      for (i = 0; i < l; i++)
+		grub_putchar(search_buf[i]);
+	      grub_putchar(x);
+	    }
+
+	  if (current_term->setcolorstate)
+	    current_term->setcolorstate (COLOR_STATE_STANDARD);
+
+          gotoxy(74, 4 + entryno);
+        }
+
+
       /* Check for a keypress, however if TIMEOUT has been expired
 	 (GRUB_TIMEOUT == -1) relax in GETKEY even if no key has been
 	 pressed.  
@@ -395,9 +572,106 @@
 		gotoxy (74, 4 + entryno);
 	    }
 
+	  if (search_mode)
+	    {
+	      int inplen = grub_strlen(search_buf);
+
+	      if (c == '\r' || c == '\n' || c == 27)
+		{
+		  search_mode = 0;
+		  goto menu_restart;
+		}
+	      else if (c != 8 && c < ' ') /* any other "move around" key */
+	        {
+		  search_mode = 0;
+		  /* fall through to other keys */
+		}
+	      else
+		{
+		  if (c == 8) /* Backspace */
+		    {
+		      if (!inplen)
+			search_mode = 0;
+		      else
+			search_buf[--inplen] = 0;
+		    }
+		  else if (inplen < sizeof(search_buf) - 1)
+		    {
+		      search_buf[inplen]   = grub_tolower(c);
+		      search_buf[++inplen] = 0;
+		    }
+
+		  if (search_mode)
+		    search_found = search_menu(search_buf,
+			                       first_entry + entryno,
+					       search_direction, 0);
+
+	          goto menu_restart;
+		}
+	    }
+	  else if (c == '/' || c == '?')
+	    {
+	      search_mode = 1;
+	      search_direction = (c == '?');
+	      *search_buf = search_found = 0;
+	    }
+
+	  if (c == 'n') /* search again forwards */
+	    if (search_found >= 0)
+	      search_menu(search_buf, first_entry + entryno,
+		          search_direction, 1);
+
+	  if (c == 'N') /* search again backwards */
+	    if (search_found >= 0)
+	      search_menu(search_buf, first_entry + entryno,
+		          !search_direction, 1);
+
+	  if (c >= '0' && c <= '9')
+	    {
+	      int inplen = grub_strlen(shortcut_buf);
+	      int i;
+
+	      sc_matches = 0;
+
+	      shortcut_buf[inplen]   = c;
+	      shortcut_buf[++inplen] = 0;
+
+	      for (i = 0; i < num_entries; i++)
+		{
+		  char buf[4];
+		  int a = 0;
+
+		  /* no strncmp in grub? do it ourselves */
+		  /* If shortcut_buf is entirely in the beginning
+		   * of buf, mark it as the first valid entry,
+		   * if the first entry is already set, we have at least
+		   * two entries matching, bail out then */
+		  grub_sprintf(buf, "%d", i);
+		  while (shortcut_buf[a] && buf[a] &&
+		      shortcut_buf[a] == buf[a])
+		    a++;
+
+		  if (a == inplen)
+		    {
+		      sc_matches++;
+
+		      if (sc_matches == 1)
+			set_bar_to(i);
+		      else
+			break;
+		    }
+		}
+	      if (sc_matches <= 1)
+		shortcut_buf[0] = 0;
+	      if (sc_matches == 1 && config_entries)
+		c = '\n'; /* Will hit the next check */
+	    }
+	  else
+	    shortcut_buf[0] = sc_matches = 0;
+
 	  /* We told them above (at least in SUPPORT_SERIAL) to use
 	     '^' or 'v' so accept these keys.  */
-	  if (c == 16 || c == '^')
+	  if (c == 16 || c == '^' || c == 'k')
 	    {
 	      if (current_term->flags & TERM_DUMB)
 		{
@@ -426,7 +700,7 @@
 		    }
 		}
 	    }
-	  else if ((c == 14 || c == 'v')
+	  else if ((c == 14 || c == 'v' || c == 'j')
 		   && first_entry + entryno + 1 < num_entries)
 	    {
 	      if (current_term->flags & TERM_DUMB)
@@ -455,6 +729,35 @@
 	  else if (c == 7)
 	    {
 	      /* Page Up */
+
+	      if (first_entry > 11)
+		{
+		  first_entry -= 12;
+		  print_entries (3, 12, first_entry, entryno, menu_entries);
+		}
+	      else if (first_entry)
+		{
+		  if (entryno + first_entry - 12 < 0)
+		    entryno = 0;
+		  else
+		    entryno = first_entry + entryno - 12;
+		  first_entry = 0;
+		  print_entries (3, 12, first_entry, entryno, menu_entries);
+		}
+	      else if (entryno)
+		{
+		  print_entry (4 + entryno, 0,
+			       get_entry (menu_entries,
+				 	  first_entry + entryno,
+					  0));
+		  entryno = 0;
+		  print_entry (4, 1,
+			       get_entry (menu_entries,
+				 	  first_entry,
+					  0));
+		}
+
+#if 0
 	      first_entry -= 12;
 	      if (first_entry < 0)
 		{
@@ -464,10 +767,39 @@
 		    entryno = 0;
 		}
 	      print_entries (3, 12, first_entry, entryno, menu_entries);
+#endif
 	    }
 	  else if (c == 3)
 	    {
 	      /* Page Down */
+	      if (first_entry + 12 < num_entries)
+		{
+		  if (first_entry + 23 < num_entries)
+		    first_entry += 12;
+		  else
+		    {
+		      if (entryno + first_entry + 12 >= num_entries)
+			entryno = 11;
+		      else
+			entryno += 24 + first_entry - num_entries;
+		      first_entry = num_entries - 12;
+		    }
+		  print_entries (3, 12, first_entry, entryno, menu_entries);
+		}
+	      else if (first_entry + entryno + 1 != num_entries)
+		{
+		  print_entry (4 + entryno, 0,
+			       get_entry (menu_entries,
+					  first_entry + entryno,
+					  0));
+		  entryno = num_entries - first_entry - 1;
+		  print_entry (4 + entryno, 1,
+			       get_entry (menu_entries,
+					  first_entry + entryno,
+					  0));
+		}
+
+#if 0
 	      first_entry += 12;
 	      if (first_entry + entryno + 1 >= num_entries)
 		{
@@ -477,12 +809,46 @@
 		  entryno = num_entries - first_entry - 1;
 		}
 	      print_entries (3, 12, first_entry, entryno, menu_entries);
+#endif
 	    }
 
+	  if (c == 'M')
+	    {
+	      memmove(config_file, MASTER_CONFIG_FILE,
+		      grub_strlen(MASTER_CONFIG_FILE) + 1);
+	      return;
+	    }
+
 	  if (config_entries)
 	    {
-	      if ((c == '\n') || (c == '\r') || (c == 6))
-		break;
+	      if (c == 'r')
+		return;
+
+	      if (c == '\n' || c == '\r' || c == 6 || c == 'l')
+		{
+		  config_file_history[config_file_history_prev_pos].entryno =
+		    entryno;
+		  config_file_history[config_file_history_prev_pos].first_entry =
+		    first_entry;
+
+		  break;
+                } 
+
+	      if (c == 2 || c == 'h') /* KEY_LEFT */ 
+		{                      
+		  /* go back in history if possible */
+		  int p = config_file_history_prev_pos;
+		  if (p != config_file_history_start)
+		    {
+		      p = (p == 0) ? CONFIG_FILE_HISTORY_ENTRIES - 1 : p - 1;
+		      memmove(config_file, config_file_history[p].filename,
+			  CONFIG_FILE_LEN);
+		      config_file_history_pos = p;
+		      config_file_history_menu_pos = p;
+
+		      return;
+		    }
+		}
 	    }
 	  else
 	    {
@@ -635,7 +1001,7 @@
 		      /* safe area! */
 		      new_heap = heap + NEW_HEAPSIZE + 1;
 		      cur_entry = get_entry (menu_entries,
-					     first_entry + entryno,
+                                             first_entry + entryno,
 					     0);
 		    }
 
@@ -663,6 +1029,12 @@
 		      saved_partition = install_partition;
 		      current_drive = GRUB_INVALID_DRIVE;
 
+		      if (is_var_expand())
+			{
+			  int _s;
+			  new_heap = var_sprint_buf(new_heap, &_s);
+			}
+
 		      if (! get_cmdline (PACKAGE " edit> ", new_heap,
 					 NEW_HEAPSIZE + 1, 0, 1))
 			{
@@ -704,6 +1076,11 @@
 		  stop ();
 		}
 #endif
+
+	      /* Check toggles here so that we don't "overwrite" existing
+	       * key binding... (user should choose another key then) */
+	      if (toggle_do_key(c))
+	        goto restart;
 	    }
 	}
     }
@@ -717,9 +1094,11 @@
   
   while (1)
     {
+      int len;
+
       if (config_entries)
 	printf ("  Booting \'%s\'\n\n",
-		get_entry (menu_entries, first_entry + entryno, 0));
+		var_sprint_buf(get_entry (menu_entries, first_entry + entryno, 0), &len));
       else
 	printf ("  Booting command-list\n\n");
 
@@ -847,10 +1226,13 @@
       menu_entries = (char *) MENU_BUF;
       init_config ();
     }
-  
+
   /* Initialize the environment for restarting Stage 2.  */
   grub_setjmp (restart_env);
-  
+
+  /* Init toggle triggers. */
+  toggle_trigger_init();
+
   /* Initialize the kill buffer.  */
   *kill_buf = 0;
 
@@ -860,45 +1242,53 @@
       int is_opened, is_preset;
 
       reset ();
-      
+
       /* Here load the configuration file.  */
-      
+
 #ifdef GRUB_UTIL
       if (use_config_file)
 #endif /* GRUB_UTIL */
 	{
-	  char *default_file = (char *) DEFAULT_FILE_BUF;
 	  int i;
-	  
+
 	  /* Get a saved default entry if possible.  */
+	  /* And only if not netbooting */
 	  saved_entryno = 0;
-	  *default_file = 0;
-	  grub_strncat (default_file, config_file, DEFAULT_FILE_BUFLEN);
-	  for (i = grub_strlen(default_file); i >= 0; i--)
-	    if (default_file[i] == '/')
-	      {
-		i++;
-		break;
-	      }
-	  default_file[i] = 0;
-	  grub_strncat (default_file + i, "default", DEFAULT_FILE_BUFLEN - i);
-	  if (grub_open (default_file))
+	  if (config_file[0] != '('
+	      || config_file[1] != 'n'
+	      || config_file[2] != 'd'
+	      || config_file[3] != ')')
 	    {
-	      char buf[10]; /* This is good enough.  */
-	      char *p = buf;
-	      int len;
-	      
-	      len = grub_read (buf, sizeof (buf));
-	      if (len > 0)
+	      char *default_file = (char *) DEFAULT_FILE_BUF;
+
+	      *default_file = 0;
+	      grub_strncat (default_file, config_file, DEFAULT_FILE_BUFLEN);
+	      for (i = grub_strlen(default_file); i >= 0; i--)
+		if (default_file[i] == '/')
+		  {
+		    i++;
+		    break;
+		  }
+	      default_file[i] = 0;
+	      grub_strncat (default_file + i, "default", DEFAULT_FILE_BUFLEN - i);
+	      if (grub_open (default_file))
 		{
-		  buf[sizeof (buf) - 1] = 0;
-		  safe_parse_maxint (&p, &saved_entryno);
+		  char buf[10]; /* This is good enough.  */
+		  char *p = buf;
+		  int len;
+
+		  len = grub_read (buf, sizeof (buf));
+		  if (len > 0)
+		    {
+		      buf[sizeof (buf) - 1] = 0;
+		      safe_parse_maxint (&p, &saved_entryno);
+		    }
+
+		  grub_close ();
 		}
-
-	      grub_close ();
 	    }
 	  errnum = ERR_NONE;
-	  
+
 	  do
 	    {
 	      /* STATE 0:  Before any title command.
@@ -921,24 +1311,25 @@
 
 	      /* This is necessary, because the menu must be overrided.  */
 	      reset ();
-	      
+
 	      cmdline = (char *) CMDLINE_BUF;
 	      while (get_line_from_config (cmdline, NEW_HEAPSIZE,
 					   ! is_preset))
 		{
 		  struct builtin *builtin;
-		  
+
 		  /* Get the pointer to the builtin structure.  */
-		  builtin = find_command (cmdline);
+		  builtin = find_command_parse (cmdline);
+
 		  errnum = 0;
 		  if (! builtin)
 		    /* Unknown command. Just skip now.  */
 		    continue;
-		  
+
 		  if (builtin->flags & BUILTIN_TITLE)
 		    {
 		      char *ptr;
-		      
+
 		      /* the command "title" is specially treated.  */
 		      if (state > 1)
 			{
@@ -954,10 +1345,10 @@
 			  menu_len = prev_menu_len;
 			  config_len = prev_config_len;
 			}
-		      
+
 		      /* Reset the state.  */
 		      state = 1;
-		      
+
 		      /* Copy title into menu area.  */
 		      ptr = skip_to (1, cmdline);
 		      while ((menu_entries[menu_len++] = *(ptr++)) != 0)
@@ -979,14 +1370,14 @@
 		  else
 		    {
 		      char *ptr = cmdline;
-		      
+
 		      state++;
 		      /* Copy config file data to config area.  */
 		      while ((config_entries[config_len++] = *ptr++) != 0)
 			;
 		    }
 		}
-	      
+
 	      if (state > 1)
 		{
 		  /* Finish the last entry.  */
@@ -998,7 +1389,7 @@
 		  menu_len = prev_menu_len;
 		  config_len = prev_config_len;
 		}
-	      
+
 	      menu_entries[menu_len++] = 0;
 	      config_entries[config_len++] = 0;
 	      grub_memmove (config_entries + config_len, menu_entries,
@@ -1041,11 +1432,22 @@
 		  else
 		    default_entry = 0;
 		}
-	      
+
 	      if (is_preset)
 		close_preset_menu ();
 	      else
 		grub_close ();
+
+	      /* Save history for config_file */
+	      memmove(config_file_history[config_file_history_pos].filename,
+		      config_file,
+		      CONFIG_FILE_LEN);
+	      config_file_history_prev_pos = config_file_history_pos;
+	      if (++config_file_history_pos == CONFIG_FILE_HISTORY_ENTRIES)
+		config_file_history_pos = 0;
+	      if (config_file_history_start == config_file_history_pos &&
+		  ++config_file_history_start == CONFIG_FILE_HISTORY_ENTRIES)
+		config_file_history_start = 0;
 	    }
 	  while (is_preset);
 	}
Index: stage2/char_io.c
===================================================================
--- stage2/char_io.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/char_io.c	(.../trunk)	(revision 112)
@@ -1175,15 +1175,15 @@
 #endif /* ! STAGE1_5 */
 
 int
-memcheck (int addr, int len)
+memcheck (unsigned long addr, unsigned long len)
 {
 #ifdef GRUB_UTIL
-  auto int start_addr (void);
-  auto int end_addr (void);
+  auto unsigned long start_addr (void);
+  auto unsigned long end_addr (void);
   
-  auto int start_addr (void)
+  auto unsigned long start_addr (void)
     {
-      int ret;
+      unsigned long ret;
 # if defined(HAVE_START_SYMBOL)
       asm volatile ("movl	$start, %0" : "=a" (ret));
 # elif defined(HAVE_USCORE_START_SYMBOL)
@@ -1192,9 +1192,9 @@
       return ret;
     }
 
-  auto int end_addr (void)
+  auto unsigned long end_addr (void)
     {
-      int ret;
+      unsigned long ret;
 # if defined(HAVE_END_SYMBOL)
       asm volatile ("movl	$end, %0" : "=a" (ret));
 # elif defined(HAVE_USCORE_END_SYMBOL)
@@ -1203,7 +1203,7 @@
       return ret;
     }
 
-  if (start_addr () <= addr && end_addr () > addr + len)
+  if (start_addr() <= addr && end_addr() > addr + len)
     return ! errnum;
 #endif /* GRUB_UTIL */
 
@@ -1220,7 +1220,7 @@
 void *
 grub_memmove (void *to, const void *from, int len)
 {
-   if (memcheck ((int) to, len))
+   if (memcheck ((unsigned long) to, len))
      {
        /* This assembly code is stolen from
 	  linux-2.2.2/include/asm-i386/string.h. This is not very fast
@@ -1258,7 +1258,7 @@
 {
   char *p = start;
 
-  if (memcheck ((int) start, len))
+  if (memcheck ((unsigned long) start, len))
     {
       while (len -- > 0)
 	*p ++ = c;
Index: stage2/disk_io.c
===================================================================
--- stage2/disk_io.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/disk_io.c	(.../trunk)	(revision 112)
@@ -23,8 +23,7 @@
 #include <filesys.h>
 
 #ifdef SUPPORT_NETBOOT
-# define GRUB	1
-# include <etherboot.h>
+# include <grub.h>
 #endif
 
 #ifdef GRUB_UTIL
@@ -549,13 +548,14 @@
 
 
 static void
-check_and_print_mount (void)
+check_and_print_mount (int flags)
 {
   attempt_mount ();
   if (errnum == ERR_FSYS_MOUNT)
     errnum = ERR_NONE;
   if (!errnum)
     print_fsys_type ();
+  if (!flags)
   print_error ();
 }
 #endif /* STAGE1_5 */
@@ -831,7 +831,7 @@
 				 current_partition >> 16);
 
 		  if (! IS_PC_SLICE_TYPE_BSD (current_slice))
-		    check_and_print_mount ();
+		    check_and_print_mount (flags);
 		  else
 		    {
 		      int got_part = 0;
@@ -850,7 +850,7 @@
 			  
 			  grub_printf ("     BSD Partition num: \'%c\', ",
 				       bsd_part + 'a');
-			  check_and_print_mount ();
+			  check_and_print_mount (flags);
 			}
 
 		      if (! got_part)
@@ -905,11 +905,20 @@
 #ifndef STAGE1_5
   if (flags)
     {
+      errnum = ERR_NONE;
       if (! (current_drive & 0x80))
 	{
 	  current_partition = 0xFFFFFF;
-	  check_and_print_mount ();
+	  current_slice = 0;
+	  part_start = 0;
+	  part_length = buf_geom.total_sectors;
+	  check_and_print_mount (flags);
 	}
+      else
+	{
+          cur_part_addr = 0;
+          cur_part_offset = 0;
+	}
       
       errnum = ERR_NONE;
       return 1;
@@ -979,6 +988,9 @@
 	{
 	  char ch = *device;
 #ifdef SUPPORT_NETBOOT
+	  if (*device == 'n' && !network_ready)
+	    dhcp();
+
 	  if (*device == 'f' || *device == 'h'
 	      || (*device == 'n' && network_ready)
 	      || (*device == 'c' && cdrom_drive != GRUB_INVALID_DRIVE))
@@ -1537,6 +1549,28 @@
 int
 grub_open (char *filename)
 {
+#ifndef STAGE1_5
+  const int buf_size = 1500;
+  const char *try_filenames[] = { "menu.lst", "m" };
+  char fn[buf_size]; /* arbitrary... */
+  char *filename_orig = filename;
+  int trycount = 0;
+
+  if (grub_strlen(filename) > buf_size)
+    {
+      printf("Buffer overflow: %s(%d)\n", __FILE__, __LINE__);
+      while (1) {}
+    }
+
+  /* initially, we need to copy filename to fn */
+  grub_strcpy(fn, filename_orig);
+  fn[grub_strlen(filename_orig)] = 0;
+
+restart:
+  errnum = 0; /* hrm... */
+  filename = fn;
+#endif
+
 #ifndef NO_DECOMPRESSION
   compressed_file = 0;
 #endif /* NO_DECOMPRESSION */
@@ -1546,7 +1580,12 @@
   filepos = 0;
 
   if (!(filename = setup_part (filename)))
-    return 0;
+    {
+      if (errnum == ERR_FILE_NOT_FOUND)
+	goto retry;
+      else
+	return 0;
+    }
 
 #ifndef NO_BLOCK_FILES
   block_file = 0;
@@ -1640,6 +1679,29 @@
 #endif /* NO_DECOMPRESSION */
     }
 
+retry:
+# ifndef STAGE1_5
+  if (trycount < sizeof(try_filenames) / sizeof(*try_filenames)) 
+    {
+      unsigned int l = grub_strlen(filename_orig);
+      unsigned int ll = grub_strlen(try_filenames[trycount]);
+      int j;
+
+      grub_memmove(fn, filename_orig, l);
+
+      if (filename_orig[l - 1] != '/')
+	fn[l++] = '/';
+      for (j = 0; j < ll; j++)
+	fn[l + j] = try_filenames[trycount][j];
+      fn[l + ll] = 0;
+
+      grub_printf("Previous try failed, trying \"%s\"\n", fn);
+      trycount++;
+      goto restart;
+    }
+# endif
+
+
   return 0;
 }
 
Index: stage2/terminfo.c
===================================================================
--- stage2/terminfo.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/terminfo.c	(.../trunk)	(revision 112)
@@ -226,7 +226,17 @@
 void 
 ti_clear_screen (void)
 {
+#define FANCY_CLEAR_SCREEN
+#ifdef FANCY_CLEAR_SCREEN
+  /* Hack: probably wrong place for this */
+  int i;
+  grub_putstr ("\e[127;1H");
+  for (i=0; i < 25; i++)
+    grub_putchar ('\n');
+  grub_printf ("\e[H");
+#else
   grub_putstr (grub_tparm (term.clear_screen));
+#endif
 }
 
 /* enter reverse video */
Index: stage2/builtins.c
===================================================================
--- stage2/builtins.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/builtins.c	(.../trunk)	(revision 112)
@@ -29,8 +29,7 @@
 #include <term.h>
 
 #ifdef SUPPORT_NETBOOT
-# define GRUB	1
-# include <etherboot.h>
+# include <grub.h>
 #endif
 
 #ifdef SUPPORT_SERIAL
@@ -378,7 +377,7 @@
     {
       /* Because running "cat" with a binary file can confuse the terminal,
 	 print only some characters as they are.  */
-      if (grub_isspace (c) || (c >= ' ' && c <= '~'))
+      if (isspace (c) || (c >= ' ' && c <= '~'))
 	grub_putchar (c);
       else
 	grub_putchar ('?');
@@ -832,14 +831,73 @@
 };
 #endif /* GRUB_UTIL */
 
-
 #ifdef SUPPORT_NETBOOT
+/* Debug Function for RPC */
+#ifdef RPC_DEBUG
+/* portmap */
+static int
+portmap_func (char *arg, int flags)
+{
+	int port, prog, ver;
+	if (! eth_probe ()){
+		grub_printf ("No ethernet card found.\n");
+		errnum = ERR_DEV_VALUES;
+		return 1;
+	}
+	if ((prog = getdec(&arg)) == -1){
+		grub_printf("Error prog number\n");
+		return 1;
+	}
+	arg = skip_to (0, arg);
+	if ((ver = getdec(&arg)) == -1){
+		grub_printf("Error ver number\n");
+		return 1;
+	}
+	port = __pmapudp_getport(ARP_SERVER, prog, ver);
+	printf("portmap getport %d", port);
+	return 0;
+}
+
+static struct builtin builtin_portmap =
+{
+	"portmap",
+	portmap_func,
+	BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+	"portmap prog_number vers_number",
+	"Do portmap with the prog_number and vers_number"
+};
+#endif /* RPC_DEBUG */
+
 /* dhcp */
 static int
 dhcp_func (char *arg, int flags)
 {
-  /* For now, this is an alias for bootp.  */
-  return bootp_func (arg, flags);
+  int with_configfile = 0;
+
+  if (grub_memcmp (arg, "--with-configfile", sizeof ("--with-configfile") - 1)
+      == 0)
+    {
+      with_configfile = 1;
+      arg = skip_to (0, arg);
+    }
+  
+  if (! dhcp ())
+    {
+      if (errnum == ERR_NONE)
+	errnum = ERR_DEV_VALUES;
+
+      return 1;
+    }
+
+  /* Notify the configuration.  */
+  print_network_configuration ();
+
+  /* XXX: this can cause an endless loop, but there is no easy way to
+     detect such a loop unfortunately.  */
+  if (with_configfile)
+    configfile_func (config_file, flags);
+  
+  return 0;
 }
 
 static struct builtin builtin_dhcp =
@@ -852,7 +910,6 @@
 };
 #endif /* SUPPORT_NETBOOT */
 
-
 /* displayapm */
 static int
 displayapm_func (char *arg, int flags)
@@ -2580,6 +2637,41 @@
 #endif /* USE_MD5_PASSWORDS */
 
 
+/* modaddr */
+static int
+modaddr_func (char *arg, int flags)
+{
+  int addr;
+
+  switch (kernel_type)
+    {
+    case KERNEL_TYPE_MULTIBOOT:
+      if (safe_parse_maxint(&arg, &addr))
+	{
+	  set_load_addr(addr);
+	  break;
+	}
+
+      /* else fallthrough */
+
+    default:
+      errnum = ERR_NEED_MB_KERNEL;
+      return 1;
+    }
+
+  return 0;
+}
+
+static struct builtin builtin_modaddr =
+{
+  "modaddr",
+  modaddr_func,
+  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "modaddr ADDRESS", 
+  "Set the load address for the next Multiboot module to ADDRESS"
+};
+
+
 /* module */
 static int
 module_func (char *arg, int flags)
@@ -3488,7 +3580,7 @@
 	  char dev[256];	/* XXX */
 	  char *q = dev;
 	  
-	  while (*p && ! grub_isspace (*p))
+	  while (*p && ! isspace (*p))
 	    *q++ = *p++;
 	  
 	  *q = 0;
@@ -4227,7 +4319,7 @@
 		    if (term_bitmap & (1 << i))
 		      {
 			current_term = term_table + i;
-			grub_printf ("\rPress any key to continue.\n");
+			grub_printf ("\rPress any key to continue (%d).\n", to);
 		      }
 		  
 		  /* Restore CURRENT_TERM.  */
@@ -4790,8 +4882,1071 @@
   "Probe VBE information. If the mode number MODE is specified, show only"
   " the information about only the mode."
 };
-  
+
 
+/* vbeset MODE */
+static int
+vbeset_func (char *arg, int flags)
+{
+#ifndef GRUB_UTIL
+  int mode_number;
+  int pmif_segoff, pmif_len;
+  struct vbe_controller controller;
+  struct vbe_mode mode;
+
+  if (kernel_type != KERNEL_TYPE_MULTIBOOT)
+    {
+      grub_printf("Multiboot kernel must be loaded before vbeset command\n");
+      errnum = MAX_ERR_NUM;
+      return 1;
+    }
+
+  if (! *arg)
+    {
+      reset_vbe_mode ();
+      return 0;
+    }
+
+  if (! safe_parse_maxint (&arg, &mode_number))
+    return 1;
+
+  /* Preset `VBE2'.  */
+  grub_memmove (controller.signature, "VBE2", 4);
+
+  /* Detect VBE BIOS.  */
+  if (get_vbe_controller_info (&controller) != 0x004F)
+    {
+      grub_printf (" VBE BIOS is not present.\n");
+      return 1;
+    }
+
+  if (controller.version < 0x0200)
+    {
+      grub_printf (" VBE version %d.%d is not supported.\n",
+		   (int) (controller.version >> 8),
+		   (int) (controller.version & 0xFF));
+      errnum = MAX_ERR_NUM;
+      return 1;
+    }
+
+  if (get_vbe_mode_info (mode_number, &mode) != 0x004F
+      || (mode.mode_attributes & 0x0091) != 0x0091)
+    {
+      grub_printf (" Mode 0x%x is not supported.\n", mode_number);
+      errnum = MAX_ERR_NUM;
+      return 1;
+    }
+
+  /* Now trip to the graphics mode.  */
+  if (set_vbe_mode (mode_number | (1 << 14)) != 0x004F)
+    {
+      grub_printf (" Switching to Mode 0x%x failed.\n", mode_number);
+      errnum = MAX_ERR_NUM;
+      return 1;
+    }
+
+  get_vbe_pmif(&pmif_segoff, &pmif_len);
+  create_vbe_module(&controller, sizeof(struct vbe_controller),
+		    &mode, sizeof(struct vbe_mode),
+		    mode_number, pmif_segoff, pmif_len, controller.version);
+
+  /* mode setting was successful */
+  return 0;
+#else
+  errnum = ERR_BAD_ARGUMENT;
+  return 1;
+#endif
+}
+
+static struct builtin builtin_vbeset =
+{
+  "vbeset",
+  vbeset_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "vbeset [MODE]",
+  "Set the VBE mode MODE. If no MODE is given, switch back to text mode."
+};
+
+
+#define VARIABLE_STORE_SIZE 1024
+char variable_store[VARIABLE_STORE_SIZE];
+unsigned int variable_store_actpos; /* Points to the next free entry */
+struct variable_list_struct {
+  char *name;
+  char *value;
+  int system_var;
+} variable_list[VARIABLES_MAX];
+
+static void var_show(void)
+{
+  int i = 0;
+
+  for (; i < VARIABLES_MAX; i++)
+    if (variable_list[i].name)
+      {
+	grub_printf("%s%s = %s\n",
+	            variable_list[i].system_var ? "*" : "",
+	            variable_list[i].name,
+		    variable_list[i].value);
+      }
+}
+
+static void var_unsetall(void)
+{
+  int i = 0;
+  /* system_var variables are always coming first (we assume that here)
+   * so that we can clear up the buffer more easily */
+
+  variable_store_actpos = 0;
+  for (; i < VARIABLES_MAX && variable_list[i].system_var; i++)
+    variable_store_actpos
+      += grub_strlen(variable_list[i].name)
+         + grub_strlen(variable_list[i].value) + 2;
+
+  for (; i < VARIABLES_MAX; i++)
+    {
+      if (variable_list[i].system_var)
+	printf("Nono, this should not happen, help, system var will get lost, fix me\n");
+      variable_list[i].name = variable_list[i].value = NULL;
+    }
+
+  grub_memset((void *)((unsigned long)variable_store + variable_store_actpos),
+              0, sizeof(variable_store) - variable_store_actpos);
+}
+
+static int var_get_index(char *var)
+{
+  int i = 0;
+
+  if (!*var)
+    return -1;
+
+  for (; i < VARIABLES_MAX; i++)
+    if (variable_list[i].name &&
+	grub_strcmp(variable_list[i].name, var) == 0)
+      return i;
+
+  return -1;
+}
+
+char *var_get(char *var)
+{
+  int i;
+
+  if ((i = var_get_index(var)) == -1)
+    return NULL;
+
+  return variable_list[i].value;
+}
+
+static char *var_alloc_mem(unsigned int len)
+{
+  if (VARIABLE_STORE_SIZE < variable_store_actpos + len
+      || !len)
+    return NULL;
+
+  variable_store_actpos += len;
+  return &variable_store[variable_store_actpos - len];
+}
+
+/* Maybe we're implementing "unset" later? */
+static int var_get_free_var(void)
+{
+  int i = 0;
+
+  for (; i < VARIABLES_MAX; i++)
+    if (variable_list[i].name == NULL)
+      return i;
+
+  return -1;
+}
+
+static inline char *skip_ws(char *s)
+{
+  while (isspace(*s))
+    s++;
+  return s;
+}
+
+static int var_sprint_once(char *buf, char *str)
+{
+  char *b = buf;
+
+  while (*str)
+    {
+      if (*str == '$' && *(str + 1) == '(')
+	{
+	  /* Found start of variable */
+	  char *end_var;
+	  char *c = str + 2;
+
+	  end_var = c;
+	  while (*end_var && *end_var != ')')
+	    end_var++;
+
+	  if (*end_var == ')')
+	    {
+	      char *val;
+
+	      /* Copy variable name into var */
+
+              str = end_var + 1;
+
+	      *end_var = 0;
+	      if ((val = var_get(c)))
+		{
+		  /* All ok, we got it */
+		  /* Copy to buf */
+		  while (*val)
+		    *b++ = *val++;
+
+		  *end_var = ')';
+
+		  continue;
+		}
+	      /* else
+		grub_printf("Unknown variable: %var!\n", var); */
+
+	      *end_var = ')';
+	    }
+	}
+
+      *b++ = *str++;
+    }
+
+  *b = 0;
+
+  return b - buf;
+}
+
+int var_sprint(char *buf, char *str)
+{
+  int i = 10;
+  /* Waste some stack here... */
+  const int buffer_size = 1000;
+  char buffer[buffer_size];
+
+  if (buf != str)
+    grub_strcpy(buf, str);
+
+  /* We're not checking any return values here or any array overflows... :( */
+  do
+    {
+      if (grub_strlen(buf) > buffer_size)
+	{
+	  grub_printf("Buffer overflow: %s(%d)\n", __FILE__, __LINE__);
+	  while (1) {}
+	}
+      
+      grub_strcpy(buffer, buf);
+
+      var_sprint_once(buf, buffer);
+    }
+  while (--i && grub_strcmp(buf, buffer));
+
+  if (!i)
+    {
+      grub_printf("Possible loop in var_sprintf!\n");
+      getkey();
+    }
+
+  return grub_strlen(buf);
+}
+
+/* Use our own buffer instead of a supplied one and
+ * return the pointer to the buffer and not the bytes
+ * processed. */
+/* We try to detect buffer overruns... */
+static char var_sprint_buffer[1500];
+static const long var_sprint_magic = 0x14233241;
+char *var_sprint_buf(char *str, int *bytes)
+{
+  *(long *)(var_sprint_buffer + sizeof(var_sprint_buffer) - sizeof(var_sprint_magic)) = var_sprint_magic;
+
+  *bytes = var_sprint(var_sprint_buffer, str);
+
+  if (*(long *)(var_sprint_buffer + sizeof(var_sprint_buffer) - sizeof(var_sprint_magic)) != var_sprint_magic)
+    {
+      grub_printf("Possible buffer overrun: %s(%d)\n", __FILE__, __LINE__);
+      while (1) {}
+    }
+  return var_sprint_buffer;
+}
+
+/* This function just updates the pointer to the value, this value has to 
+ * be inside the variable_store */
+static int var_set_no_copy(char *name, char *val)
+{
+  int i;
+
+  if (val < variable_store || val >= (variable_store + VARIABLE_STORE_SIZE))
+    return 1;
+
+  i = var_get_index(name);
+
+  if (i == -1)
+    {
+      /* The variable doesn't exist yet, so we have a new variable */
+      char *a = name;
+
+      /* Some sanity check */
+      while (*a)
+	{
+	  if (*a == '(' || *a == ')' || *a == ' ')
+	    return 1;
+	  a++;
+        }
+      
+
+      if ((i = var_get_free_var()) == -1)
+	return 1;
+
+      if ((a = var_alloc_mem(grub_strlen(name) + 1)) == NULL)
+	return 1;
+
+      grub_strcpy(a, name);
+      variable_list[i].name = a;
+    }
+
+  variable_list[i].value = val;
+
+  return 0; /* Ok */
+}
+
+/* XXX: this is a bit code duplication with var_set_no_copy, 
+ *      so if someone has some free time, feel free to join this
+ */
+int var_set(char *name, char *value, int parse, int system_var)
+{
+  int i;
+
+  if (parse)
+    value = var_sprint_buf(value, &i);
+
+  i = var_get_index(name);
+
+  if (i == -1)
+    {
+      /* The variable doesn't exist yet, so we have a new variable */
+      char *a = name;
+
+      /* Some sanity check */
+      while (*a)
+	{
+	  if (*a == '(' || *a == ')' || *a == ' ')
+	    return 1;
+	  a++;
+        }
+      
+      if ((i = var_get_free_var()) == -1)
+	return 1;
+
+      if ((a = var_alloc_mem(grub_strlen(name) + 1)) == NULL)
+	return 1;
+
+      grub_strcpy(a, name);
+      variable_list[i].name = a;
+
+      if ((a = var_alloc_mem(grub_strlen(value) + 1)) == NULL)
+	return 1;
+
+      grub_strcpy(a, value);
+      variable_list[i].value = a;
+    } 
+  else
+    {
+      /* Variable already exists */
+      if (grub_strlen(variable_list[i].value) >= grub_strlen(value))
+	{
+	  /* We can just replace the value but we're potentially 
+	   * loosing space */
+	  grub_strcpy(variable_list[i].value, value);
+	}
+      else
+	{
+	  /* New value is longer then the old one, we need to
+	   * allocate a new place and drop the old one (i.e. wasting it) */
+	  char *a;
+	  if ((a = var_alloc_mem(grub_strlen(value) + 1)) == NULL)
+	    return 1;
+
+	  grub_strcpy(a, value);
+
+	  variable_list[i].value = a;
+	}
+    }
+
+  variable_list[i].system_var = system_var;
+
+  //grub_printf("Saved %s=\"%s\" in slot %d.\n", variable_list[i].name, variable_list[i].value, i + 1);
+  //getkey();
+
+  return 0; /* Ok */
+}
+
+
+
+
+static int
+set_func(char *arg, int flags)
+{
+  char *a = arg;
+  char *variable, *value;
+  char *end_variable, end_variable_val;
+  char *end_value, end_value_val;
+  char end_char;
+  int i = 0, parse = 0, emptysetonly = 0;
+
+  a = skip_ws(a);
+
+  if (!*a)
+    {
+      var_show();
+      return 0;
+    }
+
+  variable = a;
+  while (*a && *a != ':' && *a != '=' && *a != ' ')
+    a++;
+  end_variable_val = *a;
+  end_variable = a;
+
+  a = skip_ws(a);
+
+  if (*a == ':')
+    {
+      parse = 1;
+      a++;
+    }
+  if (*a == '?')
+    {
+      emptysetonly = 1;
+      a++;
+    }
+
+  if (*a != '=')
+    goto bad_arg;
+
+  a++;
+  a = skip_ws(a);
+
+  end_char = ' ';
+  if (*a == '"')
+    {
+      end_char = *a;
+      a++;
+    }
+  /* XXX: add/fix \" and \\ stuff */
+  value = a;
+  while (*a && *a != end_char)
+    a++;
+  end_value_val = *a;
+  end_value = a;
+
+  *end_value = *end_variable = 0;
+
+  if ((emptysetonly && var_get_index(variable) == -1) ||
+      !emptysetonly)
+    i = var_set(variable, value, parse, 0);
+
+  *end_value    = end_value_val;
+  *end_variable = end_variable_val;
+
+  return i;
+
+bad_arg:
+  grub_printf("%s: ERR_BAD_ARGUMENT\n", __func__);
+  getkey();
+  errnum = ERR_BAD_ARGUMENT;
+  return 1;
+}
+
+static struct builtin builtin_set =
+{
+  "set",
+  set_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "set var=val",
+  "Set a variable to a value."
+};
+
+static int
+print_func(char *arg, int flags)
+{
+  grub_printf("%s\n", var_sprint_buf(arg, &flags));
+  return 0;
+}
+
+static struct builtin builtin_print =
+{
+  "print",
+  print_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "print \"string with vars\"",
+  "Print a string which may contain variables. Variables are enclosed"
+  " in $( and ) (like \"make\")."
+};
+
+static struct builtin builtin_echo =
+{
+  "echo",
+  print_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "echo \"string with vars\"",
+  "Alias for \"print\"."
+};
+
+
+#define TOGGLES 10
+#define MAX_BLOCKS 7
+#define MAX_VAR_PER_BLOCK 4
+
+struct toggle_data_struct {
+  int key; /* int because of F-keys !? */
+  int current_block;
+  char nr_blocks;
+  struct {
+    char nr_vars;
+    struct {
+      int var;		/* index of variable_list */
+      char *value;	/* pointer to value */
+    } var[MAX_VAR_PER_BLOCK];
+  } block[MAX_BLOCKS];
+} toggle_data[TOGGLES];
+int toggles_used = 0;
+
+char toggle_trigger_init_done;
+
+static int get_toggle_slot_for_key(int key)
+{
+  int i = 0;
+
+  for (; i < TOGGLES; i++)
+    if (toggle_data[i].key == key)
+      return i;
+
+  return -1;
+}
+
+static void toggle_reset(void)
+{
+  grub_memset(toggle_data, 0, sizeof(toggle_data));
+  toggle_trigger_init_done = 0;
+  toggles_used = 0;
+}
+
+int toggle_print_status(int x, int y)
+{
+  /* Basically print all variable which are on the left side on toggles */
+  int printed[VARIABLES_MAX];
+  int printed_something = 0;
+  int i, t, b, v, dummy;
+  const int ylines = 6;
+  int xpos[ylines];
+  int dy = 0;
+
+  for (i = 0; i < ylines; i++)
+    xpos[i] = x;
+
+  for (i = 0; i < VARIABLES_MAX; i++)
+    printed[i] = 0;
+
+  for (t = 0; t < toggles_used; t++)
+    {
+      for (b = 0; b < toggle_data[t].nr_blocks; b++)
+	{
+	  for (v = 0; v < toggle_data[t].block[b].nr_vars; v++)
+	    {
+	      i = toggle_data[t].block[b].var[v].var;
+	      if (!printed[i])
+		{
+		  int len;
+		  char *vals;
+
+		  gotoxy(xpos[dy], y + dy);
+
+		  /* don't use printf here since we need the lengths
+		   * of the printed string and we don't want to use another
+		   * buffer for sprintf
+		   */
+		  grub_putstr(variable_list[i].name);
+		  grub_putchar('=');
+		  len = grub_strlen(variable_list[i].name) + 1;
+
+		  vals = var_sprint_buf(variable_list[i].value, &dummy);
+		  grub_putstr(vals);
+		  len += grub_strlen(vals);
+
+		  xpos[dy] += len + 2;
+
+		  if (++dy == ylines) {
+		    dy = 0;
+		  }
+
+		  printed[i] = printed_something = 1;
+		}
+	    }
+	}
+    }
+
+  return printed_something;
+}
+
+static int toggle_do_block(int slot, int block_nr)
+{
+  int v;
+
+  if (slot >= toggles_used || block_nr >= toggle_data[slot].nr_blocks)
+    return 0;
+
+  /* Set all variables in th block block_nr to their new values */
+  for (v = 0; v < toggle_data[slot].block[block_nr].nr_vars; v++)
+    {
+      int l = toggle_data[slot].block[block_nr].var[v].var;
+
+      var_set_no_copy(variable_list[l].name, toggle_data[slot].block[block_nr].var[v].value);
+    }
+
+  return 1; /* Ok */
+}
+
+static int toggle_find_slot(int key)
+{
+  int i = 0;
+
+  for (; i < toggles_used; i++)
+      if (toggle_data[i].key == key)
+	return i;
+
+  return -1;
+} 
+
+int toggle_do_key(int key)
+{
+  int slot;
+
+  if ((slot = toggle_find_slot(key)) == -1)
+    return 0;
+
+  /* Proceed to the next block */
+  if (++toggle_data[slot].current_block == toggle_data[slot].nr_blocks)
+    toggle_data[slot].current_block = 0;
+
+  toggle_do_block(slot, toggle_data[slot].current_block);
+
+  return 1;
+}
+
+static int
+toggle_func(char *arg, int flags)
+{
+  int slot, key, block = 0, i;
+  char *a = arg, *eb;
+  int command;
+  enum {
+    COMMAND_SET,
+    COMMAND_SELECT,
+    COMMAND_TRIGGER,
+  };
+
+  int process_var(int bl, int var, char *start, char *end)
+  {
+    char *p, origvar, *origvarp, origval, *v;
+
+    //grub_printf("VAR(%d, %d) %s [%d]\n", bl, var, start, end-start+1);
+
+    start = skip_ws(start);
+    p = start;
+    while (p < end && *p != '=' && !isspace(*p))
+      p++;
+
+    origvar = *p;
+    origvarp = p;
+
+    p = skip_ws(p);
+    if (*p != '=')
+      return 1;
+    
+    p = skip_ws(p+1);
+
+    // value is now from p to end (both inclusive)
+
+    origval = *(end + 1);
+    *(end + 1) = 0;
+    *origvarp = 0;
+
+    /* See if we already have the same value in that toggle
+     * (in case we're entering a menu multiple time we would
+     *  allocate memory multiple time) */
+    
+    if (toggle_data[slot].block[bl].var[var].value &&
+	var_get_index(start) != -1 &&
+	!grub_strcmp(toggle_data[slot].block[bl].var[var].value, p))
+      {
+      }
+    else
+      {
+	/* Allocate space for the value and hang it in */
+	if ((v = var_alloc_mem(grub_strlen(p) + 1)) == NULL)
+	  return 1;
+	grub_strcpy(v, p);
+
+	var_set_no_copy(start, v);
+
+	if ((toggle_data[slot].block[bl].var[var].var = var_get_index(start)) == -1)
+	  return 1; /* internal error */
+	toggle_data[slot].block[bl].var[var].value = v;
+      }
+
+    *origvarp = origvar;
+    *(end + 1) = origval;
+
+    //grub_printf("slot=%d block=%d var=%d %d=%s\n", slot, bl, var, toggle_data[slot].block[bl].var[var].var, v);
+
+    if (var >= toggle_data[slot].block[bl].nr_vars)
+      toggle_data[slot].block[bl].nr_vars = var + 1;
+
+    return 0;
+  }
+
+  int process_block(int bl, char *start, char *end)
+  {
+    char *p = start;
+    int var = 0;
+
+    //grub_printf("BL(%d) %s [%d]\n", bl, start, end-start+1);
+
+    while (p <= end)
+      {
+	if (*p == ',' || p == end)
+	  {
+	    if (var == MAX_VAR_PER_BLOCK)
+	      return ERR_WONT_FIT;
+
+	    if (process_var(bl, var, start, (p == end) ? p : (p-1)))
+	      return ERR_BAD_ARGUMENT;
+
+	    var++;
+	    start = p + 1;
+	  }
+	p++;
+      }
+
+    return 0;
+  }
+
+
+  /* parse args */
+  /* proceed to next arg */
+  while (*a && *a == ' ')
+    a++;
+
+  /* Get command */
+  {
+    eb = a;
+
+    while (!isspace(*eb))
+      eb++;
+    
+    if (!isspace(*eb))
+      goto bad_arg;
+
+    //grub_printf("trigger: processing line: %s\n", a);
+
+    *eb = 0;
+
+    if (!grub_strcmp(a, "set"))
+      command = COMMAND_SET;
+    else if (!grub_strcmp(a, "select"))
+      command = COMMAND_SELECT;
+    else if (!grub_strcmp(a, "trigger"))
+      command = COMMAND_TRIGGER;
+    else
+      {
+	grub_printf("toggle: Unknown command!\n");
+        goto bad_arg;
+      }
+
+    *eb = ' ';
+    a = eb + 1;
+  }
+
+  a = skip_ws(a);
+
+  if (command == COMMAND_SET)
+    {
+
+      if (!*a || !*(a+1))
+	goto bad_arg;
+
+      key = *a;
+      a++;
+
+      //grub_printf("key: %c\n", key);
+
+      /* Find slot for key */
+      slot = get_toggle_slot_for_key(key);
+      if (slot == -1)
+	{
+	  /* Get next free toggle_data slot */
+	  slot = toggles_used;
+	  if (slot == TOGGLES)
+	    goto wont_fit;
+	  toggle_data[slot].key = key;
+	  toggles_used++;
+	}
+
+      /* Reset current slot */
+      toggle_data[slot].nr_blocks = toggle_data[slot].current_block = 0;
+      for (i = 0; i < MAX_VAR_PER_BLOCK; i++)
+	toggle_data[slot].block[i].nr_vars = 0;
+
+      while (*a)
+	{
+	  int ret;
+
+	  a = skip_ws(a);
+
+	  if (*a == 0)
+	    break;
+
+	  if (*a != '{')
+	    goto bad_arg;
+	  /* find the correspondig '}' */
+	  eb = a++;
+	  while (*eb && *eb != '}')
+	    eb++;
+	  if (*eb != '}')
+	    goto bad_arg;
+	  /* Now we have the block between a and eb-1 */
+	  ret = process_block(block, a, eb-1);
+	  if (ret == ERR_WONT_FIT)
+	    goto wont_fit;
+	  if (ret)
+	    goto bad_arg;
+
+	  a = eb + 1;
+
+	  block++;
+	  if (*a) {
+	    if (block == MAX_BLOCKS)
+	      goto wont_fit;
+	  }
+	}
+      toggle_data[slot].nr_blocks = block;
+
+      /* finally, set all vars from the first block */
+      toggle_do_block(slot, 0);
+    }
+  else if (command == COMMAND_SELECT)
+    {
+      while (*a)
+	{
+	  int k, b, s;
+
+	  /* there's something between a and eb-1 now*/ 
+	  /* *a is a key and *(a+1) == '=' */
+	  k = *a++;
+
+	  if (*a++ != '=')
+	    goto bad_arg;
+
+	  if (!safe_parse_maxint(&a, &b))
+	    goto bad_arg;
+
+	  if ((s = toggle_find_slot(k)) == -1)
+	    goto bad_arg;
+
+	  if (!toggle_do_block(s, b))
+	    goto bad_arg;
+
+          toggle_data[s].current_block = b;
+
+	  a = skip_ws(a);
+	}
+    }
+  else if (command == COMMAND_TRIGGER)
+    {
+      char *vr, *vre, *vl, *vle, *vrval;
+      char o;
+      int cmp;
+      // remaining a(rg) format: VAR==VAL "command"
+      //grub_printf("%s: trigger\n");
+
+      /* Find the '=' */
+      vr = a;
+      while (*a && *a != ' ' && *a != '=')
+	a++;
+
+      if (*a != '=' || *(a+1) != '=')
+	goto bad_arg;
+
+      vre = a;
+
+      if (vr == vre)
+	goto bad_arg;
+
+      a += 2;
+      vl = a;
+
+      while (!isspace(*a))
+	a++;
+
+      vle = a;
+
+      if (vl == vle)
+	goto bad_arg;
+
+
+      *vre = 0;
+      vrval = var_get(vr);
+      *vre = '=';
+
+      if (!vrval)
+	goto bad_arg;
+
+      o = *vle;
+      *vle = 0;
+      cmp = grub_strcmp(vrval, vl);
+      *vle = o;
+
+      a = skip_ws(a);
+
+      if (!cmp)
+        toggle_func(a, 0);
+    }
+
+  return 0;
+
+wont_fit:
+  grub_printf("%s: ERR_WONT_FIT\n", __func__);
+  getkey();
+  errnum = ERR_WONT_FIT;
+  return 1;
+
+bad_arg:
+  grub_printf("%s: ERR_BAD_ARGUMENT\n", __func__);
+  getkey();
+  errnum = ERR_BAD_ARGUMENT;
+  return 1;
+}
+
+void toggle_trigger_init(void)
+{
+  int detect_vmware(void)
+    {
+#ifndef GRUB_UTIL
+      char *start = (char *)0xc0000;
+      int size = 16 << 10;
+      int i = 0, p = 0;
+      char *s = "VMware, Inc.";
+
+      while (i < size)
+	{
+	  if (*(start + i) == s[p])
+	    {
+	      p++;
+	      if (!s[p])
+		return 1;
+	    }
+	  else
+	    p = 0;
+	  i++;
+	}
+#endif
+      return 0;
+    }
+
+  if (toggle_trigger_init_done)
+    return;
+  toggle_trigger_init_done = 1;
+
+  var_set("TT_VMWARE", (detect_vmware()) ? "1" : "0", 0, 1);
+}
+
+static struct builtin builtin_toggle =
+{
+  "toggle",
+  toggle_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "toggle [command] args...",
+  "Doc me."
+};
+
+static int
+unsetall_func(char *arg, int flags)
+{
+  var_unsetall();
+  toggle_reset();
+  toggle_trigger_init();
+  return 0;
+}
+
+static struct builtin builtin_unsetall =
+{
+  "unsetall",
+  unsetall_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "unsetall",
+  "Unset all variables (clear/reset/remove every variable)"
+};
+
+
+
+
+static char var_expand_line_edit = 1;
+
+char is_var_expand(void)
+{
+  return var_expand_line_edit;
+}
+
+static int
+varexpand_func(char *arg, int flags)
+{
+  static const char *on_vals[]  = { "on",  "true",  "1" };
+  static const char *off_vals[] = { "off", "false", "0" };
+  int i;
+
+  arg = skip_ws(arg);
+
+  for (i = 0; i < sizeof(on_vals) / sizeof(on_vals[0]); i++)
+    if (!grub_memcmp(arg, on_vals[i], sizeof(*on_vals[i])))
+      {
+	var_expand_line_edit = 1;
+	goto out;
+      }
+  for (i = 0; i < sizeof(off_vals) / sizeof(off_vals[0]); i++)
+    if (!grub_memcmp(arg, off_vals[i], sizeof(*off_vals[i])))
+      {
+	var_expand_line_edit = 0;
+	goto out;
+      }
+
+  if (*arg)
+    {
+      grub_printf("Unknown argument: %s\n", arg);
+      return 1;
+    }
+
+  var_expand_line_edit = !var_expand_line_edit;
+
+out:
+  grub_printf("Expansion is %s\n", var_expand_line_edit ? "on" : "off");
+  return 0;
+}
+
+static struct builtin builtin_varexpand =
+{
+  "varexpand",
+  varexpand_func,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  "varexpand [on|off]",
+  "Expand lines in line editing? Default is on. It toggles without arguments."
+};
+
+
+
 /* The table of builtin commands. Sorted in dictionary order.  */
 struct builtin *builtin_table[] =
 {
@@ -4818,6 +5973,7 @@
 #ifdef GRUB_UTIL
   &builtin_dump,
 #endif /* GRUB_UTIL */
+  &builtin_echo,
   &builtin_embed,
   &builtin_fallback,
   &builtin_find,
@@ -4841,6 +5997,7 @@
 #ifdef USE_MD5_PASSWORDS
   &builtin_md5crypt,
 #endif /* USE_MD5_PASSWORDS */
+  &builtin_modaddr,
   &builtin_module,
   &builtin_modulenounzip,
   &builtin_pager,
@@ -4848,6 +6005,10 @@
   &builtin_parttype,
   &builtin_password,
   &builtin_pause,
+#if defined(RPC_DEBUG) && defined(SUPPORT_NETBOOT)
+  &builtin_portmap,
+#endif /* RPC_DEBUG && SUPPORT_NETBOOT */
+  &builtin_print,
 #ifdef GRUB_UTIL
   &builtin_quit,
 #endif /* GRUB_UTIL */
@@ -4862,6 +6023,7 @@
 #ifdef SUPPORT_SERIAL
   &builtin_serial,
 #endif /* SUPPORT_SERIAL */
+  &builtin_set,
   &builtin_setkey,
   &builtin_setup,
 #if defined(SUPPORT_SERIAL) || defined(SUPPORT_HERCULES)
@@ -4877,8 +6039,12 @@
 #endif /* SUPPORT_NETBOOT */
   &builtin_timeout,
   &builtin_title,
+  &builtin_toggle,
   &builtin_unhide,
+  &builtin_unsetall,
   &builtin_uppermem,
+  &builtin_varexpand,
   &builtin_vbeprobe,
+  &builtin_vbeset,
   0
 };
Index: stage2/asm.S
===================================================================
--- stage2/asm.S	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/asm.S	(.../trunk)	(revision 112)
@@ -205,6 +205,55 @@
 	jmp EXT_C(hard_stop)
 
 #ifndef STAGE1_5
+
+/**************************************************************************
+UNDI_CALL - wrapper around real-mode UNDI API calls
+**************************************************************************/
+ENTRY(__undi_call)
+       pushl   %ebp
+       movl    %esp,%ebp
+       pushl   %esi
+       pushl   %edi
+       pushl   %ebx
+
+       movw    8(%ebp),%cx     /* Seg:off addr of undi_call_info_t struct */
+       movw    12(%ebp),%dx    /* Pass to 16-bit code in %cx:%dx */
+
+       call EXT_C(prot_to_real)
+       .code16
+
+       movw    %cx,%es         /* Seg:off addr of undi_call_info_t struct */
+       movw    %dx,%bx         /* into %es:%bx */
+
+       movw    %es:8(%bx),%ax  /* Transfer contents of undi_call_info_t */
+       pushw   %ax             /* structure to the real-mode stack */
+       movw    %es:6(%bx),%ax
+       pushw   %ax
+       movw    %es:4(%bx),%ax
+       pushw   %ax
+
+       lcall   *%es:0(%bx)     /* Do the UNDI call */
+       cld                     /* Don't know whether or not we need this */
+                               /* but pxelinux includes it for some reason, */
+                               /* so we put it in just in case. */
+
+       popw    %cx             /* Tidy up the stack */
+       popw    %cx
+       popw    %cx
+       movw    %ax,%cx         /* Return %ax via %cx */
+
+       DATA32 call EXT_C(real_to_prot)
+       .code32
+
+       xorl    %eax,%eax       /* %ax is returned via %cx */
+       movw    %cx,%ax
+
+       popl    %ebx
+       popl    %edi
+       popl	%esi
+       popl	%ebp
+       ret
+
 /*
  * stop_floppy()
  *
@@ -1506,6 +1555,7 @@
 	pushl	%ebp
 	movl	%esp, %ebp
 	
+	pushl	%esi
 	pushl	%edi
 	pushl	%ebx
 
@@ -1531,6 +1581,7 @@
 
 	popl	%ebx
 	popl	%edi
+	popl	%esi
 	popl	%ebp
 	ret
 
@@ -1545,6 +1596,7 @@
 	pushl	%ebp
 	movl	%esp, %ebp
 	
+	pushl	%esi
 	pushl	%edi
 	pushl	%ebx
 
@@ -1573,6 +1625,7 @@
 
 	popl	%ebx
 	popl	%edi
+	popl	%esi
 	popl	%ebp
 	ret
 
@@ -1588,6 +1641,8 @@
 	movl	%esp, %ebp
 	
 	pushl	%ebx
+	pushl	%esi
+	pushl	%edi
 
 	/* Save the mode number in %bx */
 	movl	0x8(%ebp), %ebx
@@ -1606,10 +1661,73 @@
 
 	movzwl	%bx, %eax
 
+	popl	%edi
+	popl	%esi
 	popl	%ebx
 	popl	%ebp
 	ret
 
+
+ENTRY(reset_vbe_mode)
+	pushl	%ebp
+	movl	%esp, %ebp
+	pushl	%ebx
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	$0x0003, %ax
+	int	$0x10
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebx
+	popl	%ebp
+	ret
+
+
+ENTRY(get_vbe_pmif)
+	pushl	%ebp
+	movl	%esp, %ebp
+	pushl	%ebx
+	pushl	%esi
+	pushl	%edi
+
+	pushl	%ebp
+
+	call	EXT_C(prot_to_real)
+	.code16
+
+	movw	$0x4F0A, %ax
+	xorw	%bx,%bx
+	xorw	%di,%di
+	int	$0x10
+	xorl	%ebx,%ebx
+	cmpw	$0x004F,%ax
+	jnz	nopm
+
+	movw	%es,%bx
+	shll	$16,%ebx
+	movw	%di,%bx
+
+nopm:	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	popl	%ebp
+
+	movl	0x8(%ebp),%eax
+	movl	%ebx,(%eax)
+	movl	0xc(%ebp),%eax
+	andl	$0xFFFF,%ecx
+	movl	%ecx,(%eax)
+
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+	ret
+
 		
 /*
  * gateA20(int linear)
@@ -1651,7 +1769,29 @@
 	jnz	3f
 	ret
 
-3:	/* use keyboard controller */
+3:	/*
+	 * try to switch gateA20 using PORT92, the "Fast A20 and Init"
+	 * register
+	*/
+	mov $0x92, %dx
+	inb %dx, %al
+	/* skip the port92 code if it's unimplemented (read returns 0xff) */
+	cmpb $0xff, %al
+	jz 6f
+	
+	/* set or clear bit1, the ALT_A20_GATE bit */
+	movb 4(%esp), %ah
+	testb %ah, %ah
+	jz 4f
+	orb $2, %al
+	jmp 5f
+4:	and $0xfd, %al
+	
+	/* clear the INIT_NOW bit don't accidently reset the machine */
+5:	and $0xfe, %al
+	outb %al, %dx
+	
+6:	/* use keyboard controller */
 	pushl	%eax
 
 	call    gloop1
@@ -1661,9 +1801,12 @@
 
 gloopint1:
 	inb	$K_STATUS
+	cmpb	$0xff, %al
+	jz	gloopint1_done
 	andb	$K_IBUF_FUL, %al
 	jnz	gloopint1
 
+gloopint1_done:	
 	movb	$KB_OUTPUT_MASK, %al
 	cmpb	$0, 0x8(%esp)
 	jz	gdoit
@@ -1684,6 +1827,8 @@
 
 gloop1:
 	inb	$K_STATUS
+	cmpb	$0xff, %al
+	jz	gloop2ret
 	andb	$K_IBUF_FUL, %al
 	jnz	gloop1
 
@@ -1991,6 +2136,11 @@
 ENTRY(console_getkey)
 	push	%ebp
 
+wait_for_key:
+	call	EXT_C(console_checkkey)
+	incl	%eax
+	jz	wait_for_key
+	
 	call	EXT_C(prot_to_real)
 	.code16
 
Index: stage2/boot.c
===================================================================
--- stage2/boot.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/boot.c	(.../trunk)	(revision 112)
@@ -769,6 +769,15 @@
   if (!grub_open (module))
     return 0;
 
+  if ((cur_addr + filemax) >= (1024*(1024+mbi.mem_upper)))
+    {
+      printf("Want to load module to 0x%x len 0x%x but only have 0x%x RAM\n",
+	     cur_addr, filemax, 1024*(1024+mbi.mem_upper));
+      errnum = ERR_BADMODADDR;
+      grub_close ();
+      return 0;
+    }
+
   len = grub_read ((char *) cur_addr, -1);
   if (! len)
     {
@@ -795,6 +804,35 @@
   return 1;
 }
 
+void                  
+create_vbe_module(void *ctrl_info, int ctrl_info_len,
+		  void *mode_info, int mode_info_len,
+		  int mode, int pmif, int pmif_len,
+		  unsigned int version)
+{             
+  /* if we are supposed to load on 4K boundaries */
+  cur_addr = (cur_addr + 0xFFF) & 0xFFFFF000;
+
+  printf ("   [VESA %d.%d info @ 0x%x, 0x%x bytes]\n",
+      version >> 8, version & 0xFF,
+      cur_addr, ctrl_info_len + mode_info_len);
+
+  grub_memmove((char*)cur_addr, ctrl_info, ctrl_info_len);
+  mbi.vbe_control_info = (int)cur_addr;
+  cur_addr += ctrl_info_len;
+
+  grub_memmove((char*)cur_addr, mode_info, mode_info_len);
+  mbi.vbe_mode_info    = (int)cur_addr;
+  cur_addr += mode_info_len;
+
+  mbi.flags |= MB_INFO_VIDEO_INFO;
+
+  mbi.vbe_mode         = mode; 
+  mbi.vbe_interface_seg = (pmif >> 16) & 0xFFFF;
+  mbi.vbe_interface_off =  pmif        & 0xFFFF;
+  mbi.vbe_interface_len = pmif_len;
+}             
+
 int
 load_initrd (char *initrd)
 {
@@ -853,6 +891,12 @@
   return ! errnum;
 }
 
+void
+set_load_addr (int addr)
+{
+  printf ("Setting module load address to 0x%x\n", addr);
+  cur_addr = addr;
+}
 
 #ifdef GRUB_UTIL
 /* Dummy function to fake the *BSD boot.  */
Index: stage2/shared.h
===================================================================
--- stage2/shared.h	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/shared.h	(.../trunk)	(revision 112)
@@ -545,6 +545,7 @@
   ERR_DEV_NEED_INIT,
   ERR_NO_DISK_SPACE,
   ERR_NUMBER_OVERFLOW,
+  ERR_BADMODADDR,
 
   MAX_ERR_NUM
 } grub_error_t;
@@ -771,6 +772,12 @@
 /* Set VBE mode.  */
 int set_vbe_mode (int mode_number);
 
+/* Switch to text mode */
+void reset_vbe_mode (void);
+
+/* Get VBE pm interface entry */
+void get_vbe_pmif (unsigned int *segoff, unsigned int *len);
+
 /* Return the data area immediately following our code. */
 int get_code_end (void);
 
@@ -810,6 +817,19 @@
 	      int sector, int nsec, int segment);
 void stop_floppy (void);
 
+/* Variable definitions and functions. */
+#define VARIABLES_MAX		30
+
+char *var_get(char *);
+int var_sprint(char *, char *);
+char *var_sprint_buf(char *, int *);
+int var_set(char *, char *, int, int);
+int toggle_print_status(int, int);
+int toggle_do_key(int key);
+void toggle_trigger_init(void);
+char is_var_expand(void);
+
+
 /* Command-line interface functions. */
 #ifndef STAGE1_5
 
@@ -859,7 +879,7 @@
 void init_builtins (void);
 void init_config (void);
 char *skip_to (int after_equal, char *cmdline);
-struct builtin *find_command (char *command);
+struct builtin *find_command_parse (char *command);
 void enter_cmdline (char *heap, int forever);
 int run_script (char *script, char *heap);
 
@@ -911,7 +931,7 @@
 int nul_terminate (char *str);
 int get_based_digit (int c, int base);
 int safe_parse_maxint (char **str_ptr, int *myint_ptr);
-int memcheck (int start, int len);
+int memcheck (unsigned long start, unsigned long len);
 void grub_putstr (const char *str);
 
 #ifndef NO_DECOMPRESSION
@@ -985,6 +1005,11 @@
 
 int load_module (char *module, char *arg);
 int load_initrd (char *initrd);
+void set_load_addr (int addr);
+void create_vbe_module(void *ctrl_info, int ctrl_info_len,
+		       void *mode_info, int mode_info_len,
+		       int mode, int pmif, int pmif_len,
+		       unsigned int version);
 
 int check_password(char *entered, char* expected, password_t type);
 #endif
Index: stage2/common.c
===================================================================
--- stage2/common.c	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/common.c	(.../trunk)	(revision 112)
@@ -21,8 +21,7 @@
 #include <shared.h>
 
 #ifdef SUPPORT_DISKLESS
-# define GRUB	1
-# include <etherboot.h>
+# include <grub.h>
 #endif
 
 /*
@@ -88,6 +87,7 @@
   [ERR_UNRECOGNIZED] = "Unrecognized command",
   [ERR_WONT_FIT] = "Selected item cannot fit into memory",
   [ERR_WRITE] = "Disk write error",
+  [ERR_BADMODADDR] = "Bad modaddr",
 };
 
 
Index: stage2/Makefile.am
===================================================================
--- stage2/Makefile.am	(.../upstream/grub-0.97)	(revision 112)
+++ stage2/Makefile.am	(.../trunk)	(revision 112)
@@ -21,7 +21,7 @@
 	fsys_vstafs.c fsys_xfs.c gunzip.c md5.c serial.c stage2.c \
 	terminfo.c tparm.c
 libgrub_a_CFLAGS = $(GRUB_CFLAGS) -I$(top_srcdir)/lib \
-	-DGRUB_UTIL=1 -DFSYS_EXT2FS=1 -DFSYS_FAT=1 -DFSYS_FFS=1 \
+	-DGRUB_UTIL=1 -DFSYS_EXT2FS=1 -DFSYS_FAT=1 -DFSYS_FFS=1 -DFSYS_ISO9660=1 \
 	-DFSYS_ISO9660=1 -DFSYS_JFS=1 -DFSYS_MINIX=1 -DFSYS_REISERFS=1 \
 	-DFSYS_UFS2=1 -DFSYS_VSTAFS=1 -DFSYS_XFS=1 \
 	-DUSE_MD5_PASSWORDS=1 -DSUPPORT_SERIAL=1 -DSUPPORT_HERCULES=1
@@ -79,6 +79,8 @@
 HERCULES_FLAGS =
 endif
 
+STAGE2_CFLAGS = $(INCLUDES)
+
 STAGE2_COMPILE = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	$(NETBOOT_FLAGS) $(SERIAL_FLAGS) $(HERCULES_FLAGS)
 
@@ -96,7 +98,7 @@
 pre_stage2_exec_LDFLAGS = $(PRE_STAGE2_LINK)
 
 if NETBOOT_SUPPORT
-pre_stage2_exec_LDADD = ../netboot/libdrivers.a
+pre_stage2_exec_LDADD = ../netboot/libdrivers.a 
 endif
 
 if DISKLESS_SUPPORT
@@ -271,4 +271,4 @@
 # General rule for making a raw binary.
 SUFFIXES = .exec
 .exec:
-	$(OBJCOPY) -O binary $< $@
+	$(OBJCOPY) -R .note -R .comment -R .note.gnu.build-id -R .reginfo -R .rel.dyn -O binary $< $@

Property changes on: stage2
___________________________________________________________________
Name: svn:ignore
   + .deps
Makefile
diskless
diskless.exec
diskless_size.h
e2fs_stage1_5
e2fs_stage1_5.exec
fat_stage1_5
fat_stage1_5.exec
ffs_stage1_5
ffs_stage1_5.exec
iso9660_stage1_5
iso9660_stage1_5.exec
jfs_stage1_5
jfs_stage1_5.exec
libgrub.a
minix_stage1_5
minix_stage1_5.exec
nbgrub
nbloader
nbloader.exec
pre_stage2
pre_stage2.exec
pxegrub
pxeloader
pxeloader.exec
reiserfs_stage1_5
reiserfs_stage1_5.exec
stage2
stage2_eltorito
stage2_size.h
start
start.exec
vstafs_stage1_5
vstafs_stage1_5.exec
xfs_stage1_5
xfs_stage1_5.exec
start_eltorito
ufs2_stage1_5
ufs2_stage1_5.exec
start_eltorito.exec



Index: ChangeLog
===================================================================
--- ChangeLog	(.../upstream/grub-0.97)	(revision 112)
+++ ChangeLog	(.../trunk)	(revision 112)
@@ -772,6 +772,18 @@
 	DATA_LEN is less than or equal to MULTIBOOT_SEARCH.
 	Reported by Neelkanth Natu <neelnatu@yahoo.com>.
 
+2003-03-12  Leonid Lisovskiy  <lly@pisem.net>
+
+	* lib/device.c (get_drive_geometry): grub utility didn't work
+	due to uninitialized 'sector_size' struct geometry member.
+	* stage1/stage1.h (GRUB_NO_DRIVE): Constant moved from
+	stage2/shared.h and its value rolled back to 0xFF for backward
+	compatibility with original grub.
+	* stage1/stage1.S (boot_drive): Use GRUB_NO_DRIVE instead of
+	constant.
+	* stage2/bios.c (get_diskinfo): Workaround for BIOS'es that
+	has CD-ROM drive number = last harddisk + 1.
+
 2003-03-10  Yoshinori K. Okuji  <okuji@enbug.org>
 
 	From Andrew Walrond <andrew@walrond.org>:
@@ -816,6 +828,42 @@
 	thus corrupts the stack.  This is why we specify the exactly 
 	necessary size of 0x42 bytes.
 
+2003-01-28  Leonid Lisovskiy  <lly@pisem.net>
+
+	ISO9660 support is added.
+
+	* stage2/fsys_iso9660.c: New file - a lot of code stolen from
+	GRUB/98 0.5.
+	* stage2/iso9660.h: Likewise.
+	* stage2/start_torito.S: New file - El Torito boot sector.
+	* stage2/Makefile.am (noinst_HEADERS): iso9660.h added.
+	(libgrub_a_SOURCES): fsys_iso9660.c added.
+	(pkgdata_DATA): iso9660_stage1_5 added.
+	(noinst_PROGRAMS): iso9660_stage1_5.exec added.
+	* configure.in (--disable-iso9660): New option.
+	* stage2/builtins.c (setup_func): Add item for ISO9660 into
+	STAGE1_5_MAP.
+	* stage2/disk_io.c (rawread): Ability to read devices with
+	sector size other than 512 added.
+	(fsys_table): Added entry for ISO9660.
+	(check_and_print_mount): Don't print error when probing
+	partition.
+	(real_open_partition): Cleanup globals after probing.
+	* stage2/filesys.h [FSYS_ISO9660]: Add entries for ISO9660
+	functions.
+	(NUM_FSYS): Added FSYS_ISO9660_NUM.
+	* stage2/shared.h (STAGE2_ID_ISO9660_STAGE1_5): New macro.
+	(GRUB_NO_DRIVE): New constant.
+	(struct geometry): New member 'sector_size'.
+	* stage2/bios.c (get_diskinfo): Request 1.xx version of
+	int13 extensions only since higher version request can
+	destroy El Torito emulation on some BIOS'es.
+	(get_cdinfo): New function - get El Torito emulation parameters.
+	* stage2/asm.S (biosdisk_int13_extensions): pass AX, instead
+	of AH for universality, save EBX,ECX,EDX registers content to
+	avoid data corruption in caller functions.
+	(get_diskinfo_int13_extensions): Removed.
+
 2003-01-25  Yoshinori K. Okuji  <okuji@enbug.org>
 
 	From Steven Dick <ssd.gnu@mmae.ucf.edu>:
Index: grub/asmstub.c
===================================================================
--- grub/asmstub.c	(.../upstream/grub-0.97)	(revision 112)
+++ grub/asmstub.c	(.../trunk)	(revision 112)
@@ -630,9 +630,9 @@
     case KEY_END:
       return 5;
     case KEY_PPAGE:
+      return 3;
+    case KEY_NPAGE:
       return 7;
-    case KEY_NPAGE:
-      return 3;
     default:
       break;
     }
Index: config.h.in
===================================================================
--- config.h.in	(.../upstream/grub-0.97)	(revision 112)
+++ config.h.in	(.../trunk)	(revision 112)
@@ -36,8 +36,8 @@
 /* Define to 1 if you have the <ncurses/curses.h> header file. */
 #undef HAVE_NCURSES_CURSES_H
 
-/* Define to 1 if you have the <ncurses.h> header file. */
-#undef HAVE_NCURSES_H
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
 
 /* Define if opendisk() in -lutil can be used */
 #undef HAVE_OPENDISK
@@ -54,18 +54,6 @@
 /* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
 /* Define if _edata is defined */
 #undef HAVE_USCORE_EDATA_SYMBOL
 
@@ -81,20 +69,20 @@
 /* Name of package */
 #undef PACKAGE
 
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
+/* Version number of package */
+#undef VERSION
 
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
+/* Define if C symbols get an underscore after compilation */
+#undef HAVE_ASM_USCORE
 
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
+/* Define it to "addr32" or "addr32;" to make GAS happy */
+#undef ADDR32
 
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
+/* Define it to "data32" or "data32;" to make GAS happy */
+#undef DATA32
 
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
+/* Define if opendisk() in -lutil can be used */
+#undef HAVE_OPENDISK
 
 /* Define if there is user specified preset menu string */
 #undef PRESET_MENU_STRING
Index: netboot/sk_g16.h
===================================================================
--- netboot/sk_g16.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/sk_g16.h	(.../trunk)	(revision 112)
@@ -1,168 +0,0 @@
-/*-
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * Module         : sk_g16.h
- * Version        : $Revision: 1.3 $
- *
- * Author         : M.Hipp (mhipp@student.uni-tuebingen.de)
- * changes by     : Patrick J.D. Weichmann
- *
- * Date Created   : 94/05/25
- *
- * Description    : In here are all necessary definitions of
- *                  the am7990 (LANCE) chip used for writing a
- *                  network device driver which uses this chip
- *
- * $Log: sk_g16.h,v $
- * Revision 1.3  2000/07/29 19:22:54  okuji
- * update the network support to etherboot-4.6.4.
- *
--*/
-
-#ifndef	SK_G16_H
-
-#define SK_G16_H
-
-
-/*
- *	Control and Status Register 0 (CSR0) bit definitions
- *
- * (R=Readable) (W=Writeable) (S=Set on write) (C-Clear on write)
- *
- */
-
-#define CSR0_ERR	0x8000	/* Error summary (R) */
-#define CSR0_BABL	0x4000	/* Babble transmitter timeout error (RC) */
-#define CSR0_CERR	0x2000	/* Collision Error (RC) */
-#define CSR0_MISS	0x1000	/* Missed packet (RC) */
-#define CSR0_MERR	0x0800	/* Memory Error  (RC) */
-#define CSR0_RINT	0x0400	/* Receiver Interrupt (RC) */
-#define CSR0_TINT       0x0200	/* Transmit Interrupt (RC) */
-#define CSR0_IDON	0x0100	/* Initialization Done (RC) */
-#define CSR0_INTR	0x0080	/* Interrupt Flag (R) */
-#define CSR0_INEA	0x0040	/* Interrupt Enable (RW) */
-#define CSR0_RXON	0x0020	/* Receiver on (R) */
-#define CSR0_TXON	0x0010  /* Transmitter on (R) */
-#define CSR0_TDMD	0x0008	/* Transmit Demand (RS) */
-#define CSR0_STOP	0x0004	/* Stop (RS) */
-#define CSR0_STRT	0x0002	/* Start (RS) */
-#define CSR0_INIT	0x0001	/* Initialize (RS) */
-
-#define CSR0_CLRALL     0x7f00  /* mask for all clearable bits */
-
-/*
- *    Control and Status Register 3 (CSR3) bit definitions
- *
- */
-
-#define CSR3_BSWAP	0x0004	/* Byte Swap (RW) */
-#define CSR3_ACON	0x0002  /* ALE Control (RW) */
-#define CSR3_BCON	0x0001	/* Byte Control (RW) */
-
-/*
- *	Initialization Block Mode operation Bit Definitions.
- */
-
-#define MODE_PROM	0x8000	/* Promiscuous Mode */
-#define MODE_INTL	0x0040  /* Internal Loopback */
-#define MODE_DRTY	0x0020  /* Disable Retry */
-#define MODE_COLL	0x0010	/* Force Collision */
-#define MODE_DTCR	0x0008	/* Disable Transmit CRC) */
-#define MODE_LOOP	0x0004	/* Loopback */
-#define MODE_DTX	0x0002	/* Disable the Transmitter */
-#define MODE_DRX	0x0001  /* Disable the Receiver */
-
-#define MODE_NORMAL	0x0000  /* Normal operation mode */
-
-/*
- *	Receive message descriptor status bit definitions.
- */
-
-#define RX_OWN		0x80	/* Owner bit 0 = host, 1 = lance */
-#define RX_ERR		0x40	/* Error Summary */
-#define RX_FRAM		0x20	/* Framing Error */
-#define RX_OFLO		0x10	/* Overflow Error */
-#define RX_CRC		0x08	/* CRC Error */
-#define RX_BUFF		0x04	/* Buffer Error */
-#define RX_STP		0x02	/* Start of Packet */
-#define RX_ENP		0x01	/* End of Packet */
-
-
-/*
- *	Transmit message descriptor status bit definitions.
- */
-
-#define TX_OWN		0x80	/* Owner bit 0 = host, 1 = lance */
-#define TX_ERR		0x40    /* Error Summary */
-#define TX_MORE		0x10	/* More the 1 retry needed to Xmit */
-#define TX_ONE		0x08	/* One retry needed to Xmit */
-#define TX_DEF		0x04	/* Deferred */
-#define TX_STP		0x02	/* Start of Packet */
-#define TX_ENP		0x01	/* End of Packet */
-
-/*
- *      Transmit status (2) (valid if TX_ERR == 1)
- */
-
-#define TX_BUFF		0x8000  /* Buffering error (no ENP) */
-#define TX_UFLO		0x4000  /* Underflow (late memory) */
-#define TX_LCOL		0x1000  /* Late collision */
-#define TX_LCAR		0x0400  /* Loss of Carrier */
-#define TX_RTRY		0x0200  /* Failed after 16 retransmissions  */
-#define TX_TDR          0x003f  /* Time-domain-reflectometer-value */
-
-
-/*
- * Structures used for Communication with the LANCE
- */
-
-/* LANCE Initialize Block */
-
-struct init_block
-{
-  unsigned short mode;     /* Mode Register */
-  unsigned char  paddr[6]; /* Physical Address (MAC) */
-  unsigned char  laddr[8]; /* Logical Filter Address (not used) */
-  unsigned int   rdrp;     /* Receive Descriptor Ring pointer */
-  unsigned int   tdrp;     /* Transmit Descriptor Ring pointer */
-};
-
-
-/* Receive Message Descriptor Entry */
-
-struct rmd
-{
-  union rmd_u
-  {
-    unsigned long buffer;     /* Address of buffer */
-    struct rmd_s
-    {
-      unsigned char unused[3];
-      unsigned volatile char status;   /* Status Bits */
-    } s;
-  } u;
-  volatile short blen;        /* Buffer Length (two's complement) */
-  unsigned short mlen;        /* Message Byte Count */
-};
-
-
-/* Transmit Message Descriptor Entry */
-
-struct tmd
-{
-  union tmd_u
-  {
-    unsigned long  buffer;    /* Address of buffer */
-    struct tmd_s
-    {
-      unsigned char unused[3];
-      unsigned volatile char status;   /* Status Bits */
-    } s;
-  } u;
-  unsigned short blen;             /* Buffer Length (two's complement) */
-  unsigned volatile short status2; /* Error Status Bits */
-};
-
-#endif	/* End of SK_G16_H */
Index: netboot/tiara.c
===================================================================
--- netboot/tiara.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/tiara.c	(.../trunk)	(revision 112)
@@ -1,255 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-
-TIARA (Fujitsu Etherstar) NIC driver for Etherboot
-Copyright (c) Ken Yap 1998
-
-Information gleaned from:
-
-TIARA.ASM Packet driver by Brian Fisher, Queens U, Kingston, Ontario
-Fujitsu MB86960 spec sheet (different chip but same family)
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-#include "cards.h"
-
-/*
-	EtherStar I/O Register offsets
-*/
-
-/* Offsets of registers */
-#define	DLCR_XMIT_STAT	0x00
-#define	DLCR_XMIT_MASK	0x01
-#define	DLCR_RECV_STAT	0x02
-#define	DLCR_RECV_MASK	0x03
-#define	DLCR_XMIT_MODE	0x04
-#define	DLCR_RECV_MODE	0x05
-#define	DLCR_ENABLE	0x06
-#define	DLCR_TDR_LOW	0x07
-#define	DLCR_NODE_ID	0x08
-#define	DLCR_TDR_HIGH	0x0F
-#define	BMPR_MEM_PORT	0x10
-#define	BMPR_PKT_LEN	0x12
-#define	BMPR_DMA_ENABLE	0x14
-#define	PROM_ID		0x18
-
-#define	TMST		0x80
-#define	TMT_OK		0x80
-#define	TMT_16COLL	0x02
-#define	BUF_EMPTY	0x40
-
-#define	CARD_DISABLE	0x80	/* written to DLCR_ENABLE to disable card */
-#define	CARD_ENABLE	0	/* written to DLCR_ENABLE to enable card */
-
-#define	CLEAR_STATUS	0x0F	/* used to clear status info */
-/*
-	00001111B
-	!!!!!!!!--------
-	!!!!!!!+--------CLEAR BUS WRITE ERROR
-	!!!!!!+---------CLEAR 16 COLLISION
-	!!!!!+----------CLEAR COLLISION
-	!!!!+-----------CLEAR UNDERFLOW
-	!!!+------------NC
-	!!+-------------NC
-	!+--------------NC
-	+---------------NC
-*/
-
-#define	NO_TX_IRQS	0	/* written to clear transmit IRQs */
-
-#define	CLR_RCV_STATUS	0xCF	/* clears receive status */
-
-#define	EN_RCV_IRQS	0x80	/* enable receive interrupts */
-/*
-	10000000B
-	!!!!!!!!--------
-	!!!!!!!+--------ENABLE OVERFLOW
-	!!!!!!+---------ENABLE CRC
-	!!!!!+----------ENABLE ALIGN
-	!!!!+-----------ENABLE SHORT PKT
-	!!!+------------DISABLE REMOTE RESET
-	!!+-------------RESERVED
-	!+--------------RESERVED
-	+---------------ENABLE PKT READY
-*/
-
-#define	XMIT_MODE	0x02
-/*
-	00000010B
-	!!!!!!!!---------ENABLE CARRIER DETECT
-	!!!!!!!+---------DISABLE LOOPBACK
-*/
-
-#define	RECV_MODE	0x02
-/*
-	00000010B
-	!!!!!!!!---------ACCEPT ALL PACKETS
-	!!!!!!!+---------ACCEPT PHYSICAL, MULTICAST, AND
-	!!!!!!+----------BROADCAST PACKETS
-	!!!!!+-----------DISABLE REMOTE RESET
-	!!!!+------------DISABLE SHORT PACKETS
-	!!!+-------------USE 6 BYTE ADDRESS
-	!!+--------------NC
-	!+---------------NC
-	+----------------DISABLE CRC TEST MODE
-*/
-
-/* NIC specific static variables go here */
-
-static unsigned short	ioaddr;
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void tiara_reset(struct nic *nic)
-{
-	int		i;
-
-	outb(CARD_DISABLE, ioaddr + DLCR_ENABLE);
-	outb(CLEAR_STATUS, ioaddr + DLCR_XMIT_STAT);
-	outb(NO_TX_IRQS, ioaddr + DLCR_XMIT_MASK);
-	outb(CLR_RCV_STATUS, ioaddr + DLCR_RECV_STAT);
-	outb(XMIT_MODE, ioaddr + DLCR_XMIT_MODE);
-	outb(RECV_MODE, ioaddr + DLCR_RECV_MODE);
-	/* Vacuum recv buffer */
-	while ((inb(ioaddr + DLCR_RECV_MODE) & BUF_EMPTY) == 0)
-		inb(ioaddr + BMPR_MEM_PORT);
-	/* Set node address */
-	for (i = 0; i < ETH_ALEN; ++i)
-		outb(nic->node_addr[i], ioaddr + DLCR_NODE_ID + i);
-	outb(CLR_RCV_STATUS, ioaddr + DLCR_RECV_STAT);
-	outb(CARD_ENABLE, ioaddr + DLCR_ENABLE);
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int tiara_poll(struct nic *nic)
-{
-	unsigned int		len;
-
-	if (inb(ioaddr + DLCR_RECV_MODE) & BUF_EMPTY)
-		return (0);
-	/* Ack packet */
-	outw(CLR_RCV_STATUS, ioaddr + DLCR_RECV_STAT);
-	len = inw(ioaddr + BMPR_MEM_PORT);		/* throw away status */
-	len = inw(ioaddr + BMPR_MEM_PORT);
-	/* Drop overlength packets */
-	if (len > ETH_FRAME_LEN)
-		return (0);		/* should we drain the buffer? */
-	insw(ioaddr + BMPR_MEM_PORT, nic->packet, len / 2);
-	/* If it's our own, drop it */
-	if (memcmp(nic->packet + ETH_ALEN, nic->node_addr, ETH_ALEN) == 0)
-		return (0);
-	nic->packetlen = len;
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void tiara_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *p)			/* Packet */
-{
-	unsigned int	len;
-	unsigned long	time;
-
-	len = s + ETH_HLEN;
-	if (len < ETH_ZLEN)
-		len = ETH_ZLEN;
-	t = htons(t);
-	outsw(ioaddr + BMPR_MEM_PORT, d, ETH_ALEN / 2);
-	outsw(ioaddr + BMPR_MEM_PORT, nic->node_addr, ETH_ALEN / 2);
-	outw(t, ioaddr + BMPR_MEM_PORT);
-	outsw(ioaddr + BMPR_MEM_PORT, p, s / 2);
-	if (s & 1)					/* last byte */
-		outb(p[s-1], ioaddr + BMPR_MEM_PORT);
-	while (s++ < ETH_ZLEN - ETH_HLEN)	/* pad */
-		outb(0, ioaddr + BMPR_MEM_PORT);
-	outw(len | (TMST << 8), ioaddr + BMPR_PKT_LEN);
-	/* wait for transmit complete */
-	time = currticks() + TICKS_PER_SEC;		/* wait one second */
-	while (currticks() < time && (inb(ioaddr) & (TMT_OK|TMT_16COLL)) == 0)
-		;
-	if ((inb(ioaddr) & (TMT_OK|TMT_16COLL)) == 0)
-		printf("Tiara timed out on transmit\n");
-	/* Do we need to ack the transmit? */
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void tiara_disable(struct nic *nic)
-{
-	/* Apparently only a power down can do this properly */
-	outb(CARD_DISABLE, ioaddr + DLCR_ENABLE);
-}
-
-static int tiara_probe1(struct nic *nic)
-{
-	/* Hope all the Tiara cards have this vendor prefix */
-	static char	vendor_prefix[] = { 0x08, 0x00, 0x1A };
-	static char	all_ones[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
-	int		i;
-
-	for (i = 0; i < ETH_ALEN; ++i)
-		nic->node_addr[i] = inb(ioaddr + PROM_ID + i);
-	if (memcmp(nic->node_addr, vendor_prefix, sizeof(vendor_prefix)) != 0)
-		return (0);
-	if (memcmp(nic->node_addr, all_ones, sizeof(all_ones)) == 0)
-		return (0);
-	printf("\nTiara ioaddr %#hX, addr %!\n", ioaddr, nic->node_addr);
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *tiara_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	/* missing entries are addresses usually already used */
-	static unsigned short	io_addrs[] = {
-		0x100, 0x120, 0x140, 0x160,
-		0x180, 0x1A0, 0x1C0, 0x1E0,
-		0x200, 0x220, 0x240, /*Par*/
-		0x280, 0x2A0, 0x2C0, /*Ser*/
-		0x300, 0x320, 0x340, /*Par*/
-		0x380, /*Vid,Par*/ 0x3C0, /*Ser*/
-		0x0
-	};
-	unsigned short		*p;
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (tiara_probe1(nic))
-			break;
-	/* if board found */
-	if (ioaddr != 0)
-	{
-		tiara_reset(nic);
-		/* point to NIC specific routines */
-		nic->reset = tiara_reset;
-		nic->poll = tiara_poll;
-		nic->transmit = tiara_transmit;
-		nic->disable = tiara_disable;
-		return nic;
-	}
-	else
-		return (0);
-}
Index: netboot/cards.h
===================================================================
--- netboot/cards.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/cards.h	(.../trunk)	(revision 112)
@@ -1,183 +0,0 @@
-#ifndef	CARDS_H
-#define CARDS_H
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-#include "nic.h"
-
-/* OK, this is how the PCI support hack works:  if pci.h is included before
- * this file is included, assume that the driver supports PCI.  This means that
- * this file is usually included last.  */
-
-#ifdef	PCI_H
-#define PCI_ARG(x) ,x
-#else
-#define PCI_ARG(x)
-#endif
-
-#ifdef	INCLUDE_WD
-extern struct nic	*wd_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C503
-extern struct nic	*t503_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_VIA_RHINE
-extern struct nic	*rhine_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NE
-extern struct nic	*ne_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NS8390
-extern struct nic	*nepci_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C509
-extern struct nic	*t509_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C529
-extern struct nic	*t529_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C595
-extern struct nic	*t595_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C90X
-extern struct nic	*a3c90x_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EEPRO
-extern struct nic	*eepro_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EEPRO100
-extern struct nic	*eepro100_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EPIC100
-extern struct nic	*epic100_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_OTULIP
-extern struct nic	*otulip_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_TULIP
-extern struct nic	*tulip_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_DAVICOM
-extern struct nic	*davicom_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_CS89X0
-extern struct nic	*cs89x0_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_LANCE
-extern struct nic	*lancepci_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NE2100
-extern struct nic	*ne2100_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NI6510
-extern struct nic	*ni6510_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_SK_G16
-extern struct nic	*SK_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_3C507
-extern struct nic	*t507_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NI5010
-extern struct nic	*ni5010_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NI5210
-extern struct nic	*ni5210_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_EXOS205
-extern struct nic	*exos205_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_SMC9000
-extern struct nic	*smc9000_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_TIARA
-extern struct nic	*tiara_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_DEPCA
-extern struct nic	*depca_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_RTL8139
-extern struct nic	*rtl8139_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_W89C840
-extern struct nic	*w89c840_probe(struct nic *, unsigned short *
-	PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_SIS900
-extern struct nic	*sis900_probe(struct nic *, unsigned short *
-        PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_NATSEMI
-extern struct nic	*natsemi_probe(struct nic *, unsigned short *
-        PCI_ARG(struct pci_device *));
-#endif
-
-#ifdef	INCLUDE_TLAN
-extern struct nic	*tlan_probe(struct nic *, unsigned short *
-        PCI_ARG(struct pci_device *));
-#endif
-
-#endif	/* CARDS_H */
Index: netboot/eepro.c
===================================================================
--- netboot/eepro.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/eepro.c	(.../trunk)	(revision 112)
@@ -1,586 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-Intel EEPRO/10 NIC driver for Etherboot
-Adapted from Linux eepro.c from kernel 2.2.17
-
-This board accepts a 32 pin EEPROM (29C256), however a test with a
-27C010 shows that this EPROM also works in the socket, but it's not clear
-how repeatably. The two top address pins appear to be held low, thus
-the bottom 32kB of the 27C010 is visible in the CPU's address space.
-To be sure you could put 4 copies of the code in the 27C010, then
-it doesn't matter whether the extra lines are held low or high, just
-hopefully not floating as CMOS chips don't like floating inputs.
-
-Be careful with seating the EPROM as the socket on my board actually
-has 34 pins, the top row of 2 are not used.
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-/* to get our own prototype */
-#include "cards.h"
-/* we use timer2 for microsecond waits */
-#include "timer.h"
-
-#undef	DEBUG		/* only after include files */
-
-/* Different 82595 chips */
-#define LAN595		0
-#define LAN595TX	1
-#define LAN595FX	2
-#define LAN595FX_10ISA	3
-
-#define	SLOW_DOWN	inb(0x80);
-
-/* The station (ethernet) address prefix, used for IDing the board. */
-#define SA_ADDR0 0x00	/* Etherexpress Pro/10 */
-#define SA_ADDR1 0xaa
-#define SA_ADDR2 0x00
-
-#define GetBit(x,y) ((x & (1<<y))>>y)
-
-/* EEPROM Word 0: */
-#define ee_PnP       0  /* Plug 'n Play enable bit */
-#define ee_Word1     1  /* Word 1? */
-#define ee_BusWidth  2  /* 8/16 bit */
-#define ee_FlashAddr 3  /* Flash Address */
-#define ee_FlashMask 0x7   /* Mask */
-#define ee_AutoIO    6  /* */
-#define ee_reserved0 7  /* =0! */
-#define ee_Flash     8  /* Flash there? */
-#define ee_AutoNeg   9  /* Auto Negotiation enabled? */
-#define ee_IO0       10 /* IO Address LSB */
-#define ee_IO0Mask   0x /*...*/
-#define ee_IO1       15 /* IO MSB */
-
-/* EEPROM Word 1: */
-#define ee_IntSel    0   /* Interrupt */
-#define ee_IntMask   0x7
-#define ee_LI        3   /* Link Integrity 0= enabled */
-#define ee_PC        4   /* Polarity Correction 0= enabled */
-#define ee_TPE_AUI   5   /* PortSelection 1=TPE */
-#define ee_Jabber    6   /* Jabber prevention 0= enabled */
-#define ee_AutoPort  7   /* Auto Port Selection 1= Disabled */
-#define ee_SMOUT     8   /* SMout Pin Control 0= Input */
-#define ee_PROM      9   /* Flash EPROM / PROM 0=Flash */
-#define ee_reserved1 10  /* .. 12 =0! */
-#define ee_AltReady  13  /* Alternate Ready, 0=normal */
-#define ee_reserved2 14  /* =0! */
-#define ee_Duplex    15
-
-/* Word2,3,4: */
-#define ee_IA5       0 /*bit start for individual Addr Byte 5 */
-#define ee_IA4       8 /*bit start for individual Addr Byte 5 */
-#define ee_IA3       0 /*bit start for individual Addr Byte 5 */
-#define ee_IA2       8 /*bit start for individual Addr Byte 5 */
-#define ee_IA1       0 /*bit start for individual Addr Byte 5 */
-#define ee_IA0       8 /*bit start for individual Addr Byte 5 */
-
-/* Word 5: */
-#define ee_BNC_TPE   0 /* 0=TPE */
-#define ee_BootType  1 /* 00=None, 01=IPX, 10=ODI, 11=NDIS */
-#define ee_BootTypeMask 0x3 
-#define ee_NumConn   3  /* Number of Connections 0= One or Two */
-#define ee_FlashSock 4  /* Presence of Flash Socket 0= Present */
-#define ee_PortTPE   5
-#define ee_PortBNC   6
-#define ee_PortAUI   7
-#define ee_PowerMgt  10 /* 0= disabled */
-#define ee_CP        13 /* Concurrent Processing */
-#define ee_CPMask    0x7
-
-/* Word 6: */
-#define ee_Stepping  0 /* Stepping info */
-#define ee_StepMask  0x0F
-#define ee_BoardID   4 /* Manucaturer Board ID, reserved */
-#define ee_BoardMask 0x0FFF
-
-/* Word 7: */
-#define ee_INT_TO_IRQ 0 /* int to IRQ Mapping  = 0x1EB8 for Pro/10+ */
-#define ee_FX_INT2IRQ 0x1EB8 /* the _only_ mapping allowed for FX chips */
-
-/*..*/
-#define ee_SIZE 0x40 /* total EEprom Size */
-#define ee_Checksum 0xBABA /* initial and final value for adding checksum */
-
-
-/* Card identification via EEprom:   */
-#define ee_addr_vendor 0x10  /* Word offset for EISA Vendor ID */
-#define ee_addr_id 0x11      /* Word offset for Card ID */
-#define ee_addr_SN 0x12      /* Serial Number */
-#define ee_addr_CRC_8 0x14   /* CRC over last thee Bytes */
-
-
-#define ee_vendor_intel0 0x25  /* Vendor ID Intel */
-#define ee_vendor_intel1 0xD4
-#define ee_id_eepro10p0 0x10   /* ID for eepro/10+ */
-#define ee_id_eepro10p1 0x31
-
-/* now this section could be used by both boards: the oldies and the ee10:
- * ee10 uses tx buffer before of rx buffer and the oldies the inverse.
- * (aris)
- */
-#define	RAM_SIZE	0x8000
-
-#define	RCV_HEADER	8
-#define RCV_DEFAULT_RAM	0x6000
-#define RCV_RAM 	rcv_ram
-
-static unsigned rcv_ram = RCV_DEFAULT_RAM;
-
-#define XMT_HEADER	8
-#define XMT_RAM		(RAM_SIZE - RCV_RAM)
-
-#define XMT_START	((rcv_start + RCV_RAM) % RAM_SIZE)
-
-#define RCV_LOWER_LIMIT	(rcv_start >> 8)
-#define RCV_UPPER_LIMIT	(((rcv_start + RCV_RAM) - 2) >> 8)
-#define XMT_LOWER_LIMIT	(XMT_START >> 8)
-#define XMT_UPPER_LIMIT	(((XMT_START + XMT_RAM) - 2) >> 8)
-
-#define RCV_START_PRO	0x00
-#define RCV_START_10	XMT_RAM
-					/* by default the old driver */
-static unsigned rcv_start = RCV_START_PRO;
-
-#define	RCV_DONE	0x0008
-#define	RX_OK		0x2000
-#define	RX_ERROR	0x0d81
-
-#define	TX_DONE_BIT	0x0080
-#define	CHAIN_BIT	0x8000
-#define	XMT_STATUS	0x02
-#define	XMT_CHAIN	0x04
-#define	XMT_COUNT	0x06
-
-#define	BANK0_SELECT	0x00		
-#define	BANK1_SELECT	0x40		
-#define	BANK2_SELECT	0x80		
-
-/* Bank 0 registers */
-#define	COMMAND_REG	0x00	/* Register 0 */
-#define	MC_SETUP	0x03
-#define	XMT_CMD		0x04
-#define	DIAGNOSE_CMD	0x07
-#define	RCV_ENABLE_CMD	0x08
-#define	RCV_DISABLE_CMD	0x0a
-#define	STOP_RCV_CMD	0x0b
-#define	RESET_CMD	0x0e
-#define	POWER_DOWN_CMD	0x18
-#define	RESUME_XMT_CMD	0x1c
-#define	SEL_RESET_CMD	0x1e
-#define	STATUS_REG	0x01	/* Register 1 */
-#define	RX_INT		0x02
-#define	TX_INT		0x04
-#define	EXEC_STATUS	0x30
-#define	ID_REG		0x02	/* Register 2	*/
-#define	R_ROBIN_BITS	0xc0	/* round robin counter */
-#define	ID_REG_MASK	0x2c
-#define	ID_REG_SIG	0x24
-#define	AUTO_ENABLE	0x10
-#define	INT_MASK_REG	0x03	/* Register 3	*/
-#define	RX_STOP_MASK	0x01
-#define	RX_MASK		0x02
-#define	TX_MASK		0x04
-#define	EXEC_MASK	0x08
-#define	ALL_MASK	0x0f
-#define	IO_32_BIT	0x10
-#define	RCV_BAR		0x04	/* The following are word (16-bit) registers */
-#define	RCV_STOP	0x06
-
-#define	XMT_BAR_PRO	0x0a
-#define	XMT_BAR_10	0x0b
-static unsigned xmt_bar = XMT_BAR_PRO;
-
-#define	HOST_ADDRESS_REG	0x0c
-#define	IO_PORT		0x0e
-#define	IO_PORT_32_BIT	0x0c
-
-/* Bank 1 registers */
-#define	REG1	0x01
-#define	WORD_WIDTH	0x02
-#define	INT_ENABLE	0x80
-#define INT_NO_REG	0x02
-#define	RCV_LOWER_LIMIT_REG	0x08
-#define	RCV_UPPER_LIMIT_REG	0x09
-
-#define	XMT_LOWER_LIMIT_REG_PRO	0x0a
-#define	XMT_UPPER_LIMIT_REG_PRO	0x0b
-#define	XMT_LOWER_LIMIT_REG_10	0x0b
-#define	XMT_UPPER_LIMIT_REG_10	0x0a
-static unsigned xmt_lower_limit_reg = XMT_LOWER_LIMIT_REG_PRO;
-static unsigned xmt_upper_limit_reg = XMT_UPPER_LIMIT_REG_PRO;
-
-/* Bank 2 registers */
-#define	XMT_Chain_Int	0x20	/* Interrupt at the end of the transmit chain */
-#define	XMT_Chain_ErrStop	0x40 /* Interrupt at the end of the chain even if there are errors */
-#define	RCV_Discard_BadFrame	0x80 /* Throw bad frames away, and continue to receive others */
-#define	REG2		0x02
-#define	PRMSC_Mode	0x01
-#define	Multi_IA	0x20
-#define	REG3		0x03
-#define	TPE_BIT		0x04
-#define	BNC_BIT		0x20
-#define	REG13		0x0d
-#define	FDX		0x00
-#define	A_N_ENABLE	0x02
-	
-#define	I_ADD_REG0	0x04
-#define	I_ADD_REG1	0x05
-#define	I_ADD_REG2	0x06
-#define	I_ADD_REG3	0x07
-#define	I_ADD_REG4	0x08
-#define	I_ADD_REG5	0x09
-
-#define EEPROM_REG_PRO	0x0a
-#define EEPROM_REG_10	0x0b
-static unsigned eeprom_reg = EEPROM_REG_PRO;
-
-#define EESK 0x01
-#define EECS 0x02
-#define EEDI 0x04
-#define EEDO 0x08
-
-/* The horrible routine to read a word from the serial EEPROM. */
-/* IMPORTANT - the 82595 will be set to Bank 0 after the eeprom is read */
-
-/* The delay between EEPROM clock transitions. */
-#define eeprom_delay() { udelay(40); }
-#define EE_READ_CMD (6 << 6)
-
-/* do a full reset */
-#define eepro_full_reset(ioaddr)	outb(RESET_CMD, ioaddr); udelay(40);
-
-/* do a nice reset */
-#define eepro_sel_reset(ioaddr) 	{ \
-					outb(SEL_RESET_CMD, ioaddr); \
-					SLOW_DOWN; \
-					SLOW_DOWN; \
-					}
-
-/* clear all interrupts */
-#define	eepro_clear_int(ioaddr)	outb(ALL_MASK, ioaddr + STATUS_REG)
-
-/* enable rx */
-#define	eepro_en_rx(ioaddr)	outb(RCV_ENABLE_CMD, ioaddr)
-
-/* disable rx */
-#define	eepro_dis_rx(ioaddr)	outb(RCV_DISABLE_CMD, ioaddr)
-
-/* switch bank */
-#define eepro_sw2bank0(ioaddr) outb(BANK0_SELECT, ioaddr)
-#define eepro_sw2bank1(ioaddr) outb(BANK1_SELECT, ioaddr)
-#define eepro_sw2bank2(ioaddr) outb(BANK2_SELECT, ioaddr)
-
-static unsigned int	rx_start, tx_start;
-static int		tx_last;
-static unsigned		tx_end;
-static int		eepro = 0;
-static unsigned short	ioaddr = 0;
-static unsigned int	mem_start, mem_end = RCV_DEFAULT_RAM / 1024;
-
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void eepro_reset(struct nic *nic)
-{
-	int		temp_reg, i;
-
-	/* put the card in its initial state */
-	eepro_sw2bank2(ioaddr);	/* be careful, bank2 now */
-	temp_reg = inb(ioaddr + eeprom_reg);
-#ifdef	DEBUG
-	printf("Stepping %d\n", temp_reg >> 5);
-#endif
-	if (temp_reg & 0x10)	/* check the TurnOff Enable bit */
-		outb(temp_reg & 0xEF, ioaddr + eeprom_reg);
-	for (i = 0; i < ETH_ALEN; i++)	/* fill the MAC address */
-		outb(nic->node_addr[i], ioaddr + I_ADD_REG0 + i);
-	temp_reg = inb(ioaddr + REG1);
-	/* setup Transmit Chaining and discard bad RCV frames */
-	outb(temp_reg | XMT_Chain_Int | XMT_Chain_ErrStop
-		| RCV_Discard_BadFrame, ioaddr + REG1);
-	temp_reg = inb(ioaddr + REG2);		/* match broadcast */
-	outb(temp_reg | 0x14, ioaddr + REG2);
-	temp_reg = inb(ioaddr + REG3);
-	outb(temp_reg & 0x3F, ioaddr + REG3);	/* clear test mode */
-	/* set the receiving mode */
-	eepro_sw2bank1(ioaddr);	/* be careful, bank1 now */
-	/* initialise the RCV and XMT upper and lower limits */
-	outb(RCV_LOWER_LIMIT, ioaddr + RCV_LOWER_LIMIT_REG);
-	outb(RCV_UPPER_LIMIT, ioaddr + RCV_UPPER_LIMIT_REG);
-	outb(XMT_LOWER_LIMIT, ioaddr + xmt_lower_limit_reg);
-	outb(XMT_UPPER_LIMIT, ioaddr + xmt_upper_limit_reg);
-	eepro_sw2bank0(ioaddr);	/* Switch back to bank 0 */
-	eepro_clear_int(ioaddr);
-	/* Initialise RCV */
-	outw(rx_start = (RCV_LOWER_LIMIT << 8), ioaddr + RCV_BAR);
-	outw(((RCV_UPPER_LIMIT << 8) | 0xFE), ioaddr + RCV_STOP);
-	/* Intialise XMT */
-	outw((XMT_LOWER_LIMIT << 8), ioaddr + xmt_bar);
-	eepro_sel_reset(ioaddr);
-	tx_start = tx_end = (XMT_LOWER_LIMIT << 8);
-	tx_last = 0;
-	eepro_en_rx(ioaddr);
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int eepro_poll(struct nic *nic)
-{
-	int		i;
-	unsigned int	rcv_car = rx_start;
-	unsigned int	rcv_event, rcv_status, rcv_next_frame, rcv_size;
-
-	/* return true if there's an ethernet packet ready to read */
-	/* nic->packet should contain data on return */
-	/* nic->packetlen should contain length of data */
-#if	0
-	if ((inb(ioaddr + STATUS_REG) & 0x40) == 0)
-		return (0);
-	outb(0x40, ioaddr + STATUS_REG);
-#endif
-	outw(rcv_car, ioaddr + HOST_ADDRESS_REG);
-	rcv_event = inw(ioaddr + IO_PORT);
-	if (rcv_event != RCV_DONE)
-		return (0);
-	rcv_status = inw(ioaddr + IO_PORT);
-	rcv_next_frame = inw(ioaddr + IO_PORT);
-	rcv_size = inw(ioaddr + IO_PORT);
-#if	0
-	printf("%hX %hX %d %hhX\n", rcv_status, rcv_next_frame, rcv_size,
-		inb(ioaddr + STATUS_REG));
-#endif
-	if ((rcv_status & (RX_OK|RX_ERROR)) != RX_OK) {
-		printf("Receive error %hX\n", rcv_status);
-		return (0);
-	}
-	rcv_size &= 0x3FFF;
-	insw(ioaddr + IO_PORT, nic->packet, ((rcv_size + 3) >> 1));
-#if	0
-	for (i = 0; i < 48; i++) {
-		printf("%hhX", nic->packet[i]);
-		putchar(i % 16 == 15 ? '\n' : ' ');
-	}
-#endif
-	nic->packetlen = rcv_size;
-	rcv_car = rx_start + RCV_HEADER + rcv_size;
-	rx_start = rcv_next_frame;
-	if (rcv_car == 0)
-		rcv_car = ((RCV_UPPER_LIMIT << 8) | 0xff);
-	outw(rcv_car - 1, ioaddr + RCV_STOP);
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void eepro_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	unsigned int	status, tx_available, last, end, length;
-	unsigned short	type;
-	int		boguscount = 20;
-
-	length = s + ETH_HLEN;
-	if (tx_end > tx_start)
-		tx_available = XMT_RAM - (tx_end - tx_start);
-	else if (tx_end < tx_start)
-		tx_available = tx_start - tx_end;
-	else
-		tx_available = XMT_RAM;
-	last = tx_end;
-	end = last + (((length + 3) >> 1) << 1) + XMT_HEADER;
-	if (end >= (XMT_UPPER_LIMIT << 8)) {
-		last = (XMT_LOWER_LIMIT << 8);
-		end = last + (((length + 3) >> 1) << 1) + XMT_HEADER;
-	}
-	outw(last, ioaddr + HOST_ADDRESS_REG);
-	outw(XMT_CMD, ioaddr + IO_PORT);
-	outw(0, ioaddr + IO_PORT);
-	outw(end, ioaddr + IO_PORT);
-	outw(length, ioaddr + IO_PORT);
-	outsw(ioaddr + IO_PORT, d, ETH_ALEN / 2);
-	outsw(ioaddr + IO_PORT, nic->node_addr, ETH_ALEN / 2);
-	type = htons(t);
-	outsw(ioaddr + IO_PORT, &type, sizeof(type) / 2);
-	outsw(ioaddr + IO_PORT, p, (s + 3) >> 1);
-	/* A dummy read to flush the DRAM write pipeline */
-	status = inw(ioaddr + IO_PORT);
-	outw(last, ioaddr + xmt_bar);
-	outb(XMT_CMD, ioaddr);
-	tx_start = last;
-	tx_last = last;
-	tx_end = end;
-#if	0
-	printf("%d %d\n", tx_start, tx_end);
-#endif
-	while (boguscount > 0) {
-		if (((status = inw(ioaddr + IO_PORT)) & TX_DONE_BIT) == 0) {
-			udelay(40);
-			boguscount--;
-			continue;
-		}
-#if	DEBUG
-		if ((status & 0x2000) == 0)
-			printf("Transmit status %hX\n", status);
-#endif
-	}
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void eepro_disable(struct nic *nic)
-{
-	eepro_sw2bank0(ioaddr);	/* Switch to bank 0 */
-	/* Flush the Tx and disable Rx */
-	outb(STOP_RCV_CMD, ioaddr);
-	tx_start = tx_end = (XMT_LOWER_LIMIT << 8);
-	tx_last = 0;
-	/* Reset the 82595 */
-	eepro_full_reset(ioaddr);
-}
-
-static int read_eeprom(int location)
-{
-	int		i;
-	unsigned short	retval = 0;
-	int		ee_addr = ioaddr + eeprom_reg;
-	int		read_cmd = location | EE_READ_CMD;
-	int		ctrl_val = EECS;
-
-	if (eepro == LAN595FX_10ISA) {
-		eepro_sw2bank1(ioaddr);
-		outb(0x00, ioaddr + STATUS_REG);
-	}
-	eepro_sw2bank2(ioaddr);
-	outb(ctrl_val, ee_addr);
-	/* shift the read command bits out */
-	for (i = 8; i >= 0; i--) {
-		short outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : ctrl_val;
-		outb(outval, ee_addr);
-		outb(outval | EESK, ee_addr);	/* EEPROM clock tick */
-		eeprom_delay();
-		outb(outval, ee_addr);		/* finish EEPROM clock tick */
-		eeprom_delay();
-	}
-	outb(ctrl_val, ee_addr);
-	for (i = 16; i > 0; i--) {
-		outb(ctrl_val | EESK, ee_addr);
-		eeprom_delay();
-		retval = (retval << 1) | ((inb(ee_addr) & EEDO) ? 1 : 0);
-		outb(ctrl_val, ee_addr);
-		eeprom_delay();
-	}
-	/* terminate the EEPROM access */
-	ctrl_val &= ~EECS;
-	outb(ctrl_val | EESK, ee_addr);
-	eeprom_delay();
-	outb(ctrl_val, ee_addr);
-	eeprom_delay();
-	eepro_sw2bank0(ioaddr);
-	return (retval);
-}
-
-static int eepro_probe1(struct nic *nic)
-{
-	int		i, id, counter, l_eepro = 0;
-	union {
-		unsigned char	caddr[ETH_ALEN];
-		unsigned short	saddr[ETH_ALEN/2];
-	} station_addr;
-	char		*name;
-
-	id = inb(ioaddr + ID_REG);
-	if ((id & ID_REG_MASK) != ID_REG_SIG)
-		return (0);
-	counter = id & R_ROBIN_BITS;
-	if (((id = inb(ioaddr + ID_REG)) & R_ROBIN_BITS) != (counter + 0x40))
-		return (0);
-	/* yes the 82595 has been found */
-	station_addr.saddr[2] = read_eeprom(2);
-	if (station_addr.saddr[2] == 0x0000 || station_addr.saddr[2] == 0xFFFF) {
-		l_eepro = 3;
-		eepro = LAN595FX_10ISA;
-		eeprom_reg= EEPROM_REG_10;
-		rcv_start = RCV_START_10;
-		xmt_lower_limit_reg = XMT_LOWER_LIMIT_REG_10;
-		xmt_upper_limit_reg = XMT_UPPER_LIMIT_REG_10;
-		station_addr.saddr[2] = read_eeprom(2);
-	}
-	station_addr.saddr[1] = read_eeprom(3);
-	station_addr.saddr[0] = read_eeprom(4);
-	if (l_eepro)
-		name = "Intel EtherExpress 10 ISA";
-	else if (read_eeprom(7) == ee_FX_INT2IRQ) {
-		name = "Intel EtherExpress Pro/10+ ISA";
-		l_eepro = 2;
-	} else if (station_addr.saddr[0] == SA_ADDR1) {
-		name = "Intel EtherExpress Pro/10 ISA";
-		l_eepro = 1;
-	} else {
-		l_eepro = 0;
-		name = "Intel 82595-based LAN card";
-	}
-	station_addr.saddr[0] = swap16(station_addr.saddr[0]);
-	station_addr.saddr[1] = swap16(station_addr.saddr[1]);
-	station_addr.saddr[2] = swap16(station_addr.saddr[2]);
-	for (i = 0; i < ETH_ALEN; i++) {
-		nic->node_addr[i] = station_addr.caddr[i];
-	}
-	printf("\n%s ioaddr %#hX, addr %!", name, ioaddr, nic->node_addr);
-	mem_start = RCV_LOWER_LIMIT << 8;
-	if ((mem_end & 0x3F) < 3 || (mem_end & 0x3F) > 29)
-		mem_end = RCV_UPPER_LIMIT << 8;
-	else {
-		mem_end = mem_end * 1024 + (RCV_LOWER_LIMIT << 8);
-		rcv_ram = mem_end - (RCV_LOWER_LIMIT << 8);
-	}
-	printf(", Rx mem %dK, if %s\n", (mem_end - mem_start) >> 10,
-		GetBit(read_eeprom(5), ee_BNC_TPE) ? "BNC" : "TP");
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *eepro_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	unsigned short		*p;
-	/* same probe list as the Linux driver */
-	static unsigned short	ioaddrs[] = {
-		0x300, 0x210, 0x240, 0x280, 0x2C0, 0x200, 0x320, 0x340, 0x360, 0};
-
-	if (probe_addrs == 0 || probe_addrs[0] == 0)
-		probe_addrs = ioaddrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; p++) {
-		if (eepro_probe1(nic))
-			break;
-	}
-	if (*p == 0)
-		return (0);
-	eepro_reset(nic);
-	/* point to NIC specific routines */
-	nic->reset = eepro_reset;
-	nic->poll = eepro_poll;
-	nic->transmit = eepro_transmit;
-	nic->disable = eepro_disable;
-	return (nic);
-}
Index: netboot/depca.c
===================================================================
--- netboot/depca.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/depca.c	(.../trunk)	(revision 112)
@@ -1,752 +0,0 @@
-/* Etherboot: depca.h merged, comments from Linux driver retained */
-/*  depca.c: A DIGITAL DEPCA  & EtherWORKS ethernet driver for linux.
-
-    Written 1994, 1995 by David C. Davies.
-
-
-                      Copyright 1994 David C. Davies
-		                   and 
-			 United States Government
-	 (as represented by the Director, National Security Agency).  
-
-               Copyright 1995  Digital Equipment Corporation.
-
-
-    This software may be used and distributed according to the terms of
-    the GNU Public License, incorporated herein by reference.
-
-    This driver is written for the Digital Equipment Corporation series
-    of DEPCA and EtherWORKS ethernet cards:
-
-        DEPCA       (the original)
-    	DE100
-    	DE101
-	DE200 Turbo
-	DE201 Turbo
-	DE202 Turbo (TP BNC)
-	DE210
-	DE422       (EISA)
-
-    The  driver has been tested on DE100, DE200 and DE202 cards  in  a
-    relatively busy network. The DE422 has been tested a little.
-
-    This  driver will NOT work   for the DE203,  DE204  and DE205 series  of
-    cards,  since they have  a  new custom ASIC in   place of the AMD  LANCE
-    chip.  See the 'ewrk3.c'   driver in the  Linux  source tree for running
-    those cards.
-
-    I have benchmarked the driver with a  DE100 at 595kB/s to (542kB/s from)
-    a DECstation 5000/200.
-
-    The author may be reached at davies@maniac.ultranet.com
-
-    =========================================================================
-
-    The  driver was originally based  on   the 'lance.c' driver from  Donald
-    Becker   which  is included with  the  standard  driver distribution for
-    linux.  V0.4  is  a complete  re-write  with only  the kernel  interface
-    remaining from the original code.
-
-    1) Lance.c code in /linux/drivers/net/
-    2) "Ethernet/IEEE 802.3 Family. 1992 World Network Data Book/Handbook",
-       AMD, 1992 [(800) 222-9323].
-    3) "Am79C90 CMOS Local Area Network Controller for Ethernet (C-LANCE)",
-       AMD, Pub. #17881, May 1993.
-    4) "Am79C960 PCnet-ISA(tm), Single-Chip Ethernet Controller for ISA",
-       AMD, Pub. #16907, May 1992
-    5) "DEC EtherWORKS LC Ethernet Controller Owners Manual",
-       Digital Equipment corporation, 1990, Pub. #EK-DE100-OM.003
-    6) "DEC EtherWORKS Turbo Ethernet Controller Owners Manual",
-       Digital Equipment corporation, 1990, Pub. #EK-DE200-OM.003
-    7) "DEPCA Hardware Reference Manual", Pub. #EK-DEPCA-PR
-       Digital Equipment Corporation, 1989
-    8) "DEC EtherWORKS Turbo_(TP BNC) Ethernet Controller Owners Manual",
-       Digital Equipment corporation, 1991, Pub. #EK-DE202-OM.001
-    
-
-    Peter Bauer's depca.c (V0.5) was referred to when debugging V0.1 of this
-    driver.
-
-    The original DEPCA  card requires that the  ethernet ROM address counter
-    be enabled to count and has an 8 bit NICSR.  The ROM counter enabling is
-    only  done when a  0x08 is read as the  first address octet (to minimise
-    the chances  of writing over some  other hardware's  I/O register).  The
-    NICSR accesses   have been changed  to  byte accesses  for all the cards
-    supported by this driver, since there is only one  useful bit in the MSB
-    (remote boot timeout) and it  is not used.  Also, there  is a maximum of
-    only 48kB network  RAM for this  card.  My thanks  to Torbjorn Lindh for
-    help debugging all this (and holding my feet to  the fire until I got it
-    right).
-
-    The DE200  series  boards have  on-board 64kB  RAM for  use  as a shared
-    memory network  buffer. Only the DE100  cards make use  of a  2kB buffer
-    mode which has not  been implemented in  this driver (only the 32kB  and
-    64kB modes are supported [16kB/48kB for the original DEPCA]).
-
-    At the most only 2 DEPCA cards can  be supported on  the ISA bus because
-    there is only provision  for two I/O base addresses  on each card (0x300
-    and 0x200). The I/O address is detected by searching for a byte sequence
-    in the Ethernet station address PROM at the expected I/O address for the
-    Ethernet  PROM.   The shared memory  base   address  is 'autoprobed'  by
-    looking  for the self  test PROM  and detecting the  card name.   When a
-    second  DEPCA is  detected,  information  is   placed in the   base_addr
-    variable of the  next device structure (which  is created if necessary),
-    thus  enabling ethif_probe  initialization  for the device.  More than 2
-    EISA cards can  be  supported, but  care will  be  needed assigning  the
-    shared memory to ensure that each slot has the  correct IRQ, I/O address
-    and shared memory address assigned.
-
-    ************************************************************************
-
-    NOTE: If you are using two  ISA DEPCAs, it is  important that you assign
-    the base memory addresses correctly.   The  driver autoprobes I/O  0x300
-    then 0x200.  The  base memory address for  the first device must be less
-    than that of the second so that the auto probe will correctly assign the
-    I/O and memory addresses on the same card.  I can't think of a way to do
-    this unambiguously at the moment, since there is nothing on the cards to
-    tie I/O and memory information together.
-
-    I am unable  to  test  2 cards   together for now,    so this  code   is
-    unchecked. All reports, good or bad, are welcome.
-
-    ************************************************************************
-
-    The board IRQ   setting must be  at an  unused IRQ which  is auto-probed
-    using Donald Becker's autoprobe routines. DEPCA and DE100 board IRQs are
-    {2,3,4,5,7}, whereas the  DE200 is at {5,9,10,11,15}.  Note that IRQ2 is
-    really IRQ9 in machines with 16 IRQ lines.
-
-    No 16MB memory  limitation should exist with this  driver as DMA is  not
-    used and the common memory area is in low memory on the network card (my
-    current system has 20MB and I've not had problems yet).
-
-    The ability to load this driver as a loadable module has been added. To
-    utilise this ability, you have to do <8 things:
-
-    0) have a copy of the loadable modules code installed on your system.
-    1) copy depca.c from the  /linux/drivers/net directory to your favourite
-    temporary directory.
-    2) if you wish, edit the  source code near  line 1530 to reflect the I/O
-    address and IRQ you're using (see also 5).
-    3) compile  depca.c, but include -DMODULE in  the command line to ensure
-    that the correct bits are compiled (see end of source code).
-    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a
-    kernel with the depca configuration turned off and reboot.
-    5) insmod depca.o [irq=7] [io=0x200] [mem=0xd0000] [adapter_name=DE100]
-       [Alan Cox: Changed the code to allow command line irq/io assignments]
-       [Dave Davies: Changed the code to allow command line mem/name
-                                                                assignments]
-    6) run the net startup bits for your eth?? interface manually 
-    (usually /etc/rc.inet[12] at boot time). 
-    7) enjoy!
-
-    Note that autoprobing is not allowed in loadable modules - the system is
-    already up and running and you're messing with interrupts.
-
-    To unload a module, turn off the associated interface 
-    'ifconfig eth?? down' then 'rmmod depca'.
-
-    To assign a base memory address for the shared memory  when running as a
-    loadable module, see 5 above.  To include the adapter  name (if you have
-    no PROM  but know the card name)  also see 5  above. Note that this last
-    option  will not work  with kernel  built-in  depca's. 
-
-    The shared memory assignment for a loadable module  makes sense to avoid
-    the 'memory autoprobe' picking the wrong shared memory  (for the case of
-    2 depca's in a PC).
-
-    ************************************************************************
-    Support for MCA EtherWORKS cards added 11-3-98.
-    Verified to work with up to 2 DE212 cards in a system (although not
-      fully stress-tested).  
-
-    Currently known bugs/limitations:
-
-    Note:  with the MCA stuff as a module, it trusts the MCA configuration,
-           not the command line for IRQ and memory address.  You can
-           specify them if you want, but it will throw your values out.
-           You still have to pass the IO address it was configured as
-           though.
-
-    ************************************************************************
-    TO DO:
-    ------
-
-
-    Revision History
-    ----------------
-
-    Version   Date        Description
-  
-      0.1     25-jan-94   Initial writing.
-      0.2     27-jan-94   Added LANCE TX hardware buffer chaining.
-      0.3      1-feb-94   Added multiple DEPCA support.
-      0.31     4-feb-94   Added DE202 recognition.
-      0.32    19-feb-94   Tidy up. Improve multi-DEPCA support.
-      0.33    25-feb-94   Fix DEPCA ethernet ROM counter enable.
-                          Add jabber packet fix from murf@perftech.com
-			  and becker@super.org
-      0.34     7-mar-94   Fix DEPCA max network memory RAM & NICSR access.
-      0.35     8-mar-94   Added DE201 recognition. Tidied up.
-      0.351   30-apr-94   Added EISA support. Added DE422 recognition.
-      0.36    16-may-94   DE422 fix released.
-      0.37    22-jul-94   Added MODULE support
-      0.38    15-aug-94   Added DBR ROM switch in depca_close(). 
-                          Multi DEPCA bug fix.
-      0.38axp 15-sep-94   Special version for Alpha AXP Linux V1.0.
-      0.381   12-dec-94   Added DE101 recognition, fix multicast bug.
-      0.382    9-feb-95   Fix recognition bug reported by <bkm@star.rl.ac.uk>.
-      0.383   22-feb-95   Fix for conflict with VESA SCSI reported by
-                          <stromain@alf.dec.com>
-      0.384   17-mar-95   Fix a ring full bug reported by <bkm@star.rl.ac.uk>
-      0.385    3-apr-95   Fix a recognition bug reported by 
-                                                <ryan.niemi@lastfrontier.com>
-      0.386   21-apr-95   Fix the last fix...sorry, must be galloping senility
-      0.40    25-May-95   Rewrite for portability & updated.
-                          ALPHA support from <jestabro@amt.tay1.dec.com>
-      0.41    26-Jun-95   Added verify_area() calls in depca_ioctl() from
-                          suggestion by <heiko@colossus.escape.de>
-      0.42    27-Dec-95   Add 'mem' shared memory assignment for loadable 
-                          modules.
-                          Add 'adapter_name' for loadable modules when no PROM.
-			  Both above from a suggestion by 
-			  <pchen@woodruffs121.residence.gatech.edu>.
-			  Add new multicasting code.
-      0.421   22-Apr-96	  Fix alloc_device() bug <jari@markkus2.fimr.fi>
-      0.422   29-Apr-96	  Fix depca_hw_init() bug <jari@markkus2.fimr.fi>
-      0.423    7-Jun-96   Fix module load bug <kmg@barco.be>
-      0.43    16-Aug-96   Update alloc_device() to conform to de4x5.c
-      0.44     1-Sep-97   Fix *_probe() to test check_region() first - bug
-                           reported by <mmogilvi@elbert.uccs.edu>
-      0.45     3-Nov-98   Added support for MCA EtherWORKS (DE210/DE212) cards
-                           by <tymm@computer.org> 
-      0.451    5-Nov-98   Fixed mca stuff cuz I'm a dummy. <tymm@computer.org>
-      0.5     14-Nov-98   Re-spin for 2.1.x kernels.
-      0.51    27-Jun-99   Correct received packet length for CRC from
-                           report by <worm@dkik.dk>
-
-    =========================================================================
-*/
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-
-/*
-** I/O addresses. Note that the 2k buffer option is not supported in
-** this driver.
-*/
-#define DEPCA_NICSR ioaddr+0x00   /* Network interface CSR */
-#define DEPCA_RBI   ioaddr+0x02   /* RAM buffer index (2k buffer mode) */
-#define DEPCA_DATA  ioaddr+0x04   /* LANCE registers' data port */
-#define DEPCA_ADDR  ioaddr+0x06   /* LANCE registers' address port */
-#define DEPCA_HBASE ioaddr+0x08   /* EISA high memory base address reg. */
-#define DEPCA_PROM  ioaddr+0x0c   /* Ethernet address ROM data port */
-#define DEPCA_CNFG  ioaddr+0x0c   /* EISA Configuration port */
-#define DEPCA_RBSA  ioaddr+0x0e   /* RAM buffer starting address (2k buff.) */
-
-/*
-** These are LANCE registers addressable through DEPCA_ADDR 
-*/
-#define CSR0       0
-#define CSR1       1
-#define CSR2       2
-#define CSR3       3
-
-/* 
-** NETWORK INTERFACE CSR (NI_CSR) bit definitions 
-*/
- 
-#define TO       	0x0100	/* Time Out for remote boot */
-#define SHE      	0x0080  /* SHadow memory Enable */
-#define BS       	0x0040  /* Bank Select */
-#define BUF      	0x0020	/* BUFfer size (1->32k, 0->64k) */
-#define RBE      	0x0010	/* Remote Boot Enable (1->net boot) */
-#define AAC      	0x0008  /* Address ROM Address Counter (1->enable) */
-#define _128KB      	0x0008  /* 128kB Network RAM (1->enable) */
-#define IM       	0x0004	/* Interrupt Mask (1->mask) */
-#define IEN      	0x0002	/* Interrupt tristate ENable (1->enable) */
-#define LED      	0x0001	/* LED control */
-
-/* 
-** Control and Status Register 0 (CSR0) bit definitions 
-*/
-
-#define ERR     	0x8000 	/* Error summary */
-#define BABL    	0x4000 	/* Babble transmitter timeout error  */
-#define CERR    	0x2000 	/* Collision Error */
-#define MISS    	0x1000 	/* Missed packet */
-#define MERR    	0x0800 	/* Memory Error */
-#define RINT    	0x0400 	/* Receiver Interrupt */
-#define TINT    	0x0200 	/* Transmit Interrupt */
-#define IDON    	0x0100 	/* Initialization Done */
-#define INTR    	0x0080 	/* Interrupt Flag */
-#define INEA    	0x0040 	/* Interrupt Enable */
-#define RXON    	0x0020 	/* Receiver on */
-#define TXON    	0x0010 	/* Transmitter on */
-#define TDMD    	0x0008 	/* Transmit Demand */
-#define STOP    	0x0004 	/* Stop */
-#define STRT    	0x0002 	/* Start */
-#define INIT    	0x0001 	/* Initialize */
-#define INTM            0xff00  /* Interrupt Mask */
-#define INTE            0xfff0  /* Interrupt Enable */
-
-/*
-** CONTROL AND STATUS REGISTER 3 (CSR3)
-*/
-
-#define BSWP    	0x0004	/* Byte SWaP */
-#define ACON    	0x0002	/* ALE control */
-#define BCON    	0x0001	/* Byte CONtrol */
-
-/*
-** Initialization Block Mode Register 
-*/
-
-#define PROM       	0x8000 	/* Promiscuous Mode */
-#define EMBA       	0x0080	/* Enable Modified Back-off Algorithm */
-#define INTL       	0x0040 	/* Internal Loopback */
-#define DRTY       	0x0020 	/* Disable Retry */
-#define COLL       	0x0010 	/* Force Collision */
-#define DTCR       	0x0008 	/* Disable Transmit CRC */
-#define LOOP       	0x0004 	/* Loopback */
-#define DTX        	0x0002 	/* Disable the Transmitter */
-#define DRX        	0x0001 	/* Disable the Receiver */
-
-/*
-** Receive Message Descriptor 1 (RMD1) bit definitions. 
-*/
-
-#define R_OWN       0x80000000 	/* Owner bit 0 = host, 1 = lance */
-#define R_ERR     	0x4000 	/* Error Summary */
-#define R_FRAM    	0x2000 	/* Framing Error */
-#define R_OFLO    	0x1000 	/* Overflow Error */
-#define R_CRC     	0x0800 	/* CRC Error */
-#define R_BUFF    	0x0400 	/* Buffer Error */
-#define R_STP     	0x0200 	/* Start of Packet */
-#define R_ENP     	0x0100 	/* End of Packet */
-
-/*
-** Transmit Message Descriptor 1 (TMD1) bit definitions. 
-*/
-
-#define T_OWN       0x80000000 	/* Owner bit 0 = host, 1 = lance */
-#define T_ERR     	0x4000 	/* Error Summary */
-#define T_ADD_FCS 	0x2000 	/* More the 1 retry needed to Xmit */
-#define T_MORE    	0x1000	/* >1 retry to transmit packet */
-#define T_ONE     	0x0800 	/* 1 try needed to transmit the packet */
-#define T_DEF     	0x0400 	/* Deferred */
-#define T_STP       0x02000000 	/* Start of Packet */
-#define T_ENP       0x01000000	/* End of Packet */
-#define T_FLAGS     0xff000000  /* TX Flags Field */
-
-/*
-** Transmit Message Descriptor 3 (TMD3) bit definitions.
-*/
-
-#define TMD3_BUFF    0x8000	/* BUFFer error */
-#define TMD3_UFLO    0x4000	/* UnderFLOw error */
-#define TMD3_RES     0x2000	/* REServed */
-#define TMD3_LCOL    0x1000	/* Late COLlision */
-#define TMD3_LCAR    0x0800	/* Loss of CARrier */
-#define TMD3_RTRY    0x0400	/* ReTRY error */
-
-/*
-** Ethernet PROM defines
-*/
-#define PROBE_LENGTH    32
-
-/*
-** Set the number of Tx and Rx buffers. Ensure that the memory requested
-** here is <= to the amount of shared memory set up by the board switches.
-** The number of descriptors MUST BE A POWER OF 2.
-**
-** total_memory = NUM_RX_DESC*(8+RX_BUFF_SZ) + NUM_TX_DESC*(8+TX_BUFF_SZ)
-*/
-#define NUM_RX_DESC     2               /* Number of RX descriptors */
-#define NUM_TX_DESC     2               /* Number of TX descriptors */
-#define RX_BUFF_SZ	1536            /* Buffer size for each Rx buffer */
-#define TX_BUFF_SZ	1536            /* Buffer size for each Tx buffer */
-
-/*
-** ISA Bus defines
-*/
-#define DEPCA_IO_PORTS	{0x300, 0x200, 0}
-
-#ifndef	DEPCA_MODEL
-#define	DEPCA_MODEL	DEPCA
-#endif
-
-static enum {
-	DEPCA, DE100, DE101, DE200, DE201, DE202, DE210, DE212, DE422, unknown
-} adapter = DEPCA_MODEL;
-
-/*
-** Name <-> Adapter mapping
-*/
-
-static char *adapter_name[] = {
-	"DEPCA",
-	"DE100","DE101",
-	"DE200","DE201","DE202",
-	"DE210","DE212",
-	"DE422",
-	""
-};
-
-#ifndef	DEPCA_RAM_BASE
-#define DEPCA_RAM_BASE	0xd0000
-#endif
-
-/*
-** Memory Alignment. Each descriptor is 4 longwords long. To force a
-** particular alignment on the TX descriptor, adjust DESC_SKIP_LEN and
-** DESC_ALIGN. ALIGN aligns the start address of the private memory area
-** and hence the RX descriptor ring's first entry. 
-*/
-#define ALIGN4      ((u32)4 - 1)       /* 1 longword align */
-#define ALIGN8      ((u32)8 - 1)       /* 2 longword (quadword) align */
-#define ALIGN         ALIGN8              /* Keep the LANCE happy... */
-
-typedef	long		s32;
-typedef	unsigned long	u32;
-typedef	short		s16;
-typedef	unsigned short	u16;
-typedef	char		s8;
-typedef	unsigned char	u8;
-
-/*
-** The DEPCA Rx and Tx ring descriptors. 
-*/
-struct depca_rx_desc {
-    volatile s32 base;
-    s16 buf_length;		/* This length is negative 2's complement! */
-    s16 msg_length;		/* This length is "normal". */
-};
-
-struct depca_tx_desc {
-    volatile s32 base;
-    s16 length;		        /* This length is negative 2's complement! */
-    s16 misc;                   /* Errors and TDR info */
-};
-
-#define LA_MASK 0x0000ffff      /* LANCE address mask for mapping network RAM
-				   to LANCE memory address space */
-
-/*
-** The Lance initialization block, described in databook, in common memory.
-*/
-struct depca_init {
-    u16 mode;	                /* Mode register */
-    u8  phys_addr[ETH_ALEN];	/* Physical ethernet address */
-    u8  mcast_table[8];	        /* Multicast Hash Table. */
-    u32 rx_ring;     	        /* Rx ring base pointer & ring length */
-    u32 tx_ring;	        /* Tx ring base pointer & ring length */
-};
-
-struct depca_private {
-	struct depca_rx_desc	*rx_ring;
-	struct depca_tx_desc	*tx_ring;
-	struct depca_init	init_block;	/* Shadow init block */
-	char			*rx_memcpy[NUM_RX_DESC];
-	char			*tx_memcpy[NUM_TX_DESC];
-	u32			bus_offset;	/* ISA bus address offset */
-	u32			sh_mem;		/* address of shared mem */
-	u32			dma_buffs;	/* Rx & Tx buffer start */
-	int			rx_cur, tx_cur;	/* Next free ring entry */
-	int			txRingMask, rxRingMask;
-	s32			rx_rlen, tx_rlen;
-	/* log2([rt]xRingMask+1) for the descriptors */
-};
-
-static Address		mem_start = DEPCA_RAM_BASE;
-static Address		mem_len, offset;
-static unsigned short	ioaddr = 0;
-static struct depca_private	lp;
-
-/*
-** Miscellaneous defines...
-*/
-#define STOP_DEPCA \
-    outw(CSR0, DEPCA_ADDR);\
-    outw(STOP, DEPCA_DATA)
-
-/* Initialize the lance Rx and Tx descriptor rings. */
-static void depca_init_ring(struct nic *nic)
-{
-	int	i;
-	u32	p;
-
-	lp.rx_cur = lp.tx_cur = 0;
-	/* Initialize the base addresses and length of each buffer in the ring */
-	for (i = 0; i <= lp.rxRingMask; i++) {
-		writel((p = lp.dma_buffs + i * RX_BUFF_SZ) | R_OWN, &lp.rx_ring[i].base);
-		writew(-RX_BUFF_SZ, &lp.rx_ring[i].buf_length);
-		lp.rx_memcpy[i] = (char *) (p + lp.bus_offset);
-	}
-	for (i = 0; i <= lp.txRingMask; i++) {
-		writel((p = lp.dma_buffs + (i + lp.txRingMask + 1) * TX_BUFF_SZ) & 0x00ffffff, &lp.tx_ring[i].base);
-		lp.tx_memcpy[i] = (char *) (p + lp.bus_offset);
-	}
-
-	/* Set up the initialization block */
-	lp.init_block.rx_ring = ((u32) ((u32) lp.rx_ring) & LA_MASK) | lp.rx_rlen;
-	lp.init_block.tx_ring = ((u32) ((u32) lp.tx_ring) & LA_MASK) | lp.tx_rlen;
-	for (i = 0; i < ETH_ALEN; i++)
-		lp.init_block.phys_addr[i] = nic->node_addr[i];
-	lp.init_block.mode = 0x0000;	/* Enable the Tx and Rx */
-	memset(lp.init_block.mcast_table, 0, sizeof(lp.init_block.mcast_table));
-}
-
-static void LoadCSRs(void)
-{
-	outw(CSR1, DEPCA_ADDR);	/* initialisation block address LSW */
-	outw((u16) (lp.sh_mem & LA_MASK), DEPCA_DATA);
-	outw(CSR2, DEPCA_ADDR);	/* initialisation block address MSW */
-	outw((u16) ((lp.sh_mem & LA_MASK) >> 16), DEPCA_DATA);
-	outw(CSR3, DEPCA_ADDR);	/* ALE control */
-	outw(ACON, DEPCA_DATA);
-	outw(CSR0, DEPCA_ADDR);	/* Point back to CSR0 */
-}
-
-static int InitRestartDepca(void)
-{
-	int		i;
-
-	/* Copy the shadow init_block to shared memory */
-	memcpy_toio((char *)lp.sh_mem, &lp.init_block, sizeof(struct depca_init));
-	outw(CSR0, DEPCA_ADDR);		/* point back to CSR0 */
-	outw(INIT, DEPCA_DATA);		/* initialise DEPCA */
-
-	for (i = 0; i < 100 && !(inw(DEPCA_DATA) & IDON); i++)
-		;
-	if (i < 100) {
-		/* clear IDON by writing a 1, and start LANCE */
-		outw(IDON | STRT, DEPCA_DATA);
-	} else {
-		printf("DEPCA not initialised\n");
-		return (1);
-	}
-	return (0);
-}
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void depca_reset(struct nic *nic)
-{
-	s16	nicsr;
-	int	i, j;
-
-	STOP_DEPCA;
-	nicsr = inb(DEPCA_NICSR);
-	nicsr = ((nicsr & ~SHE & ~RBE & ~IEN) | IM);
-	outb(nicsr, DEPCA_NICSR);
-	if (inw(DEPCA_DATA) != STOP)
-	{
-		printf("depca: Cannot stop NIC\n");
-		return;
-	}
-
-	/* Initialisation block */
-	lp.sh_mem = mem_start;
-	mem_start += sizeof(struct depca_init);
-	/* Tx & Rx descriptors (aligned to a quadword boundary) */
-	mem_start = (mem_start + ALIGN) & ~ALIGN;
-	lp.rx_ring = (struct depca_rx_desc *) mem_start;
-	mem_start += (sizeof(struct depca_rx_desc) * NUM_RX_DESC);
-	lp.tx_ring = (struct depca_tx_desc *) mem_start;
-	mem_start += (sizeof(struct depca_tx_desc) * NUM_TX_DESC);
-
-	lp.bus_offset = mem_start & 0x00ff0000;
-	/* LANCE re-mapped start address */
-	lp.dma_buffs = mem_start & LA_MASK;
-
-	/* Finish initialising the ring information. */
-	lp.rxRingMask = NUM_RX_DESC - 1;
-	lp.txRingMask = NUM_TX_DESC - 1;
-
-	/* Calculate Tx/Rx RLEN size for the descriptors. */
-	for (i = 0, j = lp.rxRingMask; j > 0; i++) {
-		j >>= 1;
-	}
-	lp.rx_rlen = (s32) (i << 29);
-	for (i = 0, j = lp.txRingMask; j > 0; i++) {
-		j >>= 1;
-	}
-	lp.tx_rlen = (s32) (i << 29);
-
-	/* Load the initialisation block */
-	depca_init_ring(nic);
-	LoadCSRs();
-	InitRestartDepca();
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int depca_poll(struct nic *nic)
-{
-	int		entry;
-	u32		status;
-
-	entry = lp.rx_cur;
-	if ((status = readl(&lp.rx_ring[entry].base) & R_OWN))
-		return (0);
-	memcpy(nic->packet, lp.rx_memcpy[entry], nic->packetlen = lp.rx_ring[entry].msg_length);
-	lp.rx_ring[entry].base |= R_OWN;
-	lp.rx_cur = (++lp.rx_cur) & lp.rxRingMask;
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void depca_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	int		entry, len;
-	char		*mem;
-
-	/* send the packet to destination */
-	/*
-	** Caution: the right order is important here... dont
-	** setup the ownership rights until all the other
-	** information is in place
-	*/
-	mem = lp.tx_memcpy[entry = lp.tx_cur];
-	memcpy_toio(mem, d, ETH_ALEN);
-	memcpy_toio(mem + ETH_ALEN, nic->node_addr, ETH_ALEN);
-	mem[ETH_ALEN * 2] = t >> 8;
-	mem[ETH_ALEN * 2 + 1] = t;
-	memcpy_toio(mem + ETH_HLEN, p, s);
-	s += ETH_HLEN;
-	len = (s < ETH_ZLEN ? ETH_ZLEN : s);
-	/* clean out flags */
-	writel(readl(&lp.tx_ring[entry].base) & ~T_FLAGS, &lp.tx_ring[entry].base);
-	/* clears other error flags */
-	writew(0x0000, &lp.tx_ring[entry].misc);
-	/* packet length in buffer */
-	writew(-len, &lp.tx_ring[entry].length);
-	/* start and end of packet, ownership */
-	writel(readl(&lp.tx_ring[entry].base) | (T_STP|T_ENP|T_OWN), &lp.tx_ring[entry].base);
-	/* update current pointers */
-	lp.tx_cur = (++lp.tx_cur) & lp.txRingMask;
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void depca_disable(struct nic *nic)
-{
-	STOP_DEPCA;
-}
-
-/*
-** Look for a special sequence in the Ethernet station address PROM that
-** is common across all DEPCA products. Note that the original DEPCA needs
-** its ROM address counter to be initialized and enabled. Only enable
-** if the first address octet is a 0x08 - this minimises the chances of
-** messing around with some other hardware, but it assumes that this DEPCA
-** card initialized itself correctly.
-**
-** Search the Ethernet address ROM for the signature. Since the ROM address
-** counter can start at an arbitrary point, the search must include the entire
-** probe sequence length plus the (length_of_the_signature - 1).
-** Stop the search IMMEDIATELY after the signature is found so that the
-** PROM address counter is correctly positioned at the start of the
-** ethernet address for later read out.
-*/
-static int depca_probe1(struct nic *nic)
-{
-	u8	data, nicsr;
-	/* This is only correct for little endian machines, but then
-	   Etherboot doesn't work on anything but a PC */
-	u8	sig[] = { 0xFF, 0x00, 0x55, 0xAA, 0xFF, 0x00, 0x55, 0xAA };
-	int	i, j;
-	long	sum, chksum;
-
-	data = inb(DEPCA_PROM);		/* clear counter on DEPCA */
-	data = inb(DEPCA_PROM);		/* read data */
-	if (data == 0x8) {
-		nicsr = inb(DEPCA_NICSR);
-		nicsr |= AAC;
-		outb(nicsr, DEPCA_NICSR);
-	}
-	for (i = 0, j = 0; j < (int)sizeof(sig) && i < PROBE_LENGTH+((int)sizeof(sig))-1; ++i) {
-		data = inb(DEPCA_PROM);
-		if (data == sig[j])		/* track signature */
-			++j;
-		else
-			j = (data == sig[0]) ? 1 : 0;
-	}
-	if (j != sizeof(sig))
-		return (0);
-	/* put the card in its initial state */
-	STOP_DEPCA;
-	nicsr = ((inb(DEPCA_NICSR) & ~SHE & ~RBE & ~IEN) | IM);
-	outb(nicsr, DEPCA_NICSR);
-	if (inw(DEPCA_DATA) != STOP)
-		return (0);
-	memcpy((char *)mem_start, sig, sizeof(sig));
-	if (memcmp((char *)mem_start, sig, sizeof(sig)) != 0)
-		return (0);
-	for (i = 0, j = 0, sum = 0; j < 3; j++) {
-		sum <<= 1;
-		if (sum > 0xFFFF)
-			sum -= 0xFFFF;
-		sum += (u8)(nic->node_addr[i++] = inb(DEPCA_PROM));
-		sum += (u16)((nic->node_addr[i++] = inb(DEPCA_PROM)) << 8);
-		if (sum > 0xFFFF)
-			sum -= 0xFFFF;
-	}
-	if (sum == 0xFFFF)
-		sum = 0;
-	chksum = (u8)inb(DEPCA_PROM);
-	chksum |= (u16)(inb(DEPCA_PROM) << 8);
-	mem_len = (adapter == DEPCA) ? (48 << 10) : (64 << 10);
-	offset = 0;
-	if (nicsr & BUF) {
-		offset = 0x8000;
-		nicsr &= ~BS;
-		mem_len -= (32 << 10);
-	}
-	if (adapter != DEPCA)	/* enable shadow RAM */
-		outb(nicsr |= SHE, DEPCA_NICSR);
-	printf("%s base %#hX, memory [%#hX-%#hX], addr %!",
-		adapter_name[adapter], ioaddr, mem_start, mem_start + mem_len,
-		nic->node_addr);
-	if (sum != chksum)
-		printf(" (bad checksum)");
-	putchar('\n');
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *depca_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static unsigned short	base[] = DEPCA_IO_PORTS;
-	int			i;
-
-	if (probe_addrs == 0 || probe_addrs[0] == 0)
-		probe_addrs = base;	/* Use defaults */
-	for (i = 0; (ioaddr = base[i]) != 0; ++i) {
-		if (depca_probe1(nic))
-			break;
-	}
-	if (ioaddr == 0)
-		return (0);
-	depca_reset(nic);
-	/* point to NIC specific routines */
-	nic->reset = depca_reset;
-	nic->poll = depca_poll;
-	nic->transmit = depca_transmit;
-	nic->disable = depca_disable;
-	return (nic);
-}
Index: netboot/otulip.c
===================================================================
--- netboot/otulip.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/otulip.c	(.../trunk)	(revision 112)
@@ -1,374 +0,0 @@
-/*
-  Etherboot DEC Tulip driver
-  adapted by Ken Yap from
-
-  FreeBSD netboot DEC 21143 driver
-
-  Author: David Sharp
-    date: Nov/98
-
- Known to work on DEC DE500 using 21143-PC chipset.
- Even on cards with the same chipset there can be
- incompatablity problems with the way media selection
- and status LED settings are done.  See comments below.
-
- Some code fragments were taken from verious places,
- Ken Yap's etherboot, FreeBSD's if_de.c, and various
- Linux related files.  DEC's manuals for the 21143 and
- SROM format were very helpful.  The Linux de driver
- development page has a number of links to useful
- related information.  Have a look at:
- ftp://cesdis.gsfc.nasa.gov/pub/linux/drivers/tulip-devel.html
-
-*/
-
-#include "etherboot.h"
-#include "nic.h"
-#include "pci.h"
-#include "cards.h"
-#include "otulip.h"
-
-static unsigned short vendor, dev_id;
-static unsigned short ioaddr;
-static unsigned int *membase;
-static unsigned char srom[1024];
-
-#define BUFLEN 1536     /* must be longword divisable */
-                        /* buffers must be longword aligned */
-
-/* transmit descriptor and buffer */
-static struct txdesc txd;
-
-/* receive descriptor(s) and buffer(s) */
-#define NRXD 4
-static struct rxdesc rxd[NRXD];
-static int rxd_tail = 0;
-#ifdef	USE_LOWMEM_BUFFER
-#define rxb ((char *)0x10000 - NRXD * BUFLEN)
-#define txb ((char *)0x10000 - NRXD * BUFLEN - BUFLEN)
-#else
-static unsigned char rxb[NRXD * BUFLEN];
-static unsigned char txb[BUFLEN];
-#endif
-
-static unsigned char ehdr[ETH_HLEN];    /* buffer for ethernet header */
-
-enum tulip_offsets {
-        CSR0=0,    CSR1=0x08, CSR2=0x10, CSR3=0x18, CSR4=0x20, CSR5=0x28,
-        CSR6=0x30, CSR7=0x38, CSR8=0x40, CSR9=0x48, CSR10=0x50, CSR11=0x58,
-        CSR12=0x60, CSR13=0x68, CSR14=0x70, CSR15=0x78 };
-
-
-/***************************************************************************/
-/* 21143 specific stuff  */
-/***************************************************************************/
-
-/* XXX assume 33MHz PCI bus,  this is not very accurate and should be
-   used only with gross over estimations of required delay times unless
-   you tune UADJUST to your specific processor and I/O subsystem */
-
-#define UADJUST 870
-static void udelay(unsigned long usec) {
-  unsigned long i;
-  for (i=((usec*UADJUST)/33)+1; i>0; i--) (void) TULIP_CSR_READ(csr_0);
-}
-
-/* The following srom related code was taken from FreeBSD's if_de.c */
-/* with minor alterations to make it work here.  the Linux code is */
-/* better but this was easier to use */
-
-static void delay_300ns(void)
-{
-    int idx;
-    for (idx = (300 / 33) + 1; idx > 0; idx--)
-        (void) TULIP_CSR_READ(csr_busmode);
-}
-
-#define EMIT do { TULIP_CSR_WRITE(csr_srom_mii, csr); delay_300ns(); } while (0)
-
-static void srom_idle(void)
-{
-    unsigned bit, csr;
-
-    csr  = SROMSEL ; EMIT;
-    csr  = SROMSEL | SROMRD; EMIT;
-    csr ^= SROMCS; EMIT;
-    csr ^= SROMCLKON; EMIT;
-    /*
-     * Write 25 cycles of 0 which will force the SROM to be idle.
-     */
-    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {
-        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
-        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
-    }
-    csr ^= SROMCLKOFF; EMIT;
-    csr ^= SROMCS; EMIT;
-    csr  = 0; EMIT;
-}
-
-static void srom_read(void)
-{
-    unsigned idx;
-    const unsigned bitwidth = SROM_BITWIDTH;
-    const unsigned cmdmask = (SROMCMD_RD << bitwidth);
-    const unsigned msb = 1 << (bitwidth + 3 - 1);
-    unsigned lastidx = (1 << bitwidth) - 1;
-
-    srom_idle();
-
-    for (idx = 0; idx <= lastidx; idx++) {
-        unsigned lastbit, data, bits, bit, csr;
-        csr  = SROMSEL ;                EMIT;
-        csr  = SROMSEL | SROMRD;        EMIT;
-        csr ^= SROMCSON;                EMIT;
-        csr ^=            SROMCLKON;    EMIT;
-
-        lastbit = 0;
-        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1)
- {
-            const unsigned thisbit = bits & msb;
-            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
-            if (thisbit != lastbit) {
-                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */
-            } else {
-                EMIT;
-            }
-            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
-            lastbit = thisbit;
-        }
-        csr ^= SROMCLKOFF; EMIT;
-
-        for (data = 0, bits = 0; bits < 16; bits++) {
-            data <<= 1;
-            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
-            data |= TULIP_CSR_READ(csr_srom_mii) & SROMDIN ? 1 : 0;
-            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
-        }
-        srom[idx*2] = data & 0xFF;
-        srom[idx*2+1] = data >> 8;
-        csr  = SROMSEL | SROMRD; EMIT;
-        csr  = 0; EMIT;
-    }
-    srom_idle();
-}
-
-/**************************************************************************
-ETH_RESET - Reset adapter
-***************************************************************************/
-static void tulip_reset(struct nic *nic)
-{
-        int x,cnt=2;
-
-        outl(0x00000001, ioaddr + CSR0);
-        udelay(1000);
-        /* turn off reset and set cache align=16lword, burst=unlimit */
-        outl(0x01A08000, ioaddr + CSR0);
-
-	/* for some reason the media selection does not take
-           the first time se it is repeated.  */
-
-        while(cnt--) {
-        /* stop TX,RX processes */
-        if (cnt == 1)
-		outl(0x32404000, ioaddr + CSR6);
-        else
-		outl(0x32000040, ioaddr + CSR6);
-
-        /* XXX - media selection is vendor specific and hard coded right
-           here.  This should be fixed to use the hints in the SROM and
-           allow media selection by the user at runtime.  MII support
-           should also be added.  Support for chips other than the
-           21143 should be added here as well  */
-
-        /* start  set to 10Mbps half-duplex */
-
-        /* setup SIA */
-        outl(0x0, ioaddr + CSR13);              /* reset SIA */
-        outl(0x7f3f, ioaddr + CSR14);
-        outl(0x8000008, ioaddr + CSR15);
-        outl(0x0, ioaddr + CSR13);
-        outl(0x1, ioaddr + CSR13);
-        outl(0x2404000, ioaddr + CSR6);
-
-        /* initalize GP */
-        outl(0x8af0008, ioaddr + CSR15);
-        outl(0x50008, ioaddr + CSR15);
-
-        /* end  set to 10Mbps half-duplex */
-
-	if (vendor == PCI_VENDOR_ID_MACRONIX && dev_id == PCI_DEVICE_ID_MX987x5) {
-		/* do stuff for MX98715 */
-		outl(0x01a80000, ioaddr + CSR6);
-		outl(0xFFFFFFFF, ioaddr + CSR14);
-		outl(0x00001000, ioaddr + CSR12);
-	}
-
-        outl(0x0, ioaddr + CSR7);       /* disable interrupts */
-
-        /* construct setup packet which is used by the 21143 to
-           program its CAM to recognize interesting MAC addresses */
-
-        memset(&txd, 0, sizeof(struct txdesc));
-        txd.buf1addr = &txb[0];
-        txd.buf2addr = &txb[0];         /* just in case */
-        txd.buf1sz   = 192;             /* setup packet must be 192 bytes */
-        txd.buf2sz   = 0;
-        txd.control  = 0x020;           /* setup packet */
-        txd.status   = 0x80000000;      /* give ownership to 21143 */
-
-        /* construct perfect filter frame */
-        /* with mac address as first match */
-        /* and broadcast address for all others */
-
-        for(x=0;x<192;x++) txb[x] = 0xff;
-        txb[0] = nic->node_addr[0];
-        txb[1] = nic->node_addr[1];
-        txb[4] = nic->node_addr[2];
-        txb[5] = nic->node_addr[3];
-        txb[8] = nic->node_addr[4];
-        txb[9] = nic->node_addr[5];
-        outl((unsigned long)&txd, ioaddr + CSR4);        /* set xmit buf */
-        outl(0x2406000, ioaddr + CSR6);         /* start transmiter */
-
-        udelay(50000);  /* wait for the setup packet to be processed */
-
-        }
-
-        /* setup receive descriptor */
-        {
-          int x;
-          for(x=0;x<NRXD;x++) {
-            memset(&rxd[x], 0, sizeof(struct rxdesc));
-            rxd[x].buf1addr = &rxb[x * BUFLEN];
-            rxd[x].buf2addr = 0;        /* not used */
-            rxd[x].buf1sz   = BUFLEN;
-            rxd[x].buf2sz   = 0;        /* not used */
-            rxd[x].control  = 0x0;
-            rxd[x].status   = 0x80000000;       /* give ownership it to 21143 */
-          }
-          rxd[NRXD - 1].control  = 0x008;       /* Set Receive end of ring on la
-st descriptor */
-          rxd_tail = 0;
-        }
-
-        /* tell DC211XX where to find rx descriptor list */
-        outl((unsigned long)&rxd[0], ioaddr + CSR3);
-        /* start the receiver */
-        outl(0x2406002, ioaddr + CSR6);
-
-}
-
-/**************************************************************************
-ETH_TRANSMIT - Transmit a frame
-***************************************************************************/
-static const char padmap[] = {
-        0, 3, 2, 1};
-
-static void tulip_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p)
-{
-        unsigned long time;
-
-        /* setup ethernet header */
-
-	memcpy(ehdr, d, ETH_ALEN);
-	memcpy(&ehdr[ETH_ALEN], nic->node_addr, ETH_ALEN);
-        ehdr[ETH_ALEN*2] = (t >> 8) & 0xff;
-        ehdr[ETH_ALEN*2+1] = t & 0xff;
-
-        /* setup the transmit descriptor */
-
-        memset(&txd, 0, sizeof(struct txdesc));
-
-        txd.buf1addr = &ehdr[0];        /* ethernet header */
-        txd.buf1sz   = ETH_HLEN;
-
-        txd.buf2addr = p;               /* packet to transmit */
-        txd.buf2sz   = s;
-
-        txd.control  = 0x188;           /* LS+FS+TER */
-
-        txd.status   = 0x80000000;      /* give it to 21143 */
-
-        outl(inl(ioaddr + CSR6) & ~0x00004000, ioaddr + CSR6);
-        outl((unsigned long)&txd, ioaddr + CSR4);
-        outl(inl(ioaddr + CSR6) | 0x00004000, ioaddr + CSR6);
-
-/*   Wait for transmit to complete before returning.  not well tested.
-
-        time = currticks();
-        while(txd.status & 0x80000000) {
-          if (currticks() - time > 20) {
-            printf("transmit timeout.\n");
-            break;
-          }
-        }
-*/
-
-}
-
-/**************************************************************************
-ETH_POLL - Wait for a frame
-***************************************************************************/
-static int tulip_poll(struct nic *nic)
-{
-        if (rxd[rxd_tail].status & 0x80000000) return 0;
-
-        nic->packetlen = (rxd[rxd_tail].status & 0x3FFF0000) >> 16;
-
-        /* copy packet to working buffer */
-        /* XXX - this copy could be avoided with a little more work
-           but for now we are content with it because the optimised
-           memcpy(, , ) is quite fast */
-
-        memcpy(nic->packet, rxb + rxd_tail * BUFLEN, nic->packetlen);
-
-        /* return the descriptor and buffer to recieve ring */
-        rxd[rxd_tail].status = 0x80000000;
-        rxd_tail++;
-        if (rxd_tail == NRXD) rxd_tail = 0;
-
-        return 1;
-}
-
-static void tulip_disable(struct nic *nic)
-{
-	/* nothing for the moment */
-}
-
-/**************************************************************************
-ETH_PROBE - Look for an adapter
-***************************************************************************/
-struct nic *otulip_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
-{
-        int i;
-
-	if (io_addrs == 0 || *io_addrs == 0)
-		return (0);
-	vendor = pci->vendor;
-	dev_id = pci->dev_id;
-	ioaddr = *io_addrs;
-	membase = (unsigned int *)pci->membase;
-
-        /* wakeup chip */
-        pcibios_write_config_dword(pci->bus,pci->devfn,0x40,0x00000000);
-
-        /* Stop the chip's Tx and Rx processes. */
-        /* outl(inl(ioaddr + CSR6) & ~0x2002, ioaddr + CSR6); */
-        /* Clear the missed-packet counter. */
-        /* (volatile int)inl(ioaddr + CSR8); */
-
-        srom_read();
-
-	for (i=0; i < ETH_ALEN; i++)
-		nic->node_addr[i] = srom[20+i];
-
-        printf("Tulip %! at ioaddr %#hX\n", nic->node_addr, ioaddr);
-
-        tulip_reset(nic);
-
-	nic->reset = tulip_reset;
-	nic->poll = tulip_poll;
-	nic->transmit = tulip_transmit;
-	nic->disable = tulip_disable;
-        return nic;
-}
Index: netboot/otulip.h
===================================================================
--- netboot/otulip.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/otulip.h	(.../trunk)	(revision 112)
@@ -1,76 +0,0 @@
-/* mostly stolen from FreeBSD if_de.c, if_devar.h */
-
-#define TULIP_CSR_READ(csr)		(membase[csr*2])
-#define CSR_READ(csr)			(membase[csr*2])
-#define TULIP_CSR_WRITE(csr, val)	(membase[csr*2] = val)
-#define CSR_WRITE(csr, val)		(membase[csr*2] = val)
-
-#define csr_0			0
-#define csr_1			1
-#define csr_2			2
-#define csr_3			3
-#define csr_4			4
-#define csr_5			5
-#define csr_6			6
-#define csr_7			7
-#define csr_8			8
-#define csr_9			9
-#define csr_10			10
-#define csr_11			11
-#define csr_12			12
-#define csr_13			13
-#define csr_14			14
-#define csr_15			15
-
-#define csr_busmode		csr_0
-#define csr_txpoll		csr_1
-#define csr_rxpoll		csr_2
-#define csr_rxlist		csr_3
-#define csr_txlist		csr_4
-#define csr_status		csr_5
-#define csr_command		csr_6
-#define csr_intr		csr_7
-#define csr_missed_frames	csr_8
-#define csr_enetrom		csr_9		/* 21040 */
-#define csr_reserved		csr_10		/* 21040 */
-#define csr_full_duplex		csr_11		/* 21040 */
-#define csr_bootrom		csr_10		/* 21041/21140A/?? */
-#define csr_gp			csr_12		/* 21140* */
-#define csr_watchdog		csr_15		/* 21140* */
-#define csr_gp_timer		csr_11		/* 21041/21140* */
-#define csr_srom_mii		csr_9		/* 21041/21140* */
-#define csr_sia_status		csr_12		/* 2104x */
-#define csr_sia_connectivity	csr_13		/* 2104x */
-#define csr_sia_tx_rx		csr_14		/* 2104x */
-#define csr_sia_general		csr_15		/* 2104x */
-
-#define SROMSEL		0x0800
-#define SROMCS		0x0001
-#define SROMCLKON	0x0002
-#define SROMCLKOFF	0x0002
-#define SROMRD		0x4000
-#define SROMWR		0x2000
-#define SROM_BITWIDTH	6
-#define SROMCMD_RD	6
-#define SROMCSON	0x0001
-#define SROMDOUT	0x0004
-#define SROMDIN		0x0008
-
-
-struct txdesc {
-	unsigned long	status;		/* owner, status */
-	unsigned long	buf1sz:11,	/* size of buffer 1 */
-			buf2sz:11,	/* size of buffer 2 */
-			control:10;	/* control bits */
-	const unsigned char *buf1addr;	/* buffer 1 address */
-	const unsigned char *buf2addr;	/* buffer 2 address */
-};
-
-struct rxdesc {
-	unsigned long	status;		/* owner, status */
-	unsigned long	buf1sz:11,	/* size of buffer 1 */
-			buf2sz:11,	/* size of buffer 2 */
-			control:10;	/* control bits */
-	unsigned char	*buf1addr;	/* buffer 1 address */
-	unsigned char	*buf2addr;	/* buffer 2 address */
-};
Index: netboot/lance.c
===================================================================
--- netboot/lance.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/lance.c	(.../trunk)	(revision 112)
@@ -1,564 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-LANCE NIC driver for Etherboot
-Large portions borrowed from the Linux LANCE driver by Donald Becker
-Ken Yap, July 1997
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-#ifdef	INCLUDE_LANCE
-#include "pci.h"
-#endif
-#include "cards.h"
-
-/* Offsets from base I/O address */
-#if	defined(INCLUDE_NE2100) || defined(INCLUDE_LANCE)
-#define	LANCE_ETH_ADDR	0x0
-#define	LANCE_DATA	0x10
-#define	LANCE_ADDR	0x12
-#define	LANCE_RESET	0x14
-#define	LANCE_BUS_IF	0x16
-#define	LANCE_TOTAL_SIZE	0x18
-#endif
-#ifdef	INCLUDE_NI6510
-#define	LANCE_ETH_ADDR	0x8
-#define	LANCE_DATA	0x0
-#define	LANCE_ADDR	0x2
-#define	LANCE_RESET	0x4
-#define	LANCE_BUS_IF	0x6
-#define	LANCE_TOTAL_SIZE	0x10
-#endif
-
-/* lance_poll() now can use multiple Rx buffers to prevent packet loss. Set
- * Set LANCE_LOG_RX_BUFFERS to 0..7 for 1, 2, 4, 8, 16, 32, 64 or 128 Rx
- * buffers. Usually 4 (=16 Rx buffers) is a good value. (Andreas Neuhaus)
- * Decreased to 2 (=4 Rx buffers) (Ken Yap, 20010305) */
-
-#define LANCE_LOG_RX_BUFFERS	2		/* Use 2^2=4 Rx buffers */
-
-#define RX_RING_SIZE		(1 << (LANCE_LOG_RX_BUFFERS))
-#define RX_RING_MOD_MASK	(RX_RING_SIZE - 1)
-#define RX_RING_LEN_BITS	((LANCE_LOG_RX_BUFFERS) << 29)
-
-struct lance_init_block
-{
-	unsigned short	mode;
-	unsigned char	phys_addr[ETH_ALEN];
-	unsigned long	filter[2];
-	Address		rx_ring;
-	Address		tx_ring;
-};
-
-struct lance_rx_head
-{
-	union {
-		Address		base;
-		unsigned char	addr[4];
-	} u;
-	short		buf_length;	/* 2s complement */
-	short		msg_length;
-};
-
-struct lance_tx_head
-{
-	union {
-		Address		base;
-		unsigned char	addr[4];
-	} u;
-	short		buf_length;	/* 2s complement */
-	short		misc;
-};
-
-struct lance_interface
-{
-	struct lance_init_block	init_block;
-	struct lance_rx_head	rx_ring[RX_RING_SIZE];
-	struct lance_tx_head	tx_ring;
-	unsigned char		rbuf[RX_RING_SIZE][ETH_FRAME_LEN+4];
-	unsigned char		tbuf[ETH_FRAME_LEN];
-	/*
-	 * Do not alter the order of the struct members above;
-	 * the hardware depends on the correct alignment.
-	 */
-	int			rx_idx;
-};
-
-#define	LANCE_MUST_PAD		0x00000001
-#define	LANCE_ENABLE_AUTOSELECT	0x00000002
-#define	LANCE_SELECT_PHONELINE	0x00000004
-#define	LANCE_MUST_UNRESET	0x00000008
-
-/* A mapping from the chip ID number to the part number and features.
-   These are from the datasheets -- in real life the '970 version
-   reportedly has the same ID as the '965. */
-static const struct lance_chip_type
-{
-	int	id_number;
-	const char	*name;
-	int	flags;
-} chip_table[] = {
-	{0x0000, "LANCE 7990",			/* Ancient lance chip.  */
-		LANCE_MUST_PAD + LANCE_MUST_UNRESET},
-	{0x0003, "PCnet/ISA 79C960",		/* 79C960 PCnet/ISA.  */
-		LANCE_ENABLE_AUTOSELECT},
-	{0x2260, "PCnet/ISA+ 79C961",		/* 79C961 PCnet/ISA+, Plug-n-Play.  */
-		LANCE_ENABLE_AUTOSELECT},
-	{0x2420, "PCnet/PCI 79C970",		/* 79C970 or 79C974 PCnet-SCSI, PCI. */
-		LANCE_ENABLE_AUTOSELECT},
-	/* Bug: the PCnet/PCI actually uses the PCnet/VLB ID number, so just call
-		it the PCnet32. */
-	{0x2430, "PCnet32",			/* 79C965 PCnet for VL bus. */
-		LANCE_ENABLE_AUTOSELECT},
-        {0x2621, "PCnet/PCI-II 79C970A",        /* 79C970A PCInetPCI II. */
-                LANCE_ENABLE_AUTOSELECT},
-	{0x2625, "PCnet-FAST III 79C973",	/* 79C973 PCInet-FAST III. */
-		LANCE_ENABLE_AUTOSELECT},
-        {0x2626, "PCnet/HomePNA 79C978",        
-                LANCE_ENABLE_AUTOSELECT|LANCE_SELECT_PHONELINE},
-	{0x0, "PCnet (unknown)",
-		LANCE_ENABLE_AUTOSELECT},
-};
-
-/* Define a macro for converting program addresses to real addresses */
-#undef	virt_to_bus
-#define	virt_to_bus(x)		((unsigned long)x)
-
-static int			chip_version;
-static int			lance_version;
-static unsigned short		ioaddr;
-#ifndef	INCLUDE_LANCE
-static int			dma;
-#endif
-static struct lance_interface	*lp;
-
-/* additional 8 bytes for 8-byte alignment space */
-#ifdef	USE_LOWMEM_BUFFER
-#define lance ((char *)0x10000 - (sizeof(struct lance_interface)+8))
-#else
-static char			lance[sizeof(struct lance_interface)+8];
-#endif
-
-#ifndef	INCLUDE_LANCE
-/* DMA defines and helper routines */
-
-/* DMA controller registers */
-#define DMA1_CMD_REG		0x08	/* command register (w) */
-#define DMA1_STAT_REG		0x08	/* status register (r) */
-#define DMA1_REQ_REG            0x09    /* request register (w) */
-#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
-#define DMA1_MODE_REG		0x0B	/* mode register (w) */
-#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
-#define DMA1_TEMP_REG           0x0D    /* Temporary Register (r) */
-#define DMA1_RESET_REG		0x0D	/* Master Clear (w) */
-#define DMA1_CLR_MASK_REG       0x0E    /* Clear Mask */
-#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
-
-#define DMA2_CMD_REG		0xD0	/* command register (w) */
-#define DMA2_STAT_REG		0xD0	/* status register (r) */
-#define DMA2_REQ_REG            0xD2    /* request register (w) */
-#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
-#define DMA2_MODE_REG		0xD6	/* mode register (w) */
-#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
-#define DMA2_TEMP_REG           0xDA    /* Temporary Register (r) */
-#define DMA2_RESET_REG		0xDA	/* Master Clear (w) */
-#define DMA2_CLR_MASK_REG       0xDC    /* Clear Mask */
-#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
-
-
-#define DMA_MODE_READ	0x44	/* I/O to memory, no autoinit, increment, single mode */
-#define DMA_MODE_WRITE	0x48	/* memory to I/O, no autoinit, increment, single mode */
-#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
-
-/* enable/disable a specific DMA channel */
-static void enable_dma(unsigned int dmanr)
-{
-	if (dmanr <= 3)
-		outb_p(dmanr, DMA1_MASK_REG);
-	else
-		outb_p(dmanr & 3, DMA2_MASK_REG);
-}
-
-static void disable_dma(unsigned int dmanr)
-{
-	if (dmanr <= 3)
-		outb_p(dmanr | 4, DMA1_MASK_REG);
-	else
-		outb_p((dmanr & 3) | 4, DMA2_MASK_REG);
-}
-
-/* set mode (above) for a specific DMA channel */
-static void set_dma_mode(unsigned int dmanr, char mode)
-{
-	if (dmanr <= 3)
-		outb_p(mode | dmanr, DMA1_MODE_REG);
-	else
-		outb_p(mode | (dmanr&3), DMA2_MODE_REG);
-}
-#endif	/* !INCLUDE_LANCE */
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void lance_reset(struct nic *nic)
-{
-	int		i;
-	Address		l;
-
-	/* Reset the LANCE */
-	(void)inw(ioaddr+LANCE_RESET);
-	/* Un-Reset the LANCE, needed only for the NE2100 */
-	if (chip_table[lance_version].flags & LANCE_MUST_UNRESET)
-		outw(0, ioaddr+LANCE_RESET);
-	if (chip_table[lance_version].flags & LANCE_ENABLE_AUTOSELECT)
-	{
-		/* This is 79C960 specific; Turn on auto-select of media
-		   (AUI, BNC). */
-		outw(0x2, ioaddr+LANCE_ADDR);
-		/* Don't touch 10base2 power bit. */
-		outw(inw(ioaddr+LANCE_BUS_IF) | 0x2, ioaddr+LANCE_BUS_IF);
-	}
-	/* HomePNA cards need to explicitly pick the phoneline interface.
-	 * Some of these cards have ethernet interfaces as well, this
-	 * code might require some modification for those.
-  	 */
-        if (chip_table[lance_version].flags & LANCE_SELECT_PHONELINE) {
-                short media, check ;
-                /* this is specific to HomePNA cards... */
-                outw(49, ioaddr+0x12) ;
-                media = inw(ioaddr+0x16) ;
-#ifdef DEBUG
-                printf("media was %d\n", media) ;
-#endif
-                media &= ~3 ;
-                media |= 1 ;
-#ifdef DEBUG
-                printf("media changed to %d\n", media) ;
-#endif
-                media &= ~3 ;
-                media |= 1 ;
-                outw(49, ioaddr+0x12) ;
-                outw(media, ioaddr+0x16) ;
-                outw(49, ioaddr+0x12) ;
-                check = inw(ioaddr+0x16) ;
-#ifdef DEBUG
-                printf("check %s, media was set properly\n", 
-			check ==  media ? "passed" : "FAILED" ) ; 
-#endif
-	}
- 
-	/* Re-initialise the LANCE, and start it when done. */
-	/* Set station address */
-	for (i = 0; i < ETH_ALEN; ++i)
-		lp->init_block.phys_addr[i] = nic->node_addr[i];
-	/* Preset the receive ring headers */
-	for (i=0; i<RX_RING_SIZE; i++) {
-		lp->rx_ring[i].buf_length = -ETH_FRAME_LEN-4;
-		/* OWN */
-		lp->rx_ring[i].u.base = virt_to_bus(lp->rbuf[i]) & 0xffffff;
-		/* we set the top byte as the very last thing */
-		lp->rx_ring[i].u.addr[3] = 0x80;
-	}
-	lp->rx_idx = 0;
-	lp->init_block.mode = 0x0;	/* enable Rx and Tx */
-	l = (Address)virt_to_bus(&lp->init_block);
-	outw(0x1, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((short)l, ioaddr+LANCE_DATA);
-	outw(0x2, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((short)(l >> 16), ioaddr+LANCE_DATA);
-	outw(0x4, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x915, ioaddr+LANCE_DATA);
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x4, ioaddr+LANCE_DATA);		/* stop */
-	outw(0x1, ioaddr+LANCE_DATA);		/* init */
-	for (i = 10000; i > 0; --i)
-		if (inw(ioaddr+LANCE_DATA) & 0x100)
-			break;
-#ifdef	DEBUG
-	if (i <= 0)
-		printf("Init timed out\n");
-#endif
-	/* Apparently clearing the InitDone bit here triggers a bug
-	   in the '974. (Mark Stockton) */
-	outw(0x2, ioaddr+LANCE_DATA);		/* start */
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int lance_poll(struct nic *nic)
-{
-	int		status;
-
-	status = lp->rx_ring[lp->rx_idx].u.base >> 24;
-	if (status & 0x80)
-		return (0);
-#ifdef	DEBUG
-	printf("LANCE packet received rx_ring.u.base %X mcnt %hX csr0 %hX\n",
-		lp->rx_ring[lp->rx_idx].u.base, lp->rx_ring[lp->rx_idx].msg_length,
-		inw(ioaddr+LANCE_DATA));
-#endif
-	if (status == 0x3)
-		memcpy(nic->packet, lp->rbuf[lp->rx_idx], nic->packetlen = lp->rx_ring[lp->rx_idx].msg_length);
-	/* Andrew Boyd of QNX reports that some revs of the 79C765
-	   clear the buffer length */
-	lp->rx_ring[lp->rx_idx].buf_length = -ETH_FRAME_LEN-4;
-	lp->rx_ring[lp->rx_idx].u.addr[3] |= 0x80;	/* prime for next receive */
-
-	/* I'm not sure if the following is still ok with multiple Rx buffers, but it works */
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x500, ioaddr+LANCE_DATA);		/* clear receive + InitDone */
-
-	/* Switch to the next Rx ring buffer */
-	lp->rx_idx = (lp->rx_idx + 1) & RX_RING_MOD_MASK;
-
-	return (status == 0x3);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void lance_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	unsigned long		time;
-
-	/* copy the packet to ring buffer */
-	memcpy(lp->tbuf, d, ETH_ALEN);	/* dst */
-	memcpy(&lp->tbuf[ETH_ALEN], nic->node_addr, ETH_ALEN); /* src */
-	lp->tbuf[ETH_ALEN+ETH_ALEN] = t >> 8;	/* type */
-	lp->tbuf[ETH_ALEN+ETH_ALEN+1] = t;	/* type */
-	memcpy(&lp->tbuf[ETH_HLEN], p, s);
-	s += ETH_HLEN;
-	if (chip_table[chip_version].flags & LANCE_MUST_PAD)
-		while (s < ETH_ZLEN)	/* pad to min length */
-			lp->tbuf[s++] = 0;
-	lp->tx_ring.buf_length = -s;
-	lp->tx_ring.misc = 0x0;
-	/* OWN, STP, ENP */
-	lp->tx_ring.u.base = virt_to_bus(lp->tbuf) & 0xffffff;
-	/* we set the top byte as the very last thing */
-	lp->tx_ring.u.addr[3] = 0x83;
-	/* Trigger an immediate send poll */
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);	/* as in the datasheets... */
-	/* Klaus Espenlaub: the value below was 0x48, but that enabled the
-	 * interrupt line, causing a hang if for some reasone the interrupt
-	 * controller had the LANCE interrupt enabled.  I have no idea why
-	 * nobody ran into this before...  */
-	outw(0x08, ioaddr+LANCE_DATA);
-	/* wait for transmit complete */
-	time = currticks() + TICKS_PER_SEC;		/* wait one second */
-	while (currticks() < time && (lp->tx_ring.u.base & 0x80000000) != 0)
-		;
-	if ((lp->tx_ring.u.base & 0x80000000) != 0)
-		printf("LANCE timed out on transmit\n");
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x200, ioaddr+LANCE_DATA);		/* clear transmit + InitDone */
-#ifdef	DEBUG
-	printf("tx_ring.u.base %X tx_ring.buf_length %hX tx_ring.misc %hX csr0 %hX\n",
-		lp->tx_ring.u.base, lp->tx_ring.buf_length, lp->tx_ring.misc,
-		inw(ioaddr+LANCE_DATA));
-#endif
-}
-
-static void lance_disable(struct nic *nic)
-{
-	(void)inw(ioaddr+LANCE_RESET);
-	if (chip_table[lance_version].flags & LANCE_MUST_UNRESET)
-		outw(0, ioaddr+LANCE_RESET);
-
-	outw(0, ioaddr+LANCE_ADDR);
-	outw(0x0004, ioaddr+LANCE_DATA);	/* stop the LANCE */
-
-#ifndef	INCLUDE_LANCE
-	disable_dma(dma);
-#endif
-}
-
-#ifdef	INCLUDE_LANCE
-static int lance_probe1(struct nic *nic, struct pci_device *pci)
-#else
-static int lance_probe1(struct nic *nic)
-#endif
-{
-	int			reset_val ;
-	unsigned int		i;
-	Address			l;
-	short			dma_channels;
-#ifndef	INCLUDE_LANCE
-	static const char	dmas[] = { 5, 6, 7, 3 };
-#endif
-
-	reset_val = inw(ioaddr+LANCE_RESET);
-	outw(reset_val, ioaddr+LANCE_RESET);
-#if	1  /* Klaus Espenlaub -- was #ifdef	INCLUDE_NE2100*/
-	outw(0x0, ioaddr+LANCE_ADDR);	/* Switch to window 0 */
-	if (inw(ioaddr+LANCE_DATA) != 0x4)
-		return (-1);
-#endif
-	outw(88, ioaddr+LANCE_ADDR);	/* Get the version of the chip */
-	if (inw(ioaddr+LANCE_ADDR) != 88)
-		lance_version = 0;
-	else
-	{
-		chip_version = inw(ioaddr+LANCE_DATA);
-		outw(89, ioaddr+LANCE_ADDR);
-		chip_version |= inw(ioaddr+LANCE_DATA) << 16;
-		if ((chip_version & 0xfff) != 0x3)
-			return (-1);
-		chip_version = (chip_version >> 12) & 0xffff;
-		for (lance_version = 1; chip_table[lance_version].id_number != 0; ++lance_version)
-			if (chip_table[lance_version].id_number == chip_version)
-				break;
-	}
-	/* make sure data structure is 8-byte aligned */
-	l = ((Address)lance + 7) & ~7;
-	lp = (struct lance_interface *)l;
-	lp->init_block.mode = 0x3;	/* disable Rx and Tx */
-	lp->init_block.filter[0] = lp->init_block.filter[1] = 0x0;
-	/* using multiple Rx buffer and a single Tx buffer */
-	lp->init_block.rx_ring = (virt_to_bus(&lp->rx_ring) & 0xffffff) | RX_RING_LEN_BITS;
-	lp->init_block.tx_ring = virt_to_bus(&lp->tx_ring) & 0xffffff;
-	l = virt_to_bus(&lp->init_block);
-	outw(0x1, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((unsigned short)l, ioaddr+LANCE_DATA);
-	outw(0x2, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw((unsigned short)(l >> 16), ioaddr+LANCE_DATA);
-	outw(0x4, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	outw(0x915, ioaddr+LANCE_DATA);
-	outw(0x0, ioaddr+LANCE_ADDR);
-	(void)inw(ioaddr+LANCE_ADDR);
-	/* Get station address */
-	for (i = 0; i < ETH_ALEN; ++i) {
-		nic->node_addr[i] = inb(ioaddr+LANCE_ETH_ADDR+i);
-	}
-#ifndef	INCLUDE_LANCE
-	/* now probe for DMA channel */
-	dma_channels = ((inb(DMA1_STAT_REG) >> 4) & 0xf) |
-		(inb(DMA2_STAT_REG) & 0xf0);
-	/* need to fix when PCI provides DMA info */
-	for (i = 0; i < (sizeof(dmas)/sizeof(dmas[0])); ++i)
-	{
-		int		j;
-
-		dma = dmas[i];
-		/* Don't enable a permanently busy DMA channel,
-		   or the machine will hang */
-		if (dma_channels & (1 << dma))
-			continue;
-		outw(0x7f04, ioaddr+LANCE_DATA);	/* clear memory error bits */
-		set_dma_mode(dma, DMA_MODE_CASCADE);
-		enable_dma(dma);
-		outw(0x1, ioaddr+LANCE_DATA);		/* init */
-		for (j = 100; j > 0; --j)
-			if (inw(ioaddr+LANCE_DATA) & 0x900)
-				break;
-		if (inw(ioaddr+LANCE_DATA) & 0x100)
-			break;
-		else
-			disable_dma(dma);
-	}
-	if (i >= (sizeof(dmas)/sizeof(dmas[0])))
-		dma = 0;
-	printf("\n%s base %#X, DMA %d, addr %!\n",
-		chip_table[lance_version].name, ioaddr, dma, nic->node_addr);
-#else
-	printf(" %s base %#hX, addr %!\n", chip_table[lance_version].name, ioaddr, nic->node_addr);
-#endif
-	if (chip_table[chip_version].flags & LANCE_ENABLE_AUTOSELECT) {
-		/* Turn on auto-select of media (10baseT or BNC) so that the
-		 * user watch the LEDs. */
-		outw(0x0002, ioaddr+LANCE_ADDR);
-		/* Don't touch 10base2 power bit. */
-		outw(inw(ioaddr+LANCE_BUS_IF) | 0x0002, ioaddr+LANCE_BUS_IF);
-	}
-	return (lance_version);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-
-#ifdef	INCLUDE_LANCE
-struct nic *lancepci_probe(struct nic *nic, unsigned short *probe_addrs, struct pci_device *pci)
-#endif
-#ifdef	INCLUDE_NE2100
-struct nic *ne2100_probe(struct nic *nic, unsigned short *probe_addrs)
-#endif
-#ifdef	INCLUDE_NI6510
-struct nic *ni6510_probe(struct nic *nic, unsigned short *probe_addrs)
-#endif
-{
-	unsigned short		*p;
-#ifndef	INCLUDE_LANCE
-	static unsigned short	io_addrs[] = { 0x300, 0x320, 0x340, 0x360, 0 };
-#endif
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0) {
-#ifdef	INCLUDE_LANCE
-		return 0;
-#else
-		probe_addrs = io_addrs;
-#endif
-	}
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-	{
-		char	offset15, offset14 = inb(ioaddr + 14);
-		unsigned short	pci_cmd;
-
-#ifdef	INCLUDE_NE2100
-		if ((offset14 == 0x52 || offset14 == 0x57) &&
-		 ((offset15 = inb(ioaddr + 15)) == 0x57 || offset15 == 0x44))
-			if (lance_probe1(nic) >= 0)
-				break;
-#endif
-#ifdef	INCLUDE_NI6510
-		if ((offset14 == 0x00 || offset14 == 0x52) &&
-		 ((offset15 = inb(ioaddr + 15)) == 0x55 || offset15 == 0x44))
-			if (lance_probe1(nic) >= 0)
-				break;
-#endif
-#ifdef	INCLUDE_LANCE
-		adjust_pci_device(pci);
-		if (lance_probe1(nic, pci) >= 0)
-			break;
-#endif
-	}
-	/* if board found */
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		lance_reset(nic);
-		nic->reset = lance_reset;
-		nic->poll = lance_poll;
-		nic->transmit = lance_transmit;
-		nic->disable = lance_disable;
-		return nic;
-	}
-
-	/* no board found */
-	return 0;
-}
Index: netboot/linux-asm-string.h
===================================================================
--- netboot/linux-asm-string.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/linux-asm-string.h	(.../trunk)	(revision 112)
@@ -1,291 +0,0 @@
-/*
- * Taken from Linux /usr/include/asm/string.h
- * All except memcpy, memmove, memset and memcmp removed.
- */
-
-#ifndef	_I386_STRING_H_
-#define _I386_STRING_H_
-
-/*
- * This string-include defines all string functions as inline
- * functions. Use gcc. It also assumes ds=es=data space, this should be
- * normal. Most of the string-functions are rather heavily hand-optimized,
- * see especially strtok,strstr,str[c]spn. They should work, but are not
- * very easy to understand. Everything is done entirely within the register
- * set, making the functions fast and clean. String instructions have been
- * used through-out, making for "slightly" unclear code :-)
- *
- *		NO Copyright (C) 1991, 1992 Linus Torvalds,
- *		consider these trivial functions to be PD.
- */
-
-typedef int	size_t;
-
-extern void *__memcpy(void * to, const void * from, size_t n);
-extern void *__constant_memcpy(void * to, const void * from, size_t n);
-extern void *memmove(void * dest,const void * src, size_t n);
-extern void *__memset_generic(void * s, char c,size_t count);
-extern void *__constant_c_memset(void * s, unsigned long c, size_t count);
-extern void *__constant_c_and_count_memset(void * s, unsigned long pattern, size_t count);
-
-
-extern inline void * __memcpy(void * to, const void * from, size_t n)
-{
-int d0, d1, d2;
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep ; movsl\n\t"
-	"testb $2,%b4\n\t"
-	"je 1f\n\t"
-	"movsw\n"
-	"1:\ttestb $1,%b4\n\t"
-	"je 2f\n\t"
-	"movsb\n"
-	"2:"
-	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
-	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
-	: "memory");
-return (to);
-}
-
-/*
- * This looks horribly ugly, but the compiler can optimize it totally,
- * as the count is constant.
- */
-extern inline void * __constant_memcpy(void * to, const void * from, size_t n)
-{
-	switch (n) {
-		case 0:
-			return to;
-		case 1:
-			*(unsigned char *)to = *(const unsigned char *)from;
-			return to;
-		case 2:
-			*(unsigned short *)to = *(const unsigned short *)from;
-			return to;
-		case 3:
-			*(unsigned short *)to = *(const unsigned short *)from;
-			*(2+(unsigned char *)to) = *(2+(const unsigned char *)from);
-			return to;
-		case 4:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			return to;
-		case 6:	/* for Ethernet addresses */
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(2+(unsigned short *)to) = *(2+(const unsigned short *)from);
-			return to;
-		case 8:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			return to;
-		case 12:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
-			return to;
-		case 16:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
-			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
-			return to;
-		case 20:
-			*(unsigned long *)to = *(const unsigned long *)from;
-			*(1+(unsigned long *)to) = *(1+(const unsigned long *)from);
-			*(2+(unsigned long *)to) = *(2+(const unsigned long *)from);
-			*(3+(unsigned long *)to) = *(3+(const unsigned long *)from);
-			*(4+(unsigned long *)to) = *(4+(const unsigned long *)from);
-			return to;
-	}
-#define COMMON(x) \
-__asm__ __volatile__( \
-	"cld\n\t" \
-	"rep ; movsl" \
-	x \
-	: "=&c" (d0), "=&D" (d1), "=&S" (d2) \
-	: "0" (n/4),"1" ((long) to),"2" ((long) from) \
-	: "memory");
-{
-	int d0, d1, d2;
-	switch (n % 4) {
-		case 0: COMMON(""); return to;
-		case 1: COMMON("\n\tmovsb"); return to;
-		case 2: COMMON("\n\tmovsw"); return to;
-		default: COMMON("\n\tmovsw\n\tmovsb"); return to;
-	}
-}
-
-#undef COMMON
-}
-
-#define __HAVE_ARCH_MEMCPY
-#define memcpy(t, f, n) \
-(__builtin_constant_p(n) ? \
- __constant_memcpy((t),(f),(n)) : \
- __memcpy((t),(f),(n)))
-
-#define __HAVE_ARCH_MEMMOVE
-extern inline void * memmove(void * dest,const void * src, size_t n)
-{
-int d0, d1, d2;
-if (dest<src)
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep\n\t"
-	"movsb"
-	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
-	:"0" (n),"1" (src),"2" (dest)
-	: "memory");
-else
-__asm__ __volatile__(
-	"std\n\t"
-	"rep\n\t"
-	"movsb\n\t"
-	"cld"
-	: "=&c" (d0), "=&S" (d1), "=&D" (d2)
-	:"0" (n),
-	 "1" (n-1+(const char *)src),
-	 "2" (n-1+(char *)dest)
-	:"memory");
-return dest;
-}
-
-#define memcmp __builtin_memcmp
-
-extern inline void * __memset_generic(void * s, char c,size_t count)
-{
-int d0, d1;
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep\n\t"
-	"stosb"
-	: "=&c" (d0), "=&D" (d1)
-	:"a" (c),"1" (s),"0" (count)
-	:"memory");
-return s;
-}
-
-/* we might want to write optimized versions of these later */
-#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
-
-/*
- * memset(x,0,y) is a reasonably common thing to do, so we want to fill
- * things 32 bits at a time even when we don't know the size of the
- * area at compile-time..
- */
-extern inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
-{
-int d0, d1;
-__asm__ __volatile__(
-	"cld\n\t"
-	"rep ; stosl\n\t"
-	"testb $2,%b3\n\t"
-	"je 1f\n\t"
-	"stosw\n"
-	"1:\ttestb $1,%b3\n\t"
-	"je 2f\n\t"
-	"stosb\n"
-	"2:"
-	: "=&c" (d0), "=&D" (d1)
-	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
-	:"memory");
-return (s);
-}
-
-/*
- * This looks horribly ugly, but the compiler can optimize it totally,
- * as we by now know that both pattern and count is constant..
- */
-extern inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
-{
-	switch (count) {
-		case 0:
-			return s;
-		case 1:
-			*(unsigned char *)s = pattern;
-			return s;
-		case 2:
-			*(unsigned short *)s = pattern;
-			return s;
-		case 3:
-			*(unsigned short *)s = pattern;
-			*(2+(unsigned char *)s) = pattern;
-			return s;
-		case 4:
-			*(unsigned long *)s = pattern;
-			return s;
-	}
-#define COMMON(x) \
-__asm__  __volatile__("cld\n\t" \
-	"rep ; stosl" \
-	x \
-	: "=&c" (d0), "=&D" (d1) \
-	: "a" (pattern),"0" (count/4),"1" ((long) s) \
-	: "memory")
-{
-	int d0, d1;
-	switch (count % 4) {
-		case 0: COMMON(""); return s;
-		case 1: COMMON("\n\tstosb"); return s;
-		case 2: COMMON("\n\tstosw"); return s;
-		default: COMMON("\n\tstosw\n\tstosb"); return s;
-	}
-}
-
-#undef COMMON
-}
-
-#define __constant_c_x_memset(s, c, count) \
-(__builtin_constant_p(count) ? \
- __constant_c_and_count_memset((s),(c),(count)) : \
- __constant_c_memset((s),(c),(count)))
-
-#define __memset(s, c, count) \
-(__builtin_constant_p(count) ? \
- __constant_count_memset((s),(c),(count)) : \
- __memset_generic((s),(c),(count)))
-
-#define __HAVE_ARCH_MEMSET
-#define memset(s, c, count) \
-(__builtin_constant_p(c) ? \
- __constant_c_x_memset((s),(c),(count)) : \
- __memset((s),(c),(count)))
-
-#define __HAVE_ARCH_STRNCMP
-static inline int strncmp(const char * cs,const char * ct,size_t count)
-{
-register int __res;
-int d0, d1, d2;
-__asm__ __volatile__(
-	"1:\tdecl %3\n\t"
-	"js 2f\n\t"
-	"lodsb\n\t"
-	"scasb\n\t"
-	"jne 3f\n\t"
-	"testb %%al,%%al\n\t"
-	"jne 1b\n"
-	"2:\txorl %%eax,%%eax\n\t"
-	"jmp 4f\n"
-	"3:\tsbbl %%eax,%%eax\n\t"
-	"orb $1,%%al\n"
-	"4:"
-		     :"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
-		     :"1" (cs),"2" (ct),"3" (count));
-return __res;
-}
-
-#define __HAVE_ARCH_STRLEN
-static inline size_t strlen(const char * s)
-{
-int d0;
-register int __res;
-__asm__ __volatile__(
-	"repne\n\t"
-	"scasb\n\t"
-	"notl %0\n\t"
-	"decl %0"
-	:"=c" (__res), "=&D" (d0) :"1" (s),"a" (0), "0" (0xffffffff));
-return __res;
-}
-
-#endif
Index: netboot/linux-asm-io.h
===================================================================
--- netboot/linux-asm-io.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/linux-asm-io.h	(.../trunk)	(revision 112)
@@ -1,187 +0,0 @@
-#ifndef	_ASM_IO_H
-#define _ASM_IO_H
-
-/*
- * This file contains the definitions for the x86 IO instructions
- * inb/inw/inl/outb/outw/outl and the "string versions" of the same
- * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
- * versions of the single-IO instructions (inb_p/inw_p/..).
- *
- * This file is not meant to be obfuscating: it's just complicated
- * to (a) handle it all in a way that makes gcc able to optimize it
- * as well as possible and (b) trying to avoid writing the same thing
- * over and over again with slight variations and possibly making a
- * mistake somewhere.
- */
-
-/*
- * Thanks to James van Artsdalen for a better timing-fix than
- * the two short jumps: using outb's to a nonexistent port seems
- * to guarantee better timings even on fast machines.
- *
- * On the other hand, I'd like to be sure of a non-existent port:
- * I feel a bit unsafe about using 0x80 (should be safe, though)
- *
- *		Linus
- */
-
-#ifdef	SLOW_IO_BY_JUMPING
-#define __SLOW_DOWN_IO __asm__ __volatile__("jmp 1f\n1:\tjmp 1f\n1:")
-#else
-#define __SLOW_DOWN_IO __asm__ __volatile__("outb %al,$0x80")
-#endif
-
-#ifdef	REALLY_SLOW_IO
-#define SLOW_DOWN_IO { __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; }
-#else
-#define SLOW_DOWN_IO __SLOW_DOWN_IO
-#endif
-
-/*
- * readX/writeX() are used to access memory mapped devices. On some
- * architectures the memory mapped IO stuff needs to be accessed
- * differently. On the x86 architecture, we just read/write the
- * memory location directly.
- */
-#define readb(addr) (*(volatile unsigned char *) (addr))
-#define readw(addr) (*(volatile unsigned short *) (addr))
-#define readl(addr) (*(volatile unsigned int *) (addr))
-
-#define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
-#define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
-#define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
-
-#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
-#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
-#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
-
-/*
- * Again, i386 does not require mem IO specific function.
- */
-
-#define eth_io_copy_and_sum(a,b,c,d)	eth_copy_and_sum((a),(void *)(b),(c),(d))
-
-/*
- * Talk about misusing macros..
- */
-
-#define __OUT1(s,x) \
-extern void __out##s(unsigned x value, unsigned short port); \
-extern inline void __out##s(unsigned x value, unsigned short port) {
-
-#define __OUT2(s,s1,s2) \
-__asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
-
-#define __OUT(s,s1,x) \
-__OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); } \
-__OUT1(s##c,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); } \
-__OUT1(s##_p,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); SLOW_DOWN_IO; } \
-__OUT1(s##c_p,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); SLOW_DOWN_IO; }
-
-#define __IN1(s,x) \
-extern unsigned x __in##s(unsigned short port); \
-extern inline unsigned x __in##s(unsigned short port) { unsigned x _v;
-
-#define __IN2(s,s1,s2) \
-__asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
-
-#define __IN(s,s1,x,i...) \
-__IN1(s,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); return _v; } \
-__IN1(s##c,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); return _v; } \
-__IN1(s##_p,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); SLOW_DOWN_IO; return _v; } \
-__IN1(s##c_p,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); SLOW_DOWN_IO; return _v; }
-
-#define __INS(s) \
-extern void ins##s(unsigned short port, void * addr, unsigned long count); \
-extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
-{ __asm__ __volatile__ ("cld ; rep ; ins" #s \
-: "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
-
-#define __OUTS(s) \
-extern void outs##s(unsigned short port, const void * addr, unsigned long  count); \
-extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
-{ __asm__ __volatile__ ("cld ; rep ; outs" #s \
-: "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
-
-__IN(b,"", char)
-__IN(w,"",short)
-__IN(l,"", long)
-
-__OUT(b,"b",char)
-__OUT(w,"w",short)
-__OUT(l,,int)
-
-__INS(b)
-__INS(w)
-__INS(l)
-
-__OUTS(b)
-__OUTS(w)
-__OUTS(l)
-
-/*
- * Note that due to the way __builtin_constant_p() works, you
- *  - can't use it inside a inline function (it will never be true)
- *  - you don't have to worry about side effects within the __builtin..
- */
-#define outb(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outbc((val),(port)) : \
-	__outb((val),(port)))
-
-#define inb(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inbc(port) : \
-	__inb(port))
-
-#define outb_p(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outbc_p((val),(port)) : \
-	__outb_p((val),(port)))
-
-#define inb_p(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inbc_p(port) : \
-	__inb_p(port))
-
-#define outw(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outwc((val),(port)) : \
-	__outw((val),(port)))
-
-#define inw(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inwc(port) : \
-	__inw(port))
-
-#define outw_p(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outwc_p((val),(port)) : \
-	__outw_p((val),(port)))
-
-#define inw_p(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inwc_p(port) : \
-	__inw_p(port))
-
-#define outl(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outlc((val),(port)) : \
-	__outl((val),(port)))
-
-#define inl(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inlc(port) : \
-	__inl(port))
-
-#define outl_p(val,port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__outlc_p((val),(port)) : \
-	__outl_p((val),(port)))
-
-#define inl_p(port) \
-((__builtin_constant_p((port)) && (port) < 256) ? \
-	__inlc_p(port) : \
-	__inl_p(port))
-
-#endif
Index: netboot/cs89x0.txt
===================================================================
--- netboot/cs89x0.txt	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/cs89x0.txt	(.../trunk)	(revision 112)
@@ -1,26 +0,0 @@
-Permission is granted to distribute the enclosed cs89x0.[ch] driver
-only in conjunction with the Etherboot package.  The code is
-ordinarily distributed under the GPL.
-
-Russ Nelson, January 2000
-
-CREDITS
-
-I want to thank
-
-  Mike Cruse <mcruse@cti-ltd.com>
-     for providing an evaluation NIC and for sponsoring the
-     development of this driver.
-
-  Randall Sears <sears@crystal.cirrus.com>
-  Deva Bodas <bodas@crystal.cirrus.com>
-  Andreas Kraemer <akraemer@crystal.cirrus.com>
-  Wolfgang Krause <100303.2673@compuserve.com>
-     for excellent technical support and for providing the required
-     programming information. I appreciate Crystal Semiconductor's
-     commitment towards free software.
-
-  Russell Nelson <nelson@crynwr.com>
-     for writing the Linux device driver for the CS89x0
-     chipset. Russel's code is very well designed and simplified my
-     job a lot.
Index: netboot/smc9000.c
===================================================================
--- netboot/smc9000.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/smc9000.c	(.../trunk)	(revision 112)
@@ -1,522 +0,0 @@
- /*------------------------------------------------------------------------
- * smc9000.c
- * This is a Etherboot driver for SMC's 9000 series of Ethernet cards.
- *
- * Copyright (C) 1998 Daniel Engstrm <daniel.engstrom@riksnett.no>
- * Based on the Linux SMC9000 driver, smc9194.c by Eric Stahlman
- * Copyright (C) 1996 by Erik Stahlman <eric@vt.edu>
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * "Features" of the SMC chip:
- *   4608 byte packet memory. ( for the 91C92/4.  Others have more )
- *   EEPROM for configuration
- *   AUI/TP selection
- *
- * Authors
- *	Erik Stahlman				<erik@vt.edu>
- *      Daniel Engstrm                         <daniel.engstrom@riksnett.no>
- *
- * History
- * 98-09-25              Daniel Engstrm Etherboot driver crated from Eric's
- *                                       Linux driver.
- *
- *---------------------------------------------------------------------------*/
-#define LINUX_OUT_MACROS 1
-#define SMC9000_VERBOSE  1
-#define SMC9000_DEBUG    0
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "smc9000.h"
-
-# define _outb outb
-# define _outw outw
-
-static const char       smc9000_version[] = "Version 0.99 98-09-30";
-static unsigned int	smc9000_base=0;
-static const char       *interfaces[ 2 ] = { "TP", "AUI" };
-static const char       *chip_ids[ 15 ] =  {
-   NULL, NULL, NULL,
-   /* 3 */ "SMC91C90/91C92",
-   /* 4 */ "SMC91C94",
-   /* 5 */ "SMC91C95",
-   NULL,
-   /* 7 */ "SMC91C100",
-   /* 8 */ "SMC91C100FD",
-   NULL, NULL, NULL,
-   NULL, NULL, NULL
-};
-static const char      smc91c96_id[] = "SMC91C96";
-
-/*
- * Function: smc_reset( int ioaddr )
- * Purpose:
- *	This sets the SMC91xx chip to its normal state, hopefully from whatever
- *	mess that any other DOS driver has put it in.
- *
- * Maybe I should reset more registers to defaults in here?  SOFTRESET  should
- * do that for me.
- *
- * Method:
- *	1.  send a SOFT RESET
- *	2.  wait for it to finish
- *	3.  reset the memory management unit
- *      4.  clear all interrupts
- *
-*/
-static void smc_reset(int ioaddr)
-{
-   /* This resets the registers mostly to defaults, but doesn't
-    * affect EEPROM.  That seems unnecessary */
-   SMC_SELECT_BANK(ioaddr, 0);
-   _outw( RCR_SOFTRESET, ioaddr + RCR );
-
-   /* this should pause enough for the chip to be happy */
-   SMC_DELAY(ioaddr);
-
-   /* Set the transmit and receive configuration registers to
-    * default values */
-   _outw(RCR_CLEAR, ioaddr + RCR);
-   _outw(TCR_CLEAR, ioaddr + TCR);
-
-   /* Reset the MMU */
-   SMC_SELECT_BANK(ioaddr, 2);
-   _outw( MC_RESET, ioaddr + MMU_CMD );
-
-   /* Note:  It doesn't seem that waiting for the MMU busy is needed here,
-    * but this is a place where future chipsets _COULD_ break.  Be wary
-    * of issuing another MMU command right after this */
-   _outb(0, ioaddr + INT_MASK);
-}
-
-
-/*----------------------------------------------------------------------
- * Function: smc_probe( int ioaddr )
- *
- * Purpose:
- *	Tests to see if a given ioaddr points to an SMC9xxx chip.
- *	Returns a 0 on success
- *
- * Algorithm:
- *	(1) see if the high byte of BANK_SELECT is 0x33
- *	(2) compare the ioaddr with the base register's address
- *	(3) see if I recognize the chip ID in the appropriate register
- *
- * ---------------------------------------------------------------------
- */
-static int smc_probe( int ioaddr )
-{
-   word bank;
-   word	revision_register;
-   word base_address_register;
-
-   /* First, see if the high byte is 0x33 */
-   bank = inw(ioaddr + BANK_SELECT);
-   if ((bank & 0xFF00) != 0x3300) {
-      return -1;
-   }
-   /* The above MIGHT indicate a device, but I need to write to further
-    *	test this.  */
-   _outw(0x0, ioaddr + BANK_SELECT);
-   bank = inw(ioaddr + BANK_SELECT);
-   if ((bank & 0xFF00) != 0x3300) {
-      return -1;
-   }
-
-   /* well, we've already written once, so hopefully another time won't
-    *  hurt.  This time, I need to switch the bank register to bank 1,
-    *  so I can access the base address register */
-   SMC_SELECT_BANK(ioaddr, 1);
-   base_address_register = inw(ioaddr + BASE);
-
-   if (ioaddr != (base_address_register >> 3 & 0x3E0))  {
-#ifdef	SMC9000_VERBOSE
-      printf("SMC9000: IOADDR %hX doesn't match configuration (%hX)."
-	     "Probably not a SMC chip\n",
-	     ioaddr, base_address_register >> 3 & 0x3E0);
-#endif
-      /* well, the base address register didn't match.  Must not have
-       * been a SMC chip after all. */
-      return -1;
-   }
-
-
-   /* check if the revision register is something that I recognize.
-    * These might need to be added to later, as future revisions
-    * could be added.  */
-   SMC_SELECT_BANK(ioaddr, 3);
-   revision_register  = inw(ioaddr + REVISION);
-   if (!chip_ids[(revision_register >> 4) & 0xF]) {
-      /* I don't recognize this chip, so... */
-#ifdef	SMC9000_VERBOSE
-      printf("SMC9000: IO %hX: Unrecognized revision register:"
-	     " %hX, Contact author.\n", ioaddr, revision_register);
-#endif
-      return -1;
-   }
-
-   /* at this point I'll assume that the chip is an SMC9xxx.
-    * It might be prudent to check a listing of MAC addresses
-    * against the hardware address, or do some other tests. */
-   return 0;
-}
-
-
-/**************************************************************************
- * ETH_RESET - Reset adapter
- ***************************************************************************/
-
-static void smc9000_reset(struct nic *nic)
-{
-   smc_reset(smc9000_base);
-}
-
-/**************************************************************************
- * ETH_TRANSMIT - Transmit a frame
- ***************************************************************************/
-static void smc9000_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-   word length; /* real, length incl. header */
-   word numPages;
-   unsigned long time_out;
-   byte	packet_no;
-   word status;
-   int i;
-
-   /* We dont pad here since we can have the hardware doing it for us */
-   length = (s + ETH_HLEN + 1)&~1;
-
-   /* convert to MMU pages */
-   numPages = length / 256;
-
-   if (numPages > 7 ) {
-#ifdef	SMC9000_VERBOSE
-      printf("SMC9000: Far too big packet error. \n");
-#endif
-      return;
-   }
-
-   /* dont try more than, say 30 times */
-   for (i=0;i<30;i++) {
-      /* now, try to allocate the memory */
-      SMC_SELECT_BANK(smc9000_base, 2);
-      _outw(MC_ALLOC | numPages, smc9000_base + MMU_CMD);
-
-      status = 0;
-      /* wait for the memory allocation to finnish */
-      for (time_out = currticks() + 5*TICKS_PER_SEC; currticks() < time_out; ) {
-	 status = inb(smc9000_base + INTERRUPT);
-	 if ( status & IM_ALLOC_INT ) {
-	    /* acknowledge the interrupt */
-	    _outb(IM_ALLOC_INT, smc9000_base + INTERRUPT);
-	    break;
-	 }
-      }
-
-      if ((status & IM_ALLOC_INT) != 0 ) {
-	 /* We've got the memory */
-	 break;
-      } else {
-	 printf("SMC9000: Memory allocation timed out, resetting MMU.\n");
-	 _outw(MC_RESET, smc9000_base + MMU_CMD);
-      }
-   }
-
-   /* If I get here, I _know_ there is a packet slot waiting for me */
-   packet_no = inb(smc9000_base + PNR_ARR + 1);
-   if (packet_no & 0x80) {
-      /* or isn't there?  BAD CHIP! */
-      printf("SMC9000: Memory allocation failed. \n");
-      return;
-   }
-
-   /* we have a packet address, so tell the card to use it */
-   _outb(packet_no, smc9000_base + PNR_ARR);
-
-   /* point to the beginning of the packet */
-   _outw(PTR_AUTOINC, smc9000_base + POINTER);
-
-#if	SMC9000_DEBUG > 2
-   printf("Trying to xmit packet of length %hX\n", length );
-#endif
-
-   /* send the packet length ( +6 for status, length and ctl byte )
-    * and the status word ( set to zeros ) */
-   _outw(0, smc9000_base + DATA_1 );
-
-   /* send the packet length ( +6 for status words, length, and ctl) */
-   _outb((length+6) & 0xFF,  smc9000_base + DATA_1);
-   _outb((length+6) >> 8 ,   smc9000_base + DATA_1);
-
-   /* Write the contents of the packet */
-
-   /* The ethernet header first... */
-   outsw(smc9000_base + DATA_1, d, ETH_ALEN >> 1);
-   outsw(smc9000_base + DATA_1, nic->node_addr, ETH_ALEN >> 1);
-   _outw(htons(t), smc9000_base + DATA_1);
-
-   /* ... the data ... */
-   outsw(smc9000_base + DATA_1 , p, s >> 1);
-
-   /* ... and the last byte, if there is one.   */
-   if ((s & 1) == 0) {
-      _outw(0, smc9000_base + DATA_1);
-   } else {
-      _outb(p[s-1], smc9000_base + DATA_1);
-      _outb(0x20, smc9000_base + DATA_1);
-   }
-
-   /* and let the chipset deal with it */
-   _outw(MC_ENQUEUE , smc9000_base + MMU_CMD);
-
-   status = 0; time_out = currticks() + 5*TICKS_PER_SEC;
-   do {
-      status = inb(smc9000_base + INTERRUPT);
-
-      if ((status & IM_TX_INT ) != 0) {
-	 word tx_status;
-
-	 /* ack interrupt */
-	 _outb(IM_TX_INT, smc9000_base + INTERRUPT);
-
-	 packet_no = inw(smc9000_base + FIFO_PORTS);
-	 packet_no &= 0x7F;
-
-	 /* select this as the packet to read from */
-	 _outb( packet_no, smc9000_base + PNR_ARR );
-
-	 /* read the first word from this packet */
-	 _outw( PTR_AUTOINC | PTR_READ, smc9000_base + POINTER );
-
-	 tx_status = inw( smc9000_base + DATA_1 );
-
-	 if (0 == (tx_status & TS_SUCCESS)) {
-#ifdef	SMC9000_VERBOSE
-	    printf("SMC9000: TX FAIL STATUS: %hX \n", tx_status);
-#endif
-	    /* re-enable transmit */
-	    SMC_SELECT_BANK(smc9000_base, 0);
-	    _outw(inw(smc9000_base + TCR ) | TCR_ENABLE, smc9000_base + TCR );
-	 }
-
-	 /* kill the packet */
-	 SMC_SELECT_BANK(smc9000_base, 2);
-	 _outw(MC_FREEPKT, smc9000_base + MMU_CMD);
-
-	 return;
-      }
-   }while(currticks() < time_out);
-
-   printf("SMC9000: Waring TX timed out, resetting board\n");
-   smc_reset(smc9000_base);
-   return;
-}
-
-/**************************************************************************
- * ETH_POLL - Wait for a frame
- ***************************************************************************/
-static int smc9000_poll(struct nic *nic)
-{
-   if(!smc9000_base)
-     return 0;
-
-   SMC_SELECT_BANK(smc9000_base, 2);
-   if (inw(smc9000_base + FIFO_PORTS) & FP_RXEMPTY)
-     return 0;
-
-   /*  start reading from the start of the packet */
-   _outw(PTR_READ | PTR_RCV | PTR_AUTOINC, smc9000_base + POINTER);
-
-   /* First read the status and check that we're ok */
-   if (!(inw(smc9000_base + DATA_1) & RS_ERRORS)) {
-      /* Next: read the packet length and mask off the top bits */
-      nic->packetlen = (inw(smc9000_base + DATA_1) & 0x07ff);
-
-      /* the packet length includes the 3 extra words */
-      nic->packetlen -= 6;
-#if	SMC9000_DEBUG > 2
-      printf(" Reading %d words (and %d byte(s))\n",
-	       (nic->packetlen >> 1), nic->packetlen & 1);
-#endif
-      /* read the packet (and the last "extra" word) */
-      insw(smc9000_base + DATA_1, nic->packet, (nic->packetlen+2) >> 1);
-      /* is there an odd last byte ? */
-      if (nic->packet[nic->packetlen+1] & 0x20)
-	 nic->packetlen++;
-
-      /*  error or good, tell the card to get rid of this packet */
-      _outw(MC_RELEASE, smc9000_base + MMU_CMD);
-      return 1;
-   }
-
-   printf("SMC9000: RX error\n");
-   /*  error or good, tell the card to get rid of this packet */
-   _outw(MC_RELEASE, smc9000_base + MMU_CMD);
-   return 0;
-}
-
-static void smc9000_disable(struct nic *nic)
-{
-   if(!smc9000_base)
-     return;
-
-   /* no more interrupts for me */
-   SMC_SELECT_BANK(smc9000_base, 2);
-   _outb( 0, smc9000_base + INT_MASK);
-
-   /* and tell the card to stay away from that nasty outside world */
-   SMC_SELECT_BANK(smc9000_base, 0);
-   _outb( RCR_CLEAR, smc9000_base + RCR );
-   _outb( TCR_CLEAR, smc9000_base + TCR );
-}
-
-/**************************************************************************
- * ETH_PROBE - Look for an adapter
- ***************************************************************************/
-
-struct nic *smc9000_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-   unsigned short   revision;
-   int	            memory;
-   int              media;
-   const char *	    version_string;
-   const char *	    if_string;
-   int              i;
-
-   /*
-    * the SMC9000 can be at any of the following port addresses.  To change,
-    * for a slightly different card, you can add it to the array.  Keep in
-    * mind that the array must end in zero.
-    */
-   static unsigned short portlist[] = {
-#ifdef	SMC9000_SCAN
-      SMC9000_SCAN,
-#else
-      0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
-      0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0,
-#endif
-      0 };
-
-   printf("\nSMC9000 %s\n", smc9000_version);
-#ifdef	SMC9000_VERBOSE
-   printf("Copyright (C) 1998 Daniel Engstr\x94m\n");
-   printf("Copyright (C) 1996 Eric Stahlman\n");
-#endif
-   /* if no addresses supplied, fall back on defaults */
-   if (probe_addrs == 0 || probe_addrs[0] == 0)
-     probe_addrs = portlist;
-
-   /* check every ethernet address */
-   for (i = 0; probe_addrs[i]; i++) {
-      /* check this specific address */
-      if (smc_probe(probe_addrs[i]) == 0)
-	smc9000_base = probe_addrs[i];
-   }
-
-   /* couldn't find anything */
-   if(0 == smc9000_base)
-     goto out;
-
-   /*
-    * Get the MAC address ( bank 1, regs 4 - 9 )
-    */
-   SMC_SELECT_BANK(smc9000_base, 1);
-   for ( i = 0; i < 6; i += 2 ) {
-      word address;
-
-      address = inw(smc9000_base + ADDR0 + i);
-      nic->node_addr[i+1] = address >> 8;
-      nic->node_addr[i] = address & 0xFF;
-   }
-
-
-   /* get the memory information */
-   SMC_SELECT_BANK(smc9000_base, 0);
-   memory = ( inw(smc9000_base + MCR) >> 9 )  & 0x7;  /* multiplier */
-   memory *= 256 * (inw(smc9000_base + MIR) & 0xFF);
-
-   /*
-    * Now, I want to find out more about the chip.  This is sort of
-    * redundant, but it's cleaner to have it in both, rather than having
-    * one VERY long probe procedure.
-    */
-   SMC_SELECT_BANK(smc9000_base, 3);
-   revision  = inw(smc9000_base + REVISION);
-   version_string = chip_ids[(revision >> 4) & 0xF];
-
-   if (((revision & 0xF0) >> 4 == CHIP_9196) &&
-       ((revision & 0x0F) >= REV_9196)) {
-      /* This is a 91c96. 'c96 has the same chip id as 'c94 (4) but
-       * a revision starting at 6 */
-      version_string = smc91c96_id;
-   }
-
-   if ( !version_string ) {
-      /* I shouldn't get here because this call was done before.... */
-      goto out;
-   }
-
-   /* is it using AUI or 10BaseT ? */
-   SMC_SELECT_BANK(smc9000_base, 1);
-   if (inw(smc9000_base + CONFIG) & CFG_AUI_SELECT)
-     media = 2;
-   else
-     media = 1;
-
-   if_string = interfaces[media - 1];
-
-   /* now, reset the chip, and put it into a known state */
-   smc_reset(smc9000_base);
-
-   printf("%s rev:%d I/O port:%hX Interface:%s RAM:%d bytes \n",
-	  version_string, revision & 0xF,
-	  smc9000_base, if_string, memory );
-   /*
-    * Print the Ethernet address
-    */
-   printf("Ethernet MAC address: %!\n", nic->node_addr);
-
-   SMC_SELECT_BANK(smc9000_base, 0);
-
-   /* see the header file for options in TCR/RCR NORMAL*/
-   _outw(TCR_NORMAL, smc9000_base + TCR);
-   _outw(RCR_NORMAL, smc9000_base + RCR);
-
-   /* Select which interface to use */
-   SMC_SELECT_BANK(smc9000_base, 1);
-   if ( media == 1 ) {
-      _outw( inw( smc9000_base + CONFIG ) & ~CFG_AUI_SELECT,
-	   smc9000_base + CONFIG );
-   }
-   else if ( media == 2 ) {
-      _outw( inw( smc9000_base + CONFIG ) | CFG_AUI_SELECT,
-	   smc9000_base + CONFIG );
-   }
-
-   nic->reset = smc9000_reset;
-   nic->poll = smc9000_poll;
-   nic->transmit = smc9000_transmit;
-   nic->disable = smc9000_disable;
-
-
-   return nic;
-
-out:
-#ifdef	SMC9000_VERBOSE
-   printf("No SMC9000 adapters found\n");
-#endif
-   smc9000_base = 0;
-
-   return (0);
-}
-
-
-
Index: netboot/cs89x0.c
===================================================================
--- netboot/cs89x0.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/cs89x0.c	(.../trunk)	(revision 112)
@@ -1,659 +0,0 @@
-/* cs89x0.c: A Crystal Semiconductor CS89[02]0 driver for etherboot. */
-/*
-  Permission is granted to distribute the enclosed cs89x0.[ch] driver
-  only in conjunction with the Etherboot package.  The code is
-  ordinarily distributed under the GPL.
-  
-  Russ Nelson, January 2000
-
-  ChangeLog:
-
-  Thu Dec 6 22:40:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * disabled all "advanced" features; this should make the code more reliable
-
-  * reorganized the reset function
-
-  * always reset the address port, so that autoprobing will continue working
-
-  * some cosmetic changes
-
-  * 2.5
-
-  Thu Dec 5 21:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * tested the code against a CS8900 card
-
-  * lots of minor bug fixes and adjustments
-
-  * this is the first release, that actually works! it still requires some
-    changes in order to be more tolerant to different environments
-
-  * 4
-
-  Fri Nov 22 23:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * read the manuals for the CS89x0 chipsets and took note of all the
-    changes that will be neccessary in order to adapt Russel Nelson's code
-    to the requirements of a BOOT-Prom
-
-  * 6
-
-  Thu Nov 19 22:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * Synched with Russel Nelson's current code (v1.00)
-
-  * 2
-
-  Thu Nov 12 18:00:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * Cleaned up some of the code and tried to optimize the code size.
-
-  * 1.5
-
-  Sun Nov 10 16:30:00 1996  Markus Gutschke  <gutschk@math.uni-muenster.de>
-
-  * First experimental release. This code compiles fine, but I
-  have no way of testing whether it actually works.
-
-  * I did not (yet) bother to make the code 16bit aware, so for
-  the time being, it will only work for Etherboot/32.
-
-  * 12
-
-  */
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "cs89x0.h"
-
-static unsigned short	eth_nic_base;
-static unsigned long    eth_mem_start;
-static unsigned short   eth_irq;
-static unsigned short   eth_cs_type;	/* one of: CS8900, CS8920, CS8920M  */
-static unsigned short   eth_auto_neg_cnf;
-static unsigned short   eth_adapter_cnf;
-static unsigned short	eth_linectl;
-
-/*************************************************************************
-	CS89x0 - specific routines
-**************************************************************************/
-
-static inline int readreg(int portno)
-{
-	outw(portno, eth_nic_base + ADD_PORT);
-	return inw(eth_nic_base + DATA_PORT);
-}
-
-static inline void writereg(int portno, int value)
-{
-	outw(portno, eth_nic_base + ADD_PORT);
-	outw(value, eth_nic_base + DATA_PORT);
-	return;
-}
-
-/*************************************************************************
-EEPROM access
-**************************************************************************/
-
-static int wait_eeprom_ready(void)
-{
-	unsigned long tmo = currticks() + 4*TICKS_PER_SEC;
-
-	/* check to see if the EEPROM is ready, a timeout is used -
-	   just in case EEPROM is ready when SI_BUSY in the
-	   PP_SelfST is clear */
-	while(readreg(PP_SelfST) & SI_BUSY) {
-		if (currticks() >= tmo)
-			return -1; }
-	return 0;
-}
-
-static int get_eeprom_data(int off, int len, unsigned short *buffer)
-{
-	int i;
-
-#ifdef	EDEBUG
-	printf("\ncs: EEPROM data from %hX for %hX:",off,len);
-#endif
-	for (i = 0; i < len; i++) {
-		if (wait_eeprom_ready() < 0)
-			return -1;
-		/* Now send the EEPROM read command and EEPROM location
-		   to read */
-		writereg(PP_EECMD, (off + i) | EEPROM_READ_CMD);
-		if (wait_eeprom_ready() < 0)
-			return -1;
-		buffer[i] = readreg(PP_EEData);
-#ifdef	EDEBUG
-		if (!(i%10))
-			printf("\ncs: ");
-		printf("%hX ", buffer[i]);
-#endif
-	}
-#ifdef	EDEBUG
-	putchar('\n');
-#endif
-
-	return(0);
-}
-
-static int get_eeprom_chksum(int off, int len, unsigned short *buffer)
-{
-	int  i, cksum;
-
-	cksum = 0;
-	for (i = 0; i < len; i++)
-		cksum += buffer[i];
-	cksum &= 0xffff;
-	if (cksum == 0)
-		return 0;
-	return -1;
-}
-
-/*************************************************************************
-Activate all of the available media and probe for network
-**************************************************************************/
-
-static void clrline(void)
-{
-	int i;
-
-	putchar('\r');
-	for (i = 79; i--; ) putchar(' ');
-	printf("\rcs: ");
-	return;
-}
-
-static void control_dc_dc(int on_not_off)
-{
-	unsigned int selfcontrol;
-	unsigned long tmo = currticks() + TICKS_PER_SEC;
-
-	/* control the DC to DC convertor in the SelfControl register.  */
-	selfcontrol = HCB1_ENBL; /* Enable the HCB1 bit as an output */
-	if (((eth_adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)
-		selfcontrol |= HCB1;
-	else
-		selfcontrol &= ~HCB1;
-	writereg(PP_SelfCTL, selfcontrol);
-
-	/* Wait for the DC/DC converter to power up - 1000ms */
-	while (currticks() < tmo);
-
-	return;
-}
-
-static int detect_tp(void)
-{
-	unsigned long tmo;
-
-	/* Turn on the chip auto detection of 10BT/ AUI */
-
-	clrline(); printf("attempting %s:","TP");
-
-        /* If connected to another full duplex capable 10-Base-T card
-	   the link pulses seem to be lost when the auto detect bit in
-	   the LineCTL is set.  To overcome this the auto detect bit
-	   will be cleared whilst testing the 10-Base-T interface.
-	   This would not be necessary for the sparrow chip but is
-	   simpler to do it anyway. */
-	writereg(PP_LineCTL, eth_linectl &~ AUI_ONLY);
-	control_dc_dc(0);
-
-        /* Delay for the hardware to work out if the TP cable is
-	   present - 150ms */
-	for (tmo = currticks() + 4; currticks() < tmo; );
-
-	if ((readreg(PP_LineST) & LINK_OK) == 0)
-		return 0;
-
-	if (eth_cs_type != CS8900) {
-
-		writereg(PP_AutoNegCTL, eth_auto_neg_cnf & AUTO_NEG_MASK);
-
-		if ((eth_auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {
-			printf(" negotiating duplex... ");
-			while (readreg(PP_AutoNegST) & AUTO_NEG_BUSY) {
-				if (currticks() - tmo > 40*TICKS_PER_SEC) {
-					printf("time out ");
-					break;
-				}
-			}
-		}
-		if (readreg(PP_AutoNegST) & FDX_ACTIVE)
-			printf("using full duplex");
-		else
-			printf("using half duplex");
-	}
-
-	return A_CNF_MEDIA_10B_T;
-}
-
-/* send a test packet - return true if carrier bits are ok */
-static int send_test_pkt(struct nic *nic)
-{
-	static unsigned char testpacket[] = { 0,0,0,0,0,0, 0,0,0,0,0,0,
-				     0, 46, /*A 46 in network order       */
-				     0, 0,  /*DSAP=0 & SSAP=0 fields      */
-				     0xf3,0 /*Control (Test Req+P bit set)*/ };
-	unsigned long tmo;
-
-	writereg(PP_LineCTL, readreg(PP_LineCTL) | SERIAL_TX_ON);
-
-	memcpy(testpacket, nic->node_addr, ETH_ALEN);
-	memcpy(testpacket+ETH_ALEN, nic->node_addr, ETH_ALEN);
-
-	outw(TX_AFTER_ALL, eth_nic_base + TX_CMD_PORT);
-	outw(ETH_ZLEN, eth_nic_base + TX_LEN_PORT);
-
-	/* Test to see if the chip has allocated memory for the packet */
-	for (tmo = currticks() + 2;
-	     (readreg(PP_BusST) & READY_FOR_TX_NOW) == 0; )
-		if (currticks() >= tmo)
-			return(0);
-
-	/* Write the contents of the packet */
-	outsw(eth_nic_base + TX_FRAME_PORT, testpacket,
-	      (ETH_ZLEN+1)>>1);
-
-	printf(" sending test packet ");
-	/* wait a couple of timer ticks for packet to be received */
-	for (tmo = currticks() + 2; currticks() < tmo; );
-
-	if ((readreg(PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {
-			printf("succeeded");
-			return 1;
-	}
-	printf("failed");
-	return 0;
-}
-
-
-static int detect_aui(struct nic *nic)
-{
-	clrline(); printf("attempting %s:","AUI");
-	control_dc_dc(0);
-
-	writereg(PP_LineCTL, (eth_linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);
-
-	if (send_test_pkt(nic)) {
-		return A_CNF_MEDIA_AUI; }
-	else
-		return 0;
-}
-
-static int detect_bnc(struct nic *nic)
-{
-	clrline(); printf("attempting %s:","BNC");
-	control_dc_dc(1);
-
-	writereg(PP_LineCTL, (eth_linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);
-
-	if (send_test_pkt(nic)) {
-		return A_CNF_MEDIA_10B_2; }
-	else
-		return 0;
-}
-
-/**************************************************************************
-ETH_RESET - Reset adapter
-***************************************************************************/
-
-static void cs89x0_reset(struct nic *nic)
-{
-	int  i;
-	unsigned long reset_tmo;
-
-	writereg(PP_SelfCTL, readreg(PP_SelfCTL) | POWER_ON_RESET);
-
-	/* wait for two ticks; that is 2*55ms */
-	for (reset_tmo = currticks() + 2; currticks() < reset_tmo; );
-
-	if (eth_cs_type != CS8900) {
-		/* Hardware problem requires PNP registers to be reconfigured
-		   after a reset */
-		if (eth_irq != 0xFFFF) {
-			outw(PP_CS8920_ISAINT, eth_nic_base + ADD_PORT);
-			outb(eth_irq, eth_nic_base + DATA_PORT);
-			outb(0, eth_nic_base + DATA_PORT + 1); }
-
-		if (eth_mem_start) {
-			outw(PP_CS8920_ISAMemB, eth_nic_base + ADD_PORT);
-			outb((eth_mem_start >> 8) & 0xff, eth_nic_base + DATA_PORT);
-			outb((eth_mem_start >> 24) & 0xff, eth_nic_base + DATA_PORT + 1); } }
-
-	/* Wait until the chip is reset */
-	for (reset_tmo = currticks() + 2;
-	     (readreg(PP_SelfST) & INIT_DONE) == 0 &&
-		     currticks() < reset_tmo; );
-
-	/* disable interrupts and memory accesses */
-	writereg(PP_BusCTL, 0);
-
-	/* set the ethernet address */
-	for (i=0; i < ETH_ALEN/2; i++)
-		writereg(PP_IA+i*2,
-			 nic->node_addr[i*2] |
-			 (nic->node_addr[i*2+1] << 8));
-
-	/* receive only error free packets addressed to this card */
-	writereg(PP_RxCTL, DEF_RX_ACCEPT);
-
-	/* do not generate any interrupts on receive operations */
-	writereg(PP_RxCFG, 0);
-
-	/* do not generate any interrupts on transmit operations */
-	writereg(PP_TxCFG, 0);
-
-	/* do not generate any interrupts on buffer operations */
-	writereg(PP_BufCFG, 0);
-
-	/* reset address port, so that autoprobing will keep working */
-	outw(PP_ChipID, eth_nic_base + ADD_PORT);
-
-	return;
-}
-
-/**************************************************************************
-ETH_TRANSMIT - Transmit a frame
-***************************************************************************/
-
-static void cs89x0_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	unsigned long tmo;
-	int           sr;
-
-	/* does this size have to be rounded??? please,
-	   somebody have a look in the specs */
-	if ((sr = ((s + ETH_HLEN + 1)&~1)) < ETH_ZLEN)
-		sr = ETH_ZLEN;
-
-retry:
-	/* initiate a transmit sequence */
-	outw(TX_AFTER_ALL, eth_nic_base + TX_CMD_PORT);
-	outw(sr, eth_nic_base + TX_LEN_PORT);
-
-	/* Test to see if the chip has allocated memory for the packet */
-	if ((readreg(PP_BusST) & READY_FOR_TX_NOW) == 0) {
-		/* Oops... this should not happen! */
-		printf("cs: unable to send packet; retrying...\n");
-		for (tmo = currticks() + 5*TICKS_PER_SEC; currticks() < tmo; );
-		cs89x0_reset(nic);
-		goto retry; }
-
-	/* Write the contents of the packet */
-	outsw(eth_nic_base + TX_FRAME_PORT, d, ETH_ALEN/2);
-	outsw(eth_nic_base + TX_FRAME_PORT, nic->node_addr,
-	      ETH_ALEN/2);
-	outw(((t >> 8)&0xFF)|(t << 8), eth_nic_base + TX_FRAME_PORT);
-	outsw(eth_nic_base + TX_FRAME_PORT, p, (s+1)/2);
-	for (sr = sr/2 - (s+1)/2 - ETH_ALEN - 1; sr-- > 0;
-	     outw(0, eth_nic_base + TX_FRAME_PORT));
-
-	/* wait for transfer to succeed */
-	for (tmo = currticks()+5*TICKS_PER_SEC;
-	     (s = readreg(PP_TxEvent)&~0x1F) == 0 && currticks() < tmo;)
-		/* nothing */ ;
-	if ((s & TX_SEND_OK_BITS) != TX_OK) {
-		printf("\ntransmission error %#hX\n", s);
-	}
-
-	return;
-}
-
-/**************************************************************************
-ETH_POLL - Wait for a frame
-***************************************************************************/
-
-static int cs89x0_poll(struct nic *nic)
-{
-	int status;
-
-	status = readreg(PP_RxEvent);
-
-	if ((status & RX_OK) == 0)
-		return(0);
-
-	status = inw(eth_nic_base + RX_FRAME_PORT);
-	nic->packetlen = inw(eth_nic_base + RX_FRAME_PORT);
-	insw(eth_nic_base + RX_FRAME_PORT, nic->packet, nic->packetlen >> 1);
-	if (nic->packetlen & 1)
-		nic->packet[nic->packetlen-1] = inw(eth_nic_base + RX_FRAME_PORT);
-	return 1;
-}
-
-static void cs89x0_disable(struct nic *nic)
-{
-	cs89x0_reset(nic);
-}
-
-/**************************************************************************
-ETH_PROBE - Look for an adapter
-***************************************************************************/
-
-struct nic *cs89x0_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static const unsigned int netcard_portlist[] = {
-#ifdef	CS_SCAN
-		CS_SCAN,
-#else	/* use "conservative" default values for autoprobing */
-		0x300,0x320,0x340,0x200,0x220,0x240,
-		0x260,0x280,0x2a0,0x2c0,0x2e0,
-	/* if that did not work, then be more aggressive */
-		0x301,0x321,0x341,0x201,0x221,0x241,
-		0x261,0x281,0x2a1,0x2c1,0x2e1,
-#endif
-		0};
-
-	int      i, result = -1;
-	unsigned rev_type = 0, ioaddr, ioidx, isa_cnf, cs_revision;
-	unsigned short eeprom_buff[CHKSUM_LEN];
-
-
-	for (ioidx = 0; (ioaddr=netcard_portlist[ioidx++]) != 0; ) {
-		/* if they give us an odd I/O address, then do ONE write to
-		   the address port, to get it back to address zero, where we
-		   expect to find the EISA signature word. */
-		if (ioaddr & 1) {
-			ioaddr &= ~1;
-			if ((inw(ioaddr + ADD_PORT) & ADD_MASK) != ADD_SIG)
-				continue;
-			outw(PP_ChipID, ioaddr + ADD_PORT);
-		}
-
-		if (inw(ioaddr + DATA_PORT) != CHIP_EISA_ID_SIG)
-			continue;
-		eth_nic_base = ioaddr;
-
-		/* get the chip type */
-		rev_type = readreg(PRODUCT_ID_ADD);
-		eth_cs_type = rev_type &~ REVISON_BITS;
-		cs_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';
-
-		printf("\ncs: cs89%c0%s rev %c, base %#hX",
-		       eth_cs_type==CS8900?'0':'2',
-		       eth_cs_type==CS8920M?"M":"",
-		       cs_revision,
-		       eth_nic_base);
-
-		/* First check to see if an EEPROM is attached*/
-		if ((readreg(PP_SelfST) & EEPROM_PRESENT) == 0) {
-			printf("\ncs: no EEPROM...\n");
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue; }
-		else if (get_eeprom_data(START_EEPROM_DATA,CHKSUM_LEN,
-					 eeprom_buff) < 0) {
-			printf("\ncs: EEPROM read failed...\n");
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue; }
-		else if (get_eeprom_chksum(START_EEPROM_DATA,CHKSUM_LEN,
-					   eeprom_buff) < 0) {
-			printf("\ncs: EEPROM checksum bad...\n");
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue; }
-
-		/* get transmission control word but keep the
-		   autonegotiation bits */
-		eth_auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET/2];
-		/* Store adapter configuration */
-		eth_adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET/2];
-		/* Store ISA configuration */
-		isa_cnf = eeprom_buff[ISA_CNF_OFFSET/2];
-
-		/* store the initial memory base address */
-		eth_mem_start = eeprom_buff[PACKET_PAGE_OFFSET/2] << 8;
-
-		printf("%s%s%s, addr ",
-		       (eth_adapter_cnf & A_CNF_10B_T)?", RJ-45":"",
-		       (eth_adapter_cnf & A_CNF_AUI)?", AUI":"",
-		       (eth_adapter_cnf & A_CNF_10B_2)?", BNC":"");
-
-		/* If this is a CS8900 then no pnp soft */
-		if (eth_cs_type != CS8900 &&
-		    /* Check if the ISA IRQ has been set  */
-		    (i = readreg(PP_CS8920_ISAINT) & 0xff,
-		     (i != 0 && i < CS8920_NO_INTS)))
-			eth_irq = i;
-		else {
-			i = isa_cnf & INT_NO_MASK;
-			if (eth_cs_type == CS8900) {
-				/* the table that follows is dependent
-				   upon how you wired up your cs8900
-				   in your system.  The table is the
-				   same as the cs8900 engineering demo
-				   board.  irq_map also depends on the
-				   contents of the table.  Also see
-				   write_irq, which is the reverse
-				   mapping of the table below. */
-				if (i < 4) i = "\012\013\014\005"[i];
-				else printf("\ncs: BUG: isa_config is %d\n", i); }
-			eth_irq = i; }
-
-		/* Retrieve and print the ethernet address. */
-		for (i=0; i<ETH_ALEN; i++) {
-			nic->node_addr[i] = ((unsigned char *)eeprom_buff)[i];
-		}
-		printf("%!\n", nic->node_addr);
-
-		/* Set the LineCTL quintuplet based on adapter
-		   configuration read from EEPROM */
-		if ((eth_adapter_cnf & A_CNF_EXTND_10B_2) &&
-		    (eth_adapter_cnf & A_CNF_LOW_RX_SQUELCH))
-			eth_linectl = LOW_RX_SQUELCH;
-		else
-			eth_linectl = 0;
-
-		/* check to make sure that they have the "right"
-		   hardware available */
-		switch(eth_adapter_cnf & A_CNF_MEDIA_TYPE) {
-		case A_CNF_MEDIA_10B_T: result = eth_adapter_cnf & A_CNF_10B_T;
-			break;
-		case A_CNF_MEDIA_AUI:   result = eth_adapter_cnf & A_CNF_AUI;
-			break;
-		case A_CNF_MEDIA_10B_2: result = eth_adapter_cnf & A_CNF_10B_2;
-			break;
-		default: result = eth_adapter_cnf & (A_CNF_10B_T | A_CNF_AUI |
-						     A_CNF_10B_2);
-		}
-		if (!result) {
-			printf("cs: EEPROM is configured for unavailable media\n");
-		error:
-			writereg(PP_LineCTL, readreg(PP_LineCTL) &
-				 ~(SERIAL_TX_ON | SERIAL_RX_ON));
-			outw(PP_ChipID, eth_nic_base + ADD_PORT);
-			continue;
-		}
-
-		/* Initialize the card for probing of the attached media */
-		cs89x0_reset(nic);
-
-		/* set the hardware to the configured choice */
-		switch(eth_adapter_cnf & A_CNF_MEDIA_TYPE) {
-		case A_CNF_MEDIA_10B_T:
-			result = detect_tp();
-			if (!result) {
-				clrline();
-				printf("10Base-T (RJ-45%s",
-				       ") has no cable\n"); }
-			/* check "ignore missing media" bit */
-			if (eth_auto_neg_cnf & IMM_BIT)
-				/* Yes! I don't care if I see a link pulse */
-				result = A_CNF_MEDIA_10B_T;
-			break;
-		case A_CNF_MEDIA_AUI:
-			result = detect_aui(nic);
-			if (!result) {
-				clrline();
-				printf("10Base-5 (AUI%s",
-				       ") has no cable\n"); }
-			/* check "ignore missing media" bit */
-			if (eth_auto_neg_cnf & IMM_BIT)
-				/* Yes! I don't care if I see a carrrier */
-				result = A_CNF_MEDIA_AUI;
-			break;
-		case A_CNF_MEDIA_10B_2:
-			result = detect_bnc(nic);
-			if (!result) {
-				clrline();
-				printf("10Base-2 (BNC%s",
-				       ") has no cable\n"); }
-			/* check "ignore missing media" bit */
-			if (eth_auto_neg_cnf & IMM_BIT)
-				/* Yes! I don't care if I can xmit a packet */
-				result = A_CNF_MEDIA_10B_2;
-			break;
-		case A_CNF_MEDIA_AUTO:
-			writereg(PP_LineCTL, eth_linectl | AUTO_AUI_10BASET);
-			if (eth_adapter_cnf & A_CNF_10B_T)
-				if ((result = detect_tp()) != 0)
-					break;
-			if (eth_adapter_cnf & A_CNF_AUI)
-				if ((result = detect_aui(nic)) != 0)
-					break;
-			if (eth_adapter_cnf & A_CNF_10B_2)
-				if ((result = detect_bnc(nic)) != 0)
-					break;
-			clrline(); printf("no media detected\n");
-			goto error;
-		}
-		clrline();
-		switch(result) {
-		case 0:                 printf("no network cable attached to configured media\n");
-			goto error;
-		case A_CNF_MEDIA_10B_T: printf("using 10Base-T (RJ-45)\n");
-			break;
-		case A_CNF_MEDIA_AUI:   printf("using 10Base-5 (AUI)\n");
-			break;
-		case A_CNF_MEDIA_10B_2: printf("using 10Base-2 (BNC)\n");
-			break;
-		}
-
-		/* Turn on both receive and transmit operations */
-		writereg(PP_LineCTL, readreg(PP_LineCTL) | SERIAL_RX_ON |
-			 SERIAL_TX_ON);
-
-		break;
-	}
-
-	if (ioaddr == 0)
-		return (0);
-	nic->reset = cs89x0_reset;
-	nic->poll = cs89x0_poll;
-	nic->transmit = cs89x0_transmit;
-	nic->disable = cs89x0_disable;
-	return (nic);
-}
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
-
Index: netboot/smc9000.h
===================================================================
--- netboot/smc9000.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/smc9000.h	(.../trunk)	(revision 112)
@@ -1,205 +0,0 @@
-/*------------------------------------------------------------------------
- * smc9000.h
- *
- * Copyright (C) 1998 by Daniel Engstrm
- * Copyright (C) 1996 by Erik Stahlman
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * This file contains register information and access macros for
- * the SMC91xxx chipset.
- *
- * Information contained in this file was obtained from the SMC91C94
- * manual from SMC.  To get a copy, if you really want one, you can find
- * information under www.smsc.com in the components division.
- * ( this thanks to advice from Donald Becker ).
- *
- * Authors
- *      Daniel Engstrm                         <daniel.engstrom@riksnett.no>
- *	Erik Stahlman				<erik@vt.edu>
- *
- * History
- * 96-01-06		 Erik Stahlman   moved definitions here from main .c
- *                                       file
- * 96-01-19		 Erik Stahlman	 polished this up some, and added
- *                                       better error handling
- * 98-09-25              Daniel Engstrm adjusted for Etherboot
- * 98-09-27              Daniel Engstrm moved some static strings back to the
- *                                       main .c file
- * --------------------------------------------------------------------------*/
-#ifndef	_SMC9000_H_
-# define _SMC9000_H_
-
-/* I want some simple types */
-typedef unsigned char			byte;
-typedef unsigned short			word;
-typedef unsigned long int		dword;
-
-/*---------------------------------------------------------------
- *
- * A description of the SMC registers is probably in order here,
- * although for details, the SMC datasheet is invaluable.
- *
- * Basically, the chip has 4 banks of registers ( 0 to 3 ), which
- * are accessed by writing a number into the BANK_SELECT register
- * ( I also use a SMC_SELECT_BANK macro for this ).
- *
- * The banks are configured so that for most purposes, bank 2 is all
- * that is needed for simple run time tasks.
- * ----------------------------------------------------------------------*/
-
-/*
- * Bank Select Register:
- *
- *		yyyy yyyy 0000 00xx
- *		xx		= bank number
- *		yyyy yyyy	= 0x33, for identification purposes.
- */
-#define	BANK_SELECT		14
-
-/* BANK 0  */
-
-#define	TCR		0	/* transmit control register */
-#define TCR_ENABLE	0x0001	/* if this is 1, we can transmit */
-#define TCR_FDUPLX	0x0800	/* receive packets sent out */
-#define TCR_STP_SQET	0x1000	/* stop transmitting if Signal quality error */
-#define	TCR_MON_CNS	0x0400	/* monitors the carrier status */
-#define	TCR_PAD_ENABLE	0x0080	/* pads short packets to 64 bytes */
-
-#define	TCR_CLEAR	0	/* do NOTHING */
-/* the normal settings for the TCR register : */
-#define	TCR_NORMAL	(TCR_ENABLE | TCR_PAD_ENABLE)
-
-
-#define EPH_STATUS	2
-#define ES_LINK_OK	0x4000	/* is the link integrity ok ? */
-
-#define	RCR		4
-#define RCR_SOFTRESET	0x8000	/* resets the chip */
-#define	RCR_STRIP_CRC	0x200	/* strips CRC */
-#define RCR_ENABLE	0x100	/* IFF this is set, we can receive packets */
-#define RCR_ALMUL	0x4	/* receive all multicast packets */
-#define	RCR_PROMISC	0x2	/* enable promiscuous mode */
-
-/* the normal settings for the RCR register : */
-#define	RCR_NORMAL	(RCR_STRIP_CRC | RCR_ENABLE)
-#define RCR_CLEAR	0x0		/* set it to a base state */
-
-#define	COUNTER		6
-#define	MIR		8
-#define	MCR		10
-/* 12 is reserved */
-
-/* BANK 1 */
-#define CONFIG			0
-#define CFG_AUI_SELECT		0x100
-#define	BASE			2
-#define	ADDR0			4
-#define	ADDR1			6
-#define	ADDR2			8
-#define	GENERAL			10
-#define	CONTROL			12
-#define	CTL_POWERDOWN		0x2000
-#define	CTL_LE_ENABLE		0x80
-#define	CTL_CR_ENABLE		0x40
-#define	CTL_TE_ENABLE		0x0020
-#define CTL_AUTO_RELEASE	0x0800
-#define	CTL_EPROM_ACCESS	0x0003 /* high if Eprom is being read */
-
-/* BANK 2 */
-#define MMU_CMD		0
-#define MC_BUSY		1	/* only readable bit in the register */
-#define MC_NOP		0
-#define	MC_ALLOC	0x20	/* or with number of 256 byte packets */
-#define	MC_RESET	0x40
-#define	MC_REMOVE	0x60	/* remove the current rx packet */
-#define MC_RELEASE	0x80	/* remove and release the current rx packet */
-#define MC_FREEPKT	0xA0	/* Release packet in PNR register */
-#define MC_ENQUEUE	0xC0	/* Enqueue the packet for transmit */
-
-#define	PNR_ARR		2
-#define FIFO_PORTS	4
-
-#define FP_RXEMPTY	0x8000
-#define FP_TXEMPTY	0x80
-
-#define	POINTER		6
-#define PTR_READ	0x2000
-#define	PTR_RCV		0x8000
-#define	PTR_AUTOINC	0x4000
-#define PTR_AUTO_INC	0x0040
-
-#define	DATA_1		8
-#define	DATA_2		10
-#define	INTERRUPT	12
-
-#define INT_MASK	13
-#define IM_RCV_INT	0x1
-#define	IM_TX_INT	0x2
-#define	IM_TX_EMPTY_INT	0x4
-#define	IM_ALLOC_INT	0x8
-#define	IM_RX_OVRN_INT	0x10
-#define	IM_EPH_INT	0x20
-#define	IM_ERCV_INT	0x40 /* not on SMC9192 */
-
-/* BANK 3 */
-#define	MULTICAST1	0
-#define	MULTICAST2	2
-#define	MULTICAST3	4
-#define	MULTICAST4	6
-#define	MGMT		8
-#define	REVISION	10 /* ( hi: chip id   low: rev # ) */
-
-
-/* this is NOT on SMC9192 */
-#define	ERCV		12
-
-/* Note that 9194 and 9196 have the smame chip id,
- * the 9196 will have revisions starting at 6 */
-#define CHIP_9190	3
-#define CHIP_9194	4
-#define CHIP_9195	5
-#define CHIP_9196	4
-#define CHIP_91100	7
-#define CHIP_91100FD	8
-
-#define REV_9196	6
-
-/*
- * Transmit status bits
- */
-#define TS_SUCCESS	0x0001
-#define TS_LOSTCAR	0x0400
-#define TS_LATCOL	0x0200
-#define TS_16COL	0x0010
-
-/*
- * Receive status bits
- */
-#define RS_ALGNERR	0x8000
-#define RS_BADCRC	0x2000
-#define RS_ODDFRAME	0x1000
-#define RS_TOOLONG	0x0800
-#define RS_TOOSHORT	0x0400
-#define RS_MULTICAST	0x0001
-#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
-
-
-/*-------------------------------------------------------------------------
- *  I define some macros to make it easier to do somewhat common
- * or slightly complicated, repeated tasks.
- --------------------------------------------------------------------------*/
-
-/* select a register bank, 0 to 3  */
-
-#define SMC_SELECT_BANK(x, y) { _outw( y, x + BANK_SELECT ); }
-
-/* define a small delay for the reset */
-#define SMC_DELAY(x) { inw( x + RCR );\
-			inw( x + RCR );\
-			inw( x + RCR ); }
-
-
-#endif	/* _SMC_9000_H_ */
-
Index: netboot/3c509.c
===================================================================
--- netboot/3c509.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/3c509.c	(.../trunk)	(revision 112)
@@ -1,620 +0,0 @@
-/**************************************************************************
-ETHERBOOT -  BOOTP/TFTP Bootstrap Program
-
-Author: Martin Renters.
-  Date: Mar 22 1995
-
- This code is based heavily on David Greenman's if_ed.c driver and
-  Andres Vega Garcia's if_ep.c driver.
-
- Copyright (C) 1993-1994, David Greenman, Martin Renters.
- Copyright (C) 1993-1995, Andres Vega Garcia.
- Copyright (C) 1995, Serge Babkin.
-  This software may be used, modified, copied, distributed, and sold, in
-  both source and binary form provided that the above copyright and these
-  terms are retained. Under no circumstances are the authors responsible for
-  the proper functioning of this software, nor do the authors assume any
-  responsibility for damages incurred with its use.
-
-3c509 support added by Serge Babkin (babkin@hq.icb.chel.su)
-
-$Id: 3c509.c,v 1.4 2002/01/02 21:56:40 okuji Exp $
-
-***************************************************************************/
-
-/* #define EDEBUG */
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "timer.h"
-#include "3c509.h"
-
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
-static unsigned short	eth_nic_base;
-static enum { none, bnc, utp } connector = none;	/* for 3C509 */
-
-#ifdef	INCLUDE_3C529
-/*
- * This table and several other pieces of the MCA support
- * code were shamelessly borrowed from the Linux kernel source.
- *
- * MCA support added by Adam Fritzler (mid@auk.cx)
- *
- */
-struct el3_mca_adapters_struct {
-        const char *name;
-        int id;
-};
-static struct el3_mca_adapters_struct el3_mca_adapters[] = {
-        { "3Com 3c529 EtherLink III (10base2)", 0x627c },
-        { "3Com 3c529 EtherLink III (10baseT)", 0x627d },
-        { "3Com 3c529 EtherLink III (test mode)", 0x62db },
-        { "3Com 3c529 EtherLink III (TP or coax)", 0x62f6 },
-        { "3Com 3c529 EtherLink III (TP)", 0x62f7 },
-        { NULL, 0 },
-};
-#endif
-
-/**************************************************************************
-ETH_RESET - Reset adapter
-***************************************************************************/
-static void t509_reset(struct nic *nic)
-{
-	int i;
-
-	/***********************************************************
-			Reset 3Com 509 card
-	*************************************************************/
-
-	/* stop card */
-	outw(RX_DISABLE, BASE + EP_COMMAND);
-	outw(RX_DISCARD_TOP_PACK, BASE + EP_COMMAND);
-	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
-		;
-	outw(TX_DISABLE, BASE + EP_COMMAND);
-	outw(STOP_TRANSCEIVER, BASE + EP_COMMAND);
-	udelay(1000);
-	outw(RX_RESET, BASE + EP_COMMAND);
-	outw(TX_RESET, BASE + EP_COMMAND);
-	outw(C_INTR_LATCH, BASE + EP_COMMAND);
-	outw(SET_RD_0_MASK, BASE + EP_COMMAND);
-	outw(SET_INTR_MASK, BASE + EP_COMMAND);
-	outw(SET_RX_FILTER, BASE + EP_COMMAND);
-
-	/*
-	* initialize card
-	*/
-	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
-		;
-
-	GO_WINDOW(0);
-
-	/* Disable the card */
-	outw(0, BASE + EP_W0_CONFIG_CTRL);
-
-	/* Configure IRQ to none */
-	outw(SET_IRQ(0), BASE + EP_W0_RESOURCE_CFG);
-
-	/* Enable the card */
-	outw(ENABLE_DRQ_IRQ, BASE + EP_W0_CONFIG_CTRL);
-
-	GO_WINDOW(2);
-
-	/* Reload the ether_addr. */
-	for (i = 0; i < ETH_ALEN; i++)
-		outb(nic->node_addr[i], BASE + EP_W2_ADDR_0 + i);
-
-	outw(RX_RESET, BASE + EP_COMMAND);
-	outw(TX_RESET, BASE + EP_COMMAND);
-
-	/* Window 1 is operating window */
-	GO_WINDOW(1);
-	for (i = 0; i < 31; i++)
-		inb(BASE + EP_W1_TX_STATUS);
-
-	/* get rid of stray intr's */
-	outw(ACK_INTR | 0xff, BASE + EP_COMMAND);
-
-	outw(SET_RD_0_MASK | S_5_INTS, BASE + EP_COMMAND);
-
-	outw(SET_INTR_MASK, BASE + EP_COMMAND);
-
-	outw(SET_RX_FILTER | FIL_INDIVIDUAL | FIL_BRDCST, BASE + EP_COMMAND);
-
-	/* configure BNC */
-	if (connector == bnc) {
-		outw(START_TRANSCEIVER, BASE + EP_COMMAND);
-		udelay(1000);
-	}
-	/* configure UTP */
-	else if (connector == utp) {
-		GO_WINDOW(4);
-		outw(ENABLE_UTP, BASE + EP_W4_MEDIA_TYPE);
-		sleep(2);	/* Give time for media to negotiate */
-		GO_WINDOW(1);
-	}
-
-	/* start transceiver and receiver */
-	outw(RX_ENABLE, BASE + EP_COMMAND);
-	outw(TX_ENABLE, BASE + EP_COMMAND);
-
-	/* set early threshold for minimal packet length */
-	outw(SET_RX_EARLY_THRESH | ETH_ZLEN, BASE + EP_COMMAND);
-	outw(SET_TX_START_THRESH | 16, BASE + EP_COMMAND);
-}
-
-/**************************************************************************
-ETH_TRANSMIT - Transmit a frame
-***************************************************************************/
-static char padmap[] = {
-	0, 3, 2, 1};
-
-static void t509_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *p)			/* Packet */
-{
-	register unsigned int len;
-	int pad;
-	int status;
-
-#ifdef	EDEBUG
-	printf("{l=%d,t=%hX}",s+ETH_HLEN,t);
-#endif
-
-	/* swap bytes of type */
-	t= htons(t);
-
-	len=s+ETH_HLEN; /* actual length of packet */
-	pad = padmap[len & 3];
-
-	/*
-	* The 3c509 automatically pads short packets to minimum ethernet length,
-	* but we drop packets that are too large. Perhaps we should truncate
-	* them instead?
-	*/
-	if (len + pad > ETH_FRAME_LEN) {
-		return;
-	}
-
-	/* drop acknowledgements */
-	while ((status=inb(BASE + EP_W1_TX_STATUS)) & TXS_COMPLETE ) {
-		if (status & (TXS_UNDERRUN|TXS_MAX_COLLISION|TXS_STATUS_OVERFLOW)) {
-			outw(TX_RESET, BASE + EP_COMMAND);
-			outw(TX_ENABLE, BASE + EP_COMMAND);
-		}
-		outb(0x0, BASE + EP_W1_TX_STATUS);
-	}
-
-	while (inw(BASE + EP_W1_FREE_TX) < (unsigned short)len + pad + 4)
-		; /* no room in FIFO */
-
-	outw(len, BASE + EP_W1_TX_PIO_WR_1);
-	outw(0x0, BASE + EP_W1_TX_PIO_WR_1);	/* Second dword meaningless */
-
-	/* write packet */
-	outsw(BASE + EP_W1_TX_PIO_WR_1, d, ETH_ALEN/2);
-	outsw(BASE + EP_W1_TX_PIO_WR_1, nic->node_addr, ETH_ALEN/2);
-	outw(t, BASE + EP_W1_TX_PIO_WR_1);
-	outsw(BASE + EP_W1_TX_PIO_WR_1, p, s / 2);
-	if (s & 1)
-		outb(*(p+s - 1), BASE + EP_W1_TX_PIO_WR_1);
-
-	while (pad--)
-		outb(0, BASE + EP_W1_TX_PIO_WR_1);	/* Padding */
-
-	/* wait for Tx complete */
-	while((inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS) != 0)
-		;
-}
-
-/**************************************************************************
-ETH_POLL - Wait for a frame
-***************************************************************************/
-static int t509_poll(struct nic *nic)
-{
-	/* common variables */
-	unsigned short type = 0;	/* used by EDEBUG */
-	/* variables for 3C509 */
-	short status, cst;
-	register short rx_fifo;
-
-	cst=inw(BASE + EP_STATUS);
-
-#ifdef	EDEBUG
-	if(cst & 0x1FFF)
-		printf("-%hX-",cst);
-#endif
-
-	if( (cst & S_RX_COMPLETE)==0 ) {
-		/* acknowledge  everything */
-		outw(ACK_INTR| (cst & S_5_INTS), BASE + EP_COMMAND);
-		outw(C_INTR_LATCH, BASE + EP_COMMAND);
-
-		return 0;
-	}
-
-	status = inw(BASE + EP_W1_RX_STATUS);
-#ifdef	EDEBUG
-	printf("*%hX*",status);
-#endif
-
-	if (status & ERR_RX) {
-		outw(RX_DISCARD_TOP_PACK, BASE + EP_COMMAND);
-		return 0;
-	}
-
-	rx_fifo = status & RX_BYTES_MASK;
-	if (rx_fifo==0)
-		return 0;
-
-		/* read packet */
-#ifdef	EDEBUG
-	printf("[l=%d",rx_fifo);
-#endif
-	insw(BASE + EP_W1_RX_PIO_RD_1, nic->packet, rx_fifo / 2);
-	if(rx_fifo & 1)
-		nic->packet[rx_fifo-1]=inb(BASE + EP_W1_RX_PIO_RD_1);
-	nic->packetlen=rx_fifo;
-
-	while(1) {
-		status = inw(BASE + EP_W1_RX_STATUS);
-#ifdef	EDEBUG
-		printf("*%hX*",status);
-#endif
-		rx_fifo = status & RX_BYTES_MASK;
-		if(rx_fifo>0) {
-			insw(BASE + EP_W1_RX_PIO_RD_1, nic->packet+nic->packetlen, rx_fifo / 2);
-			if(rx_fifo & 1)
-				nic->packet[nic->packetlen+rx_fifo-1]=inb(BASE + EP_W1_RX_PIO_RD_1);
-			nic->packetlen+=rx_fifo;
-#ifdef	EDEBUG
-			printf("+%d",rx_fifo);
-#endif
-		}
-		if(( status & RX_INCOMPLETE )==0) {
-#ifdef	EDEBUG
-			printf("=%d",nic->packetlen);
-#endif
-			break;
-		}
-		udelay(1000);	/* if incomplete wait 1 ms */
-	}
-	/* acknowledge reception of packet */
-	outw(RX_DISCARD_TOP_PACK, BASE + EP_COMMAND);
-	while (inw(BASE + EP_STATUS) & S_COMMAND_IN_PROGRESS)
-		;
-#ifdef	EDEBUG
-	type = (nic->packet[12]<<8) | nic->packet[13];
-	if(nic->packet[0]+nic->packet[1]+nic->packet[2]+nic->packet[3]+nic->packet[4]+
-	    nic->packet[5] == 0xFF*ETH_ALEN)
-		printf(",t=%hX,b]",type);
-	else
-		printf(",t=%hX]",type);
-#endif
-	return (1);
-}
-
-/*************************************************************************
-	3Com 509 - specific routines
-**************************************************************************/
-
-static int
-eeprom_rdy(void)
-{
-	int i;
-
-	for (i = 0; is_eeprom_busy(IS_BASE) && i < MAX_EEPROMBUSY; i++);
-	if (i >= MAX_EEPROMBUSY) {
-		/* printf("3c509: eeprom failed to come ready.\n"); */
-		printf("3c509: eeprom busy.\n"); /* memory in EPROM is tight */
-		return (0);
-	}
-	return (1);
-}
-
-/*
- * get_e: gets a 16 bits word from the EEPROM. we must have set the window
- * before
- */
-static int
-get_e(int offset)
-{
-	if (!eeprom_rdy())
-		return (0xffff);
-	outw(EEPROM_CMD_RD | offset, IS_BASE + EP_W0_EEPROM_COMMAND);
-	if (!eeprom_rdy())
-		return (0xffff);
-	return (inw(IS_BASE + EP_W0_EEPROM_DATA));
-}
-
-static int
-send_ID_sequence(int port)
-{
-	int cx, al;
-
-	for (al = 0xff, cx = 0; cx < 255; cx++) {
-		outb(al, port);
-		al <<= 1;
-		if (al & 0x100)
-			al ^= 0xcf;
-	}
-	return (1);
-}
-
-
-/*
- * We get eeprom data from the id_port given an offset into the eeprom.
- * Basically; after the ID_sequence is sent to all of the cards; they enter
- * the ID_CMD state where they will accept command requests. 0x80-0xbf loads
- * the eeprom data.  We then read the port 16 times and with every read; the
- * cards check for contention (ie: if one card writes a 0 bit and another
- * writes a 1 bit then the host sees a 0. At the end of the cycle; each card
- * compares the data on the bus; if there is a difference then that card goes
- * into ID_WAIT state again). In the meantime; one bit of data is returned in
- * the AX register which is conveniently returned to us by inb().  Hence; we
- * read 16 times getting one bit of data with each read.
- */
-static int
-get_eeprom_data(int id_port, int offset)
-{
-	int i, data = 0;
-	outb(0x80 + offset, id_port);
-	/* Do we really need this wait? Won't be noticeable anyway */
-	udelay(10000);
-	for (i = 0; i < 16; i++)
-		data = (data << 1) | (inw(id_port) & 1);
-	return (data);
-}
-
-static void t509_disable(struct nic *nic)
-{
-	outb(0xc0, EP_ID_PORT);
-}
-
-/**************************************************************************
-ETH_PROBE - Look for an adapter
-***************************************************************************/
-#ifdef	INCLUDE_3C529
-struct nic *t529_probe(struct nic *nic, unsigned short *probe_addrs)
-#else
-struct nic *t509_probe(struct nic *nic, unsigned short *probe_addrs)
-#endif
-{
-	/* common variables */
-	int i;
-	int failcount;
-
-#ifdef	INCLUDE_3C529
-	struct el3_mca_adapters_struct *mcafound = NULL;
-	int mca_pos4 = 0, mca_pos5 = 0, mca_irq = 0;
-#endif
-
-	t509_disable(nic);		/* in case board was active */
-					/* note that nic is not used */
-	for (failcount = 0; failcount < 4000; failcount++) {
-		int data, j, io_base, id_port;
-		unsigned short k;
-		int ep_current_tag;
-		short *p;
-#ifdef	INCLUDE_3C529
-		int curboard;
-#endif
-
-		id_port = EP_ID_PORT;
-		ep_current_tag = EP_LAST_TAG + 1;
-
-	/*********************************************************
-			Search for 3Com 509 card
-	***********************************************************/
-#ifdef	INCLUDE_3C529
-		/*
-		 * XXX: We should really check to make sure we have an MCA
-		 * bus controller before going ahead with this...
-		 *
-		 * For now, we avoid any hassle by making it a compile
-		 * time option.
-		 *
-		 */
-		printf("\nWarning: Assuming presence of MCA bus\n");
-
-                /* Make sure motherboard setup is off */
-                outb_p(0xff, MCA_MOTHERBOARD_SETUP_REG);
-
-		/* Cycle through slots */
-		for(curboard=0; curboard<MCA_MAX_SLOT_NR; curboard++) {
-			int boardid;
-			int curcard;
-
-			outb_p(0x8|(curboard&0xf), MCA_ADAPTER_SETUP_REG);
-
-			boardid = inb_p(MCA_POS_REG(0));
-			boardid += inb_p(MCA_POS_REG(1)) << 8;
-
-			curcard = 0;
-			while (el3_mca_adapters[curcard].name) {
-				if (el3_mca_adapters[curcard].id == boardid) {
-					mcafound = &el3_mca_adapters[curcard];
-
-					mca_pos4 = inb_p(MCA_POS_REG(4));
-					mca_pos5 = inb_p(MCA_POS_REG(5));
-
-					goto donewithdetect;
-				}
-				else
-					curcard++;
-			}
-
-		}
-	donewithdetect:
-		/* Kill all setup modes */
-		outb_p(0, MCA_ADAPTER_SETUP_REG);
-
-		if (mcafound) {
-			eth_nic_base = ((short)((mca_pos4&0xfc)|0x02)) << 8;
-			mca_irq = mca_pos5 & 0x0f;
-			ep_current_tag--;
-		}
-		else
-			printf("MCA Card not found\n");
-#endif
-	/* Look for the EISA boards, leave them activated */
-	/* search for the first card, ignore all others */
-	for(j = 1; j < 16; j++) {
-		io_base = (j * EP_EISA_START) | EP_EISA_W0;
-		if (inw(io_base + EP_W0_MFG_ID) != MFG_ID)
-			continue;
-
-		/* we must have found 0x1f if the board is EISA configurated */
-		if ((inw(io_base + EP_W0_ADDRESS_CFG) & 0x1f) != 0x1f)
-			continue;
-
-		/* Reset and Enable the card */
-		outb(W0_P4_CMD_RESET_ADAPTER, io_base + EP_W0_CONFIG_CTRL);
-		udelay(1000); /* Must wait 800 s, be conservative */
-		outb(W0_P4_CMD_ENABLE_ADAPTER, io_base + EP_W0_CONFIG_CTRL);
-
-		/*
-		 * Once activated, all the registers are mapped in the range
-		 * x000 - x00F, where x is the slot number.
-		 */
-		eth_nic_base = j * EP_EISA_START;
-		break;
-	}
-	ep_current_tag--;
-
-	/* Look for the ISA boards. Init and leave them actived */
-	/* search for the first card, ignore all others */
-	outb(0xc0, id_port);	/* Global reset */
-	udelay(1000);		/* wait 1 ms */
-	for (i = 0; i < EP_MAX_BOARDS; i++) {
-		outb(0, id_port);
-		outb(0, id_port);
-		send_ID_sequence(id_port);
-
-		data = get_eeprom_data(id_port, EEPROM_MFG_ID);
-		if (data != MFG_ID)
-			break;
-
-		/* resolve contention using the Ethernet address */
-		for (j = 0; j < 3; j++)
-			data = get_eeprom_data(id_port, j);
-
-		eth_nic_base =
-		    (get_eeprom_data(id_port, EEPROM_ADDR_CFG) & 0x1f) * 0x10 + 0x200;
-		outb(ep_current_tag, id_port);	/* tags board */
-		outb(ACTIVATE_ADAPTER_TO_CONFIG, id_port);
-		ep_current_tag--;
-		break;
-	}
-
-	if (i >= EP_MAX_BOARDS)
-		goto no3c509;
-
-	/*
-	* The iobase was found and MFG_ID was 0x6d50. PROD_ID should be
-	* 0x9[0-f]50
-	*/
-	GO_WINDOW(0);
-	k = get_e(EEPROM_PROD_ID);
-#ifdef	INCLUDE_3C529
-	/*
-	 * On MCA, the PROD_ID matches the MCA card ID (POS0+POS1)
-	 */
-	if (mcafound) {
-		if (mcafound->id != k) {
-			printf("MCA: PROD_ID in EEPROM does not match MCA card ID! (%hX != %hX)\n", k, mcafound->id);
-			goto no3c509;
-		}
-	} else { /* for ISA/EISA */
-		if ((k & 0xf0ff) != (PROD_ID & 0xf0ff))
-			goto no3c509;
-	}
-#else
-	if ((k & 0xf0ff) != (PROD_ID & 0xf0ff))
-		goto no3c509;
-#endif
-
-#ifdef	INCLUDE_3C529
-	if (mcafound) {
-		printf("%s board found on MCA at %#hx IRQ %d -",
-		       mcafound->name, eth_nic_base, mca_irq);
-	} else {
-#endif
-		if(eth_nic_base >= EP_EISA_START)
-			printf("3C5x9 board on EISA at %#hx - ",eth_nic_base);
-		else
-			printf("3C5x9 board on ISA at %#hx - ",eth_nic_base);
-#ifdef	INCLUDE_3C529
-	}
-#endif
-
-	/* test for presence of connectors */
-	i = inw(IS_BASE + EP_W0_CONFIG_CTRL);
-	j = (inw(IS_BASE + EP_W0_ADDRESS_CFG) >> 14) & 0x3;
-
-	switch(j) {
-		case 0:
-			if (i & IS_UTP) {
-				printf("10baseT\n");
-				connector = utp;
-				}
-			else {
-				printf("10baseT not present\n");
-				goto no3c509;
-				}
-			break;
-		case 1:
-			if (i & IS_AUI)
-				printf("10base5\n");
-			else {
-				printf("10base5 not present\n");
-				goto no3c509;
-				}
-			break;
-		case 3:
-			if (i & IS_BNC) {
-				printf("10base2\n");
-				connector = bnc;
-				}
-			else {
-				printf("10base2 not present\n");
-				goto no3c509;
-				}
-			break;
-		default:
-			printf("unknown connector\n");
-			goto no3c509;
-		}
-	/*
-	* Read the station address from the eeprom
-	*/
-	p = (unsigned short *) nic->node_addr;
-	for (i = 0; i < ETH_ALEN / 2; i++) {
-		GO_WINDOW(0);
-		p[i] = htons(get_e(i));
-		GO_WINDOW(2);
-		outw(ntohs(p[i]), BASE + EP_W2_ADDR_0 + (i * 2));
-	}
-	printf("Ethernet address: %!\n", nic->node_addr);
-	t509_reset(nic);
-	nic->reset = t509_reset;
-	nic->poll = t509_poll;
-	nic->transmit = t509_transmit;
-	nic->disable = t509_disable;
-	return nic;
-no3c509:
-	printf("(probe fail)");
-	}
-	return 0;
-}
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
Index: netboot/cs89x0.h
===================================================================
--- netboot/cs89x0.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/cs89x0.h	(.../trunk)	(revision 112)
@@ -1,461 +0,0 @@
-/*  Copyright, 1988-1992, Russell Nelson, Crynwr Software
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, version 1.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
-
-#define PP_ChipID 0x0000	/* offset   0h -> Corp -ID              */
-				/* offset   2h -> Model/Product Number  */
-				/* offset   3h -> Chip Revision Number  */
-
-#define PP_ISAIOB 0x0020	/*  IO base address */
-#define PP_CS8900_ISAINT 0x0022	/*  ISA interrupt select */
-#define PP_CS8920_ISAINT 0x0370	/*  ISA interrupt select */
-#define PP_CS8900_ISADMA 0x0024	/*  ISA Rec DMA channel */
-#define PP_CS8920_ISADMA 0x0374	/*  ISA Rec DMA channel */
-#define PP_ISASOF 0x0026	/*  ISA DMA offset */
-#define PP_DmaFrameCnt 0x0028	/*  ISA DMA Frame count */
-#define PP_DmaByteCnt 0x002A	/*  ISA DMA Byte count */
-#define PP_CS8900_ISAMemB 0x002C	/*  Memory base */
-#define PP_CS8920_ISAMemB 0x0348 /*  */
-
-#define PP_ISABootBase 0x0030	/*  Boot Prom base  */
-#define PP_ISABootMask 0x0034	/*  Boot Prom Mask */
-
-/* EEPROM data and command registers */
-#define PP_EECMD 0x0040		/*  NVR Interface Command register */
-#define PP_EEData 0x0042	/*  NVR Interface Data Register */
-#define PP_DebugReg 0x0044	/*  Debug Register */
-
-#define PP_RxCFG 0x0102		/*  Rx Bus config */
-#define PP_RxCTL 0x0104		/*  Receive Control Register */
-#define PP_TxCFG 0x0106		/*  Transmit Config Register */
-#define PP_TxCMD 0x0108		/*  Transmit Command Register */
-#define PP_BufCFG 0x010A	/*  Bus configuration Register */
-#define PP_LineCTL 0x0112	/*  Line Config Register */
-#define PP_SelfCTL 0x0114	/*  Self Command Register */
-#define PP_BusCTL 0x0116	/*  ISA bus control Register */
-#define PP_TestCTL 0x0118	/*  Test Register */
-#define PP_AutoNegCTL 0x011C	/*  Auto Negotiation Ctrl */
-
-#define PP_ISQ 0x0120		/*  Interrupt Status */
-#define PP_RxEvent 0x0124	/*  Rx Event Register */
-#define PP_TxEvent 0x0128	/*  Tx Event Register */
-#define PP_BufEvent 0x012C	/*  Bus Event Register */
-#define PP_RxMiss 0x0130	/*  Receive Miss Count */
-#define PP_TxCol 0x0132		/*  Transmit Collision Count */
-#define PP_LineST 0x0134	/*  Line State Register */
-#define PP_SelfST 0x0136	/*  Self State register */
-#define PP_BusST 0x0138		/*  Bus Status */
-#define PP_TDR 0x013C		/*  Time Domain Reflectometry */
-#define PP_AutoNegST 0x013E	/*  Auto Neg Status */
-#define PP_TxCommand 0x0144	/*  Tx Command */
-#define PP_TxLength 0x0146	/*  Tx Length */
-#define PP_LAF 0x0150		/*  Hash Table */
-#define PP_IA 0x0158		/*  Physical Address Register */
-
-#define PP_RxStatus 0x0400	/*  Receive start of frame */
-#define PP_RxLength 0x0402	/*  Receive Length of frame */
-#define PP_RxFrame 0x0404	/*  Receive frame pointer */
-#define PP_TxFrame 0x0A00	/*  Transmit frame pointer */
-
-/*  Primary I/O Base Address. If no I/O base is supplied by the user, then this */
-/*  can be used as the default I/O base to access the PacketPage Area. */
-#define DEFAULTIOBASE 0x0300
-#define FIRST_IO 0x020C		/*  First I/O port to check */
-#define LAST_IO 0x037C		/*  Last I/O port to check (+10h) */
-#define ADD_MASK 0x3000		/*  Mask it use of the ADD_PORT register */
-#define ADD_SIG 0x3000		/*  Expected ID signature */
-
-#define CHIP_EISA_ID_SIG 0x630E   /*  Product ID Code for Crystal Chip (CS8900 spec 4.3) */
-
-#ifdef	IBMEIPKT
-#define EISA_ID_SIG 0x4D24	/*  IBM */
-#define PART_NO_SIG 0x1010	/*  IBM */
-#define MONGOOSE_BIT 0x0000	/*  IBM */
-#else
-#define EISA_ID_SIG 0x630E	/*  PnP Vendor ID (same as chip id for Crystal board) */
-#define PART_NO_SIG 0x4000	/*  ID code CS8920 board (PnP Vendor Product code) */
-#define MONGOOSE_BIT 0x2000	/*  PART_NO_SIG + MONGOOSE_BUT => ID of mongoose */
-#endif
-
-#define PRODUCT_ID_ADD 0x0002   /*  Address of product ID */
-
-/*  Mask to find out the types of  registers */
-#define REG_TYPE_MASK 0x001F
-
-/*  Eeprom Commands */
-#define ERSE_WR_ENBL 0x00F0
-#define ERSE_WR_DISABLE 0x0000
-
-/*  Defines Control/Config register quintuplet numbers */
-#define RX_BUF_CFG 0x0003
-#define RX_CONTROL 0x0005
-#define TX_CFG 0x0007
-#define TX_COMMAND 0x0009
-#define BUF_CFG 0x000B
-#define LINE_CONTROL 0x0013
-#define SELF_CONTROL 0x0015
-#define BUS_CONTROL 0x0017
-#define TEST_CONTROL 0x0019
-
-/*  Defines Status/Count registers quintuplet numbers */
-#define RX_EVENT 0x0004
-#define TX_EVENT 0x0008
-#define BUF_EVENT 0x000C
-#define RX_MISS_COUNT 0x0010
-#define TX_COL_COUNT 0x0012
-#define LINE_STATUS 0x0014
-#define SELF_STATUS 0x0016
-#define BUS_STATUS 0x0018
-#define TDR 0x001C
-
-/* PP_RxCFG - Receive  Configuration and Interrupt Mask bit definition -  Read/write */
-#define SKIP_1 0x0040
-#define RX_STREAM_ENBL 0x0080
-#define RX_OK_ENBL 0x0100
-#define RX_DMA_ONLY 0x0200
-#define AUTO_RX_DMA 0x0400
-#define BUFFER_CRC 0x0800
-#define RX_CRC_ERROR_ENBL 0x1000
-#define RX_RUNT_ENBL 0x2000
-#define RX_EXTRA_DATA_ENBL 0x4000
-
-/* PP_RxCTL - Receive Control bit definition - Read/write */
-#define RX_IA_HASH_ACCEPT 0x0040
-#define RX_PROM_ACCEPT 0x0080
-#define RX_OK_ACCEPT 0x0100
-#define RX_MULTCAST_ACCEPT 0x0200
-#define RX_IA_ACCEPT 0x0400
-#define RX_BROADCAST_ACCEPT 0x0800
-#define RX_BAD_CRC_ACCEPT 0x1000
-#define RX_RUNT_ACCEPT 0x2000
-#define RX_EXTRA_DATA_ACCEPT 0x4000
-#define RX_ALL_ACCEPT (RX_PROM_ACCEPT|RX_BAD_CRC_ACCEPT|RX_RUNT_ACCEPT|RX_EXTRA_DATA_ACCEPT)
-/*  Default receive mode - individually addressed, broadcast, and error free */
-#define DEF_RX_ACCEPT (RX_IA_ACCEPT | RX_BROADCAST_ACCEPT | RX_OK_ACCEPT)
-
-/* PP_TxCFG - Transmit Configuration Interrupt Mask bit definition - Read/write */
-#define TX_LOST_CRS_ENBL 0x0040
-#define TX_SQE_ERROR_ENBL 0x0080
-#define TX_OK_ENBL 0x0100
-#define TX_LATE_COL_ENBL 0x0200
-#define TX_JBR_ENBL 0x0400
-#define TX_ANY_COL_ENBL 0x0800
-#define TX_16_COL_ENBL 0x8000
-
-/* PP_TxCMD - Transmit Command bit definition - Read-only */
-#define TX_START_4_BYTES 0x0000
-#define TX_START_64_BYTES 0x0040
-#define TX_START_128_BYTES 0x0080
-#define TX_START_ALL_BYTES 0x00C0
-#define TX_FORCE 0x0100
-#define TX_ONE_COL 0x0200
-#define TX_TWO_PART_DEFF_DISABLE 0x0400
-#define TX_NO_CRC 0x1000
-#define TX_RUNT 0x2000
-
-/* PP_BufCFG - Buffer Configuration Interrupt Mask bit definition - Read/write */
-#define GENERATE_SW_INTERRUPT 0x0040
-#define RX_DMA_ENBL 0x0080
-#define READY_FOR_TX_ENBL 0x0100
-#define TX_UNDERRUN_ENBL 0x0200
-#define RX_MISS_ENBL 0x0400
-#define RX_128_BYTE_ENBL 0x0800
-#define TX_COL_COUNT_OVRFLOW_ENBL 0x1000
-#define RX_MISS_COUNT_OVRFLOW_ENBL 0x2000
-#define RX_DEST_MATCH_ENBL 0x8000
-
-/* PP_LineCTL - Line Control bit definition - Read/write */
-#define SERIAL_RX_ON 0x0040
-#define SERIAL_TX_ON 0x0080
-#define AUI_ONLY 0x0100
-#define AUTO_AUI_10BASET 0x0200
-#define MODIFIED_BACKOFF 0x0800
-#define NO_AUTO_POLARITY 0x1000
-#define TWO_PART_DEFDIS 0x2000
-#define LOW_RX_SQUELCH 0x4000
-
-/* PP_SelfCTL - Software Self Control bit definition - Read/write */
-#define POWER_ON_RESET 0x0040
-#define SW_STOP 0x0100
-#define SLEEP_ON 0x0200
-#define AUTO_WAKEUP 0x0400
-#define HCB0_ENBL 0x1000
-#define HCB1_ENBL 0x2000
-#define HCB0 0x4000
-#define HCB1 0x8000
-
-/* PP_BusCTL - ISA Bus Control bit definition - Read/write */
-#define RESET_RX_DMA 0x0040
-#define MEMORY_ON 0x0400
-#define DMA_BURST_MODE 0x0800
-#define IO_CHANNEL_READY_ON 0x1000
-#define RX_DMA_SIZE_64K 0x2000
-#define ENABLE_IRQ 0x8000
-
-/* PP_TestCTL - Test Control bit definition - Read/write */
-#define LINK_OFF 0x0080
-#define ENDEC_LOOPBACK 0x0200
-#define AUI_LOOPBACK 0x0400
-#define BACKOFF_OFF 0x0800
-#define FAST_TEST 0x8000
-
-/* PP_RxEvent - Receive Event Bit definition - Read-only */
-#define RX_IA_HASHED 0x0040
-#define RX_DRIBBLE 0x0080
-#define RX_OK 0x0100
-#define RX_HASHED 0x0200
-#define RX_IA 0x0400
-#define RX_BROADCAST 0x0800
-#define RX_CRC_ERROR 0x1000
-#define RX_RUNT 0x2000
-#define RX_EXTRA_DATA 0x4000
-
-#define HASH_INDEX_MASK 0x0FC00
-
-/* PP_TxEvent - Transmit Event Bit definition - Read-only */
-#define TX_LOST_CRS 0x0040
-#define TX_SQE_ERROR 0x0080
-#define TX_OK 0x0100
-#define TX_LATE_COL 0x0200
-#define TX_JBR 0x0400
-#define TX_16_COL 0x8000
-#define TX_SEND_OK_BITS (TX_OK|TX_LOST_CRS)
-#define TX_COL_COUNT_MASK 0x7800
-
-/* PP_BufEvent - Buffer Event Bit definition - Read-only */
-#define SW_INTERRUPT 0x0040
-#define RX_DMA 0x0080
-#define READY_FOR_TX 0x0100
-#define TX_UNDERRUN 0x0200
-#define RX_MISS 0x0400
-#define RX_128_BYTE 0x0800
-#define TX_COL_OVRFLW 0x1000
-#define RX_MISS_OVRFLW 0x2000
-#define RX_DEST_MATCH 0x8000
-
-/* PP_LineST - Ethernet Line Status bit definition - Read-only */
-#define LINK_OK 0x0080
-#define AUI_ON 0x0100
-#define TENBASET_ON 0x0200
-#define POLARITY_OK 0x1000
-#define CRS_OK 0x4000
-
-/* PP_SelfST - Chip Software Status bit definition */
-#define ACTIVE_33V 0x0040
-#define INIT_DONE 0x0080
-#define SI_BUSY 0x0100
-#define EEPROM_PRESENT 0x0200
-#define EEPROM_OK 0x0400
-#define EL_PRESENT 0x0800
-#define EE_SIZE_64 0x1000
-
-/* PP_BusST - ISA Bus Status bit definition */
-#define TX_BID_ERROR 0x0080
-#define READY_FOR_TX_NOW 0x0100
-
-/* PP_AutoNegCTL - Auto Negotiation Control bit definition */
-#define RE_NEG_NOW 0x0040
-#define ALLOW_FDX 0x0080
-#define AUTO_NEG_ENABLE 0x0100
-#define NLP_ENABLE 0x0200
-#define FORCE_FDX 0x8000
-#define AUTO_NEG_BITS (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE)
-#define AUTO_NEG_MASK (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE|ALLOW_FDX|RE_NEG_NOW)
-
-/* PP_AutoNegST - Auto Negotiation Status bit definition */
-#define AUTO_NEG_BUSY 0x0080
-#define FLP_LINK 0x0100
-#define FLP_LINK_GOOD 0x0800
-#define LINK_FAULT 0x1000
-#define HDX_ACTIVE 0x4000
-#define FDX_ACTIVE 0x8000
-
-/*  The following block defines the ISQ event types */
-#define ISQ_RECEIVER_EVENT 0x04
-#define ISQ_TRANSMITTER_EVENT 0x08
-#define ISQ_BUFFER_EVENT 0x0c
-#define ISQ_RX_MISS_EVENT 0x10
-#define ISQ_TX_COL_EVENT 0x12
-
-#define ISQ_EVENT_MASK 0x003F   /*  ISQ mask to find out type of event */
-#define ISQ_HIST 16		/*  small history buffer */
-#define AUTOINCREMENT 0x8000	/*  Bit mask to set bit-15 for autoincrement */
-
-#define TXRXBUFSIZE 0x0600
-#define RXDMABUFSIZE 0x8000
-#define RXDMASIZE 0x4000
-#define TXRX_LENGTH_MASK 0x07FF
-
-/*  rx options bits */
-#define RCV_WITH_RXON	1       /*  Set SerRx ON */
-#define RCV_COUNTS	2       /*  Use Framecnt1 */
-#define RCV_PONG	4       /*  Pong respondent */
-#define RCV_DONG	8       /*  Dong operation */
-#define RCV_POLLING	0x10	/*  Poll RxEvent */
-#define RCV_ISQ		0x20	/*  Use ISQ, int */
-#define RCV_AUTO_DMA	0x100	/*  Set AutoRxDMAE */
-#define RCV_DMA		0x200	/*  Set RxDMA only */
-#define RCV_DMA_ALL	0x400	/*  Copy all DMA'ed */
-#define RCV_FIXED_DATA	0x800	/*  Every frame same */
-#define RCV_IO		0x1000	/*  Use ISA IO only */
-#define RCV_MEMORY	0x2000	/*  Use ISA Memory */
-
-#define RAM_SIZE	0x1000       /*  The card has 4k bytes or RAM */
-#define PKT_START PP_TxFrame  /*  Start of packet RAM */
-
-#define RX_FRAME_PORT	0x0000
-#define TX_FRAME_PORT RX_FRAME_PORT
-#define TX_CMD_PORT	0x0004
-#define TX_NOW		0x0000       /*  Tx packet after   5 bytes copied */
-#define TX_AFTER_381	0x0020       /*  Tx packet after 381 bytes copied */
-#define TX_AFTER_ALL	0x0060       /*  Tx packet after all bytes copied */
-#define TX_LEN_PORT	0x0006
-#define ISQ_PORT	0x0008
-#define ADD_PORT	0x000A
-#define DATA_PORT	0x000C
-
-#define EEPROM_WRITE_EN		0x00F0
-#define EEPROM_WRITE_DIS	0x0000
-#define EEPROM_WRITE_CMD	0x0100
-#define EEPROM_READ_CMD		0x0200
-
-/*  Receive Header */
-/*  Description of header of each packet in receive area of memory */
-#define RBUF_EVENT_LOW	0   /*  Low byte of RxEvent - status of received frame */
-#define RBUF_EVENT_HIGH	1   /*  High byte of RxEvent - status of received frame */
-#define RBUF_LEN_LOW	2   /*  Length of received data - low byte */
-#define RBUF_LEN_HI	3   /*  Length of received data - high byte */
-#define RBUF_HEAD_LEN	4   /*  Length of this header */
-
-#define CHIP_READ 0x1   /*  Used to mark state of the repins code (chip or dma) */
-#define DMA_READ 0x2   /*  Used to mark state of the repins code (chip or dma) */
-
-/*  for bios scan */
-/*  */
-#ifdef	CSDEBUG
-/*  use these values for debugging bios scan */
-#define BIOS_START_SEG 0x00000
-#define BIOS_OFFSET_INC 0x0010
-#else
-#define BIOS_START_SEG 0x0c000
-#define BIOS_OFFSET_INC 0x0200
-#endif
-
-#define BIOS_LAST_OFFSET 0x0fc00
-
-/*  Byte offsets into the EEPROM configuration buffer */
-#define ISA_CNF_OFFSET 0x6
-#define TX_CTL_OFFSET (ISA_CNF_OFFSET + 8)			/*  8900 eeprom */
-#define AUTO_NEG_CNF_OFFSET (ISA_CNF_OFFSET + 8)		/*  8920 eeprom */
-
-  /*  the assumption here is that the bits in the eeprom are generally  */
-  /*  in the same position as those in the autonegctl register. */
-  /*  Of course the IMM bit is not in that register so it must be  */
-  /*  masked out */
-#define EE_FORCE_FDX  0x8000
-#define EE_NLP_ENABLE 0x0200
-#define EE_AUTO_NEG_ENABLE 0x0100
-#define EE_ALLOW_FDX 0x0080
-#define EE_AUTO_NEG_CNF_MASK (EE_FORCE_FDX|EE_NLP_ENABLE|EE_AUTO_NEG_ENABLE|EE_ALLOW_FDX)
-
-#define IMM_BIT 0x0040		/*  ignore missing media */
-
-#define ADAPTER_CNF_OFFSET (AUTO_NEG_CNF_OFFSET + 2)
-#define A_CNF_10B_T 0x0001
-#define A_CNF_AUI 0x0002
-#define A_CNF_10B_2 0x0004
-#define A_CNF_MEDIA_TYPE 0x0060
-#define A_CNF_MEDIA_AUTO 0x0000
-#define A_CNF_MEDIA_10B_T 0x0020
-#define A_CNF_MEDIA_AUI 0x0040
-#define A_CNF_MEDIA_10B_2 0x0060
-#define A_CNF_DC_DC_POLARITY 0x0080
-#define A_CNF_NO_AUTO_POLARITY 0x2000
-#define A_CNF_LOW_RX_SQUELCH 0x4000
-#define A_CNF_EXTND_10B_2 0x8000
-
-#define PACKET_PAGE_OFFSET 0x8
-
-/*  Bit definitions for the ISA configuration word from the EEPROM */
-#define INT_NO_MASK 0x000F
-#define DMA_NO_MASK 0x0070
-#define ISA_DMA_SIZE 0x0200
-#define ISA_AUTO_RxDMA 0x0400
-#define ISA_RxDMA 0x0800
-#define DMA_BURST 0x1000
-#define STREAM_TRANSFER 0x2000
-#define ANY_ISA_DMA (ISA_AUTO_RxDMA | ISA_RxDMA)
-
-/*  DMA controller registers */
-#define DMA_BASE 0x00     /*  DMA controller base */
-#define DMA_BASE_2 0x0C0    /*  DMA controller base */
-
-#define DMA_STAT 0x0D0    /*  DMA controller status register */
-#define DMA_MASK 0x0D4    /*  DMA controller mask register */
-#define DMA_MODE 0x0D6    /*  DMA controller mode register */
-#define DMA_RESETFF 0x0D8    /*  DMA controller first/last flip flop */
-
-/*  DMA data */
-#define DMA_DISABLE 0x04     /*  Disable channel n */
-#define DMA_ENABLE 0x00     /*  Enable channel n */
-/*  Demand transfers, incr. address, auto init, writes, ch. n */
-#define DMA_RX_MODE 0x14
-/*  Demand transfers, incr. address, auto init, reads, ch. n */
-#define DMA_TX_MODE 0x18
-
-#define DMA_SIZE (16*1024) /*  Size of dma buffer - 16k */
-
-#define CS8900 0x0000
-#define CS8920 0x4000
-#define CS8920M 0x6000
-#define REVISON_BITS 0x1F00
-#define EEVER_NUMBER 0x12
-#define CHKSUM_LEN 0x14
-#define CHKSUM_VAL 0x0000
-#define START_EEPROM_DATA 0x001c /*  Offset into eeprom for start of data */
-#define IRQ_MAP_EEPROM_DATA 0x0046 /*  Offset into eeprom for the IRQ map */
-#define IRQ_MAP_LEN 0x0004 /*  No of bytes to read for the IRQ map */
-#define PNP_IRQ_FRMT 0x0022 /*  PNP small item IRQ format */
-#define CS8900_IRQ_MAP 0x1c20 /*  This IRQ map is fixed */
-
-#define CS8920_NO_INTS 0x0F   /*  Max CS8920 interrupt select # */
-
-#define PNP_ADD_PORT 0x0279
-#define PNP_WRITE_PORT 0x0A79
-
-#define GET_PNP_ISA_STRUCT 0x40
-#define PNP_ISA_STRUCT_LEN 0x06
-#define PNP_CSN_CNT_OFF 0x01
-#define PNP_RD_PORT_OFF 0x02
-#define PNP_FUNCTION_OK 0x00
-#define PNP_WAKE 0x03
-#define PNP_RSRC_DATA 0x04
-#define PNP_RSRC_READY 0x01
-#define PNP_STATUS 0x05
-#define PNP_ACTIVATE 0x30
-#define PNP_CNF_IO_H 0x60
-#define PNP_CNF_IO_L 0x61
-#define PNP_CNF_INT 0x70
-#define PNP_CNF_DMA 0x74
-#define PNP_CNF_MEM 0x48
-
-#define BIT0 1
-#define BIT15 0x8000
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
-
Index: netboot/i82586.c
===================================================================
--- netboot/i82586.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/i82586.c	(.../trunk)	(revision 112)
@@ -1,825 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-i82586 NIC driver for Etherboot
-Ken Yap, January 1998
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-#include "etherboot.h"
-#include "nic.h"
-#include "cards.h"
-#include "timer.h"
-
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
-/* Sources of information:
-
-   Donald Becker's excellent 3c507 driver in Linux
-   Intel 82596 data sheet (yes, 82596; it has a 586 compatibility mode)
-*/
-
-/* Code below mostly stolen wholesale from 3c507.c driver in Linux */
-
-/*
-		Details of the i82586.
-
-   You'll really need the databook to understand the details of this part,
-   but the outline is that the i82586 has two separate processing units.
-   Both are started from a list of three configuration tables, of which only
-   the last, the System Control Block (SCB), is used after reset-time.  The SCB
-   has the following fields:
-		Status word
-		Command word
-		Tx/Command block addr.
-		Rx block addr.
-   The command word accepts the following controls for the Tx and Rx units:
-  */
-
-#define	CUC_START	0x0100
-#define	CUC_RESUME	0x0200
-#define	CUC_SUSPEND	0x0300
-#define	RX_START	0x0010
-#define	RX_RESUME	0x0020
-#define	RX_SUSPEND	0x0030
-
-/* The Rx unit uses a list of frame descriptors and a list of data buffer
-   descriptors.  We use full-sized (1518 byte) data buffers, so there is
-   a one-to-one pairing of frame descriptors to buffer descriptors.
-
-   The Tx ("command") unit executes a list of commands that look like:
-	Status word	Written by the 82586 when the command is done.
-	Command word	Command in lower 3 bits, post-command action in upper 3
-	Link word	The address of the next command.
-	Parameters	(as needed).
-
-	Some definitions related to the Command Word are:
- */
-#define CMD_EOL		0x8000		/* The last command of the list, stop. */
-#define CMD_SUSP	0x4000		/* Suspend after doing cmd. */
-#define CMD_INTR	0x2000		/* Interrupt after doing cmd. */
-
-enum commands {
-	CmdNOp = 0, CmdSASetup = 1, CmdConfigure = 2, CmdMulticastList = 3,
-	CmdTx = 4, CmdTDR = 5, CmdDump = 6, CmdDiagnose = 7};
-
-/*
-		Details of the EtherLink16 Implementation
-
-  The 3c507 and NI5210 are generic shared-memory i82586 implementations.
-  3c507: The host can map 16K, 32K, 48K, or 64K of the 64K memory into
-  0x0[CD][08]0000, or all 64K into 0xF[02468]0000.
-  NI5210: The host can map 8k or 16k at 0x[CDE][048C]000 but we
-  assume 8k because to have 16k you cannot put a ROM on the NIC.
-  */
-
-/* Offsets from the base I/O address. */
-
-#ifdef	INCLUDE_3C507
-
-#define	SA_DATA		0	/* Station address data, or 3Com signature. */
-#define MISC_CTRL	6	/* Switch the SA_DATA banks, and bus config bits. */
-#define RESET_IRQ	10	/* Reset the latched IRQ line. */
-#define I82586_ATTN	11	/* Frob the 82586 Channel Attention line. */
-#define ROM_CONFIG	13
-#define MEM_CONFIG	14
-#define IRQ_CONFIG	15
-#define EL16_IO_EXTENT	16
-
-/* The ID port is used at boot-time to locate the ethercard. */
-#define ID_PORT		0x100
-
-#endif
-
-#ifdef	INCLUDE_NI5210
-
-#define	NI52_RESET	0  /* writing to this address, resets the i82586 */
-#define	I82586_ATTN	1  /* channel attention, kick the 586 */
-
-#endif
-
-#ifdef	INCLUDE_EXOS205
-
-#define	EXOS205_RESET	0  /* writing to this address, resets the i82586 */
-#define	I82586_ATTN	1  /* channel attention, kick the 586 */
-
-#endif
-
-/* Offsets to registers in the mailbox (SCB). */
-#define iSCB_STATUS	0x8
-#define iSCB_CMD	0xA
-#define iSCB_CBL	0xC	/* Command BLock offset. */
-#define iSCB_RFA	0xE	/* Rx Frame Area offset. */
-
-/*  Since the 3c507 maps the shared memory window so that the last byte is
-at 82586 address FFFF, the first byte is at 82586 address 0, 16K, 32K, or
-48K corresponding to window sizes of 64K, 48K, 32K and 16K respectively.
-We can account for this be setting the 'SBC Base' entry in the ISCP table
-below for all the 16 bit offset addresses, and also adding the 'SCB Base'
-value to all 24 bit physical addresses (in the SCP table and the TX and RX
-Buffer Descriptors).
-				-Mark
-*/
-
-/*
-  What follows in 'init_words[]' is the "program" that is downloaded to the
-  82586 memory.  It's mostly tables and command blocks, and starts at the
-  reset address 0xfffff6.  This is designed to be similar to the EtherExpress,
-  thus the unusual location of the SCB at 0x0008.
-
-  Even with the additional "don't care" values, doing it this way takes less
-  program space than initializing the individual tables, and I feel it's much
-  cleaner.
-
-  The databook is particularly useless for the first two structures, I had
-  to use the Crynwr driver as an example.
-
-  The memory setup is as follows:
-*/
-
-#define CONFIG_CMD	0x18
-#define SET_SA_CMD	0x24
-#define SA_OFFSET	0x2A
-#define IDLELOOP	0x30
-#define TDR_CMD		0x38
-#define TDR_TIME	0x3C
-#define DUMP_CMD	0x40
-#define DIAG_CMD	0x48
-#define SET_MC_CMD	0x4E
-#define DUMP_DATA	0x56	/* A 170 byte buffer for dump and Set-MC into. */
-
-#define TX_BUF_START	0x0100
-#define TX_BUF_SIZE	(1518+14+20+16) /* packet+header+TBD */
-
-#define RX_BUF_START	0x1000
-#define RX_BUF_SIZE	(1518+14+18)	/* packet+header+RBD */
-#define RX_BUF_END	(mem_end - mem_start - 20)
-
-/*
-  That's it: only 86 bytes to set up the beast, including every extra
-  command available.  The 170 byte buffer at DUMP_DATA is shared between the
-  Dump command (called only by the diagnostic program) and the SetMulticastList
-  command.
-
-  To complete the memory setup you only have to write the station address at
-  SA_OFFSET and create the Tx & Rx buffer lists.
-
-  The Tx command chain and buffer list is setup as follows:
-  A Tx command table, with the data buffer pointing to...
-  A Tx data buffer descriptor.  The packet is in a single buffer, rather than
-	chaining together several smaller buffers.
-  A NoOp command, which initially points to itself,
-  And the packet data.
-
-  A transmit is done by filling in the Tx command table and data buffer,
-  re-writing the NoOp command, and finally changing the offset of the last
-  command to point to the current Tx command.  When the Tx command is finished,
-  it jumps to the NoOp, when it loops until the next Tx command changes the
-  "link offset" in the NoOp.  This way the 82586 never has to go through the
-  slow restart sequence.
-
-  The Rx buffer list is set up in the obvious ring structure.  We have enough
-  memory (and low enough interrupt latency) that we can avoid the complicated
-  Rx buffer linked lists by alway associating a full-size Rx data buffer with
-  each Rx data frame.
-
-  I currently use one transmit buffer starting at TX_BUF_START (0x0100), and
-  use the rest of memory, from RX_BUF_START to RX_BUF_END, for Rx buffers.
-
-  */
-
-static unsigned short init_words[] = {
-	/*	System Configuration Pointer (SCP). */
-#if	defined(INCLUDE_3C507)
-	0x0000,					/* Set bus size to 16 bits. */
-#else
-	0x0001,					/* Set bus size to 8 bits */
-#endif
-	0,0,					/* pad words. */
-	0x0000,0x0000,				/* ISCP phys addr, set in init_82586_mem(). */
-
-	/*	Intermediate System Configuration Pointer (ISCP). */
-	0x0001,					/* Status word that's cleared when init is done. */
-	0x0008,0,0,				/* SCB offset, (skip, skip) */
-
-	/* System Control Block (SCB). */
-	0,0xf000|RX_START|CUC_START,		/* SCB status and cmd. */
-	CONFIG_CMD,				/* Command list pointer, points to Configure. */
-	RX_BUF_START,				/* Rx block list. */
-	0,0,0,0,				/* Error count: CRC, align, buffer, overrun. */
-
-	/* 0x0018: Configure command.  Change to put MAC data with packet. */
-	0, CmdConfigure,			/* Status, command. */
-	SET_SA_CMD,				/* Next command is Set Station Addr. */
-	0x0804,					/* "4" bytes of config data, 8 byte FIFO. */
-	0x2e40,					/* Magic values, including MAC data location. */
-	0,					/* Unused pad word. */
-
-	/* 0x0024: Setup station address command. */
-	0, CmdSASetup,
-	SET_MC_CMD,				/* Next command. */
-	0xaa00,0xb000,0x0bad,	/* Station address (to be filled in) */
-
-	/* 0x0030: NOP, looping back to itself.  Point to first Tx buffer to Tx. */
-	0, CmdNOp, IDLELOOP, 0 /* pad */,
-
-	/* 0x0038: A unused Time-Domain Reflectometer command. */
-	0, CmdTDR, IDLELOOP, 0,
-
-	/* 0x0040: An unused Dump State command. */
-	0, CmdDump, IDLELOOP, DUMP_DATA,
-
-	/* 0x0048: An unused Diagnose command. */
-	0, CmdDiagnose, IDLELOOP,
-
-	/* 0x004E: An empty set-multicast-list command. */
-	0, CmdMulticastList, IDLELOOP, 0,
-};
-
-/* NIC specific static variables go here */
-
-static unsigned short		ioaddr, irq, scb_base;
-static Address			mem_start, mem_end;
-static unsigned short		rx_head, rx_tail;
-
-#define	read_mem(m,s)	fmemcpy((char *)s, m, sizeof(s))
-
-static void setup_rx_buffers(struct nic *nic)
-{
-	Address			write_ptr;
-	unsigned short		cur_rx_buf;
-	static unsigned short	rx_cmd[16] = {
-		0x0000,			/* Rx status */
-		0x0000,			/* Rx command, only and last */
-		RX_BUF_START,		/* Link (will be adjusted) */
-		RX_BUF_START + 22,	/* Buffer offset (will be adjusted) */
-		0x0000, 0x0000, 0x0000,	/* Pad for dest addr */
-		0x0000, 0x0000, 0x0000,	/* Pad for source addr */
-		0x0000,			/* Pad for protocol */
-		0x0000,			/* Buffer: Actual count */
-		-1,			/* Buffer: Next (none) */
-		RX_BUF_START + 0x20,	/* Buffer: Address low (+ scb_base) (will be adjusted) */
-		0x0000,			/* Buffer: Address high */
-		0x8000 | (RX_BUF_SIZE - 0x20)
-	};
-
-	cur_rx_buf = rx_head = RX_BUF_START;
-	do {		/* While there is room for one more buffer */
-		write_ptr = mem_start + cur_rx_buf;
-		/* adjust some contents */
-		rx_cmd[1] = 0x0000;
-		rx_cmd[2] = cur_rx_buf + RX_BUF_SIZE;
-		rx_cmd[3] = cur_rx_buf + 22;
-		rx_cmd[13] = cur_rx_buf + 0x20 + scb_base;
-		memcpy((char *)write_ptr, (char *)rx_cmd, sizeof(rx_cmd));
-		rx_tail = cur_rx_buf;
-		cur_rx_buf += RX_BUF_SIZE;
-	} while (cur_rx_buf <= RX_BUF_END - RX_BUF_SIZE);
-	/* Terminate the list by setting the EOL bit and wrap ther pointer
-	   to make the list a ring. */
-	write_ptr = mem_start + rx_tail;
-	rx_cmd[1] = 0xC000;
-	rx_cmd[2] = rx_head;
-	memcpy((char *)write_ptr, (char *)rx_cmd, sizeof(unsigned short) * 3);
-}
-
-static void ack_status(void)
-{
-	unsigned short	cmd, status;
-	unsigned short	*shmem = (short *)mem_start;
-
-	cmd = (status = shmem[iSCB_STATUS>>1]) & 0xf000;
-	if (status & 0x100)		/* CU suspended? */
-		cmd |= CUC_RESUME;
-	if ((status & 0x200) == 0)	/* CU not active? */
-		cmd |= CUC_START;
-	if (status & 0x010)		/* RU suspended? */
-		cmd |= RX_RESUME;
-	else if ((status & 0x040) == 0)	/* RU not active? */
-		cmd |= RX_START;
-	if (cmd == 0)			/* Nothing to do */
-		return;
-	shmem[iSCB_CMD>>1] = cmd;
-#if	defined(DEBUG)
-	printf("Status %hX Command %hX\n", status, cmd);
-#endif
-	outb(0, ioaddr + I82586_ATTN);
-}
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-
-static void i82586_reset(struct nic *nic)
-{
-	unsigned long	time;
-	unsigned short	*shmem = (short *)mem_start;
-
-	/* put the card in its initial state */
-
-#ifdef	INCLUDE_3C507
-	/* Enable loopback to protect the wire while starting up,
-	   and hold the 586 in reset during the memory initialisation. */
-	outb(0x20, ioaddr + MISC_CTRL);
-#endif
-
-	/* Fix the ISCP address and base. */
-	init_words[3] = scb_base;
-	init_words[7] = scb_base;
-
-	/* Write the words at 0xfff6. */
-	/* Write the words at 0x0000. */
-	/* Fill in the station address. */
-	memcpy((char *)(mem_end - 10), (char *)init_words, 10);
-	memcpy((char *)mem_start, (char *)&init_words[5], sizeof(init_words) - 10);
-	memcpy((char *)mem_start + SA_OFFSET, nic->node_addr, ETH_ALEN);
-	setup_rx_buffers(nic);
-
-#ifdef	INCLUDE_3C507
-	/* Start the 586 by releasing the reset line, but leave loopback. */
-	outb(0xA0, ioaddr + MISC_CTRL);
-#endif
-
-	/* This was time consuming to track down; you need to give two channel
-	   attention signals to reliably start up the i82586. */
-	outb(0, ioaddr + I82586_ATTN);
-	time = currticks() + TICKS_PER_SEC;	/* allow 1 second to init */
-	while (
-			shmem[iSCB_STATUS>>1] == 0)
-	{
-		if (currticks() > time)
-		{
-			printf("i82586 initialisation timed out with status %hX, cmd %hX\n",
-					shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-			break;
-		}
-	}
-	/* Issue channel-attn -- the 82586 won't start. */
-	outb(0, ioaddr + I82586_ATTN);
-
-#ifdef	INCLUDE_3C507
-	/* Disable loopback. */
-	outb(0x80, ioaddr + MISC_CTRL);
-#endif
-#if	defined(DEBUG)
-	printf("i82586 status %hX, cmd %hX\n",
-			shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-#endif
-}
-
-/**************************************************************************
-  POLL - Wait for a frame
- ***************************************************************************/
-static int i82586_poll(struct nic *nic)
-{
-	int		status;
-	unsigned short	rfd_cmd, next_rx_frame, data_buffer_addr,
-	frame_status, pkt_len;
-	unsigned short	*shmem = (short *)mem_start + rx_head;
-
-	/* return true if there's an ethernet packet ready to read */
-	if (
-			((frame_status = shmem[0]) & 0x8000) == 0)
-		return (0);		/* nope */
-	rfd_cmd = shmem[1];
-	next_rx_frame = shmem[2];
-	data_buffer_addr = shmem[3];
-	pkt_len = shmem[11];
-	status = 0;
-	if (rfd_cmd != 0 || data_buffer_addr != rx_head + 22
-			|| (pkt_len & 0xC000) != 0xC000)
-		printf("\nRx frame corrupt, discarded");
-	else if ((frame_status & 0x2000) == 0)
-		printf("\nRx frame had error");
-	else
-	{
-		/* We have a frame, copy it to our buffer */
-		pkt_len &= 0x3FFF;
-		memcpy(nic->packet, (char *)mem_start + rx_head + 0x20, pkt_len);
-		/* Only packets not from ourself */
-		if (memcmp(nic->packet + ETH_ALEN, nic->node_addr, ETH_ALEN) != 0)
-		{
-			nic->packetlen = pkt_len;
-			status = 1;
-		}
-	}
-	/* Clear the status word and set EOL on Rx frame */
-	shmem[0] = 0;
-	shmem[1] = 0xC000;
-	*(short *)(mem_start + rx_tail + 2) = 0;
-	rx_tail = rx_head;
-	rx_head = next_rx_frame;
-	ack_status();
-	return (status);
-}
-
-/**************************************************************************
-  TRANSMIT - Transmit a frame
- ***************************************************************************/
-static void i82586_transmit(
-		struct nic *nic,
-		const char *d,			/* Destination */
-		unsigned int t,			/* Type */
-		unsigned int s,			/* size */
-		const char *p)			/* Packet */
-{
-	Address			bptr;
-	unsigned short		type, z;
-	static unsigned short	tx_cmd[11] = {
-		0x0,			/* Tx status */
-		CmdTx,			/* Tx command */
-		TX_BUF_START+16,	/* Next command is a NoOp */
-		TX_BUF_START+8,		/* Data Buffer offset */
-		0x8000,			/* | with size */
-		0xffff,			/* No next data buffer */
-		TX_BUF_START+22,	/* + scb_base */
-		0x0,			/* Buffer address high bits (always zero) */
-		0x0,			/* Nop status */
-		CmdNOp,			/* Nop command */
-		TX_BUF_START+16		/* Next is myself */
-	};
-	unsigned short	*shmem = (short *)mem_start + TX_BUF_START;
-
-	/* send the packet to destination */
-	/* adjust some contents */
-	type = htons(t);
-	if (s < ETH_ZLEN)
-		s = ETH_ZLEN;
-	tx_cmd[4] = (s + ETH_HLEN) | 0x8000;
-	tx_cmd[6] = TX_BUF_START + 22 + scb_base;
-	bptr = mem_start + TX_BUF_START;
-	memcpy((char *)bptr, (char *)tx_cmd, sizeof(tx_cmd));
-	bptr += sizeof(tx_cmd);
-	memcpy((char *)bptr, d, ETH_ALEN);
-	bptr += ETH_ALEN;
-	memcpy((char *)bptr, nic->node_addr, ETH_ALEN);
-	bptr += ETH_ALEN;
-	memcpy((char *)bptr, (char *)&type, sizeof(type));
-	bptr += sizeof(type);
-	memcpy((char *)bptr, p, s);
-	/* Change the offset in the IDLELOOP */
-	*(unsigned short *)(mem_start + IDLELOOP + 4) = TX_BUF_START;
-	/* Wait for transmit completion */
-	while (
-			(shmem[0] & 0x2000) == 0)
-		;
-	/* Change the offset in the IDLELOOP back and
-	   change the final loop to point here */
-	*(unsigned short *)(mem_start + IDLELOOP + 4) = IDLELOOP;
-	*(unsigned short *)(mem_start + TX_BUF_START + 20) = IDLELOOP;
-	ack_status();
-}
-
-/**************************************************************************
-  DISABLE - Turn off ethernet interface
- ***************************************************************************/
-static void i82586_disable(struct nic *nic)
-{
-	unsigned short	*shmem = (short *)mem_start;
-
-#if	0
-	/* Flush the Tx and disable Rx. */
-	shmem[iSCB_CMD>>1] = RX_SUSPEND | CUC_SUSPEND;
-	outb(0, ioaddr + I82586_ATTN);
-#ifdef	INCLUDE_NI5210
-	outb(0, ioaddr + NI52_RESET);
-#endif
-#endif	/* 0 */
-}
-
-#ifdef	INCLUDE_3C507
-
-static int t507_probe1(struct nic *nic, unsigned short ioaddr)
-{
-	int			i;
-	Address			size;
-	char			mem_config;
-	char			if_port;
-
-	if (inb(ioaddr) != '*' || inb(ioaddr+1) != '3'
-		|| inb(ioaddr+2) != 'C' || inb(ioaddr+3) != 'O')
-		return (0);
-	irq = inb(ioaddr + IRQ_CONFIG) & 0x0f;
-	mem_config = inb(ioaddr + MEM_CONFIG);
-	if (mem_config & 0x20)
-	{
-		size = 65536L;
-		mem_start = 0xf00000L + (mem_config & 0x08 ? 0x080000L
-			: (((Address)mem_config & 0x3) << 17));
-	}
-	else
-	{
-		size = ((((Address)mem_config & 0x3) + 1) << 14);
-		mem_start = 0x0c0000L + (((Address)mem_config & 0x18) << 12);
-	}
-	mem_end = mem_start + size;
-	scb_base = 65536L - size;
-	if_port = inb(ioaddr + ROM_CONFIG) & 0x80;
-	/* Get station address */
-	outb(0x01, ioaddr + MISC_CTRL);
-	for (i = 0; i < ETH_ALEN; ++i)
-	{
-		nic->node_addr[i] = inb(ioaddr+i);
-	}
-	printf("\n3c507 ioaddr %#hX, IRQ %d, mem [%#X-%#X], %sternal xcvr, addr %!\n",
-		ioaddr, irq, mem_start, mem_end, if_port ? "in" : "ex", nic->node_addr);
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-
-struct nic *t507_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static unsigned char	init_ID_done = 0;
-	unsigned short		lrs_state = 0xff;
-	static unsigned short	io_addrs[] = { 0x300, 0x320, 0x340, 0x280, 0 };
-	unsigned short		*p;
-	int			i;
-
-	if (init_ID_done == 0)
-	{
-		/* Send the ID sequence to the ID_PORT to enable the board */
-		outb(0x00, ID_PORT);
-		for (i = 0; i < 255; ++i)
-		{
-			outb(lrs_state, ID_PORT);
-			lrs_state <<= 1;
-			if (lrs_state & 0x100)
-				lrs_state ^= 0xe7;
-		}
-		outb(0x00, ID_PORT);
-		init_ID_done = 1;
-	}
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (t507_probe1(nic, ioaddr))
-			break;
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		i82586_reset(nic);
-		nic->reset = i82586_reset;
-		nic->poll = i82586_poll;
-		nic->transmit = i82586_transmit;
-		nic->disable = i82586_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-
-#endif
-
-#ifdef	INCLUDE_NI5210
-
-static int ni5210_probe2(void)
-{
-	unsigned short		i;
-	unsigned short		shmem[10];
-
-	/* Fix the ISCP address and base. */
-	init_words[3] = scb_base;
-	init_words[7] = scb_base;
-
-	/* Write the words at 0xfff6. */
-	/* Write the words at 0x0000. */
-	memcpy((char *)(mem_end - 10), (char *)init_words, 10);
-	memcpy((char *)mem_start, (char *)&init_words[5], sizeof(init_words) - 10);
-	if (*(unsigned short *)mem_start != 1)
-		return (0);
-	outb(0, ioaddr + NI52_RESET);
-	outb(0, ioaddr + I82586_ATTN);
-	udelay(32);
-	i = 50;
-	while (
-		shmem[iSCB_STATUS>>1] == 0)
-	{
-		if (--i == 0)
-		{
-			printf("i82586 initialisation timed out with status %hX, cmd %hX\n",
-				shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-			break;
-		}
-	}
-	/* Issue channel-attn -- the 82586 won't start. */
-	outb(0, ioaddr + I82586_ATTN);
-	if (*(unsigned short *)mem_start != 0)
-		return (0);
-	return (1);
-}
-
-static int ni5210_probe1(struct nic *nic)
-{
-	int			i;
-	static Address		mem_addrs[] = {
-		0xc0000, 0xc4000, 0xc8000, 0xcc000,
-		0xd0000, 0xd4000, 0xd8000, 0xdc000,
-		0xe0000, 0xe4000, 0xe8000, 0xec000,
-		0 };
-	Address			*p;
-
-	if (inb(ioaddr + 6) != 0x0 || inb(ioaddr + 7) != 0x55)
-		return (0);
-	scb_base = -8192;		/* assume 8k memory */
-	for (p = mem_addrs; (mem_start = *p) != 0; ++p)
-		if (mem_end = mem_start + 8192, ni5210_probe2())
-			break;
-	if (mem_start == 0)
-		return (0);
-	/* Get station address */
-	for (i = 0; i < ETH_ALEN; ++i)
-	{
-		nic->node_addr[i] = inb(ioaddr+i);
-	}
-	printf("\nNI5210 ioaddr %#hX, mem [%#X-%#X], addr %!\n",
-		ioaddr, mem_start, mem_end, nic->node_addr);
-	return (1);
-}
-
-struct nic *ni5210_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	/* missing entries are addresses usually already used */
-	static unsigned short	io_addrs[] = {
-		0x200, 0x208, 0x210, 0x218, 0x220, 0x228, 0x230, 0x238,
-		0x240, 0x248, 0x250, 0x258, 0x260, 0x268, 0x270, /*Par*/
-		0x280, 0x288, 0x290, 0x298, 0x2A0, 0x2A8, 0x2B0, 0x2B8,
-		0x2C0, 0x2C8, 0x2D0, 0x2D8, 0x2E0, 0x2E8, 0x2F0, /*Ser*/
-		0x300, 0x308, 0x310, 0x318, 0x320, 0x328, 0x330, 0x338,
-		0x340, 0x348, 0x350, 0x358, 0x360, 0x368, 0x370, /*Par*/
-		0x380, 0x388, 0x390, 0x398, 0x3A0, 0x3A8, /*Vid,Par*/
-		0x3C0, 0x3C8, 0x3D0, 0x3D8, 0x3E0, 0x3E8, /*Ser*/
-		0x0
-	};
-	unsigned short		*p;
-	int			i;
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (ni5210_probe1(nic))
-			break;
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		i82586_reset(nic);
-		nic->reset = i82586_reset;
-		nic->poll = i82586_poll;
-		nic->transmit = i82586_transmit;
-		nic->disable = i82586_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-#endif
-
-#ifdef	INCLUDE_EXOS205
-
-/*
- * Code to download to I186 in EXOS205
- */
-
-static unsigned char exos_i186_init[] =
-{
-0x08,0x00,0x14,0x00,0x00,0x00,0xaa,0xfa,0x33,0xc0,0xba,0xfe,0xff,0xef,0xb8,0xf8,
-0xff,0xe7,0xa0,0xb8,0x7c,0x00,0xe7,0xa4,0xb8,0xbc,0x80,0xe7,0xa8,0x8c,0xc8,0x8e,
-0xd8,0xbb,0x2f,0x0e,0xc6,0x07,0xa5,0x33,0xc9,0xeb,0x00,0xeb,0x00,0xeb,0x00,0xe2,
-0xf8,0xbe,0x2c,0x0e,0xba,0x02,0x05,0x33,0xdb,0xb9,0x03,0x00,0xec,0x24,0x0f,0x8a,
-0xe0,0x02,0xd8,0x42,0x42,0xec,0x02,0xd8,0xd0,0xe0,0xd0,0xe0,0xd0,0xe0,0xd0,0xe0,
-0x0a,0xc4,0x88,0x04,0x42,0x42,0x46,0xe2,0xe3,0x8a,0xe3,0xd0,0xec,0xd0,0xec,0xd0,
-0xec,0xd0,0xec,0x80,0xe3,0x0f,0x02,0xe3,0x80,0xf4,0x05,0xec,0x3a,0xe0,0x74,0x05,
-0xc6,0x04,0x5a,0xeb,0xfe,0xc6,0x04,0x55,0x33,0xc0,0x8e,0xd8,0xbe,0x38,0x00,0xc7,
-0x04,0xce,0x0e,0x46,0x46,0xc7,0x04,0x00,0xff,0xfb,0xba,0x3c,0x00,0xb8,0x03,0x00,
-0xef,0x33,0xdb,0x33,0xc9,0xbd,0x04,0x0f,0x90,0x90,0x90,0x90,0xe2,0xfa,0x43,0x2e,
-0x89,0x5e,0x00,0xeb,0xf3,0x52,0xba,0x00,0x06,0xef,0x50,0x53,0x55,0xbd,0xf8,0x0e,
-0x2e,0x8b,0x5e,0x00,0x43,0x2e,0x89,0x5e,0x00,0xba,0x22,0x00,0xb8,0x00,0x80,0xef,
-0x5d,0x5b,0x58,0x5a,0xcf,0x49,0x4e,0x54,0x52,0x20,0x63,0x6e,0x74,0x2d,0x3e,0x00,
-0x00,0x4c,0x4f,0x4f,0x50,0x20,0x63,0x6e,0x74,0x2d,0x3e,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xea,0x30,0x0e,0x00,0xff,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,00
-};
-
-/* These offsets are from the end of the i186 download code */
-
-#define	OFFSET_SEMA		0x1D1
-#define	OFFSET_ADDR		0x1D7
-
-static int exos205_probe2(void)
-{
-	unsigned short		i;
-	unsigned short		shmem[10];
-
-	/* Fix the ISCP address and base. */
-	init_words[3] = scb_base;
-	init_words[7] = scb_base;
-
-	/* Write the words at 0xfff6. */
-	/* Write the words at 0x0000. */
-	memcpy((char *)(mem_end - 10), (char *)init_words, 10);
-	memcpy((char *)mem_start, (char *)&init_words[5], sizeof(init_words) - 10);
-	if (*(unsigned short *)mem_start != 1)
-		return (0);
-	outb(0, ioaddr + EXOS205_RESET);
-	outb(0, ioaddr + I82586_ATTN);
-	i = 50;
-	while (
-		shmem[iSCB_STATUS>>1] == 0)
-	{
-		if (--i == 0)
-		{
-			printf("i82586 initialisation timed out with status %hX, cmd %hX\n",
-				shmem[iSCB_STATUS>>1], shmem[iSCB_CMD>>1]);
-			break;
-		}
-	}
-	/* Issue channel-attn -- the 82586 won't start. */
-	outb(0, ioaddr + I82586_ATTN);
-	if (*(unsigned short *)mem_start != 0)
-		return (0);
-	return (1);
-}
-
-static int exos205_probe1(struct nic *nic)
-{
-	int			i;
-	/* If you know the other addresses please let me know */
-	static Address		mem_addrs[] = {
-		0xcc000, 0 };
-	Address			*p;
-
-	scb_base = -16384;		/* assume 8k memory */
-	for (p = mem_addrs; (mem_start = *p) != 0; ++p)
-		if (mem_end = mem_start + 16384, exos205_probe2())
-			break;
-	if (mem_start == 0)
-		return (0);
-	/* Get station address */
-	for (i = 0; i < ETH_ALEN; ++i)
-	{
-		nic->node_addr[i] = inb(ioaddr+i);
-	}
-	printf("\nEXOS205 ioaddr %#hX, mem [%#X-%#X], addr %!\n",
-		ioaddr, mem_start, mem_end, nic->node_addr);
-	return (1);
-}
-
-struct nic *exos205_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	/* If you know the other addresses, please let me know */
-	static unsigned short	io_addrs[] = {
-		0x310, 0x0
-	};
-	unsigned short		*p;
-	int			i;
-
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-		if (exos205_probe1(nic))
-			break;
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		i82586_reset(nic);
-		nic->reset = i82586_reset;
-		nic->poll = i82586_poll;
-		nic->transmit = i82586_transmit;
-		nic->disable = i82586_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-
-#endif
Index: netboot/3c509.h
===================================================================
--- netboot/3c509.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/3c509.h	(.../trunk)	(revision 112)
@@ -1,397 +0,0 @@
-/*
- * Copyright (c) 1993 Herb Peyerl (hpeyerl@novatel.ca) All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met: 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer. 2. The name
- * of the author may not be used to endorse or promote products derived from
- * this software withough specific prior written permission
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
- * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * if_epreg.h,v 1.4 1994/11/13 10:12:37 gibbs Exp Modified by:
- *
- October 2, 1994
-
- Modified by: Andres Vega Garcia
-
- INRIA - Sophia Antipolis, France
- e-mail: avega@sophia.inria.fr
- finger: avega@pax.inria.fr
-
- */
-
-/*
- * Ethernet software status per interface.
- */
-/*
- * Some global constants
- */
-
-#define TX_INIT_RATE		16
-#define TX_INIT_MAX_RATE	64
-#define RX_INIT_LATENCY		64
-#define RX_INIT_EARLY_THRESH	64
-#define MIN_RX_EARLY_THRESHF	16	/* not less than ether_header */
-#define MIN_RX_EARLY_THRESHL	4
-
-#define EEPROMSIZE	0x40
-#define MAX_EEPROMBUSY	1000
-#define EP_LAST_TAG	0xd7
-#define EP_MAX_BOARDS	16
-#define EP_ID_PORT	0x100
-
-/*
- * some macros to acces long named fields
- */
-#define IS_BASE (eth_nic_base)
-#define BASE	(eth_nic_base)
-
-/*
- * Commands to read/write EEPROM trough EEPROM command register (Window 0,
- * Offset 0xa)
- */
-#define EEPROM_CMD_RD	0x0080	/* Read:  Address required (5 bits) */
-#define EEPROM_CMD_WR	0x0040	/* Write: Address required (5 bits) */
-#define EEPROM_CMD_ERASE 0x00c0	/* Erase: Address required (5 bits) */
-#define EEPROM_CMD_EWEN	0x0030	/* Erase/Write Enable: No data required */
-
-#define EEPROM_BUSY		(1<<15)
-#define EEPROM_TST_MODE		(1<<14)
-
-/*
- * Some short functions, worth to let them be a macro
- */
-#define is_eeprom_busy(b) (inw((b)+EP_W0_EEPROM_COMMAND)&EEPROM_BUSY)
-#define GO_WINDOW(x)	outw(WINDOW_SELECT|(x), BASE+EP_COMMAND)
-
-/**************************************************************************
- *
- * These define the EEPROM data structure.  They are used in the probe
- * function to verify the existance of the adapter after having sent
- * the ID_Sequence.
- *
- * There are others but only the ones we use are defined here.
- *
- **************************************************************************/
-
-#define EEPROM_NODE_ADDR_0	0x0	/* Word */
-#define EEPROM_NODE_ADDR_1	0x1	/* Word */
-#define EEPROM_NODE_ADDR_2	0x2	/* Word */
-#define EEPROM_PROD_ID		0x3	/* 0x9[0-f]50 */
-#define EEPROM_MFG_ID		0x7	/* 0x6d50 */
-#define EEPROM_ADDR_CFG		0x8	/* Base addr */
-#define EEPROM_RESOURCE_CFG	0x9	/* IRQ. Bits 12-15 */
-
-/**************************************************************************
- *
- * These are the registers for the 3Com 3c509 and their bit patterns when
- * applicable.  They have been taken out the the "EtherLink III Parallel
- * Tasking EISA and ISA Technical Reference" "Beta Draft 10/30/92" manual
- * from 3com.
- *
- **************************************************************************/
-
-#define EP_COMMAND		0x0e	/* Write. BASE+0x0e is always a
-					 * command reg. */
-#define EP_STATUS		0x0e	/* Read. BASE+0x0e is always status
-					 * reg. */
-#define EP_WINDOW		0x0f	/* Read. BASE+0x0f is always window
-					 * reg. */
-/*
- * Window 0 registers. Setup.
- */
-/* Write */
-#define EP_W0_EEPROM_DATA	0x0c
-#define EP_W0_EEPROM_COMMAND	0x0a
-#define EP_W0_RESOURCE_CFG	0x08
-#define EP_W0_ADDRESS_CFG	0x06
-#define EP_W0_CONFIG_CTRL	0x04
-/* Read */
-#define EP_W0_PRODUCT_ID	0x02
-#define EP_W0_MFG_ID		0x00
-
-/*
- * Window 1 registers. Operating Set.
- */
-/* Write */
-#define EP_W1_TX_PIO_WR_2	0x02
-#define EP_W1_TX_PIO_WR_1	0x00
-/* Read */
-#define EP_W1_FREE_TX		0x0c
-#define EP_W1_TX_STATUS		0x0b	/* byte */
-#define EP_W1_TIMER		0x0a	/* byte */
-#define EP_W1_RX_STATUS		0x08
-#define EP_W1_RX_PIO_RD_2	0x02
-#define EP_W1_RX_PIO_RD_1	0x00
-
-/*
- * Window 2 registers. Station Address Setup/Read
- */
-/* Read/Write */
-#define EP_W2_ADDR_5		0x05
-#define EP_W2_ADDR_4		0x04
-#define EP_W2_ADDR_3		0x03
-#define EP_W2_ADDR_2		0x02
-#define EP_W2_ADDR_1		0x01
-#define EP_W2_ADDR_0		0x00
-
-/*
- * Window 3 registers.  FIFO Management.
- */
-/* Read */
-#define EP_W3_FREE_TX		0x0c
-#define EP_W3_FREE_RX		0x0a
-
-/*
- * Window 4 registers. Diagnostics.
- */
-/* Read/Write */
-#define EP_W4_MEDIA_TYPE	0x0a
-#define EP_W4_CTRLR_STATUS	0x08
-#define EP_W4_NET_DIAG		0x06
-#define EP_W4_FIFO_DIAG		0x04
-#define EP_W4_HOST_DIAG		0x02
-#define EP_W4_TX_DIAG		0x00
-
-/*
- * Window 5 Registers.  Results and Internal status.
- */
-/* Read */
-#define EP_W5_READ_0_MASK	0x0c
-#define EP_W5_INTR_MASK		0x0a
-#define EP_W5_RX_FILTER		0x08
-#define EP_W5_RX_EARLY_THRESH	0x06
-#define EP_W5_TX_AVAIL_THRESH	0x02
-#define EP_W5_TX_START_THRESH	0x00
-
-/*
- * Window 6 registers. Statistics.
- */
-/* Read/Write */
-#define TX_TOTAL_OK		0x0c
-#define RX_TOTAL_OK		0x0a
-#define TX_DEFERRALS		0x08
-#define RX_FRAMES_OK		0x07
-#define TX_FRAMES_OK		0x06
-#define RX_OVERRUNS		0x05
-#define TX_COLLISIONS		0x04
-#define TX_AFTER_1_COLLISION	0x03
-#define TX_AFTER_X_COLLISIONS	0x02
-#define TX_NO_SQE		0x01
-#define TX_CD_LOST		0x00
-
-/****************************************
- *
- * Register definitions.
- *
- ****************************************/
-
-/*
- * Command register. All windows.
- *
- * 16 bit register.
- *     15-11:  5-bit code for command to be executed.
- *     10-0:   11-bit arg if any. For commands with no args;
- *	      this can be set to anything.
- */
-#define GLOBAL_RESET		(unsigned short) 0x0000	/* Wait at least 1ms
-							 * after issuing */
-#define WINDOW_SELECT		(unsigned short) (0x1<<11)
-#define START_TRANSCEIVER	(unsigned short) (0x2<<11)	/* Read ADDR_CFG reg to
-							 * determine whether
-							 * this is needed. If
-							 * so; wait 800 uSec
-							 * before using trans-
-							 * ceiver. */
-#define RX_DISABLE		(unsigned short) (0x3<<11)	/* state disabled on
-							 * power-up */
-#define RX_ENABLE		(unsigned short) (0x4<<11)
-#define RX_RESET		(unsigned short) (0x5<<11)
-#define RX_DISCARD_TOP_PACK	(unsigned short) (0x8<<11)
-#define TX_ENABLE		(unsigned short) (0x9<<11)
-#define TX_DISABLE		(unsigned short) (0xa<<11)
-#define TX_RESET		(unsigned short) (0xb<<11)
-#define REQ_INTR		(unsigned short) (0xc<<11)
-#define SET_INTR_MASK		(unsigned short) (0xe<<11)
-#define SET_RD_0_MASK		(unsigned short) (0xf<<11)
-#define SET_RX_FILTER		(unsigned short) (0x10<<11)
-#define FIL_INDIVIDUAL	(unsigned short) (0x1)
-#define FIL_GROUP		(unsigned short) (0x2)
-#define FIL_BRDCST	(unsigned short) (0x4)
-#define FIL_ALL		(unsigned short) (0x8)
-#define SET_RX_EARLY_THRESH	(unsigned short) (0x11<<11)
-#define SET_TX_AVAIL_THRESH	(unsigned short) (0x12<<11)
-#define SET_TX_START_THRESH	(unsigned short) (0x13<<11)
-#define STATS_ENABLE		(unsigned short) (0x15<<11)
-#define STATS_DISABLE		(unsigned short) (0x16<<11)
-#define STOP_TRANSCEIVER	(unsigned short) (0x17<<11)
-/*
- * The following C_* acknowledge the various interrupts. Some of them don't
- * do anything.  See the manual.
- */
-#define ACK_INTR		(unsigned short) (0x6800)
-#define C_INTR_LATCH	(unsigned short) (ACK_INTR|0x1)
-#define C_CARD_FAILURE	(unsigned short) (ACK_INTR|0x2)
-#define C_TX_COMPLETE	(unsigned short) (ACK_INTR|0x4)
-#define C_TX_AVAIL	(unsigned short) (ACK_INTR|0x8)
-#define C_RX_COMPLETE	(unsigned short) (ACK_INTR|0x10)
-#define C_RX_EARLY	(unsigned short) (ACK_INTR|0x20)
-#define C_INT_RQD		(unsigned short) (ACK_INTR|0x40)
-#define C_UPD_STATS	(unsigned short) (ACK_INTR|0x80)
-
-/*
- * Status register. All windows.
- *
- *     15-13:  Window number(0-7).
- *     12:     Command_in_progress.
- *     11:     reserved.
- *     10:     reserved.
- *     9:      reserved.
- *     8:      reserved.
- *     7:      Update Statistics.
- *     6:      Interrupt Requested.
- *     5:      RX Early.
- *     4:      RX Complete.
- *     3:      TX Available.
- *     2:      TX Complete.
- *     1:      Adapter Failure.
- *     0:      Interrupt Latch.
- */
-#define S_INTR_LATCH		(unsigned short) (0x1)
-#define S_CARD_FAILURE		(unsigned short) (0x2)
-#define S_TX_COMPLETE		(unsigned short) (0x4)
-#define S_TX_AVAIL		(unsigned short) (0x8)
-#define S_RX_COMPLETE		(unsigned short) (0x10)
-#define S_RX_EARLY		(unsigned short) (0x20)
-#define S_INT_RQD		(unsigned short) (0x40)
-#define S_UPD_STATS		(unsigned short) (0x80)
-#define S_5_INTS		(S_CARD_FAILURE|S_TX_COMPLETE|\
-				 S_TX_AVAIL|S_RX_COMPLETE|S_RX_EARLY)
-#define S_COMMAND_IN_PROGRESS	(unsigned short) (0x1000)
-
-/*
- * FIFO Registers.
- * RX Status. Window 1/Port 08
- *
- *     15:     Incomplete or FIFO empty.
- *     14:     1: Error in RX Packet   0: Incomplete or no error.
- *     13-11:  Type of error.
- *	      1000 = Overrun.
- *	      1011 = Run Packet Error.
- *	      1100 = Alignment Error.
- *	      1101 = CRC Error.
- *	      1001 = Oversize Packet Error (>1514 bytes)
- *	      0010 = Dribble Bits.
- *	      (all other error codes, no errors.)
- *
- *     10-0:   RX Bytes (0-1514)
- */
-#define ERR_RX_INCOMPLETE	(unsigned short) (0x1<<15)
-#define ERR_RX			(unsigned short) (0x1<<14)
-#define ERR_RX_OVERRUN		(unsigned short) (0x8<<11)
-#define ERR_RX_RUN_PKT		(unsigned short) (0xb<<11)
-#define ERR_RX_ALIGN		(unsigned short) (0xc<<11)
-#define ERR_RX_CRC		(unsigned short) (0xd<<11)
-#define ERR_RX_OVERSIZE		(unsigned short) (0x9<<11)
-#define ERR_RX_DRIBBLE		(unsigned short) (0x2<<11)
-
-/*
- * FIFO Registers.
- * TX Status. Window 1/Port 0B
- *
- *   Reports the transmit status of a completed transmission. Writing this
- *   register pops the transmit completion stack.
- *
- *   Window 1/Port 0x0b.
- *
- *     7:      Complete
- *     6:      Interrupt on successful transmission requested.
- *     5:      Jabber Error (TP Only, TX Reset required. )
- *     4:      Underrun (TX Reset required. )
- *     3:      Maximum Collisions.
- *     2:      TX Status Overflow.
- *     1-0:    Undefined.
- *
- */
-#define TXS_COMPLETE		0x80
-#define TXS_SUCCES_INTR_REQ		0x40
-#define TXS_JABBER		0x20
-#define TXS_UNDERRUN		0x10
-#define TXS_MAX_COLLISION	0x8
-#define TXS_STATUS_OVERFLOW	0x4
-
-/*
- * Configuration control register.
- * Window 0/Port 04
- */
-/* Read */
-#define IS_AUI				(1<<13)
-#define IS_BNC				(1<<12)
-#define IS_UTP				(1<<9)
-/* Write */
-#define ENABLE_DRQ_IRQ			0x0001
-#define W0_P4_CMD_RESET_ADAPTER		0x4
-#define W0_P4_CMD_ENABLE_ADAPTER	0x1
-/*
- * Media type and status.
- * Window 4/Port 0A
- */
-#define ENABLE_UTP			0xc0
-#define DISABLE_UTP			0x0
-
-/*
- * Resource control register
- */
-
-#define SET_IRQ(i)	( ((i)<<12) | 0xF00) /* set IRQ i */
-
-/*
- * Receive status register
- */
-
-#define RX_BYTES_MASK			(unsigned short) (0x07ff)
-#define RX_ERROR	0x4000
-#define RX_INCOMPLETE	0x8000
-
-
-/*
- * Misc defines for various things.
- */
-#define ACTIVATE_ADAPTER_TO_CONFIG	0xff /* to the id_port */
-#define MFG_ID				0x6d50 /* in EEPROM and W0 ADDR_CONFIG */
-#define PROD_ID				0x9150
-
-#define AUI				0x1
-#define BNC				0x2
-#define UTP				0x4
-
-#define RX_BYTES_MASK			(unsigned short) (0x07ff)
-
- /* EISA support */
-#define EP_EISA_START			0x1000
-#define EP_EISA_W0			0x0c80
-
-#ifdef	INCLUDE_3C529
- /* MCA support */
-#define MCA_MOTHERBOARD_SETUP_REG	0x94
-#define MCA_ADAPTER_SETUP_REG		0x96
-#define MCA_MAX_SLOT_NR			8
-#define MCA_POS_REG(n)			(0x100+(n))
-#endif
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
Index: netboot/fa311.c
===================================================================
--- netboot/fa311.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/fa311.c	(.../trunk)	(revision 112)
@@ -1,421 +0,0 @@
-/*
-        Driver for the National Semiconductor DP83810 Ethernet controller.
-        
-        Portions Copyright (C) 2001 Inprimis Technologies, Inc.
-        http://www.inprimis.com/
-        
-        This driver is based (heavily) on the Linux driver for this chip 
-        which is copyright 1999-2001 by Donald Becker.
-
-        This software has no warranties expressed or implied for any
-        purpose.
-
-        This software may be used and distributed according to the terms of
-        the GNU General Public License (GPL), incorporated herein by reference.
-        Drivers based on or derived from this code fall under the GPL and must
-        retain the authorship, copyright and license notice.  This file is not
-        a complete program and may only be used when the entire operating
-        system is licensed under the GPL.  License for under other terms may be
-        available.  Contact the original author for details.
-
-        The original author may be reached as becker@scyld.com, or at
-        Scyld Computing Corporation
-        410 Severn Ave., Suite 210
-        Annapolis MD 21403
-*/
-
-
-typedef unsigned char  u8;
-typedef   signed char  s8;
-typedef unsigned short u16;
-typedef   signed short s16;
-typedef unsigned int   u32;
-typedef   signed int   s32;
-
-#include "etherboot.h"
-#include "nic.h"
-#include "pci.h"
-
-#undef	virt_to_bus
-#define	virt_to_bus(x)          ((unsigned long)x)
-#define cpu_to_le32(val)        (val)
-#define le32_to_cpu(val)        (val)
-#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
-#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
-
-#define TX_RING_SIZE 1
-#define RX_RING_SIZE 4
-#define TIME_OUT     1000000
-#define PKT_BUF_SZ   1536
-
-/* Offsets to the device registers. */
-enum register_offsets {
-    ChipCmd=0x00, ChipConfig=0x04, EECtrl=0x08, PCIBusCfg=0x0C,
-    IntrStatus=0x10, IntrMask=0x14, IntrEnable=0x18,
-    TxRingPtr=0x20, TxConfig=0x24,
-    RxRingPtr=0x30, RxConfig=0x34,
-    WOLCmd=0x40, PauseCmd=0x44, RxFilterAddr=0x48, RxFilterData=0x4C,
-    BootRomAddr=0x50, BootRomData=0x54, StatsCtrl=0x5C, StatsData=0x60,
-    RxPktErrs=0x60, RxMissed=0x68, RxCRCErrs=0x64,
-};
-
-/* Bit in ChipCmd. */
-enum ChipCmdBits {
-    ChipReset=0x100, RxReset=0x20, TxReset=0x10, RxOff=0x08, RxOn=0x04,
-    TxOff=0x02, TxOn=0x01,
-};
-
-/* Bits in the interrupt status/mask registers. */
-enum intr_status_bits {
-    IntrRxDone=0x0001, IntrRxIntr=0x0002, IntrRxErr=0x0004, IntrRxEarly=0x0008,
-    IntrRxIdle=0x0010, IntrRxOverrun=0x0020,
-    IntrTxDone=0x0040, IntrTxIntr=0x0080, IntrTxErr=0x0100,
-    IntrTxIdle=0x0200, IntrTxUnderrun=0x0400,
-    StatsMax=0x0800, LinkChange=0x4000,	WOLPkt=0x2000,
-    RxResetDone=0x1000000, TxResetDone=0x2000000,
-    IntrPCIErr=0x00f00000, IntrNormalSummary=0x0251, IntrAbnormalSummary=0xED20,
-};
-
-/* Bits in the RxMode register. */
-enum rx_mode_bits {
-    AcceptErr=0x20, AcceptRunt=0x10, AcceptBroadcast=0xC0000000,
-    AcceptMulticast=0x00200000, AcceptAllMulticast=0x20000000,
-    AcceptAllPhys=0x10000000, AcceptMyPhys=0x08000000,
-};
-
-/* Bits in network_desc.status */
-enum desc_status_bits {
-    DescOwn=0x80000000, DescMore=0x40000000, DescIntr=0x20000000,
-    DescNoCRC=0x10000000,
-    DescPktOK=0x08000000, RxTooLong=0x00400000,
-};
-
-/* The Rx and Tx buffer descriptors. */
-struct netdev_desc {
-    u32 next_desc;
-    s32 cmd_status;
-    u32 addr;
-};
-
-static struct FA311_DEV {
-    unsigned int    ioaddr;
-    unsigned short  vendor;
-    unsigned short  device;
-    unsigned int    cur_rx;
-    unsigned int    cur_tx;
-    unsigned int    rx_buf_sz;
-    volatile struct netdev_desc *rx_head_desc;
-    volatile struct netdev_desc rx_ring[RX_RING_SIZE] __attribute__ ((aligned (4)));
-    volatile struct netdev_desc tx_ring[TX_RING_SIZE] __attribute__ ((aligned (4)));
-} fa311_dev;
-
-static int  eeprom_read(long ioaddr, int location);
-static void init_ring(struct FA311_DEV *dev);
-static void fa311_reset(struct nic *nic);
-static int  fa311_poll(struct nic *nic);
-static void fa311_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p);
-static void fa311_disable(struct nic *nic);
-
-static char rx_packet[PKT_BUF_SZ * RX_RING_SIZE] __attribute__ ((aligned (4)));
-static char tx_packet[PKT_BUF_SZ * TX_RING_SIZE] __attribute__ ((aligned (4)));
-
-struct nic * fa311_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
-{
-int            prev_eedata;
-int            i;
-int            duplex;
-int            tx_config;
-int            rx_config;
-unsigned char  macaddr[6];
-unsigned char  mactest;
-unsigned char  pci_bus = 0;
-struct FA311_DEV* dev = &fa311_dev;
-	
-    if (io_addrs == 0 || *io_addrs == 0)
-        return (0);
-    memset(dev, 0, sizeof(*dev));
-    dev->vendor = pci->vendor;
-    dev->device = pci->dev_id;
-    dev->ioaddr = pci->membase;
-
-    /* Work around the dropped serial bit. */
-    prev_eedata = eeprom_read(dev->ioaddr, 6);
-    for (i = 0; i < 3; i++) {
-        int eedata = eeprom_read(dev->ioaddr, i + 7);
-        macaddr[i*2] = (eedata << 1) + (prev_eedata >> 15);
-        macaddr[i*2+1] = eedata >> 7;
-        prev_eedata = eedata;
-    }
-    mactest = 0;
-    for (i = 0; i < 6; i++)
-        mactest |= macaddr[i];
-    if (mactest == 0)
-        return (0);
-    for (i = 0; i < 6; i++)
-        nic->node_addr[i] = macaddr[i];
-    printf("%! ", nic->node_addr);
-
-    adjust_pci_device(pci);
-
-    fa311_reset(nic);
-
-    nic->reset = fa311_reset;
-    nic->disable = fa311_disable;
-    nic->poll = fa311_poll;
-    nic->transmit = fa311_transmit;
-
-    init_ring(dev);
-
-    writel(virt_to_bus(dev->rx_ring), dev->ioaddr + RxRingPtr);
-    writel(virt_to_bus(dev->tx_ring), dev->ioaddr + TxRingPtr);
-
-    for (i = 0; i < 6; i += 2)
-    {
-        writel(i, dev->ioaddr + RxFilterAddr);
-        writew(macaddr[i] + (macaddr[i+1] << 8),
-               dev->ioaddr + RxFilterData);
-    }
-
-    /* Initialize other registers. */
-    /* Configure for standard, in-spec Ethernet. */
-    if (readl(dev->ioaddr + ChipConfig) & 0x20000000)
-    {    /* Full duplex */
-        tx_config = 0xD0801002;
-        rx_config = 0x10000020;
-    }
-    else
-    {
-        tx_config = 0x10801002;
-        rx_config = 0x0020;
-    }
-    writel(tx_config, dev->ioaddr + TxConfig);
-    writel(rx_config, dev->ioaddr + RxConfig);
-
-    duplex = readl(dev->ioaddr + ChipConfig) & 0x20000000 ? 1 : 0;
-    if (duplex) {
-        rx_config |= 0x10000000;
-        tx_config |= 0xC0000000;
-    } else {
-        rx_config &= ~0x10000000;
-        tx_config &= ~0xC0000000;
-    }
-    writew(tx_config, dev->ioaddr + TxConfig);
-    writew(rx_config, dev->ioaddr + RxConfig);
-
-    writel(AcceptBroadcast | AcceptAllMulticast | AcceptMyPhys, 
-           dev->ioaddr + RxFilterAddr);
-
-    writel(RxOn | TxOn, dev->ioaddr + ChipCmd);
-    writel(4, dev->ioaddr + StatsCtrl);              /* Clear Stats */
-    return nic;	
-
-}
-
-static void fa311_reset(struct nic *nic)
-{
-u32 chip_config;
-struct FA311_DEV* dev = &fa311_dev;
-
-    /* Reset the chip to erase previous misconfiguration. */
-    outl(ChipReset, dev->ioaddr + ChipCmd);
-
-    if ((readl(dev->ioaddr + ChipConfig) & 0xe000) != 0xe000)
-    {
-        chip_config = readl(dev->ioaddr + ChipConfig);
-    }
-}
-
-static int fa311_poll(struct nic *nic)
-{
-s32 desc_status;
-int to;
-int entry;
-int retcode;
-struct FA311_DEV* dev = &fa311_dev;
-
-    retcode = 0;
-    entry = dev->cur_rx;
-    to = TIME_OUT;
-    while (to != 0)
-    {
-        desc_status = dev->rx_ring[entry].cmd_status;
-        if ((desc_status & DescOwn) != 0)
-            break;
-        else
-            --to;
-    }
-    if (to != 0)
-    {
-        readl(dev->ioaddr + IntrStatus);         /* clear interrrupt bits */
-        /* driver owns the next entry it's a new packet. Send it up. */
-        if ((desc_status & (DescMore|DescPktOK|RxTooLong)) == DescPktOK)
-        {
-            nic->packetlen = (desc_status & 0x0fff) - 4;    /* Omit CRC size. */
-            memcpy(nic->packet, (char*)(dev->rx_ring[entry].addr), nic->packetlen);
-            retcode = 1;
-        }
-        /* Give the descriptor back to the chip */
-        dev->rx_ring[entry].cmd_status = cpu_to_le32(dev->rx_buf_sz);
-        dev->cur_rx++;
-        if (dev->cur_rx >= RX_RING_SIZE)
-            dev->cur_rx = 0;
-        dev->rx_head_desc = &dev->rx_ring[dev->cur_rx];
-    }
-    /* Restart Rx engine if stopped. */
-    writel(RxOn, dev->ioaddr + ChipCmd);
-    return retcode;
-}
-
-static void fa311_transmit(struct nic *nic, const char *destaddr, unsigned int type, unsigned int len, const char *data)
-{
-unsigned short nstype;
-s32            desc_status;
-int            to;
-int            entry;
-char*          txp;
-unsigned char* s;
-struct FA311_DEV* dev = &fa311_dev;
-
-    /* Calculate the next Tx descriptor entry. */
-    entry = dev->cur_tx;
-    txp = (char*)(dev->tx_ring[entry].addr);
-
-    memcpy(txp, destaddr, ETH_ALEN);
-    memcpy(txp + ETH_ALEN, nic->node_addr, ETH_ALEN);
-    nstype = htons(type);
-    memcpy(txp + 12, (char*)&nstype, 2);
-    memcpy(txp + ETH_HLEN, data, len);
-    len += ETH_HLEN;
-    /* pad frame */
-    if (len <  ETH_ZLEN)
-    {
-        s = (unsigned char*)(txp+len);
-        while (s < (unsigned char*)(txp+ETH_ZLEN))
-            *s++ = 0;
-        len = ETH_ZLEN;
-    }
-    dev->tx_ring[entry].cmd_status = cpu_to_le32(DescOwn | len);
-    dev->cur_tx++;
-    if (dev->cur_tx >= TX_RING_SIZE)
-        dev->cur_tx = 0;
-
-    /* Wake the potentially-idle transmit channel. */
-    writel(TxOn, dev->ioaddr + ChipCmd);
-
-    /* wait for tranmission to complete */
-    to = TIME_OUT;
-    while (to != 0)
-    {
-        desc_status = dev->tx_ring[entry].cmd_status;
-        if ((desc_status & DescOwn) == 0)
-            break;
-        else
-            --to;
-    }
-
-    readl(dev->ioaddr + IntrStatus);         /* clear interrrupt bits */
-    return;
-}
-
-static void fa311_disable(struct nic *nic)
-{
-struct FA311_DEV* dev = &fa311_dev;
-
-    /* Stop the chip's Tx and Rx processes. */
-    writel(RxOff | TxOff, dev->ioaddr + ChipCmd);
-}
-
-
-/* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.
-   The EEPROM code is for the common 93c06/46 EEPROMs with 6 bit addresses. */
-
-/* Delay between EEPROM clock transitions.
-   No extra delay is needed with 33Mhz PCI, but future 66Mhz access may need
-   a delay.  Note that pre-2.0.34 kernels had a cache-alignment bug that
-   made udelay() unreliable.
-   The old method of using an ISA access as a delay, __SLOW_DOWN_IO__, is
-   depricated.
-*/
-#define eeprom_delay(ee_addr)	inl(ee_addr)
-
-enum EEPROM_Ctrl_Bits {
-	EE_ShiftClk=0x04, EE_DataIn=0x01, EE_ChipSelect=0x08, EE_DataOut=0x02,
-};
-#define EE_Write0 (EE_ChipSelect)
-#define EE_Write1 (EE_ChipSelect | EE_DataIn)
-
-/* The EEPROM commands include the alway-set leading bit. */
-enum EEPROM_Cmds {
-	EE_WriteCmd=(5 << 6), EE_ReadCmd=(6 << 6), EE_EraseCmd=(7 << 6),
-};
-
-
-static int eeprom_read(long addr, int location)
-{
-	int i;
-	int retval = 0;
-	int ee_addr = addr + EECtrl;
-	int read_cmd = location | EE_ReadCmd;
-	writel(EE_Write0, ee_addr);
-
-	/* Shift the read command bits out. */
-	for (i = 10; i >= 0; i--) {
-		short dataval = (read_cmd & (1 << i)) ? EE_Write1 : EE_Write0;
-		writel(dataval, ee_addr);
-		eeprom_delay(ee_addr);
-		writel(dataval | EE_ShiftClk, ee_addr);
-		eeprom_delay(ee_addr);
-	}
-	writel(EE_ChipSelect, ee_addr);
-	eeprom_delay(ee_addr);
-
-	for (i = 0; i < 16; i++) {
-		writel(EE_ChipSelect | EE_ShiftClk, ee_addr);
-		eeprom_delay(ee_addr);
-		retval |= (readl(ee_addr) & EE_DataOut) ? 1 << i : 0;
-		writel(EE_ChipSelect, ee_addr);
-		eeprom_delay(ee_addr);
-	}
-
-	/* Terminate the EEPROM access. */
-	writel(EE_Write0, ee_addr);
-	writel(0, ee_addr);
-	return retval;
-}
-
-/* Initialize the Rx and Tx rings, along with various 'dev' bits. */
-static void init_ring(struct FA311_DEV *dev)
-{
-	int i;
-
-	dev->cur_rx = 0;
-    dev->cur_tx = 0;
-
-	dev->rx_buf_sz = PKT_BUF_SZ;
-	dev->rx_head_desc = &dev->rx_ring[0];
-
-	/* Initialize all Rx descriptors. */
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		dev->rx_ring[i].next_desc = virt_to_le32desc(&dev->rx_ring[i+1]);
-		dev->rx_ring[i].cmd_status = DescOwn;
-	}
-	/* Mark the last entry as wrapping the ring. */
-	dev->rx_ring[i-1].next_desc = virt_to_le32desc(&dev->rx_ring[0]);
-
-	/* Fill in the Rx buffers.  Handle allocation failure gracefully. */
-	for (i = 0; i < RX_RING_SIZE; i++) {
-		dev->rx_ring[i].addr = (u32)(&rx_packet[PKT_BUF_SZ * i]);
-	    dev->rx_ring[i].cmd_status = cpu_to_le32(dev->rx_buf_sz);
-	}
-
-	for (i = 0; i < TX_RING_SIZE; i++) {
-		dev->tx_ring[i].next_desc = virt_to_le32desc(&dev->tx_ring[i+1]);
-		dev->tx_ring[i].cmd_status = 0;
-	}
-	dev->tx_ring[i-1].next_desc = virt_to_le32desc(&dev->tx_ring[0]);
-
-	for (i = 0; i < TX_RING_SIZE; i++)
-		dev->tx_ring[i].addr = (u32)(&tx_packet[PKT_BUF_SZ * i]);
-	return;
-}
-
Index: netboot/ni5010.c
===================================================================
--- netboot/ni5010.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/ni5010.c	(.../trunk)	(revision 112)
@@ -1,371 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-Driver for NI5010.
-Code freely taken from Jan-Pascal van Best and Andreas Mohr's
-Linux NI5010 driver.
-***************************************************************************/
-
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-/* to get our own prototype */
-#include "cards.h"
-
-/* ni5010.h file included verbatim */
-/*
- * Racal-Interlan ni5010 Ethernet definitions
- *
- * This is an extension to the Linux operating system, and is covered by the
- * same Gnu Public License that covers that work.
- *
- * copyrights (c) 1996 by Jan-Pascal van Best (jvbest@wi.leidenuniv.nl)
- *
- * I have done a look in the following sources:
- *   crynwr-packet-driver by Russ Nelson
- */
-
-#define NI5010_BUFSIZE	2048	/* number of bytes in a buffer */
-
-#define NI5010_MAGICVAL0 0x00  /* magic-values for ni5010 card */
-#define NI5010_MAGICVAL1 0x55
-#define NI5010_MAGICVAL2 0xAA
-
-#define SA_ADDR0 0x02
-#define SA_ADDR1 0x07
-#define SA_ADDR2 0x01
-
-/* The number of low I/O ports used by the ni5010 ethercard. */
-#define NI5010_IO_EXTENT       32
-
-#define PRINTK(x) if (NI5010_DEBUG) printk x
-#define PRINTK2(x) if (NI5010_DEBUG>=2) printk x
-#define PRINTK3(x) if (NI5010_DEBUG>=3) printk x
-
-/* The various IE command registers */
-#define EDLC_XSTAT	(ioaddr + 0x00)	/* EDLC transmit csr */
-#define EDLC_XCLR	(ioaddr + 0x00)	/* EDLC transmit "Clear IRQ" */
-#define EDLC_XMASK	(ioaddr + 0x01)	/* EDLC transmit "IRQ Masks" */
-#define EDLC_RSTAT	(ioaddr + 0x02)	/* EDLC receive csr */
-#define EDLC_RCLR	(ioaddr + 0x02)	/* EDLC receive "Clear IRQ" */
-#define EDLC_RMASK	(ioaddr + 0x03)	/* EDLC receive "IRQ Masks" */
-#define EDLC_XMODE	(ioaddr + 0x04)	/* EDLC transmit Mode */
-#define EDLC_RMODE	(ioaddr + 0x05)	/* EDLC receive Mode */
-#define EDLC_RESET	(ioaddr + 0x06)	/* EDLC RESET register */
-#define EDLC_TDR1	(ioaddr + 0x07)	/* "Time Domain Reflectometry" reg1 */
-#define EDLC_ADDR	(ioaddr + 0x08)	/* EDLC station address, 6 bytes */
-	 			/* 0x0E doesn't exist for r/w */
-#define EDLC_TDR2	(ioaddr + 0x0f)	/* "Time Domain Reflectometry" reg2 */
-#define IE_GP		(ioaddr + 0x10)	/* GP pointer (word register) */
-				/* 0x11 is 2nd byte of GP Pointer */
-#define IE_RCNT		(ioaddr + 0x10)	/* Count of bytes in rcv'd packet */
- 				/* 0x11 is 2nd byte of "Byte Count" */
-#define IE_MMODE	(ioaddr + 0x12)	/* Memory Mode register */
-#define IE_DMA_RST	(ioaddr + 0x13)	/* IE DMA Reset.  write only */
-#define IE_ISTAT	(ioaddr + 0x13)	/* IE Interrupt Status.  read only */
-#define IE_RBUF		(ioaddr + 0x14)	/* IE Receive Buffer port */
-#define IE_XBUF		(ioaddr + 0x15)	/* IE Transmit Buffer port */
-#define IE_SAPROM	(ioaddr + 0x16)	/* window on station addr prom */
-#define IE_RESET	(ioaddr + 0x17)	/* any write causes Board Reset */
-
-/* bits in EDLC_XSTAT, interrupt clear on write, status when read */
-#define XS_TPOK		0x80	/* transmit packet successful */
-#define XS_CS		0x40	/* carrier sense */
-#define XS_RCVD		0x20	/* transmitted packet received */
-#define XS_SHORT	0x10	/* transmission media is shorted */
-#define XS_UFLW		0x08	/* underflow.  iff failed board */
-#define XS_COLL		0x04	/* collision occurred */
-#define XS_16COLL	0x02	/* 16th collision occurred */
-#define XS_PERR		0x01	/* parity error */
-
-#define XS_CLR_UFLW	0x08	/* clear underflow */
-#define XS_CLR_COLL	0x04	/* clear collision */
-#define XS_CLR_16COLL	0x02	/* clear 16th collision */
-#define XS_CLR_PERR	0x01	/* clear parity error */
-
-/* bits in EDLC_XMASK, mask/enable transmit interrupts.  register is r/w */
-#define XM_TPOK		0x80	/* =1 to enable Xmt Pkt OK interrupts */
-#define XM_RCVD		0x20	/* =1 to enable Xmt Pkt Rcvd ints */
-#define XM_UFLW		0x08	/* =1 to enable Xmt Underflow ints */
-#define XM_COLL		0x04	/* =1 to enable Xmt Collision ints */
-#define XM_COLL16	0x02	/* =1 to enable Xmt 16th Coll ints */
-#define XM_PERR		0x01	/* =1 to enable Xmt Parity Error ints */
- 				/* note: always clear this bit */
-#define XM_ALL		(XM_TPOK | XM_RCVD | XM_UFLW | XM_COLL | XM_COLL16)
-
-/* bits in EDLC_RSTAT, interrupt clear on write, status when read */
-#define RS_PKT_OK	0x80	/* received good packet */
-#define RS_RST_PKT	0x10	/* RESET packet received */
-#define RS_RUNT		0x08	/* Runt Pkt rcvd.  Len < 64 Bytes */
-#define RS_ALIGN	0x04	/* Alignment error. not 8 bit aligned */
-#define RS_CRC_ERR	0x02	/* Bad CRC on rcvd pkt */
-#define RS_OFLW		0x01	/* overflow for rcv FIFO */
-#define RS_VALID_BITS	( RS_PKT_OK | RS_RST_PKT | RS_RUNT | RS_ALIGN | RS_CRC_ERR | RS_OFLW )
- 				/* all valid RSTAT bits */
-
-#define RS_CLR_PKT_OK	0x80	/* clear rcvd packet interrupt */
-#define RS_CLR_RST_PKT	0x10	/* clear RESET packet received */
-#define RS_CLR_RUNT	0x08	/* clear Runt Pckt received */
-#define RS_CLR_ALIGN	0x04	/* clear Alignment error */
-#define RS_CLR_CRC_ERR	0x02	/* clear CRC error */
-#define RS_CLR_OFLW	0x01	/* clear rcv FIFO Overflow */
-
-/* bits in EDLC_RMASK, mask/enable receive interrupts.  register is r/w */
-#define RM_PKT_OK	0x80	/* =1 to enable rcvd good packet ints */
-#define RM_RST_PKT	0x10	/* =1 to enable RESET packet ints */
-#define RM_RUNT		0x08	/* =1 to enable Runt Pkt rcvd ints */
-#define RM_ALIGN	0x04	/* =1 to enable Alignment error ints */
-#define RM_CRC_ERR	0x02	/* =1 to enable Bad CRC error ints */
-#define RM_OFLW		0x01	/* =1 to enable overflow error ints */
-
-/* bits in EDLC_RMODE, set Receive Packet mode.  register is r/w */
-#define RMD_TEST	0x80	/* =1 for Chip testing.  normally 0 */
-#define RMD_ADD_SIZ	0x10	/* =1 5-byte addr match.  normally 0 */
-#define RMD_EN_RUNT	0x08	/* =1 enable runt rcv.  normally 0 */
-#define RMD_EN_RST	0x04	/* =1 to rcv RESET pkt.  normally 0 */
-
-#define RMD_PROMISC	0x03	/* receive *all* packets.  unusual */
-#define RMD_MULTICAST	0x02	/* receive multicasts too.  unusual */
-#define RMD_BROADCAST	0x01	/* receive broadcasts & normal. usual */
-#define RMD_NO_PACKETS	0x00	/* don't receive any packets. unusual */
-
-/* bits in EDLC_XMODE, set Transmit Packet mode.  register is r/w */
-#define XMD_COLL_CNT	0xf0	/* coll's since success.  read-only */
-#define XMD_IG_PAR	0x08	/* =1 to ignore parity.  ALWAYS set */
-#define XMD_T_MODE	0x04	/* =1 to power xcvr. ALWAYS set this */
-#define XMD_LBC		0x02	/* =1 for loopback.  normally set */
-#define XMD_DIS_C	0x01	/* =1 disables contention. normally 0 */
-
-/* bits in EDLC_RESET, write only */
-#define RS_RESET	0x80	/* =1 to hold EDLC in reset state */
-
-/* bits in IE_MMODE, write only */
-#define MM_EN_DMA	0x80	/* =1 begin DMA xfer, Cplt clrs it */
-#define MM_EN_RCV	0x40	/* =1 allows Pkt rcv.  clr'd by rcv */
-#define MM_EN_XMT	0x20	/* =1 begin Xmt pkt.  Cplt clrs it */
-#define MM_BUS_PAGE	0x18	/* =00 ALWAYS.  Used when MUX=1 */
-#define MM_NET_PAGE	0x06	/* =00 ALWAYS.  Used when MUX=0 */
-#define MM_MUX		0x01	/* =1 means Rcv Buff on system bus */
-				/* =0 means Xmt Buff on system bus */
-
-/* bits in IE_ISTAT, read only */
-#define IS_TDIAG	0x80	/* =1 if Diagnostic problem */
-#define IS_EN_RCV	0x20	/* =1 until frame is rcv'd cplt */
-#define IS_EN_XMT	0x10	/* =1 until frame is xmt'd cplt */
-#define IS_EN_DMA	0x08	/* =1 until DMA is cplt or aborted */
-#define IS_DMA_INT	0x04	/* =0 iff DMA done interrupt. */
-#define IS_R_INT	0x02	/* =0 iff unmasked Rcv interrupt */
-#define IS_X_INT	0x01	/* =0 iff unmasked Xmt interrupt */
-
-/* NIC specific static variables go here */
-
-static unsigned short		ioaddr = 0;
-static unsigned int		bufsize_rcv = 0;
-
-#if	0
-static void show_registers(void)
-{
-	printf("XSTAT %hhX ", inb(EDLC_XSTAT));
-	printf("XMASK %hhX ", inb(EDLC_XMASK));
-	printf("RSTAT %hhX ", inb(EDLC_RSTAT));
-	printf("RMASK %hhX ", inb(EDLC_RMASK));
-	printf("RMODE %hhX ", inb(EDLC_RMODE));
-	printf("XMODE %hhX ", inb(EDLC_XMODE));
-	printf("ISTAT %hhX\n", inb(IE_ISTAT));
-}
-#endif
-
-static void reset_receiver(void)
-{
-	outw(0, IE_GP);		/* Receive packet at start of buffer */
-	outb(RS_VALID_BITS, EDLC_RCLR);	/* Clear all pending Rcv interrupts */
-	outb(MM_EN_RCV, IE_MMODE); /* Enable rcv */
-}
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void ni5010_reset(struct nic *nic)
-{
-	int		i;
-
-	/* Reset the hardware here.  Don't forget to set the station address. */
-	outb(RS_RESET, EDLC_RESET);	/* Hold up EDLC_RESET while configing board */
-	outb(0, IE_RESET);	/* Hardware reset of ni5010 board */
-	outb(0, EDLC_XMASK);	/* Disable all Xmt interrupts */
-	outb(0, EDLC_RMASK);	/* Disable all Rcv interrupt */
-	outb(0xFF, EDLC_XCLR);	/* Clear all pending Xmt interrupts */
-	outb(0xFF, EDLC_RCLR);	/* Clear all pending Rcv interrupts */
-	outb(XMD_LBC, EDLC_XMODE);	/* Only loopback xmits */
-	/* Set the station address */
-	for(i = 0; i < ETH_ALEN; i++)
-		outb(nic->node_addr[i], EDLC_ADDR + i);
-	outb(XMD_IG_PAR | XMD_T_MODE | XMD_LBC, EDLC_XMODE); 
-				/* Normal packet xmit mode */
-	outb(RMD_BROADCAST, EDLC_RMODE);
-				/* Receive broadcast and normal packets */
-	reset_receiver();
-	outb(0x00, EDLC_RESET);	/* Un-reset the ni5010 */
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int ni5010_poll(struct nic *nic)
-{
-	int		rcv_stat;
-
-	if (((rcv_stat = inb(EDLC_RSTAT)) & RS_VALID_BITS) != RS_PKT_OK) {
-		outb(rcv_stat, EDLC_RSTAT);	/* Clear the status */
-		return (0);
-	}
-        outb(rcv_stat, EDLC_RCLR);	/* Clear the status */
-	nic->packetlen = inw(IE_RCNT);
-	/* Read packet into buffer */
-        outb(MM_MUX, IE_MMODE);	/* Rcv buffer to system bus */
-	outw(0, IE_GP);		/* Seek to beginning of packet */
-	insb(IE_RBUF, nic->packet, nic->packetlen); 
-	return (1);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void ni5010_transmit(struct nic *nic,
-	const char *d,	/* Destination */
-	unsigned int t,	/* Type */
-	unsigned int s,	/* size */
-	const char *p)	/* Packet */
-{
-	unsigned int	len;
-	int		buf_offs, xmt_stat;
-	unsigned long	time;
-
-	len = s + ETH_HLEN;
-	if (len < ETH_ZLEN)
-		len = ETH_ZLEN;
-	buf_offs = NI5010_BUFSIZE - len;
-	outb(0, EDLC_RMASK);	/* Mask all receive interrupts */
-	outb(0, IE_MMODE);	/* Put Xmit buffer on system bus */
-	outb(0xFF, EDLC_RCLR);	/* Clear out pending rcv interrupts */
-	outw(buf_offs, IE_GP);	/* Point GP at start of packet */
-	outsb(IE_XBUF, d, ETH_ALEN);	/* Put dst in buffer */
-	outsb(IE_XBUF, nic->node_addr, ETH_ALEN);/* Put src in buffer */
-	outb(t >> 8, IE_XBUF);
-	outb(t, IE_XBUF);
-	outsb(IE_XBUF, p, s);	/* Put data in buffer */
-	while (s++ < ETH_ZLEN - ETH_HLEN)	/* Pad to min size */
-		outb(0, IE_XBUF);
-	outw(buf_offs, IE_GP);	/* Rewrite where packet starts */
-	/* should work without that outb() (Crynwr used it) */
-	/*outb(MM_MUX, IE_MMODE);*/
-	/* Xmt buffer to EDLC bus */
-	outb(MM_EN_XMT | MM_MUX, IE_MMODE);	/* Begin transmission */
-	/* wait for transmit complete */
-	while (((xmt_stat = inb(IE_ISTAT)) & IS_EN_XMT) != 0)
-		;
-	reset_receiver();	/* Immediately switch to receive */
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void ni5010_disable(struct nic *nic)
-{
-	outb(0, IE_MMODE);
-	outb(RS_RESET, EDLC_RESET);
-}
-
-static inline int rd_port(void)
-{
-	inb(IE_RBUF);
-	return inb(IE_SAPROM);
-}
-
-static int ni5010_probe1(struct nic *nic)
-{
-	int		i, boguscount = 40, data;
-
-	/* The tests are from the Linux NI5010 driver
-	   I don't understand it all, but if it works for them...  */
-	if (inb(ioaddr) == 0xFF)
-		return (0);
-	while ((rd_port() & rd_port() & rd_port()
-		& rd_port() & rd_port() & rd_port()) != 0xFF)
-	{
-		if (boguscount-- <= 0)
-			return (0);
-	}
-	for (i = 0; i < 32; i++)
-		if ((data = rd_port()) != 0xFF)
-			break;
-	if (data == 0xFF)
-		return (0);
-	if (data == SA_ADDR0 && rd_port() == SA_ADDR1 && rd_port() == SA_ADDR2) {
-		for (i = 0; i < 4; i++)
-			rd_port();
-		if (rd_port() != NI5010_MAGICVAL1 || rd_port() != NI5010_MAGICVAL2)
-			return (0);
-	} else
-		return (0);
-	for (i = 0; i < ETH_ALEN; i++) {
-		outw(i, IE_GP);
-		nic->node_addr[i] = inb(IE_SAPROM);
-	}
-	printf("\nNI5010 ioaddr %#hX, addr %!\n", ioaddr, nic->node_addr);
-/* get the size of the onboard receive buffer
- * higher addresses than bufsize are wrapped into real buffer
- * i.e. data for offs. 0x801 is written to 0x1 with a 2K onboard buffer
- */
-	if (bufsize_rcv == 0) {
-        	outb(1, IE_MMODE);      /* Put Rcv buffer on system bus */
-        	outw(0, IE_GP);		/* Point GP at start of packet */
-        	outb(0, IE_RBUF);	/* set buffer byte 0 to 0 */
-        	for (i = 1; i < 0xFF; i++) {
-                	outw(i << 8, IE_GP); /* Point GP at packet size to be tested */
-                	outb(i, IE_RBUF);
-                	outw(0x0, IE_GP); /* Point GP at start of packet */
-                	data = inb(IE_RBUF);
-                	if (data == i) break;
-        	}
-		bufsize_rcv = i << 8;
-        	outw(0, IE_GP);		/* Point GP at start of packet */
-        	outb(0, IE_RBUF);	/* set buffer byte 0 to 0 again */
-	}
-	printf("Bufsize rcv/xmt=%d/%d\n", bufsize_rcv, NI5010_BUFSIZE);
-	return (1);
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *ni5010_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	static unsigned short	io_addrs[] = {
-		0x300, 0x320, 0x340, 0x360, 0x380, 0x3a0, 0 };
-	unsigned short		*p;
-
-	/* if probe_addrs is 0, then use list above */
-	if (probe_addrs == 0 || *probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; p++) {
-		if (ni5010_probe1(nic))
-			break;
-	}
-	if (ioaddr == 0)
-		return (0);
-	ni5010_reset(nic);
-	/* point to NIC specific routines */
-	nic->reset = ni5010_reset;
-	nic->poll = ni5010_poll;
-	nic->transmit = ni5010_transmit;
-	nic->disable = ni5010_disable;
-	return (nic);
-}
Index: netboot/main.c
===================================================================
--- netboot/main.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/main.c	(.../trunk)	(revision 112)
@@ -1,1172 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* Based on "src/main.c" in etherboot-5.0.5.  */
-
-/**************************************************************************
-ETHERBOOT -  BOOTP/TFTP Bootstrap Program
-
-Author: Martin Renters
-  Date: Dec/93
-  
-Literature dealing with the network protocols:
-       ARP - RFC826
-       RARP - RFC903
-       UDP - RFC768
-       BOOTP - RFC951, RFC2132 (vendor extensions)
-       DHCP - RFC2131, RFC2132 (options)
-       TFTP - RFC1350, RFC2347 (options), RFC2348 (blocksize), RFC2349 (tsize)
-       RPC - RFC1831, RFC1832 (XDR), RFC1833 (rpcbind/portmapper)
-       NFS - RFC1094, RFC1813 (v3, useful for clarifications, not implemented)
-
-**************************************************************************/
-
-#define GRUB	1
-#include <etherboot.h>
-#include <nic.h>
-
-/* #define DEBUG	1 */
-
-struct arptable_t arptable[MAX_ARP];
-
-/* Set if the user pushes Control-C.  */
-int ip_abort = 0;
-/* Set if an ethernet card is probed and IP addresses are set.  */
-int network_ready = 0;
-
-struct rom_info rom;
-
-static int vendorext_isvalid;
-static unsigned long netmask;
-static struct bootpd_t bootp_data;
-#define BOOTP_DATA_ADDR (&bootp_data)
-static unsigned long xid;
-static unsigned char *end_of_rfc1533 = NULL;
-
-#ifndef	NO_DHCP_SUPPORT
-#endif /* NO_DHCP_SUPPORT */
-
-/* Eth */
-static unsigned char vendorext_magic[] = {0xE4, 0x45, 0x74, 0x68};
-static const unsigned char broadcast[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-
-#ifdef	NO_DHCP_SUPPORT
-
-static unsigned char rfc1533_cookie[5] = {RFC1533_COOKIE, RFC1533_END};
-
-#else /* ! NO_DHCP_SUPPORT */
-
-static int dhcp_reply;
-static in_addr dhcp_server = {0L};
-static in_addr dhcp_addr = {0L};
-static unsigned char rfc1533_cookie[] = {RFC1533_COOKIE};
-static unsigned char rfc1533_end[] = {RFC1533_END};
-
-static const unsigned char dhcpdiscover[] =
-{
-  RFC2132_MSG_TYPE, 1, DHCPDISCOVER,	
-  RFC2132_MAX_SIZE,2,	/* request as much as we can */
-  ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
-  RFC2132_PARAM_LIST, 4, RFC1533_NETMASK, RFC1533_GATEWAY,
-  RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH
-};
-
-static const unsigned char dhcprequest[] =
-{
-  RFC2132_MSG_TYPE, 1, DHCPREQUEST,
-  RFC2132_SRV_ID, 4, 0, 0, 0, 0,
-  RFC2132_REQ_ADDR, 4, 0, 0, 0, 0,
-  RFC2132_MAX_SIZE, 2,	/* request as much as we can */
-  ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
-  /* request parameters */
-  RFC2132_PARAM_LIST,
-  /* 4 standard + 2 vendortags */
-  4 + 2,
-  /* Standard parameters */
-  RFC1533_NETMASK, RFC1533_GATEWAY,
-  RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH,
-  /* Etherboot vendortags */
-  RFC1533_VENDOR_MAGIC,
-  RFC1533_VENDOR_CONFIGFILE,
-};
-
-#endif /* ! NO_DHCP_SUPPORT */
-
-static unsigned short ipchksum (unsigned short *ip, int len);
-static unsigned short udpchksum (struct iphdr *packet);
-
-void
-print_network_configuration (void)
-{
-  if (! eth_probe ())
-    grub_printf ("No ethernet card found.\n");
-  else if (! network_ready)
-    grub_printf ("Not initialized yet.\n");
-  else
-    {
-      etherboot_printf ("Address: %@\n", arptable[ARP_CLIENT].ipaddr.s_addr);
-      etherboot_printf ("Netmask: %@\n", netmask);
-      etherboot_printf ("Server: %@\n", arptable[ARP_SERVER].ipaddr.s_addr);
-      etherboot_printf ("Gateway: %@\n", arptable[ARP_GATEWAY].ipaddr.s_addr);
-    }
-}
-
-
-/**************************************************************************
-DEFAULT_NETMASK - Return default netmask for IP address
-**************************************************************************/
-static inline unsigned long 
-default_netmask (void)
-{
-  int net = ntohl (arptable[ARP_CLIENT].ipaddr.s_addr) >> 24;
-  if (net <= 127)
-    return (htonl (0xff000000));
-  else if (net < 192)
-    return (htonl (0xffff0000));
-  else
-    return (htonl (0xffffff00));
-}
-
-/* ifconfig - configure network interface.  */
-int
-ifconfig (char *ip, char *sm, char *gw, char *svr)
-{
-  in_addr tmp;
-  
-  if (sm) 
-    {
-      if (! inet_aton (sm, &tmp))
-	return 0;
-      
-      netmask = tmp.s_addr;
-    }
-  
-  if (ip) 
-    {
-      if (! inet_aton (ip, &arptable[ARP_CLIENT].ipaddr)) 
-	return 0;
-      
-      if (! netmask && ! sm) 
-	netmask = default_netmask ();
-    }
-  
-  if (gw && ! inet_aton (gw, &arptable[ARP_GATEWAY].ipaddr)) 
-    return 0;
-
-  /* Clear out the ARP entry.  */
-  grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
-  
-  if (svr && ! inet_aton (svr, &arptable[ARP_SERVER].ipaddr)) 
-    return 0;
-
-  /* Likewise.  */
-  grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
-  
-  if (ip || sm)
-    {
-      if (IP_BROADCAST == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
-	  || netmask == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
-	  || ! netmask)
-	network_ready = 0;
-      else
-	network_ready = 1;
-    }
-  
-  return 1;
-}
-
-
-/**************************************************************************
-UDP_TRANSMIT - Send a UDP datagram
-**************************************************************************/
-int 
-udp_transmit (unsigned long destip, unsigned int srcsock,
-	      unsigned int destsock, int len, const void *buf)
-{
-  struct iphdr *ip;
-  struct udphdr *udp;
-  struct arprequest arpreq;
-  int arpentry, i;
-  int retry;
-
-  ip = (struct iphdr *) buf;
-  udp = (struct udphdr *) ((unsigned long) buf + sizeof (struct iphdr));
-  ip->verhdrlen = 0x45;
-  ip->service = 0;
-  ip->len = htons (len);
-  ip->ident = 0;
-  ip->frags = 0;
-  ip->ttl = 60;
-  ip->protocol = IP_UDP;
-  ip->chksum = 0;
-  ip->src.s_addr = arptable[ARP_CLIENT].ipaddr.s_addr;
-  ip->dest.s_addr = destip;
-  ip->chksum = ipchksum ((unsigned short *) buf, sizeof (struct iphdr));
-  udp->src = htons (srcsock);
-  udp->dest = htons (destsock);
-  udp->len = htons (len - sizeof (struct iphdr));
-  udp->chksum = 0;
-  udp->chksum = htons (udpchksum (ip));
-
-  if (udp->chksum == 0)
-    udp->chksum = 0xffff;
-  
-  if (destip == IP_BROADCAST)
-    {
-      eth_transmit (broadcast, IP, len, buf);
-    }
-  else
-    {
-      if (((destip & netmask)
-	   != (arptable[ARP_CLIENT].ipaddr.s_addr & netmask))
-	  && arptable[ARP_GATEWAY].ipaddr.s_addr)
-	destip = arptable[ARP_GATEWAY].ipaddr.s_addr;
-      
-      for (arpentry = 0; arpentry < MAX_ARP; arpentry++)
-	if (arptable[arpentry].ipaddr.s_addr == destip)
-	  break;
-      
-      if (arpentry == MAX_ARP)
-	{
-	  etherboot_printf ("%@ is not in my arp table!\n", destip);
-	  return 0;
-	}
-      
-      for (i = 0; i < ETH_ALEN; i++)
-	if (arptable[arpentry].node[i])
-	  break;
-      
-      if (i == ETH_ALEN)
-	{
-	  /* Need to do arp request.  */
-#ifdef DEBUG
-	  grub_printf ("arp request.\n");
-#endif
-	  arpreq.hwtype = htons (1);
-	  arpreq.protocol = htons (IP);
-	  arpreq.hwlen = ETH_ALEN;
-	  arpreq.protolen = 4;
-	  arpreq.opcode = htons (ARP_REQUEST);
-	  grub_memmove (arpreq.shwaddr, arptable[ARP_CLIENT].node,
-			ETH_ALEN);
-	  grub_memmove (arpreq.sipaddr, (char *) &arptable[ARP_CLIENT].ipaddr,
-			sizeof (in_addr));
-	  grub_memset (arpreq.thwaddr, 0, ETH_ALEN);
-	  grub_memmove (arpreq.tipaddr, (char *) &destip, sizeof (in_addr));
-	  
-	  for (retry = 1; retry <= MAX_ARP_RETRIES; retry++)
-	    {
-	      long timeout;
-	      
-	      eth_transmit (broadcast, ARP, sizeof (arpreq), &arpreq);
-	      timeout = rfc2131_sleep_interval (TIMEOUT, retry);
-	      
-	      if (await_reply (AWAIT_ARP, arpentry, arpreq.tipaddr, timeout))
-		goto xmit;
-
-	      if (ip_abort)
-		return 0;
-	    }
-	  
-	  return 0;
-	}
-      
-    xmit:
-      eth_transmit (arptable[arpentry].node, IP, len, buf);
-    }
-  
-  return 1;
-}
-
-/**************************************************************************
-TFTP - Download extended BOOTP data, or kernel image
-**************************************************************************/
-static int
-tftp (const char *name, int (*fnc) (unsigned char *, int, int, int))
-{
-  int retry = 0;
-  static unsigned short iport = 2000;
-  unsigned short oport = 0;
-  unsigned short len, block = 0, prevblock = 0;
-  int bcounter = 0;
-  struct tftp_t *tr;
-  struct tftpreq_t tp;
-  int rc;
-  int packetsize = TFTP_DEFAULTSIZE_PACKET;
-  
-  /* Clear out the Rx queue first.  It contains nothing of interest,
-   * except possibly ARP requests from the DHCP/TFTP server.  We use
-   * polling throughout Etherboot, so some time may have passed since we
-   * last polled the receive queue, which may now be filled with
-   * broadcast packets.  This will cause the reply to the packets we are
-   * about to send to be lost immediately.  Not very clever.  */
-  await_reply (AWAIT_QDRAIN, 0, NULL, 0);
-  
-  tp.opcode = htons (TFTP_RRQ);
-  len = (grub_sprintf ((char *) tp.u.rrq, "%s%coctet%cblksize%c%d",
-		       name, 0, 0, 0, TFTP_MAX_PACKET)
-	 + sizeof (tp.ip) + sizeof (tp.udp) + sizeof (tp.opcode) + 1);
-  if (! udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr, ++iport,
-		      TFTP_PORT, len, &tp))
-    return 0;
-  
-  for (;;)
-    {
-      long timeout;
-      
-#ifdef CONGESTED
-      timeout = rfc2131_sleep_interval (block ? TFTP_REXMT : TIMEOUT, retry);
-#else
-      timeout = rfc2131_sleep_interval (TIMEOUT, retry);
-#endif
-
-      if (! await_reply (AWAIT_TFTP, iport, NULL, timeout))
-	{
-	  if (! block && retry++ < MAX_TFTP_RETRIES)
-	    {
-	      /* Maybe initial request was lost.  */
-	      if (! udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr,
-				  ++iport, TFTP_PORT, len, &tp))
-		return 0;
-	      
-	      continue;
-	    }
-	  
-#ifdef CONGESTED
-	  if (block && ((retry += TFTP_REXMT) < TFTP_TIMEOUT))
-	    {
-	      /* We resend our last ack.  */
-#ifdef MDEBUG
-	      grub_printf ("<REXMT>\n");
-#endif
-	      udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr,
-			    iport, oport,
-			    TFTP_MIN_PACKET, &tp);
-	      continue;
-	    }
-#endif
-	  /* Timeout.  */
-	  break;
-	}
-      
-      tr = (struct tftp_t *) &nic.packet[ETH_HLEN];
-      if (tr->opcode == ntohs (TFTP_ERROR))
-	{
-	  grub_printf ("TFTP error %d (%s)\n",
-		       ntohs (tr->u.err.errcode),
-		       tr->u.err.errmsg);
-	  break;
-	}
-      
-      if (tr->opcode == ntohs (TFTP_OACK))
-	{
-	  char *p = tr->u.oack.data, *e;
-	  
-	  /* Shouldn't happen.  */
-	  if (prevblock)
-	    /* Ignore it.  */
-	    continue;
-	  
-	  len = ntohs (tr->udp.len) - sizeof (struct udphdr) - 2;
-	  if (len > TFTP_MAX_PACKET)
-	    goto noak;
-	  
-	  e = p + len;
-	  while (*p != '\000' && p < e)
-	    {
-	      if (! grub_strcmp ("blksize", p))
-		{
-		  p += 8;
-		  if ((packetsize = getdec (&p)) < TFTP_DEFAULTSIZE_PACKET)
-		    goto noak;
-		  
-		  while (p < e && *p)
-		    p++;
-		  
-		  if (p < e)
-		    p++;
-		}
-	      else
-		{
-		noak:
-		  tp.opcode = htons (TFTP_ERROR);
-		  tp.u.err.errcode = 8;
-		  len = (grub_sprintf ((char *) tp.u.err.errmsg,
-				       "RFC1782 error")
-			 + sizeof (tp.ip) + sizeof (tp.udp)
-			 + sizeof (tp.opcode) + sizeof (tp.u.err.errcode)
-			 + 1);
-		  udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr,
-				iport, ntohs (tr->udp.src),
-				len, &tp);
-		  return 0;
-		}
-	    }
-	  
-	  if (p > e)
-	    goto noak;
-	  
-	  /* This ensures that the packet does not get processed as data!  */
-	  block = tp.u.ack.block = 0; 
-	}
-      else if (tr->opcode == ntohs (TFTP_DATA))
-	{
-	  len = ntohs (tr->udp.len) - sizeof (struct udphdr) - 4;
-	  /* Shouldn't happen.  */
-	  if (len > packetsize)
-	    /* Ignore it.  */
-	    continue;
-	  
-	  block = ntohs (tp.u.ack.block = tr->u.data.block);
-	}
-      else
-	/* Neither TFTP_OACK nor TFTP_DATA.  */
-	break;
-      
-      if ((block || bcounter) && (block != prevblock + 1))
-	/* Block order should be continuous */
-	tp.u.ack.block = htons (block = prevblock);
-      
-      /* Should be continuous.  */
-      tp.opcode = htons (TFTP_ACK);
-      oport = ntohs (tr->udp.src);
-      /* Ack.  */
-      udp_transmit (arptable[ARP_SERVER].ipaddr.s_addr, iport,
-		    oport, TFTP_MIN_PACKET, &tp);
-      
-      if ((unsigned short) (block - prevblock) != 1)
-	/* Retransmission or OACK, don't process via callback
-	 * and don't change the value of prevblock.  */
-	continue;
-      
-      prevblock = block;
-      /* Is it the right place to zero the timer?  */
-      retry = 0;
-      
-      if ((rc = fnc (tr->u.data.download,
-		     ++bcounter, len, len < packetsize)) >= 0)
-	return rc;
-
-      /* End of data.  */
-      if (len < packetsize)           
-	return 1;
-    }
-  
-  return 0;
-}
-
-/**************************************************************************
-RARP - Get my IP address and load information
-**************************************************************************/
-int 
-rarp (void)
-{
-  int retry;
-
-  /* arp and rarp requests share the same packet structure.  */
-  struct arprequest rarpreq;
-
-  /* Make sure that an ethernet is probed.  */
-  if (! eth_probe ())
-    return 0;
-
-  /* Clear the ready flag.  */
-  network_ready = 0;
-  
-  grub_memset (&rarpreq, 0, sizeof (rarpreq));
-
-  rarpreq.hwtype = htons (1);
-  rarpreq.protocol = htons (IP);
-  rarpreq.hwlen = ETH_ALEN;
-  rarpreq.protolen = 4;
-  rarpreq.opcode = htons (RARP_REQUEST);
-  grub_memmove ((char *) &rarpreq.shwaddr, arptable[ARP_CLIENT].node,
-		ETH_ALEN);
-  /* sipaddr is already zeroed out */
-  grub_memmove ((char *) &rarpreq.thwaddr, arptable[ARP_CLIENT].node,
-		ETH_ALEN);
-  /* tipaddr is already zeroed out */
-
-  for (retry = 0; retry < MAX_ARP_RETRIES; ++retry)
-    {
-      long timeout;
-      
-      eth_transmit (broadcast, RARP, sizeof (rarpreq), &rarpreq);
-
-      timeout = rfc2131_sleep_interval (TIMEOUT, retry);
-      if (await_reply (AWAIT_RARP, 0, rarpreq.shwaddr, timeout))
-	break;
-
-      if (ip_abort)
-	return 0;
-    }
-
-  if (retry < MAX_ARP_RETRIES)
-    {
-      network_ready = 1;
-      return 1;
-    }
-
-  return 0;
-}
-
-/**************************************************************************
-BOOTP - Get my IP address and load information
-**************************************************************************/
-int 
-bootp (void)
-{
-  int retry;
-#ifndef	NO_DHCP_SUPPORT
-  int reqretry;
-#endif /* ! NO_DHCP_SUPPORT */
-  struct bootpip_t ip;
-  unsigned long starttime;
-
-  /* Make sure that an ethernet is probed.  */
-  if (! eth_probe ())
-    return 0;
-
-  /* Clear the ready flag.  */
-  network_ready = 0;
-
-#ifdef DEBUG
-  grub_printf ("network is ready.\n");
-#endif
-  
-  grub_memset (&ip, 0, sizeof (struct bootpip_t));
-  ip.bp.bp_op = BOOTP_REQUEST;
-  ip.bp.bp_htype = 1;
-  ip.bp.bp_hlen = ETH_ALEN;
-  starttime = currticks ();
-  /* Use lower 32 bits of node address, more likely to be
-     distinct than the time since booting */
-  grub_memmove (&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
-  ip.bp.bp_xid = xid += htonl (starttime);
-  grub_memmove (ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
-#ifdef DEBUG
-  etherboot_printf ("bp_op = %d\n", ip.bp.bp_op);
-  etherboot_printf ("bp_htype = %d\n", ip.bp.bp_htype);
-  etherboot_printf ("bp_hlen = %d\n", ip.bp.bp_hlen);
-  etherboot_printf ("bp_xid = %d\n", ip.bp.bp_xid);
-  etherboot_printf ("bp_hwaddr = %!\n", ip.bp.bp_hwaddr);
-  etherboot_printf ("bp_hops = %d\n", (int) ip.bp.bp_hops);
-  etherboot_printf ("bp_secs = %d\n", (int) ip.bp.bp_hwaddr);
-#endif
-  
-#ifdef	NO_DHCP_SUPPORT
-  /* Request RFC-style options.  */
-  grub_memmove (ip.bp.bp_vend, rfc1533_cookie, 5);
-#else
-  /* Request RFC-style options.  */
-  grub_memmove (ip.bp.bp_vend, rfc1533_cookie, sizeof rfc1533_cookie);
-  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie, dhcpdiscover,
-		sizeof dhcpdiscover);
-  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie + sizeof dhcpdiscover,
-		rfc1533_end, sizeof rfc1533_end);
-#endif /* ! NO_DHCP_SUPPORT */
-
-  for (retry = 0; retry < MAX_BOOTP_RETRIES;)
-    {
-      long timeout;
-
-#ifdef DEBUG
-      grub_printf ("retry = %d\n", retry);
-#endif
-      
-      /* Clear out the Rx queue first.  It contains nothing of
-       * interest, except possibly ARP requests from the DHCP/TFTP
-       * server.  We use polling throughout Etherboot, so some time
-       * may have passed since we last polled the receive queue,
-       * which may now be filled with broadcast packets.  This will
-       * cause the reply to the packets we are about to send to be
-       * lost immediately.  Not very clever.  */
-      await_reply (AWAIT_QDRAIN, 0, NULL, 0);
-
-      udp_transmit (IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
-		    sizeof (struct bootpip_t), &ip);
-      timeout = rfc2131_sleep_interval (TIMEOUT, retry++);
-#ifdef NO_DHCP_SUPPORT
-      if (await_reply (AWAIT_BOOTP, 0, NULL, timeout))
-	{
-	  network_ready = 1;
-	  return 1;
-	}
-#else /* ! NO_DHCP_SUPPORT */
-      if (await_reply (AWAIT_BOOTP, 0, NULL, timeout))
-	{
-	  if (dhcp_reply != DHCPOFFER)
-	    {
-	      network_ready = 1;
-	      return 1;
-	    }
-
-	  dhcp_reply = 0;
-#ifdef DEBUG
-  etherboot_printf ("bp_op = %d\n", (int) ip.bp.bp_op);
-  etherboot_printf ("bp_htype = %d\n", (int) ip.bp.bp_htype);
-  etherboot_printf ("bp_hlen = %d\n", (int) ip.bp.bp_hlen);
-  etherboot_printf ("bp_xid = %d\n", (int) ip.bp.bp_xid);
-  etherboot_printf ("bp_hwaddr = %!\n", ip.bp.bp_hwaddr);
-  etherboot_printf ("bp_hops = %d\n", (int) ip.bp.bp_hops);
-  etherboot_printf ("bp_secs = %d\n", (int) ip.bp.bp_hwaddr);
-#endif
-	  grub_memmove (ip.bp.bp_vend, rfc1533_cookie, sizeof rfc1533_cookie);
-	  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie,
-			dhcprequest, sizeof dhcprequest);
-	  grub_memmove (ip.bp.bp_vend + sizeof rfc1533_cookie
-			+ sizeof dhcprequest,
-			rfc1533_end, sizeof rfc1533_end);
-	  grub_memmove (ip.bp.bp_vend + 9, (char *) &dhcp_server,
-			sizeof (in_addr));
-	  grub_memmove (ip.bp.bp_vend + 15, (char *) &dhcp_addr,
-			sizeof (in_addr));
-#ifdef DEBUG
-	  grub_printf ("errnum = %d\n", errnum);
-#endif
-	  for (reqretry = 0; reqretry < MAX_BOOTP_RETRIES;)
-	    {
-	      int ret;
-#ifdef DEBUG
-	      grub_printf ("reqretry = %d\n", reqretry);
-#endif
-	      
-	      ret = udp_transmit (IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
-				  sizeof (struct bootpip_t), &ip);
-	      if (! ret)
-		grub_printf ("udp_transmit failed.\n");
-	      
-	      dhcp_reply = 0;
-	      timeout = rfc2131_sleep_interval (TIMEOUT, reqretry++);
-	      if (await_reply (AWAIT_BOOTP, 0, NULL, timeout))
-		if (dhcp_reply == DHCPACK)
-		  {
-		    network_ready = 1;
-		    return 1;
-		  }
-
-#ifdef DEBUG
-	      grub_printf ("dhcp_reply = %d\n", dhcp_reply);
-#endif
-	      
-	      if (ip_abort)
-		return 0;
-	    }
-	}
-#endif /* ! NO_DHCP_SUPPORT */
-      
-      if (ip_abort)
-	return 0;
-      
-      ip.bp.bp_secs = htons ((currticks () - starttime) / TICKS_PER_SEC);
-    }
-
-  /* Timeout.  */
-  return 0;
-}
-
-/**************************************************************************
-UDPCHKSUM - Checksum UDP Packet (one of the rare cases when assembly is
-            actually simpler...)
- RETURNS: checksum, 0 on checksum error. This
-          allows for using the same routine for RX and TX summing:
-          RX  if (packet->udp.chksum && udpchksum(packet))
-                  error("checksum error");
-          TX  packet->udp.chksum=0;
-              if (0==(packet->udp.chksum=udpchksum(packet)))
-                  packet->upd.chksum=0xffff;
-**************************************************************************/
-static inline void
-dosum (unsigned short *start, unsigned int len, unsigned short *sum)
-{
-  __asm__ __volatile__
-    ("clc\n"
-     "1:\tlodsw\n\t"
-     "xchg %%al,%%ah\n\t"	/* convert to host byte order */
-     "adcw %%ax,%0\n\t"		/* add carry of previous iteration */
-     "loop 1b\n\t"
-     "adcw $0,%0"		/* add carry of last iteration */
-     : "=b" (*sum), "=S"(start), "=c"(len)
-     : "0"(*sum), "1"(start), "2"(len)
-     : "ax", "cc"
-     );
-}
-
-/* UDP sum:
- * proto, src_ip, dst_ip, udp_dport, udp_sport, 2*udp_len, payload
- */
-static unsigned short
-udpchksum (struct iphdr *packet)
-{
-  int len = ntohs (packet->len);
-  unsigned short rval;
-  
-  /* add udplength + protocol number */
-  rval = (len - sizeof (struct iphdr)) + IP_UDP;
-  
-  /* pad to an even number of bytes */
-  if (len % 2) {
-    ((char *) packet)[len++] = 0;
-  }
-  
-  /* sum over src/dst ipaddr + udp packet */
-  len -= (char *) &packet->src - (char *) packet;
-  dosum ((unsigned short *) &packet->src, len >> 1, &rval);
-  
-  /* take one's complement */
-  return ~rval;
-}
-
-/**************************************************************************
-AWAIT_REPLY - Wait until we get a response for our request
-**************************************************************************/
-int 
-await_reply (int type, int ival, void *ptr, int timeout)
-{
-  unsigned long time;
-  struct iphdr *ip;
-  struct udphdr *udp;
-  struct arprequest *arpreply;
-  struct bootp_t *bootpreply;
-  unsigned short ptype;
-  unsigned int protohdrlen = (ETH_HLEN + sizeof (struct iphdr)
-			      + sizeof (struct udphdr));
-
-  /* Clear the abort flag.  */
-  ip_abort = 0;
-  
-  time = timeout + currticks ();
-  /* The timeout check is done below.  The timeout is only checked if
-   * there is no packet in the Rx queue.  This assumes that eth_poll()
-   * needs a negligible amount of time.  */
-  for (;;)
-    {
-      if (eth_poll ())
-	{
-	  /* We have something!  */
-	  
-	  /* Check for ARP - No IP hdr.  */
-	  if (nic.packetlen >= ETH_HLEN)
-	    {
-	      ptype = (((unsigned short) nic.packet[12]) << 8
-		       | ((unsigned short) nic.packet[13]));
-	    }
-	  else
-	    /* What else could we do with it?  */
-	    continue;
-	  
-	  if (nic.packetlen >= ETH_HLEN + sizeof (struct arprequest)
-	      && ptype == ARP)
-	    {
-	      unsigned long tmp;
-
-	      arpreply = (struct arprequest *) &nic.packet[ETH_HLEN];
-	      
-	      if (arpreply->opcode == htons (ARP_REPLY)
-		  && ! grub_memcmp (arpreply->sipaddr, ptr, sizeof (in_addr))
-		  && type == AWAIT_ARP)
-		{
-		  grub_memmove ((char *) arptable[ival].node,
-				arpreply->shwaddr,
-				ETH_ALEN);
-		  return 1;
-		}
-	      
-	      grub_memmove ((char *) &tmp, arpreply->tipaddr,
-			    sizeof (in_addr));
-	      
-	      if (arpreply->opcode == htons (ARP_REQUEST)
-		  && tmp == arptable[ARP_CLIENT].ipaddr.s_addr)
-		{
-		  arpreply->opcode = htons (ARP_REPLY);
-		  grub_memmove (arpreply->tipaddr, arpreply->sipaddr,
-				sizeof (in_addr));
-		  grub_memmove (arpreply->thwaddr, (char *) arpreply->shwaddr,
-				ETH_ALEN);
-		  grub_memmove (arpreply->sipaddr,
-				(char *) &arptable[ARP_CLIENT].ipaddr,
-				sizeof (in_addr));
-		  grub_memmove (arpreply->shwaddr,
-				arptable[ARP_CLIENT].node,
-				ETH_ALEN);
-		  eth_transmit (arpreply->thwaddr, ARP,
-				sizeof (struct arprequest),
-				arpreply);
-#ifdef MDEBUG
-		  grub_memmove (&tmp, arpreply->tipaddr, sizeof (in_addr));
-		  etherboot_printf ("Sent ARP reply to: %@\n", tmp);
-#endif	/* MDEBUG */
-		}
-	      
-	      continue;
-	    }
-
-	  if (type == AWAIT_QDRAIN)
-	    continue;
-	  
-	  /* Check for RARP - No IP hdr.  */
-	  if (type == AWAIT_RARP
-	      && nic.packetlen >= ETH_HLEN + sizeof (struct arprequest)
-	      && ptype == RARP)
-	    {
-	      arpreply = (struct arprequest *) &nic.packet[ETH_HLEN];
-	      
-	      if (arpreply->opcode == htons (RARP_REPLY)
-		  && ! grub_memcmp (arpreply->thwaddr, ptr, ETH_ALEN))
-		{
-		  grub_memmove ((char *) arptable[ARP_SERVER].node,
-				arpreply->shwaddr, ETH_ALEN);
-		  grub_memmove ((char *) &arptable[ARP_SERVER].ipaddr,
-				arpreply->sipaddr, sizeof (in_addr));
-		  grub_memmove ((char *) &arptable[ARP_CLIENT].ipaddr,
-				arpreply->tipaddr, sizeof (in_addr));
-		  return 1;
-		}
-	      
-	      continue;
-	    }
-
-	  /* Anything else has IP header.  */
-	  if (nic.packetlen < protohdrlen || ptype != IP)
-	    continue;
-	  
-	  ip = (struct iphdr *) &nic.packet[ETH_HLEN];
-	  if (ip->verhdrlen != 0x45
-	      || ipchksum ((unsigned short *) ip, sizeof (struct iphdr))
-	      || ip->protocol != IP_UDP)
-	    continue;
-	  
-	  /*
-	    - Till Straumann <Till.Straumann@TU-Berlin.de>
-	    added udp checksum (safer on a wireless link)
-	    added fragmentation check: I had a corrupted image
-	    in memory due to fragmented TFTP packets - took me
-	    3 days to find the cause for this :-(
-	  */
-	  
-	  /* If More Fragments bit and Fragment Offset field
-	     are non-zero then packet is fragmented */
-	  if (ip->frags & htons(0x3FFF))
-	    {
-	      grub_printf ("ALERT: got a fragmented packet - reconfigure your server\n");
-	      continue;
-	    }
-	  
-	  udp = (struct udphdr *) &nic.packet[(ETH_HLEN
-					       + sizeof (struct iphdr))];
-	  if (udp->chksum && udpchksum (ip))
-	    {
-	      grub_printf ("UDP checksum error\n");
-	      continue;
-	    }
-	  
-	  /* BOOTP ?  */
-	  bootpreply = (struct bootp_t *)
-	    &nic.packet[(ETH_HLEN + sizeof (struct iphdr)
-			 + sizeof (struct udphdr))];
-	  if (type == AWAIT_BOOTP
-#ifdef NO_DHCP_SUPPORT
-	      && (nic.packetlen
-		  >= (ETH_HLEN + sizeof (struct bootp_t) - BOOTP_VENDOR_LEN))
-#else
-	      && (nic.packetlen
-		  >= (ETH_HLEN + sizeof (struct bootp_t) - DHCP_OPT_LEN))
-#endif /* ! NO_DHCP_SUPPORT */
-	      && udp->dest == htons (BOOTP_CLIENT)
-	      && bootpreply->bp_op == BOOTP_REPLY
-	      && bootpreply->bp_xid == xid
-	      && (! grub_memcmp (broadcast, bootpreply->bp_hwaddr, ETH_ALEN)
-		  || ! grub_memcmp (arptable[ARP_CLIENT].node,
-				    bootpreply->bp_hwaddr, ETH_ALEN)))
-	    {
-#ifdef DEBUG
-	      grub_printf ("BOOTP packet was received.\n");
-#endif
-	      arptable[ARP_CLIENT].ipaddr.s_addr
-		= bootpreply->bp_yiaddr.s_addr;
-#ifndef	NO_DHCP_SUPPORT
-	      dhcp_addr.s_addr = bootpreply->bp_yiaddr.s_addr;
-#ifdef DEBUG
-	      etherboot_printf ("dhcp_addr = %@\n", dhcp_addr.s_addr);
-#endif
-#endif /* ! NO_DHCP_SUPPORT */
-	      netmask = default_netmask ();
-	      arptable[ARP_SERVER].ipaddr.s_addr
-		= bootpreply->bp_siaddr.s_addr;
-	      /* Kill arp.  */
-	      grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
-	      arptable[ARP_GATEWAY].ipaddr.s_addr
-		= bootpreply->bp_giaddr.s_addr;
-	      /* Kill arp.  */
-	      grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
-
-	      grub_memmove ((char *) BOOTP_DATA_ADDR, (char *) bootpreply,
-			    sizeof (struct bootpd_t));
-#ifdef NO_DHCP_SUPPORT
-	      decode_rfc1533 (BOOTP_DATA_ADDR->bootp_reply.bp_vend,
-			      0, BOOTP_VENDOR_LEN + MAX_BOOTP_EXTLEN, 1);
-#else
-	      decode_rfc1533 (BOOTP_DATA_ADDR->bootp_reply.bp_vend,
-			      0, DHCP_OPT_LEN + MAX_BOOTP_EXTLEN, 1);
-#endif /* ! NO_DHCP_SUPPORT */
-	      
-	      return 1;
-	    }
-	  
-	  /* TFTP ? */
-	  if (type == AWAIT_TFTP && ntohs (udp->dest) == ival)
-	    return 1;
-	}
-      else
-	{
-	  /* Check for abort key only if the Rx queue is empty -
-	   * as long as we have something to process, don't
-	   * assume that something failed.  It is unlikely that
-	   * we have no processing time left between packets.  */
-	  if (checkkey () != -1 && ASCII_CHAR (getkey ()) == CTRL_C)
-	    {
-	      ip_abort = 1;
-	      return 0;
-	    }
-	  
-	  /* Do the timeout after at least a full queue walk.  */
-	  if ((timeout == 0) || (currticks() > time))
-	    {
-	      break;
-	    }
-	}
-    }
-  
-  return 0;
-}
-
-/**************************************************************************
-DECODE_RFC1533 - Decodes RFC1533 header
-**************************************************************************/
-int
-decode_rfc1533 (unsigned char *p, int block, int len, int eof)
-{
-  static unsigned char *extdata = NULL, *extend = NULL;
-  unsigned char *extpath = NULL;
-  unsigned char *endp;
-  
-  if (block == 0)
-    {
-      end_of_rfc1533 = NULL;
-      vendorext_isvalid = 0;
-      
-      if (grub_memcmp (p, rfc1533_cookie, 4))
-	/* no RFC 1533 header found */
-	return 0;
-      
-      p += 4;
-      endp = p + len;
-    }
-  else
-    {
-      if (block == 1)
-	{
-	  if (grub_memcmp (p, rfc1533_cookie, 4))
-	    /* no RFC 1533 header found */
-	    return 0;
-	  
-	  p += 4;
-	  len -= 4;
-	}
-      
-      if (extend + len
-	  <= ((unsigned char *)
-	      &(BOOTP_DATA_ADDR->bootp_extension[MAX_BOOTP_EXTLEN])))
-	{
-	  grub_memmove (extend, p, len);
-	  extend += len;
-	}
-      else
-	{
-	  grub_printf ("Overflow in vendor data buffer! Aborting...\n");
-	  *extdata = RFC1533_END;
-	  return 0;
-	}
-      
-      p = extdata;
-      endp = extend;
-    }
-
-  if (! eof)
-    return -1;
-  
-  while (p < endp)
-    {
-      unsigned char c = *p;
-      
-      if (c == RFC1533_PAD)
-	{
-	  p++;
-	  continue;
-	}
-      else if (c == RFC1533_END)
-	{
-	  end_of_rfc1533 = endp = p;
-	  continue;
-	}
-      else if (c == RFC1533_NETMASK)
-	{
-	  grub_memmove ((char *) &netmask, p + 2, sizeof (in_addr));
-	}
-      else if (c == RFC1533_GATEWAY)
-	{
-	  /* This is a little simplistic, but it will
-	     usually be sufficient.
-	     Take only the first entry.  */
-	  if (TAG_LEN (p) >= sizeof (in_addr))
-	    grub_memmove ((char *) &arptable[ARP_GATEWAY].ipaddr, p + 2,
-			  sizeof (in_addr));
-	}
-      else if (c == RFC1533_EXTENSIONPATH)
-	extpath = p;
-#ifndef	NO_DHCP_SUPPORT
-      else if (c == RFC2132_MSG_TYPE)
-	{
-	  dhcp_reply = *(p + 2);
-	}
-      else if (c == RFC2132_SRV_ID)
-	{
-	  grub_memmove ((char *) &dhcp_server, p + 2, sizeof (in_addr));
-#ifdef DEBUG
-	  etherboot_printf ("dhcp_server = %@\n", dhcp_server.s_addr);
-#endif
-	}
-#endif /* ! NO_DHCP_SUPPORT */
-      else if (c == RFC1533_VENDOR_MAGIC
-	       && TAG_LEN(p) >= 6
-	       && ! grub_memcmp (p + 2, vendorext_magic, 4)
-	       && p[6] == RFC1533_VENDOR_MAJOR)
-	vendorext_isvalid++;
-      /* GRUB now handles its own tag. Get the name of a configuration
-	 file from the network. Cool...  */
-      else if (c == RFC1533_VENDOR_CONFIGFILE)
-	{
-	  int l = TAG_LEN (p);
-	  
-	  /* Eliminate the trailing NULs according to RFC 2132.  */
-	  while (*(p + 2 + l - 1) == '\000' && l > 0)
-	    l--;
-	  
-	  /* XXX: Should check if LEN is less than the maximum length
-	     of CONFIG_FILE. This kind of robustness will be a goal
-	     in GRUB 1.0.  */
-	  grub_memmove (config_file, p + 2, l);
-	  config_file[l] = 0;
-	}
-      
-      p += TAG_LEN (p) + 2;
-    }
-  
-  extdata = extend = endp;
-  
-  /* Perhaps we can eliminate this because we doesn't require so
-     much information, but I leave this alone.  */
-  if (block == 0 && extpath != NULL)
-    {
-      char fname[64];
-      int fnamelen = TAG_LEN (extpath);
-      
-      while (*(extpath + 2 + fnamelen - 1) == '\000' && fnamelen > 0)
-	fnamelen--;
-      
-      if (fnamelen + 1 > sizeof (fname))
-	{
-	  grub_printf ("Too long file name for Extensions Path\n");
-	  return 0;
-	}
-      else if (! fnamelen)
-	{
-	  grub_printf ("Empty file name for Extensions Path\n");
-	  return 0;
-	}
-      
-      grub_memmove (fname, extpath + 2, fnamelen);
-      fname[fnamelen] = '\000';
-      grub_printf ("Loading BOOTP-extension file: %s\n", fname);
-      tftp (fname, decode_rfc1533);
-    }
-  
-  /* Proceed with next block.  */
-  return -1;
-}
-
-/**************************************************************************
-IPCHKSUM - Checksum IP Header
-**************************************************************************/
-static unsigned short 
-ipchksum (unsigned short *ip, int len)
-{
-  unsigned long sum = 0;
-  len >>= 1;
-  while (len--)
-    {
-      sum += *(ip++);
-      if (sum > 0xFFFF)
-	sum -= 0xFFFF;
-    }
-  return (~sum) & 0x0000FFFF;
-}
-
-#define TWO_SECOND_DIVISOR (2147483647l/TICKS_PER_SEC)
-
-/**************************************************************************
-RFC2131_SLEEP_INTERVAL - sleep for expotentially longer times
-**************************************************************************/
-long
-rfc2131_sleep_interval (int base, int exp)
-{
-  static long seed = 0;
-  long q;
-  unsigned long tmo;
-  
-#ifdef BACKOFF_LIMIT
-  if (exp > BACKOFF_LIMIT)
-    exp = BACKOFF_LIMIT;
-#endif
-  if (!seed)
-    /* Initialize linear congruential generator */
-    seed = (currticks () + *((long *) &arptable[ARP_CLIENT].node)
-	    + ((short *) arptable[ARP_CLIENT].node)[2]);
-  /* simplified version of the LCG given in Bruce Schneier's
-     "Applied Cryptography" */
-  q = seed / 53668;
-  if ((seed = 40014 * (seed - 53668 * q) - 12211 *q ) < 0)
-    seed += 2147483563L;
-  tmo = (base << exp) + (TICKS_PER_SEC - (seed / TWO_SECOND_DIVISOR));
-  return tmo;
-}
-
-/**************************************************************************
-CLEANUP - shut down networking
-**************************************************************************/
-void
-cleanup_net (void)
-{
-  if (network_ready)
-    {
-      /* Stop receiving packets.  */
-      eth_disable ();
-      network_ready = 0;
-    }
-}
Index: netboot/sk_g16.c
===================================================================
--- netboot/sk_g16.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/sk_g16.c	(.../trunk)	(revision 112)
@@ -1,1160 +0,0 @@
-/**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-Schneider & Koch G16 NIC driver for Etherboot
-heavily based on SK G16 driver from Linux 2.0.36
-Changes to make it work with Etherboot by Georg Baum <Georg.Baum@gmx.de>
-***************************************************************************/
-
-/*-
- * Copyright (C) 1994 by PJD Weichmann & SWS Bern, Switzerland
- *
- * This software may be used and distributed according to the terms
- * of the GNU Public License, incorporated herein by reference.
- *
- * Module         : sk_g16.c
- *
- * Version        : $Revision: 1.4 $
- *
- * Author         : Patrick J.D. Weichmann
- *
- * Date Created   : 94/05/26
- * Last Updated   : $Date: 2002/01/02 21:56:40 $
- *
- * Description    : Schneider & Koch G16 Ethernet Device Driver for
- *                  Linux Kernel >= 1.1.22
- * Update History :
- *
--*/
-
-/*
- * The Schneider & Koch (SK) G16 Network device driver is based
- * on the 'ni6510' driver from Michael Hipp which can be found at
- * ftp://sunsite.unc.edu/pub/Linux/system/Network/drivers/nidrivers.tar.gz
- *
- * Sources: 1) ni6510.c by M. Hipp
- *          2) depca.c  by D.C. Davies
- *          3) skeleton.c by D. Becker
- *          4) Am7990 Local Area Network Controller for Ethernet (LANCE),
- *             AMD, Pub. #05698, June 1989
- *
- * Many Thanks for helping me to get things working to:
- *
- *                 A. Cox (A.Cox@swansea.ac.uk)
- *                 M. Hipp (mhipp@student.uni-tuebingen.de)
- *                 R. Bolz (Schneider & Koch, Germany)
- *
- * See README.sk_g16 for details about limitations and bugs for the
- * current version.
- *
- * To Do:
- *        - Support of SK_G8 and other SK Network Cards.
- *        - Autoset memory mapped RAM. Check for free memory and then
- *          configure RAM correctly.
- *        - SK_close should really set card in to initial state.
- *        - Test if IRQ 3 is not switched off. Use autoirq() functionality.
- *          (as in /drivers/net/skeleton.c)
- *        - Implement Multicast addressing. At minimum something like
- *          in depca.c.
- *        - Redo the statistics part.
- *        - Try to find out if the board is in 8 Bit or 16 Bit slot.
- *          If in 8 Bit mode don't use IRQ 11.
- *        - (Try to make it slightly faster.)
- */
-
-/* to get some global routines like printf */
-#include "etherboot.h"
-/* to get the interface to the body of the program */
-#include "nic.h"
-
-/* From linux/if_ether.h: */
-#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
-
-#include "sk_g16.h"
-
-/*
- * Schneider & Koch Card Definitions
- * =================================
- */
-
-#define SK_NAME   "SK_G16"
-
-/*
- * SK_G16 Configuration
- * --------------------
- */
-
-/*
- * Abbreviations
- * -------------
- *
- * RAM - used for the 16KB shared memory
- * Boot_ROM, ROM - are used for referencing the BootEPROM
- *
- * SK_ADDR is a symbolic constant used to configure
- * the behaviour of the driver and the SK_G16.
- *
- * SK_ADDR defines the address where the RAM will be mapped into the real
- *         host memory.
- *         valid addresses are from 0xa0000 to 0xfc000 in 16Kbyte steps.
- */
-
-#define SK_ADDR         0xcc000
-
-/*
- * In POS3 are bits A14-A19 of the address bus. These bits can be set
- * to choose the RAM address. That's why we only can choose the RAM address
- * in 16KB steps.
- */
-
-#define POS_ADDR       (rom_addr>>14)  /* Do not change this line */
-
-/*
- * SK_G16 I/O PORT's + IRQ's + Boot_ROM locations
- * ----------------------------------------------
- */
-
-/*
- * As nearly every card has also SK_G16 a specified I/O Port region and
- * only a few possible IRQ's.
- * In the Installation Guide from Schneider & Koch is listed a possible
- * Interrupt IRQ2. IRQ2 is always IRQ9 in boards with two cascaded interrupt
- * controllers. So we use in SK_IRQS IRQ9.
- */
-
-/* Don't touch any of the following #defines. */
-
-#define SK_IO_PORTS     { 0x100, 0x180, 0x208, 0x220, 0x288, 0x320, 0x328, 0x390, 0 }
-
-/*
- * SK_G16 POS REGISTERS
- * --------------------
- */
-
-/*
- * SK_G16 has a Programmable Option Select (POS) Register.
- * The POS is composed of 8 separate registers (POS0-7) which
- * are I/O mapped on an address set by the W1 switch.
- *
- */
-
-#define SK_POS_SIZE 8           /* 8 I/O Ports are used by SK_G16 */
-
-#define SK_POS0     ioaddr      /* Card-ID Low (R) */
-#define SK_POS1     ioaddr+1    /* Card-ID High (R) */
-#define SK_POS2     ioaddr+2    /* Card-Enable, Boot-ROM Disable (RW) */
-#define SK_POS3     ioaddr+3    /* Base address of RAM */
-#define SK_POS4     ioaddr+4    /* IRQ */
-
-/* POS5 - POS7 are unused */
-
-/*
- * SK_G16 MAC PREFIX
- * -----------------
- */
-
-/*
- * Scheider & Koch manufacturer code (00:00:a5).
- * This must be checked, that we are sure it is a SK card.
- */
-
-#define SK_MAC0         0x00
-#define SK_MAC1         0x00
-#define SK_MAC2         0x5a
-
-/*
- * SK_G16 ID
- * ---------
- */
-
-/*
- * If POS0,POS1 contain the following ID, then we know
- * at which I/O Port Address we are.
- */
-
-#define SK_IDLOW  0xfd
-#define SK_IDHIGH 0x6a
-
-
-/*
- * LANCE POS Bit definitions
- * -------------------------
- */
-
-#define SK_ROM_RAM_ON  (POS2_CARD)
-#define SK_ROM_RAM_OFF (POS2_EPROM)
-#define SK_ROM_ON      (inb(SK_POS2) & POS2_CARD)
-#define SK_ROM_OFF     (inb(SK_POS2) | POS2_EPROM)
-#define SK_RAM_ON      (inb(SK_POS2) | POS2_CARD)
-#define SK_RAM_OFF     (inb(SK_POS2) & POS2_EPROM)
-
-#define POS2_CARD  0x0001              /* 1 = SK_G16 on      0 = off */
-#define POS2_EPROM 0x0002              /* 1 = Boot EPROM off 0 = on */
-
-/*
- * SK_G16 Memory mapped Registers
- * ------------------------------
- *
- */
-
-#define SK_IOREG        (board->ioreg) /* LANCE data registers.     */
-#define SK_PORT         (board->port)  /* Control, Status register  */
-#define SK_IOCOM        (board->iocom) /* I/O Command               */
-
-/*
- * SK_G16 Status/Control Register bits
- * -----------------------------------
- *
- * (C) Controlreg (S) Statusreg
- */
-
-/*
- * Register transfer: 0 = no transfer
- *                    1 = transferring data between LANCE and I/O reg
- */
-#define SK_IORUN        0x20
-
-/*
- * LANCE interrupt: 0 = LANCE interrupt occurred
- *                  1 = no LANCE interrupt occurred
- */
-#define SK_IRQ          0x10
-
-#define SK_RESET        0x08   /* Reset SK_CARD: 0 = RESET 1 = normal */
-#define SK_RW           0x02   /* 0 = write to 1 = read from */
-#define SK_ADR          0x01   /* 0 = REG DataPort 1 = RAP Reg addr port */
-
-
-#define SK_RREG         SK_RW  /* Transferdirection to read from lance */
-#define SK_WREG         0      /* Transferdirection to write to lance */
-#define SK_RAP          SK_ADR /* Destination Register RAP */
-#define SK_RDATA        0      /* Destination Register REG DataPort */
-
-/*
- * SK_G16 I/O Command
- * ------------------
- */
-
-/*
- * Any bitcombination sets the internal I/O bit (transfer will start)
- * when written to I/O Command
- */
-
-#define SK_DOIO         0x80   /* Do Transfer */
-
-/*
- * LANCE RAP (Register Address Port).
- * ---------------------------------
- */
-
-/*
- * The LANCE internal registers are selected through the RAP.
- * The Registers are:
- *
- * CSR0 - Status and Control flags
- * CSR1 - Low order bits of initialize block (bits 15:00)
- * CSR2 - High order bits of initialize block (bits 07:00, 15:08 are reserved)
- * CSR3 - Allows redefinition of the Bus Master Interface.
- *        This register must be set to 0x0002, which means BSWAP = 0,
- *        ACON = 1, BCON = 0;
- *
- */
-
-#define CSR0            0x00
-#define CSR1            0x01
-#define CSR2            0x02
-#define CSR3            0x03
-
-/*
- * General Definitions
- * ===================
- */
-
-/*
- * Set the number of Tx and Rx buffers, using Log_2(# buffers).
- * We have 16KB RAM which can be accessed by the LANCE. In the
- * memory are not only the buffers but also the ring descriptors and
- * the initialize block.
- * Don't change anything unless you really know what you do.
- */
-
-#define LC_LOG_TX_BUFFERS 1               /* (2 == 2^^1) 2 Transmit buffers */
-#define LC_LOG_RX_BUFFERS 2               /* (8 == 2^^3) 8 Receive buffers */
-
-/* Descriptor ring sizes */
-
-#define TMDNUM (1 << (LC_LOG_TX_BUFFERS)) /* 2 Transmit descriptor rings */
-#define RMDNUM (1 << (LC_LOG_RX_BUFFERS)) /* 8 Receive Buffers */
-
-/* Define Mask for setting RMD, TMD length in the LANCE init_block */
-
-#define TMDNUMMASK (LC_LOG_TX_BUFFERS << 29)
-#define RMDNUMMASK (LC_LOG_RX_BUFFERS << 29)
-
-/*
- * Data Buffer size is set to maximum packet length.
- */
-
-#define PKT_BUF_SZ              1518
-
-/*
- * The number of low I/O ports used by the ethercard.
- */
-
-#define ETHERCARD_TOTAL_SIZE    SK_POS_SIZE
-
-/*
- * Portreserve is there to mark the Card I/O Port region as used.
- * Check_region is to check if the region at ioaddr with the size "size"
- * is free or not.
- * Snarf_region allocates the I/O Port region.
- */
-
-#ifndef	HAVE_PORTRESERVE
-
-#define check_region(ioaddr1, size)              0
-#define request_region(ioaddr1, size,name)       do ; while (0)
-
-#endif
-
-/*
- * SK_DEBUG
- *
- * Here you can choose what level of debugging wanted.
- *
- * If SK_DEBUG and SK_DEBUG2 are undefined, then only the
- *  necessary messages will be printed.
- *
- * If SK_DEBUG is defined, there will be many debugging prints
- *  which can help to find some mistakes in configuration or even
- *  in the driver code.
- *
- * If SK_DEBUG2 is defined, many many messages will be printed
- *  which normally you don't need. I used this to check the interrupt
- *  routine.
- *
- * (If you define only SK_DEBUG2 then only the messages for
- *  checking interrupts will be printed!)
- *
- * Normal way of live is:
- *
- * For the whole thing get going let both symbolic constants
- * undefined. If you face any problems and you know what's going
- * on (you know something about the card and you can interpret some
- * hex LANCE register output) then define SK_DEBUG
- *
- */
-
-#undef  SK_DEBUG	/* debugging */
-#undef  SK_DEBUG2	/* debugging with more verbose report */
-
-#ifdef	SK_DEBUG
-#define PRINTF(x) printf x
-#else
-#define PRINTF(x) /**/
-#endif
-
-#ifdef	SK_DEBUG2
-#define PRINTF2(x) printf x
-#else
-#define PRINTF2(x) /**/
-#endif
-
-/*
- * SK_G16 RAM
- *
- * The components are memory mapped and can be set in a region from
- * 0x00000 through 0xfc000 in 16KB steps.
- *
- * The Network components are: dual ported RAM, Prom, I/O Reg, Status-,
- * Controlregister and I/O Command.
- *
- * dual ported RAM: This is the only memory region which the LANCE chip
- *      has access to. From the Lance it is addressed from 0x0000 to
- *      0x3fbf. The host accesses it normally.
- *
- * PROM: The PROM obtains the ETHERNET-MAC-Address. It is realised as a
- *       8-Bit PROM, this means only the 16 even addresses are used of the
- *       32 Byte Address region. Access to a odd address results in invalid
- *       data.
- *
- * LANCE I/O Reg: The I/O Reg is build of 4 single Registers, Low-Byte Write,
- *       Hi-Byte Write, Low-Byte Read, Hi-Byte Read.
- *       Transfer from or to the LANCE is always in 16Bit so Low and High
- *       registers are always relevant.
- *
- *       The Data from the Readregister is not the data in the Writeregister!!
- *
- * Port: Status- and Controlregister.
- *       Two different registers which share the same address, Status is
- *       read-only, Control is write-only.
- *
- * I/O Command:
- *       Any bitcombination written in here starts the transmission between
- *       Host and LANCE.
- */
-
-typedef struct
-{
-	unsigned char  ram[0x3fc0];   /* 16KB dual ported ram */
-	unsigned char  rom[0x0020];   /* 32Byte PROM containing 6Byte MAC */
-	unsigned char  res1[0x0010];  /* reserved */
-	unsigned volatile short ioreg;/* LANCE I/O Register */
-	unsigned volatile char  port; /* Statusregister and Controlregister */
-	unsigned char  iocom;         /* I/O Command Register */
-} SK_RAM;
-
-/* struct  */
-
-/*
- * This is the structure for the dual ported ram. We
- * have exactly 16 320 Bytes. In here there must be:
- *
- *     - Initialize Block   (starting at a word boundary)
- *     - Receive and Transmit Descriptor Rings (quadword boundary)
- *     - Data Buffers (arbitrary boundary)
- *
- * This is because LANCE has on SK_G16 only access to the dual ported
- * RAM and nowhere else.
- */
-
-struct SK_ram
-{
-    struct init_block ib;
-    struct tmd tmde[TMDNUM];
-    struct rmd rmde[RMDNUM];
-    char tmdbuf[TMDNUM][PKT_BUF_SZ];
-    char rmdbuf[RMDNUM][PKT_BUF_SZ];
-};
-
-/*
- * Structure where all necessary information is for ring buffer
- * management and statistics.
- */
-
-struct priv
-{
-    struct SK_ram *ram;  /* dual ported ram structure */
-    struct rmd *rmdhead; /* start of receive ring descriptors */
-    struct tmd *tmdhead; /* start of transmit ring descriptors */
-    int        rmdnum;   /* actual used ring descriptor */
-    int        tmdnum;   /* actual transmit descriptor for transmitting data */
-    int        tmdlast;  /* last sent descriptor used for error handling, etc */
-    void       *rmdbufs[RMDNUM]; /* pointer to the receive buffers */
-    void       *tmdbufs[TMDNUM]; /* pointer to the transmit buffers */
-};
-
-/* global variable declaration */
-
-/* static variables */
-
-static SK_RAM *board;  /* pointer to our memory mapped board components */
-static unsigned short	ioaddr; /* base io address */
-static struct priv	p_data;
-
-/* Macros */
-
-
-/* Function Prototypes */
-
-/*
- * Device Driver functions
- * -----------------------
- * See for short explanation of each function its definitions header.
- */
-
-static int   SK_probe1(struct nic *nic, short ioaddr1);
-
-static void SK_reset(struct nic *nic);
-static int SK_poll(struct nic *nic);
-static void SK_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *p);			/* Packet */
-static void SK_disable(struct nic *nic);
-struct nic *SK_probe(struct nic *nic, unsigned short *probe_addrs);
-
-/*
- * LANCE Functions
- * ---------------
- */
-
-static int SK_lance_init(struct nic *nic, unsigned short mode);
-static void SK_reset_board(void);
-static void SK_set_RAP(int reg_number);
-static int SK_read_reg(int reg_number);
-static int SK_rread_reg(void);
-static void SK_write_reg(int reg_number, int value);
-
-/*
- * Debugging functions
- * -------------------
- */
-
-static void SK_print_pos(struct nic *nic, char *text);
-static void SK_print_ram(struct nic *nic);
-
-
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void SK_reset(struct nic *nic)
-{
-	/* put the card in its initial state */
-	SK_lance_init(nic, MODE_NORMAL);
-}
-
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int SK_poll(struct nic *nic)
-{
-	/* return true if there's an ethernet packet ready to read */
-	struct priv *p;         /* SK_G16 private structure */
-	struct rmd *rmdp;
-	int csr0, rmdstat, packet_there;
-    PRINTF2(("## %s: At beginning of SK_poll(). CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-
-	p = nic->priv_data;
-    csr0 = SK_read_reg(CSR0);      /* store register for checking */
-
-    /*
-     * Acknowledge all of the current interrupt sources, disable
-     * Interrupts (INEA = 0)
-     */
-
-    SK_write_reg(CSR0, csr0 & CSR0_CLRALL);
-
-    if (csr0 & CSR0_ERR) /* LANCE Error */
-    {
-	printf("%s: error: %#hX", SK_NAME, csr0);
-
-        if (csr0 & CSR0_MISS)      /* No place to store packet ? */
-        {
-		printf(", Packet dropped.");
-        }
-	putchar('\n');
-    }
-
-    rmdp = p->rmdhead + p->rmdnum;
-    packet_there = 0;
-    /* As long as we own the next entry, check status and send
-     * it up to higher layer
-     */
-
-    while (!( (rmdstat = rmdp->u.s.status) & RX_OWN))
-    {
-	/*
-         * Start and end of packet must be set, because we use
-	 * the ethernet maximum packet length (1518) as buffer size.
-	 *
-	 * Because our buffers are at maximum OFLO and BUFF errors are
-	 * not to be concerned (see Data sheet)
-	 */
-
-	if ((rmdstat & (RX_STP | RX_ENP)) != (RX_STP | RX_ENP))
-	{
-	    /* Start of a frame > 1518 Bytes ? */
-
-	    if (rmdstat & RX_STP)
-	    {
-		printf("%s: packet too long\n", SK_NAME);
-	    }
-
-	    /*
-             * All other packets will be ignored until a new frame with
-	     * start (RX_STP) set follows.
-	     *
-	     * What we do is just give descriptor free for new incoming
-	     * packets.
-	     */
-
-	    rmdp->u.s.status = RX_OWN;      /* Relinquish ownership to LANCE */
-
-	}
-	else if (rmdstat & RX_ERR)          /* Receive Error ? */
-	{
-	    printf("%s: RX error: %#hX\n", SK_NAME, (int) rmdstat);
-	    rmdp->u.s.status = RX_OWN;      /* Relinquish ownership to LANCE */
-	}
-	else /* We have a packet which can be queued for the upper layers */
-	{
-
-	    int len = (rmdp->mlen & 0x0fff);  /* extract message length from receive buffer */
-
-	    /*
-             * Copy data out of our receive descriptor into nic->packet.
-	     *
-	     * (rmdp->u.buffer & 0x00ffffff) -> get address of buffer and
-	     * ignore status fields)
-	     */
-
-	    memcpy(nic->packet, (unsigned char *) (rmdp->u.buffer & 0x00ffffff), nic->packetlen = len);
-	    packet_there = 1;
-
-
-	    /*
-             * Packet is queued and marked for processing so we
-	     * free our descriptor
-	     */
-
-	    rmdp->u.s.status = RX_OWN;
-
-	    p->rmdnum++;
-	    p->rmdnum %= RMDNUM;
-
-	    rmdp = p->rmdhead + p->rmdnum;
-	}
-    }
-    SK_write_reg(CSR0, CSR0_INEA); /* Enable Interrupts */
-	return (packet_there);
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void SK_transmit(
-struct nic *nic,
-const char *d,			/* Destination */
-unsigned int t,			/* Type */
-unsigned int s,			/* size */
-const char *pack)		/* Packet */
-{
-	/* send the packet to destination */
-    struct priv *p;         /* SK_G16 private structure */
-    struct tmd *tmdp;
-    short len;
-    int csr0, i, tmdstat;
-
-    PRINTF2(("## %s: At beginning of SK_transmit(). CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-	p = nic->priv_data;
-	tmdp = p->tmdhead + p->tmdnum; /* Which descriptor for transmitting */
-
-	/* Copy data into dual ported ram */
-
-	memcpy(&p->ram->tmdbuf[p->tmdnum][0], d, ETH_ALEN);	/* dst */
-	memcpy(&p->ram->tmdbuf[p->tmdnum][ETH_ALEN], nic->node_addr, ETH_ALEN); /* src */
-	p->ram->tmdbuf[p->tmdnum][ETH_ALEN + ETH_ALEN] = t >> 8;	/* type */
-	p->ram->tmdbuf[p->tmdnum][ETH_ALEN + ETH_ALEN + 1] = t;	/* type */
-	memcpy(&p->ram->tmdbuf[p->tmdnum][ETH_HLEN], pack, s);
-	s += ETH_HLEN;
-	while (s < ETH_ZLEN)	/* pad to min length */
-		p->ram->tmdbuf[p->tmdnum][s++] = 0;
-	p->ram->tmde[p->tmdnum].status2 = 0x0;
-
-	/* Evaluate Packet length */
-	len = ETH_ZLEN < s ? s : ETH_ZLEN;
-
-	/* Fill in Transmit Message Descriptor */
-
-	tmdp->blen = -len;            /* set length to transmit */
-
-	/*
-	 * Packet start and end is always set because we use the maximum
-	 * packet length as buffer length.
-	 * Relinquish ownership to LANCE
-	 */
-
-	tmdp->u.s.status = TX_OWN | TX_STP | TX_ENP;
-
-	/* Start Demand Transmission */
-	SK_write_reg(CSR0, CSR0_TDMD | CSR0_INEA);
-
-    csr0 = SK_read_reg(CSR0);      /* store register for checking */
-
-    /*
-     * Acknowledge all of the current interrupt sources, disable
-     * Interrupts (INEA = 0)
-     */
-
-    SK_write_reg(CSR0, csr0 & CSR0_CLRALL);
-
-    if (csr0 & CSR0_ERR) /* LANCE Error */
-    {
-	printf("%s: error: %#hX", SK_NAME, csr0);
-
-        if (csr0 & CSR0_MISS)      /* No place to store packet ? */
-        {
-		printf(", Packet dropped.");
-        }
-	putchar('\n');
-    }
-
-
-    /* Set next buffer */
-    p->tmdlast++;
-    p->tmdlast &= TMDNUM-1;
-
-    tmdstat = tmdp->u.s.status & 0xff00; /* filter out status bits 15:08 */
-
-    /*
-     * We check status of transmitted packet.
-     * see LANCE data-sheet for error explanation
-     */
-    if (tmdstat & TX_ERR) /* Error occurred */
-    {
-	printf("%s: TX error: %#hX %#hX\n", SK_NAME, (int) tmdstat,
-		(int) tmdp->status2);
-
-	if (tmdp->status2 & TX_TDR)    /* TDR problems? */
-	{
-	    printf("%s: tdr-problems \n", SK_NAME);
-	}
-
-        if (tmdp->status2 & TX_UFLO)   /* Underflow error ? */
-        {
-            /*
-             * If UFLO error occurs it will turn transmitter of.
-             * So we must reinit LANCE
-             */
-
-            SK_lance_init(nic, MODE_NORMAL);
-        }
-
-	tmdp->status2 = 0;             /* Clear error flags */
-    }
-
-    SK_write_reg(CSR0, CSR0_INEA); /* Enable Interrupts */
-
-	/* Set pointer to next transmit buffer */
-	p->tmdnum++;
-	p->tmdnum &= TMDNUM-1;
-
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void SK_disable(struct nic *nic)
-{
-    PRINTF(("## %s: At beginning of SK_disable(). CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-    PRINTF(("%s: Shutting %s down CSR0 %#hX\n", SK_NAME, SK_NAME,
-           (int) SK_read_reg(CSR0)));
-
-    SK_write_reg(CSR0, CSR0_STOP); /* STOP the LANCE */
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-***************************************************************************/
-struct nic *SK_probe(struct nic *nic, unsigned short *probe_addrs)
-{
-	unsigned short		*p;
-	static unsigned short	io_addrs[] = SK_IO_PORTS;
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	putchar('\n');
-	nic->priv_data = &p_data;
-	if (probe_addrs == 0)
-		probe_addrs = io_addrs;
-	for (p = probe_addrs; (ioaddr = *p) != 0; ++p)
-	{
-		long		offset1, offset0 = inb(ioaddr);
-		if ((offset0 == SK_IDLOW) &&
-		 ((offset1 = inb(ioaddr + 1)) == SK_IDHIGH))
-			if (SK_probe1(nic, ioaddr) >= 0)
-				break;
-	}
-	/* if board found */
-	if (ioaddr != 0)
-	{
-		/* point to NIC specific routines */
-		nic->reset = SK_reset;
-		nic->poll = SK_poll;
-		nic->transmit = SK_transmit;
-		nic->disable = SK_disable;
-		return nic;
-	}
-	/* else */
-	{
-		return 0;
-	}
-}
-
-int SK_probe1(struct nic *nic, short ioaddr1)
-{
-    int i,j;                /* Counters */
-    int sk_addr_flag = 0;   /* SK ADDR correct? 1 - no, 0 - yes */
-    unsigned int rom_addr;  /* used to store RAM address used for POS_ADDR */
-
-    struct priv *p;         /* SK_G16 private structure */
-
-    if (SK_ADDR & 0x3fff || SK_ADDR < 0xa0000)
-    {
-       /*
-        * Now here we could use a routine which searches for a free
-        * place in the ram and set SK_ADDR if found. TODO.
-        */
-            printf("%s: SK_ADDR %#hX is not valid. Check configuration.\n",
-                    SK_NAME, SK_ADDR);
-            return -1;
-    }
-
-    rom_addr = SK_ADDR;
-
-    outb(SK_ROM_RAM_OFF, SK_POS2); /* Boot_ROM + RAM off */
-    outb(POS_ADDR, SK_POS3);       /* Set RAM address */
-    outb(SK_ROM_RAM_ON, SK_POS2);  /* RAM on, BOOT_ROM on */
-#ifdef	SK_DEBUG
-    SK_print_pos(nic, "POS registers after ROM, RAM config");
-#endif
-
-    board = (SK_RAM *) rom_addr;
-	PRINTF(("adr[0]: %hX, adr[1]: %hX, adr[2]: %hX\n",
-	board->rom[0], board->rom[2], board->rom[4]));
-
-    /* Read in station address */
-    for (i = 0, j = 0; i < ETH_ALEN; i++, j+=2)
-    {
-	*(nic->node_addr+i) = board->rom[j];
-    }
-
-    /* Check for manufacturer code */
-#ifdef	SK_DEBUG
-    if (!(*(nic->node_addr+0) == SK_MAC0 &&
-	  *(nic->node_addr+1) == SK_MAC1 &&
-	  *(nic->node_addr+2) == SK_MAC2) )
-    {
-        PRINTF(("## %s: We did not find SK_G16 at RAM location.\n",
-                SK_NAME));
-	return -1;                     /* NO SK_G16 found */
-    }
-#endif
-
-    p = nic->priv_data;
-
-    /* Initialize private structure */
-
-    p->ram = (struct SK_ram *) rom_addr; /* Set dual ported RAM addr */
-    p->tmdhead = &(p->ram)->tmde[0];     /* Set TMD head */
-    p->rmdhead = &(p->ram)->rmde[0];     /* Set RMD head */
-
-    printf("Schneider & Koch G16 at %#hX, mem at %#hX, HW addr: %!\n",
-	    (unsigned int) ioaddr, (unsigned int) p->ram, nic->node_addr);
-
-    /* Initialize buffer pointers */
-
-    for (i = 0; i < TMDNUM; i++)
-    {
-	p->tmdbufs[i] = p->ram->tmdbuf[i];
-    }
-
-    for (i = 0; i < RMDNUM; i++)
-    {
-	p->rmdbufs[i] = p->ram->rmdbuf[i];
-    }
-    i = 0;
-
-    if (!(i = SK_lance_init(nic, MODE_NORMAL)))  /* LANCE init OK? */
-    {
-
-#ifdef	SK_DEBUG
-        /*
-         * This debug block tries to stop LANCE,
-         * reinit LANCE with transmitter and receiver disabled,
-         * then stop again and reinit with NORMAL_MODE
-         */
-
-        printf("## %s: After lance init. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_write_reg(CSR0, CSR0_STOP);
-        printf("## %s: LANCE stopped. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_lance_init(nic, MODE_DTX | MODE_DRX);
-        printf("## %s: Reinit with DTX + DRX off. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_write_reg(CSR0, CSR0_STOP);
-        printf("## %s: LANCE stopped. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_lance_init(nic, MODE_NORMAL);
-        printf("## %s: LANCE back to normal mode. CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0));
-        SK_print_pos(nic, "POS regs before returning OK");
-
-#endif	/* SK_DEBUG */
-
-    }
-    else /* LANCE init failed */
-    {
-
-	PRINTF(("## %s: LANCE init failed: CSR0: %#hX\n",
-               SK_NAME, SK_read_reg(CSR0)));
-	return -1;
-    }
-
-#ifdef	SK_DEBUG
-    SK_print_pos(nic, "End of SK_probe1");
-    SK_print_ram(nic);
-#endif
-
-    return 0;                            /* Initialization done */
-
-} /* End of SK_probe1() */
-
-static int SK_lance_init(struct nic *nic, unsigned short mode)
-{
-    int i;
-    struct priv *p = (struct priv *) nic->priv_data;
-    struct tmd  *tmdp;
-    struct rmd  *rmdp;
-
-    PRINTF(("## %s: At beginning of LANCE init. CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-
-    /* Reset LANCE */
-    SK_reset_board();
-
-    /* Initialize TMD's with start values */
-    p->tmdnum = 0;                   /* First descriptor for transmitting */
-    p->tmdlast = 0;                  /* First descriptor for reading stats */
-
-    for (i = 0; i < TMDNUM; i++)     /* Init all TMD's */
-    {
-	tmdp = p->tmdhead + i;
-
-	tmdp->u.buffer = (unsigned long) p->tmdbufs[i]; /* assign buffer */
-
-	/* Mark TMD as start and end of packet */
-	tmdp->u.s.status = TX_STP | TX_ENP;
-    }
-
-
-    /* Initialize RMD's with start values */
-
-    p->rmdnum = 0;                   /* First RMD which will be used */
-
-    for (i = 0; i < RMDNUM; i++)     /* Init all RMD's */
-    {
-	rmdp = p->rmdhead + i;
-
-
-	rmdp->u.buffer = (unsigned long) p->rmdbufs[i]; /* assign buffer */
-
-	/*
-         * LANCE must be owner at beginning so that he can fill in
-	 * receiving packets, set status and release RMD
-	 */
-
-	rmdp->u.s.status = RX_OWN;
-
-	rmdp->blen = -PKT_BUF_SZ;    /* Buffer Size in a two's complement */
-
-	rmdp->mlen = 0;              /* init message length */
-
-    }
-
-    /* Fill LANCE Initialize Block */
-
-    (p->ram)->ib.mode = mode;        /* Set operation mode */
-
-    for (i = 0; i < ETH_ALEN; i++)   /* Set physical address */
-    {
-	(p->ram)->ib.paddr[i] = *(nic->node_addr+i);
-    }
-
-    for (i = 0; i < 8; i++)          /* Set multicast, logical address */
-    {
-	(p->ram)->ib.laddr[i] = 0;   /* We do not use logical addressing */
-    }
-
-    /* Set ring descriptor pointers and set number of descriptors */
-
-    (p->ram)->ib.rdrp = (int)  p->rmdhead | RMDNUMMASK;
-    (p->ram)->ib.tdrp = (int)  p->tmdhead | TMDNUMMASK;
-
-    /* Prepare LANCE Control and Status Registers */
-
-    SK_write_reg(CSR3, CSR3_ACON);   /* Ale Control !!!THIS MUST BE SET!!!! */
-
-    /*
-     * LANCE addresses the RAM from 0x0000 to 0x3fbf and has no access to
-     * PC Memory locations.
-     *
-     * In structure SK_ram is defined that the first thing in ram
-     * is the initialization block. So his address is for LANCE always
-     * 0x0000
-     *
-     * CSR1 contains low order bits 15:0 of initialization block address
-     * CSR2 is built of:
-     *    7:0  High order bits 23:16 of initialization block address
-     *   15:8  reserved, must be 0
-     */
-
-    /* Set initialization block address (must be on word boundary) */
-    SK_write_reg(CSR1, 0);          /* Set low order bits 15:0 */
-    SK_write_reg(CSR2, 0);          /* Set high order bits 23:16 */
-
-
-    PRINTF(("## %s: After setting CSR1-3. CSR0: %#hX\n",
-           SK_NAME, SK_read_reg(CSR0)));
-
-    /* Initialize LANCE */
-
-    /*
-     * INIT = Initialize, when set, causes the LANCE to begin the
-     * initialization procedure and access the Init Block.
-     */
-
-    SK_write_reg(CSR0, CSR0_INIT);
-
-    /* Wait until LANCE finished initialization */
-
-    SK_set_RAP(CSR0);              /* Register Address Pointer to CSR0 */
-
-    for (i = 0; (i < 100) && !(SK_rread_reg() & CSR0_IDON); i++)
-	; /* Wait until init done or go ahead if problems (i>=100) */
-
-    if (i >= 100) /* Something is wrong ! */
-    {
-	printf("%s: can't init am7990, status: %#hX "
-	       "init_block: %#hX\n",
-		SK_NAME, (int) SK_read_reg(CSR0),
-		(unsigned int) &(p->ram)->ib);
-
-#ifdef	SK_DEBUG
-	SK_print_pos(nic, "LANCE INIT failed");
-#endif
-
-	return -1;                 /* LANCE init failed */
-    }
-
-    PRINTF(("## %s: init done after %d ticks\n", SK_NAME, i));
-
-    /* Clear Initialize done, enable Interrupts, start LANCE */
-
-    SK_write_reg(CSR0, CSR0_IDON | CSR0_INEA | CSR0_STRT);
-
-    PRINTF(("## %s: LANCE started. CSR0: %#hX\n", SK_NAME,
-            SK_read_reg(CSR0)));
-
-    return 0;                      /* LANCE is up and running */
-
-} /* End of SK_lance_init() */
-
-/* LANCE access functions
- *
- * ! CSR1-3 can only be accessed when in CSR0 the STOP bit is set !
- */
-
-static void SK_reset_board(void)
-{
-    int i;
-
-	PRINTF(("## %s: At beginning of SK_reset_board.\n", SK_NAME));
-    SK_PORT = 0x00;           /* Reset active */
-    for (i = 0; i < 10 ; i++) /* Delay min 5ms */
-	;
-    SK_PORT = SK_RESET;       /* Set back to normal operation */
-
-} /* End of SK_reset_board() */
-
-static void SK_set_RAP(int reg_number)
-{
-    SK_IOREG = reg_number;
-    SK_PORT  = SK_RESET | SK_RAP | SK_WREG;
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-} /* End of SK_set_RAP() */
-
-static int SK_read_reg(int reg_number)
-{
-    SK_set_RAP(reg_number);
-
-    SK_PORT  = SK_RESET | SK_RDATA | SK_RREG;
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-    return (SK_IOREG);
-
-} /* End of SK_read_reg() */
-
-static int SK_rread_reg(void)
-{
-    SK_PORT  = SK_RESET | SK_RDATA | SK_RREG;
-
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-    return (SK_IOREG);
-
-} /* End of SK_rread_reg() */
-
-static void SK_write_reg(int reg_number, int value)
-{
-    SK_set_RAP(reg_number);
-
-    SK_IOREG = value;
-    SK_PORT  = SK_RESET | SK_RDATA | SK_WREG;
-    SK_IOCOM = SK_DOIO;
-
-    while (SK_PORT & SK_IORUN)
-	;
-} /* End of SK_write_reg */
-
-/*
- * Debugging functions
- * -------------------
- */
-
-#ifdef	SK_DEBUG
-static void SK_print_pos(struct nic *nic, char *text)
-{
-
-    unsigned char pos0 = inb(SK_POS0),
-		  pos1 = inb(SK_POS1),
-		  pos2 = inb(SK_POS2),
-		  pos3 = inb(SK_POS3),
-		  pos4 = inb(SK_POS4);
-
-
-    printf("## %s: %s.\n"
-           "##   pos0=%#hX pos1=%#hX pos2=%#hX pos3=%#hX pos4=%#hX\n",
-           SK_NAME, text, pos0, pos1, pos2, (pos3<<14), pos4);
-
-} /* End of SK_print_pos() */
-
-static void SK_print_ram(struct nic *nic)
-{
-
-    int i;
-    struct priv *p = (struct priv *) nic->priv_data;
-
-    printf("## %s: RAM Details.\n"
-           "##   RAM at %#hX tmdhead: %#hX rmdhead: %#hX initblock: %#hX\n",
-           SK_NAME,
-           (unsigned int) p->ram,
-           (unsigned int) p->tmdhead,
-           (unsigned int) p->rmdhead,
-           (unsigned int) &(p->ram)->ib);
-
-    printf("##   ");
-
-    for(i = 0; i < TMDNUM; i++)
-    {
-           if (!(i % 3)) /* Every third line do a newline */
-           {
-               printf("\n##   ");
-           }
-        printf("tmdbufs%d: %#hX ", (i+1), (int) p->tmdbufs[i]);
-    }
-    printf("##   ");
-
-    for(i = 0; i < RMDNUM; i++)
-    {
-         if (!(i % 3)) /* Every third line do a newline */
-           {
-               printf("\n##   ");
-           }
-        printf("rmdbufs%d: %#hX ", (i+1), (int) p->rmdbufs[i]);
-    }
-    putchar('\n');
-
-} /* End of SK_print_ram() */
-#endif
Index: netboot/igmp.h
===================================================================
--- netboot/igmp.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/igmp.h	(.../trunk)	(revision 112)
@@ -0,0 +1,27 @@
+#ifndef	_IGMP_H
+#define	_IGMP_H
+
+/* Max interval between IGMP packets */
+#define IGMP_INTERVAL			(10*TICKS_PER_SEC)
+#define IGMPv1_ROUTER_PRESENT_TIMEOUT	(400*TICKS_PER_SEC)
+
+#define IGMP_QUERY	0x11
+#define IGMPv1_REPORT	0x12
+#define IGMPv2_REPORT	0x16
+#define IGMP_LEAVE	0x17
+#define GROUP_ALL_HOSTS 0xe0000001 /* 224.0.0.1 Host byte order */
+
+struct igmp {
+	uint8_t  type;
+	uint8_t  response_time;
+	uint16_t chksum;
+	in_addr group;
+};
+
+struct igmp_ip_t { /* Format of an igmp ip packet */
+	struct iphdr ip;
+	uint8_t router_alert[4]; /* Router alert option */
+	struct igmp igmp;
+};
+
+#endif	/* _IGMP_H */
Index: netboot/big_bswap.h
===================================================================
--- netboot/big_bswap.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/big_bswap.h	(.../trunk)	(revision 112)
@@ -0,0 +1,17 @@
+#ifndef ETHERBOOT_BIG_BSWAP_H
+#define ETHERBOOT_BIG_BSWAP_H
+
+#define ntohl(x) 	(x)
+#define htonl(x) 	(x)
+#define ntohs(x) 	(x)
+#define htons(x) 	(x)
+#define cpu_to_le32(x)	__bswap_32(x)
+#define cpu_to_le16(x)	__bswap_16(x)
+#define cpu_to_be32(x)	(x)
+#define cpu_to_be16(x)	(x)
+#define le32_to_cpu(x)	__bswap_32(x)
+#define le16_to_cpu(x)	__bswap_16(x)
+#define be32_to_cpu(x)	(x)
+#define be16_to_cpu(x)	(x)
+
+#endif /* ETHERBOOT_BIG_BSWAP_H */
Index: netboot/byteswap.h
===================================================================
--- netboot/byteswap.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/byteswap.h	(.../trunk)	(revision 112)
@@ -0,0 +1,20 @@
+#ifndef ETHERBOOT_BYTESWAP_H
+#define ETHERBOOT_BYTESWAP_H
+
+#include "endian.h"
+#include "i386_byteswap.h"
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#include "little_bswap.h"
+#endif
+#if __BYTE_ORDER == __BIG_ENDIAN
+#include "big_bswap.h"
+#endif
+
+/* Make routines available to all */
+#define swap32(x)	__bswap_32(x)
+#define swap16(x)	__bswap_16(x)
+#define bswap_32(x)	__bswap_32(x)
+#define bswap_16(x)	__bswap_16(x)
+	
+#endif /* ETHERBOOT_BYTESWAP_H */
Index: netboot/endian.h
===================================================================
--- netboot/endian.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/endian.h	(.../trunk)	(revision 112)
@@ -0,0 +1,19 @@
+#ifndef ETHERBOOT_ENDIAN_H
+#define ETHERBOOT_ENDIAN_H
+
+/* Definitions for byte order, according to significance of bytes,
+   from low addresses to high addresses.  The value is what you get by
+   putting '4' in the most significant byte, '3' in the second most
+   significant byte, '2' in the second least significant byte, and '1'
+   in the least significant byte, and then writing down one digit for
+   each byte, starting with the byte at the lowest address at the left,
+   and proceeding to the byte with the highest address at the right.  */
+
+#define __LITTLE_ENDIAN 1234
+#define __BIG_ENDIAN    4321
+#define __PDP_ENDIAN    3412
+
+#include "i386_endian.h"
+
+
+#endif /* ETHERBOOT_ENDIAN_H */
Index: netboot/config.c
===================================================================
--- netboot/config.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/config.c	(.../trunk)	(revision 112)
@@ -1,598 +1,165 @@
 /*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2001,2002  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* Based on "src/config.c" in etherboot-5.0.5.  */
-
-/*
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2, or (at
  * your option) any later version.
  */
 
-#define GRUB	1
-#include <etherboot.h>
-#include <nic.h>
+#include	"grub.h"
+#include	"pci.h"
+#include	"isa.h"
+#include	"nic.h"
 
-#undef	INCLUDE_PCI
-#if	defined(INCLUDE_NS8390) || defined(INCLUDE_EEPRO100) || defined(INCLUDE_LANCE) || defined(INCLUDE_EPIC100) || defined(INCLUDE_TULIP) || defined(INCLUDE_OTULIP) || defined(INCLUDE_3C90X) ||  defined(INCLUDE_3C595) || defined(INCLUDE_RTL8139) || defined(INCLUDE_VIA_RHINE) || defined(INCLUDE_W89C840) || defined(INCLUDE_DAVICOM) || defined(INCLUDE_SIS900) || defined(INCLUDE_NATSEMI) || defined(INCLUDE_TLAN)
-	/* || others later */
-# define INCLUDE_PCI
-# include <pci.h>
-static unsigned short pci_ioaddrs[16];
-
-static struct pci_device pci_nic_list[] =
+#ifdef CONFIG_PCI
+static int pci_probe(struct dev *dev, const char *type_name)
 {
-#ifdef	INCLUDE_NS8390
-  { PCI_VENDOR_ID_REALTEK,	PCI_DEVICE_ID_REALTEK_8029,
-    "Realtek 8029", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C940,
-    "Winbond NE2000-PCI", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_COMPEX,	PCI_DEVICE_ID_COMPEX_RL2000,
-    "Compex ReadyLink 2000", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_KTI,		PCI_DEVICE_ID_KTI_ET32P2,
-    "KTI ET32P2", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_NETVIN,	PCI_DEVICE_ID_NETVIN_NV5000SC,
-    "NetVin NV5000SC", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_HOLTEK,	PCI_DEVICE_ID_HOLTEK_HT80232,
-    "Holtek HT80232", 0, 0, 0, 0},
+/*
+ *	NIC probing is in pci device order, followed by the 
+ *      link order of the drivers.  A driver that matches 
+ *      on vendor and device id will supersede a driver
+ *      that matches on pci class.
+ *
+ *	If you want to probe for another device behind the same pci
+ *      device just increment index.  And the previous probe call
+ *      will be repeated.
+ */
+	struct pci_probe_state *state = &dev->state.pci;
+	printf("Probing pci %s...\n", type_name);
+	if (dev->how_probe == PROBE_FIRST) {
+		state->advance    = 1;
+		state->dev.driver = 0;
+		state->dev.bus    = 0;
+		state->dev.devfn  = 0;
+		dev->index        = -1;
+	}
+	for(;;) {
+		if ((dev->how_probe != PROBE_AWAKE) && state->advance) {
+			find_pci(dev->type, &state->dev);
+			dev->index = -1;
+		}
+		state->advance = 1;
+		
+		if (state->dev.driver == 0)
+			break;
+		
+#if 0
+		/* FIXME the romaddr code needs a total rethought to be useful */
+		if (state->dev.romaddr != ((unsigned long) rom.rom_segment << 4)) {
+			continue;
+		}
 #endif
-#ifdef	INCLUDE_3C90X
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900TPO,
-    "3Com900-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900COMBO,
-    "3Com900-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905TX,
-    "3Com905-TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905T4,
-    "3Com905-T4", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9004,
-    "3Com900B-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9005,
-    "3Com900B-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9006,
-    "3Com900B-2/T", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x900A,
-    "3Com900B-FL", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905B_TX,
-    "3Com905B-TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9056,
-    "3Com905B-T4", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x905A,
-    "3Com905B-FL", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C905C_TXM,
-    "3Com905C-TXM", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9800,
-    "3Com980-Cyclone", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9805,
-    "3Com9805", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x7646,
-    "3CSOHO100-TX", 0, 0, 0, 0},
+		if (dev->how_probe != PROBE_AWAKE) {
+			dev->type_index++;
+		}
+		dev->devid.bus_type = PCI_BUS_TYPE;
+		dev->devid.vendor_id = htons(state->dev.vendor);
+		dev->devid.device_id = htons(state->dev.dev_id);
+		/* FIXME how do I handle dev->index + PROBE_AGAIN?? */
+		
+		printf("[%s]", state->dev.name);
+		if (state->dev.driver->probe(dev, &state->dev)) {
+			state->advance = (dev->index == -1);
+			return PROBE_WORKED;
+		}
+		putchar('\n');
+	}
+	return PROBE_FAILED;
+}
 #endif
-#ifdef	INCLUDE_3C595
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C590,
-    "3Com590", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595,
-    "3Com595", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595_1,
-    "3Com595", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C595_2,
-    "3Com595", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900TPO,
-    "3Com900-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		PCI_DEVICE_ID_3COM_3C900COMBO,
-    "3Com900-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9004,
-    "3Com900B-TPO", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9005,
-    "3Com900B-Combo", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9006,
-    "3Com900B-2/T", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x900A,
-    "3Com900B-FL", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9800,
-    "3Com980-Cyclone", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x9805,
-    "3Com9805", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_3COM,		0x7646,
-    "3CSOHO100-TX", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_EEPRO100
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82557,
-    "Intel EtherExpressPro100", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82559ER,
-    "Intel EtherExpressPro100 82559ER", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_ID1029,
-    "Intel EtherExpressPro100 ID1029", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_ID1030,
-    "Intel Corporation 82559 InBusiness 10/100", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82562,
-    "Intel EtherExpressPro100 82562EM", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_EPIC100
-  { PCI_VENDOR_ID_SMC,		PCI_DEVICE_ID_SMC_EPIC100,
-    "SMC EtherPowerII", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_LANCE
-  { PCI_VENDOR_ID_AMD,		PCI_DEVICE_ID_AMD_LANCE,
-    "AMD Lance/PCI", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_AMD_HOMEPNA,	PCI_DEVICE_ID_AMD_HOMEPNA,
-    "AMD Lance/HomePNA", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_RTL8139
-  { PCI_VENDOR_ID_REALTEK,	PCI_DEVICE_ID_REALTEK_8139,
-    "Realtek 8139", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DLINK,	PCI_DEVICE_ID_DFE530TXP,
-    "DFE530TX+/DFE538TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_SMC_1211,	PCI_DEVICE_ID_SMC_1211,
-    "SMC EZ10/100", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_OTULIP
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP,
-    "Digital Tulip", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_FAST,
-    "Digital Tulip Fast", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_PLUS,
-    "Digital Tulip+", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_21142,
-    "Digital Tulip 21142", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_TULIP
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP,
-    "Digital Tulip", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_FAST,
-    "Digital Tulip Fast", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_TULIP_PLUS,
-    "Digital Tulip+", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DEC,		PCI_DEVICE_ID_DEC_21142,
-    "Digital Tulip 21142", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_MACRONIX,	PCI_DEVICE_ID_MX987x5,
-    "Macronix MX987x5", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_LINKSYS,	PCI_DEVICE_ID_LC82C115,
-    "LinkSys LNE100TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_LINKSYS,	PCI_DEVICE_ID_DEC_TULIP,
-    "Netgear FA310TX", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9102,
-    "Davicom 9102", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9009,
-    "Davicom 9009", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_ADMTEK,	PCI_DEVICE_ID_ADMTEK_0985,
-    "ADMtek Centaur-P", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_ADMTEK,	0x0981,
-    "ADMtek AN981 Comet", 0, 0, 0, 0},
-  { 0x125B,			0x1400,
-    "ASIX AX88140", 0, 0, 0, 0 },
-  { 0x11F6,			0x9881,
-    "Compex RL100-TX", 0, 0, 0, 0 },
-#endif
-#ifdef	INCLUDE_DAVICOM
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9102,
-    "Davicom 9102", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_DAVICOM,	PCI_DEVICE_ID_DM9009,
-    "Davicom 9009", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_VIA_RHINE
-  { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_VT6102,
-    "VIA 6102", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_RHINE_I,
-    "VIA 3043", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_VIATEC,	PCI_DEVICE_ID_VIA_86C100A,
-    "VIA 86C100A", 0, 0, 0, 0},
-#endif
-#ifdef	INCLUDE_W89C840
-  { PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C840,
-    "Winbond W89C840F", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_COMPEX,	PCI_DEVICE_ID_COMPEX_RL100ATX,
-    "Compex RL100ATX", 0, 0, 0, 0},
-#endif
-#ifdef INCLUDE_SIS900
-  { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS900,
-    "SIS900", 0, 0, 0, 0},
-  { PCI_VENDOR_ID_SIS,     	PCI_DEVICE_ID_SIS7016,
-    "SIS7016", 0, 0, 0, 0},
-#endif
-  
-#ifdef INCLUDE_NATSEMI
-  { PCI_VENDOR_ID_NS,	     	PCI_DEVICE_ID_DP83815,
-    "DP83815", 0, 0, 0, 0},
-#endif
-  
-#ifdef INCLUDE_TLAN
-  { PCI_VENDOR_ID_OLICOM,	PCI_DEVICE_ID_OLICOM_OC2326,
-    "OC2326", 0, 0, 0, 0},
-#endif
 
-  /* other PCI NICs go here */
-  {0, 0, NULL, 0, 0, 0, 0}
-};
-#endif	/* INCLUDE_*PCI */
-
-#include <cards.h>
-
-#ifdef INCLUDE_PCI
-struct pci_dispatch_table
+#ifdef CONFIG_ISA
+static int isa_probe(struct dev *dev, const char *type_name)
 {
-  unsigned short vendor;
-  unsigned short dev_id;
-  struct nic *(*eth_probe) (struct nic *, unsigned short *,
-			    struct pci_device *);
-};
-
-static struct pci_dispatch_table PCI_NIC[] =
-{
-# ifdef INCLUDE_NS8390
-  { PCI_VENDOR_ID_REALTEK,  PCI_DEVICE_ID_REALTEK_8029,    nepci_probe },
-  { PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C940, nepci_probe },
-  { PCI_VENDOR_ID_COMPEX,   PCI_DEVICE_ID_COMPEX_RL2000,   nepci_probe },
-  { PCI_VENDOR_ID_KTI,      PCI_DEVICE_ID_KTI_ET32P2,      nepci_probe },
-  { PCI_VENDOR_ID_NETVIN,   PCI_DEVICE_ID_NETVIN_NV5000SC, nepci_probe },
-  { PCI_VENDOR_ID_HOLTEK,   PCI_DEVICE_ID_HOLTEK_HT80232,  nepci_probe },
-# endif /* INCLUDE_NS8390 */
-# ifdef INCLUDE_3C90X
-  { PCI_VENDOR_ID_3COM,	    PCI_DEVICE_ID_3COM_3C900TPO,   a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900COMBO, a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905TX,    a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905T4,    a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9004,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9005,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9006,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x900A,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905B_TX,  a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9056,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x905A,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C905C_TXM, a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9800,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x9805,                        a3c90x_probe },
-  { PCI_VENDOR_ID_3COM,     0x7646,                        a3c90x_probe },
-# endif /* INCLUDE_3C90X */
-# ifdef	INCLUDE_3C595
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C590,      t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595,      t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595_1,    t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C595_2,    t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900TPO,   t595_probe },
-  { PCI_VENDOR_ID_3COM,     PCI_DEVICE_ID_3COM_3C900COMBO, t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9004,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9005,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9006,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x900A,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9800,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x9805,                        t595_probe },
-  { PCI_VENDOR_ID_3COM,     0x7646,                        t595_probe },
-# endif /* INCLUDE_3C595 */
-# ifdef	INCLUDE_EEPRO100
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82557,     eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82559ER,   eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ID1029,    eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ID1030,    eepro100_probe },
-  { PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82562,     eepro100_probe },
-# endif /* INCLUDE_EEPRO100 */
-# ifdef	INCLUDE_EPIC100
-  { PCI_VENDOR_ID_SMC,      PCI_DEVICE_ID_SMC_EPIC100,     epic100_probe },
-# endif /* INCLUDE_EPIC100 */
-# ifdef	INCLUDE_LANCE
-  { PCI_VENDOR_ID_AMD,      PCI_DEVICE_ID_AMD_LANCE,       lancepci_probe },
-  { PCI_VENDOR_ID_AMD_HOMEPNA, PCI_DEVICE_ID_AMD_HOMEPNA,  lancepci_probe },
-# endif /* INCLUDE_LANCE */
-# ifdef	INCLUDE_RTL8139
-  { PCI_VENDOR_ID_REALTEK,  PCI_DEVICE_ID_REALTEK_8139,    rtl8139_probe },
-  { PCI_VENDOR_ID_DLINK,    PCI_DEVICE_ID_DFE530TXP,       rtl8139_probe },
-  { PCI_VENDOR_ID_SMC_1211, PCI_DEVICE_ID_SMC_1211,        rtl8139_probe },
-# endif /* INCLUDE_RTL8139 */
-# ifdef	INCLUDE_OTULIP
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP,       otulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_FAST,  otulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_PLUS,  otulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_21142,       otulip_probe },
-# endif /* INCLUDE_OTULIP */
-# ifdef	INCLUDE_TULIP
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP,       tulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_FAST,  tulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_TULIP_PLUS,  tulip_probe },
-  { PCI_VENDOR_ID_DEC,      PCI_DEVICE_ID_DEC_21142,       tulip_probe },
-  { PCI_VENDOR_ID_MACRONIX, PCI_DEVICE_ID_MX987x5,         tulip_probe },
-  { PCI_VENDOR_ID_LINKSYS,  PCI_DEVICE_ID_LC82C115,        tulip_probe },
-  { PCI_VENDOR_ID_LINKSYS,  PCI_DEVICE_ID_DEC_TULIP,       tulip_probe },
-  { PCI_VENDOR_ID_DAVICOM,  PCI_DEVICE_ID_DM9102,          tulip_probe },
-  { PCI_VENDOR_ID_DAVICOM,  PCI_DEVICE_ID_DM9009,          tulip_probe },
-  { PCI_VENDOR_ID_ADMTEK,   PCI_DEVICE_ID_ADMTEK_0985,     tulip_probe },
-  { PCI_VENDOR_ID_ADMTEK,   0x0981,                        tulip_probe },
-  { 0x125B,                 0x1400,                        tulip_probe },
-  { 0x11F6,                 0x9881,                        tulip_probe },
-# endif /* INCLUDE_TULIP */
-# ifdef INCLUDE_DAVICOM
-  { PCI_VENDOR_ID_DAVICOM,   PCI_DEVICE_ID_DM9102,           davicom_probe },
-  { PCI_VENDOR_ID_DAVICOM,   PCI_DEVICE_ID_DM9009,           davicom_probe },
-# endif /* INCLUDE_DAVICOM */
-# ifdef	INCLUDE_VIA_RHINE
-  { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_VT6102,      rhine_probe },
-  { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_RHINE_I,     rhine_probe },
-  { PCI_VENDOR_ID_VIATEC,   PCI_DEVICE_ID_VIA_86C100A,     rhine_probe },
-# endif /* INCLUDE_VIA_RHINE */
-# ifdef INCLUDE_W89C840
-  { PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C840, w89c840_probe },
-  { PCI_VENDOR_ID_COMPEX,   PCI_DEVICE_ID_COMPEX_RL100ATX, w89c840_probe },
-# endif /* INCLUDE_W89C840 */
-# ifdef INCLUDE_SIS900
-  { PCI_VENDOR_ID_SIS,      PCI_DEVICE_ID_SIS900,          sis900_probe },
-  { PCI_VENDOR_ID_SIS,      PCI_DEVICE_ID_SIS7016,         sis900_probe },
-# endif /* INCLUDE_SIS900 */
-# ifdef INCLUDE_NATSEMI
-  { PCI_VENDOR_ID_NS,       PCI_DEVICE_ID_DP83815,         natsemi_probe },
-# endif /* INCLUDE_NATSEMI */
-# ifdef INCLUDE_TLAN
-  { PCI_VENDOR_ID_OLICOM,   PCI_DEVICE_ID_OLICOM_OC2326,   tlan_probe },
-# endif /* INCLUDE_TLAN */
-  { 0,                      0,                             0 }
-};
-#endif /* GRUB && INCLUDE_PCI */
-
-struct dispatch_table
-{
-  const char	*nic_name;
-#ifdef	INCLUDE_PCI
-  struct nic	*(*eth_probe) (struct nic *, unsigned short *,
-			       struct pci_device *);
-#else
-  struct nic	*(*eth_probe) (struct nic *, unsigned short *);
-#endif	/* INCLUDE_PCI */
-  unsigned short	*probe_ioaddrs;		/* for probe overrides */
-};
-
 /*
- *	NIC probing is in order of appearance in this table.
+ *	NIC probing is in the order the drivers were linked togeter.
  *	If for some reason you want to change the order,
- *	just rearrange the entries (bracketed by the #ifdef/#endif)
+ *	just change the order you list the drivers in.
  */
-static struct dispatch_table	NIC[] =
-{
-#ifdef	INCLUDE_RTL8139
-  { "RTL8139", rtl8139_probe, pci_ioaddrs },
-#endif
-#ifdef INCLUDE_SIS900
-  { "SIS900", sis900_probe, pci_ioaddrs },	
-#endif
-#ifdef INCLUDE_NATSEMI
-  { "NATSEMI", natsemi_probe, pci_ioaddrs },	
-#endif
-#ifdef	INCLUDE_WD
-  { "WD", wd_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C503
-  { "3C503", t503_probe, 0 },
-#endif
-#ifdef	INCLUDE_NE
-  { "NE*000", ne_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C509
-  { "3C5x9", t509_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C529
-  { "3C5x9", t529_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C595
-  { "3C595", t595_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_3C90X
-  { "3C90X", a3c90x_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_EEPRO
-  { "EEPRO", eepro_probe, 0 },
-#endif
-#ifdef	INCLUDE_EEPRO100
-  { "EEPRO100", eepro100_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_EPIC100
-  { "EPIC100", epic100_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_OTULIP
-  { "OTulip", otulip_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_TULIP
-  { "Tulip", tulip_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_DAVICOM
-  { "DAVICOM", davicom_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_CS89X0
-  { "CS89x0", cs89x0_probe, 0 },
-#endif
-#ifdef	INCLUDE_NE2100
-  { "NE2100", ne2100_probe, 0 },
-#endif
-#ifdef	INCLUDE_NI6510
-  { "NI6510", ni6510_probe, 0 },
-#endif
-#ifdef	INCLUDE_SK_G16
-  { "SK_G16", SK_probe, 0 },
-#endif
-#ifdef	INCLUDE_3C507
-  { "3C507", t507_probe, 0 },
-#endif
-#ifdef	INCLUDE_NI5010
-  { "NI5010", ni5010_probe, 0 },
-#endif
-#ifdef	INCLUDE_NI5210
-  { "NI5210", ni5210_probe, 0 },
-#endif
-#ifdef	INCLUDE_EXOS205
-  { "EXOS205", exos205_probe, 0 },
-#endif
-#ifdef	INCLUDE_SMC9000
-  { "SMC9000", smc9000_probe, 0 },
-#endif
-#ifdef	INCLUDE_TIARA
-  { "TIARA", tiara_probe, 0 },
-#endif
-#ifdef	INCLUDE_DEPCA
-  { "DEPCA", depca_probe, 0 },
-#endif
-#ifdef	INCLUDE_NS8390
-  { "NE2000/PCI", nepci_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_LANCE
-  { "LANCE/PCI", lancepci_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_VIA_RHINE
-  { "VIA 86C100", rhine_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_W89C840
-  { "W89C840F", w89c840_probe, pci_ioaddrs },
-#endif
-#ifdef	INCLUDE_TLAN
-  { "Olicom 2326", tlan_probe, pci_ioaddrs },
-#endif
-  /* this entry must always be last to mark the end of list */
-  { 0, 0, 0 }
-};
+	struct isa_probe_state *state = &dev->state.isa;
+	printf("Probing isa %s...\n", type_name);
+	if (dev->how_probe == PROBE_FIRST) {
+		state->advance = 0;
+		state->driver  = isa_drivers;
+		dev->index     = -1;
+	}
+	for(;;)
+	{
+		if ((dev->how_probe != PROBE_AWAKE) && state->advance) {
+			state->driver++;
+			dev->index = -1;
+		}
+		state->advance = 1;
+		
+		if (state->driver >= isa_drivers_end)
+			break;
 
-#define	NIC_TABLE_SIZE	(sizeof (NIC) / sizeof (NIC[0]))
+		if (state->driver->type != dev->type)
+			continue;
 
-static int
-eth_dummy (struct nic *dummy)
-{
-  return 0;
+		if (dev->how_probe != PROBE_AWAKE) {
+			dev->type_index++;
+		}
+		printf("[%s]", state->driver->name);
+		dev->devid.bus_type = ISA_BUS_TYPE;
+		/* FIXME how do I handle dev->index + PROBE_AGAIN?? */
+		/* driver will fill in vendor and device IDs */
+		if (state->driver->probe(dev, state->driver->ioaddrs)) {
+			state->advance = (dev->index == -1);
+			return PROBE_WORKED;
+		}
+		putchar('\n');
+	}
+	return PROBE_FAILED;
 }
-
-static char	packet[ETH_FRAME_LEN];
-
-struct nic	nic =
-{
-  (void (*) (struct nic *)) eth_dummy,	/* reset */
-  eth_dummy,				/* poll */
-  (void (*) (struct nic *, const char *,
-	     unsigned int, unsigned int,
-	     const char *)) eth_dummy,	/* transmit */
-  (void (*) (struct nic *)) eth_dummy,	/* disable */
-#ifdef	T503_AUI
-  1,					/* aui */
 #else
-  0,					/* no aui */
+#define isa_probe(d,tn) (PROBE_FAILED)
 #endif
-  &rom,					/* rom_info */
-  arptable[ARP_CLIENT].node,		/* node_addr */
-  packet,				/* packet */
-  0,				/* packetlen */
-  0,				/* priv_data */
+static const char *driver_name[] = {
+	"nic", 
+	"disk", 
+	"floppy",
 };
-
-void
-eth_reset (void)
+int probe(struct dev *dev)
 {
-  (*nic.reset) (&nic);
-}
+	const char *type_name;
 
-int
-eth_probe (void)
-{
-  struct pci_device	*p;
-  const struct dispatch_table	*t;
-  static int probed = 0;
+	EnterFunction("probe");
 
-  /* If already probed, don't try to probe it any longer.  */
-  if (probed)
-    return 1;
-  
-  /* Clear the ready flag.  */
-  network_ready = 0;
-  /* Clear the ARP table.  */
-  grub_memset ((char *) arptable, 0,
-	       MAX_ARP * sizeof (struct arptable_t));
-  
-  p = 0;
-  
-#ifdef	INCLUDE_PCI
-  /* In GRUB, the ROM info is initialized here.  */
-  rom = *((struct rom_info *) ROM_INFO_LOCATION);
-  
-  eth_pci_init(pci_nic_list);
-  pci_ioaddrs[0] = 0;
-  pci_ioaddrs[1] = 0;
-  /* at this point we have a list of possible PCI candidates
-     we just pick the first one with a non-zero ioaddr */
-  for (p = pci_nic_list; p->vendor != 0; ++p)
-    {
-      if (p->ioaddr != 0)
-	{
-	  pci_ioaddrs[0] = p->ioaddr;
-	  break;
+	type_name = "";
+	if ((dev->type >= 0) && 
+		(dev->type < sizeof(driver_name)/sizeof(driver_name[0]))) {
+		type_name = driver_name[dev->type];
 	}
-    }
-#endif
-  
-  etherboot_printf("Probing...");
-	
-#ifdef INCLUDE_PCI
-  if (p->vendor)
-    {
-      struct pci_dispatch_table *pt;
-      
-      for (pt = PCI_NIC; pt->eth_probe != 0; pt++)
-	if (p->vendor == pt->vendor && p->dev_id == pt->dev_id)
-	  {
-	    etherboot_printf ("[%s]", p->name);
-	    if ((pt->eth_probe) (&nic, pci_ioaddrs, p))
-	      {
-		probed = 1;
-		return 1;
-	      }
-	  }
-    }
-#endif /* INCLUDE_PCI */
-	
-  for (t = NIC; t->nic_name != 0; ++t)
-    {
-      etherboot_printf("[%s]", t->nic_name);
-#ifdef	INCLUDE_PCI
-      if ((*t->eth_probe) (&nic, t->probe_ioaddrs, p))
-	{
-	  probed = 1;
-	  return 1;
+	if (dev->how_probe == PROBE_FIRST) {
+		dev->to_probe = PROBE_PCI;
+		memset(&dev->state, 0, sizeof(dev->state));
 	}
-#else
-      if ((*t->eth_probe) (&nic, t->probe_ioaddrs))
-	{
-	  probed = 1;
-	  return 1;
+	if (dev->to_probe == PROBE_PCI) {
+		dev->how_probe = pci_probe(dev, type_name);
+		if (dev->how_probe == PROBE_FAILED) {
+			dev->to_probe = PROBE_ISA;
+		}
 	}
-#endif	/* INCLUDE_PCI */
-    }
-  
-  return 0;
-}
+	if (dev->to_probe == PROBE_ISA) {
+		dev->how_probe = isa_probe(dev, type_name);
+		if (dev->how_probe == PROBE_FAILED) {
+			dev->to_probe = PROBE_NONE;
+		}
+	}
+	if ((dev->to_probe != PROBE_PCI) &&
+		(dev->to_probe != PROBE_ISA)) {
+		dev->how_probe = PROBE_FAILED;
+		
+	}
 
-int
-eth_poll (void)
-{
-  return ((*nic.poll) (&nic));
+	LeaveFunction("probe");
+	return dev->how_probe;
 }
 
-void
-eth_transmit (const char *d, unsigned int t, unsigned int s, const void *p)
+void disable(struct dev *dev)
 {
-  (*nic.transmit) (&nic, d, t, s, p);
-  if (t == IP)
-    twiddle ();
+	if (dev->disable) {
+		dev->disable(dev);
+		dev->disable = 0;
+	}
 }
-
-void
-eth_disable (void)
-{
-  (*nic.disable) (&nic);
-}
Index: netboot/elf.h
===================================================================
--- netboot/elf.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/elf.h	(.../trunk)	(revision 112)
@@ -0,0 +1,234 @@
+#ifndef ELF_H
+#define ELF_H
+
+#define EI_NIDENT	16	/* Size of e_ident array. */
+
+/* Values for e_type. */
+#define ET_NONE		0	/* No file type */
+#define ET_REL		1	/* Relocatable file */
+#define ET_EXEC		2	/* Executable file */
+#define ET_DYN		3	/* Shared object file */
+#define ET_CORE		4	/* Core file */
+
+/* Values for e_machine (architecute). */
+#define EM_NONE		 0		/* No machine */
+#define EM_M32		 1		/* AT&T WE 32100 */
+#define EM_SPARC	 2		/* SUN SPARC */
+#define EM_386		 3		/* Intel 80386+ */
+#define EM_68K		 4		/* Motorola m68k family */
+#define EM_88K		 5		/* Motorola m88k family */
+#define EM_486		 6		/* Perhaps disused */
+#define EM_860		 7		/* Intel 80860 */
+#define EM_MIPS		 8		/* MIPS R3000 big-endian */
+#define EM_S370		 9		/* IBM System/370 */
+#define EM_MIPS_RS3_LE	10		/* MIPS R3000 little-endian */
+
+#define EM_PARISC	15		/* HPPA */
+#define EM_VPP500	17		/* Fujitsu VPP500 */
+#define EM_SPARC32PLUS	18		/* Sun's "v8plus" */
+#define EM_960		19		/* Intel 80960 */
+#define EM_PPC		20		/* PowerPC */
+#define EM_PPC64	21		/* PowerPC 64-bit */
+#define EM_S390		22		/* IBM S390 */
+
+#define EM_V800		36		/* NEC V800 series */
+#define EM_FR20		37		/* Fujitsu FR20 */
+#define EM_RH32		38		/* TRW RH-32 */
+#define EM_RCE		39		/* Motorola RCE */
+#define EM_ARM		40		/* ARM */
+#define EM_FAKE_ALPHA	41		/* Digital Alpha */
+#define EM_SH		42		/* Hitachi SH */
+#define EM_SPARCV9	43		/* SPARC v9 64-bit */
+#define EM_TRICORE	44		/* Siemens Tricore */
+#define EM_ARC		45		/* Argonaut RISC Core */
+#define EM_H8_300	46		/* Hitachi H8/300 */
+#define EM_H8_300H	47		/* Hitachi H8/300H */
+#define EM_H8S		48		/* Hitachi H8S */
+#define EM_H8_500	49		/* Hitachi H8/500 */
+#define EM_IA_64	50		/* Intel Merced */
+#define EM_MIPS_X	51		/* Stanford MIPS-X */
+#define EM_COLDFIRE	52		/* Motorola Coldfire */
+#define EM_68HC12	53		/* Motorola M68HC12 */
+#define EM_MMA		54		/* Fujitsu MMA Multimedia Accelerator*/
+#define EM_PCP		55		/* Siemens PCP */
+#define EM_NCPU		56		/* Sony nCPU embeeded RISC */
+#define EM_NDR1		57		/* Denso NDR1 microprocessor */
+#define EM_STARCORE	58		/* Motorola Start*Core processor */
+#define EM_ME16		59		/* Toyota ME16 processor */
+#define EM_ST100	60		/* STMicroelectronic ST100 processor */
+#define EM_TINYJ	61		/* Advanced Logic Corp. Tinyj emb.fam*/
+#define EM_X86_64	62		/* AMD x86-64 architecture */
+#define EM_PDSP		63		/* Sony DSP Processor */
+
+#define EM_FX66		66		/* Siemens FX66 microcontroller */
+#define EM_ST9PLUS	67		/* STMicroelectronics ST9+ 8/16 mc */
+#define EM_ST7		68		/* STmicroelectronics ST7 8 bit mc */
+#define EM_68HC16	69		/* Motorola MC68HC16 microcontroller */
+#define EM_68HC11	70		/* Motorola MC68HC11 microcontroller */
+#define EM_68HC08	71		/* Motorola MC68HC08 microcontroller */
+#define EM_68HC05	72		/* Motorola MC68HC05 microcontroller */
+#define EM_SVX		73		/* Silicon Graphics SVx */
+#define EM_AT19		74		/* STMicroelectronics ST19 8 bit mc */
+#define EM_VAX		75		/* Digital VAX */
+#define EM_CRIS		76		/* Axis Communications 32-bit embedded processor */
+#define EM_JAVELIN	77		/* Infineon Technologies 32-bit embedded processor */
+#define EM_FIREPATH	78		/* Element 14 64-bit DSP Processor */
+#define EM_ZSP		79		/* LSI Logic 16-bit DSP Processor */
+#define EM_MMIX		80		/* Donald Knuth's educational 64-bit processor */
+#define EM_HUANY	81		/* Harvard University machine-independent object files */
+#define EM_PRISM	82		/* SiTera Prism */
+#define EM_AVR		83		/* Atmel AVR 8-bit microcontroller */
+#define EM_FR30		84		/* Fujitsu FR30 */
+#define EM_D10V		85		/* Mitsubishi D10V */
+#define EM_D30V		86		/* Mitsubishi D30V */
+#define EM_V850		87		/* NEC v850 */
+#define EM_M32R		88		/* Mitsubishi M32R */
+#define EM_MN10300	89		/* Matsushita MN10300 */
+#define EM_MN10200	90		/* Matsushita MN10200 */
+#define EM_PJ		91		/* picoJava */
+#define EM_OPENRISC	92		/* OpenRISC 32-bit embedded processor */
+#define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
+#define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
+#define EM_NUM		95
+
+/* Values for p_type. */
+#define PT_NULL		0	/* Unused entry. */
+#define PT_LOAD		1	/* Loadable segment. */
+#define PT_DYNAMIC	2	/* Dynamic linking information segment. */
+#define PT_INTERP	3	/* Pathname of interpreter. */
+#define PT_NOTE		4	/* Auxiliary information. */
+#define PT_SHLIB	5	/* Reserved (not used). */
+#define PT_PHDR		6	/* Location of program header itself. */
+
+/* Values for p_flags. */
+#define PF_X		0x1	/* Executable. */
+#define PF_W		0x2	/* Writable. */
+#define PF_R		0x4	/* Readable. */
+
+
+#define	ELF_PROGRAM_RETURNS_BIT	0x8000000	/* e_flags bit 31 */
+
+#define EI_MAG0		0
+#define ELFMAG0		0x7f
+
+#define EI_MAG1		1
+#define ELFMAG1		'E'
+
+#define EI_MAG2		2
+#define ELFMAG2		'L'
+
+#define EI_MAG3		3
+#define ELFMAG3		'F'
+
+#define ELFMAG		"\177ELF"
+
+#define EI_CLASS	4	/* File class byte index */
+#define ELFCLASSNONE	0	/* Invalid class */
+#define ELFCLASS32	1	/* 32-bit objects */
+#define ELFCLASS64	2	/* 64-bit objects */
+
+#define EI_DATA		5	/* Data encodeing byte index */
+#define ELFDATANONE	0	/* Invalid data encoding */
+#define ELFDATA2LSB	1	/* 2's complement little endian */
+#define ELFDATA2MSB	2	/* 2's complement big endian */
+
+#define EI_VERSION	6	/* File version byte index */
+				/* Value must be EV_CURRENT */
+
+#define EV_NONE		0	/* Invalid ELF Version */
+#define EV_CURRENT	1	/* Current version */
+
+#define ELF32_PHDR_SIZE (8*4)	/* Size of an elf program header */
+
+#ifndef ASSEMBLY
+/*
+ * ELF definitions common to all 32-bit architectures.
+ */
+
+typedef uint32_t	Elf32_Addr;
+typedef uint16_t	Elf32_Half;
+typedef uint32_t	Elf32_Off;
+typedef int32_t		Elf32_Sword;
+typedef uint32_t	Elf32_Word;
+typedef uint32_t	Elf32_Size;
+
+typedef uint64_t	Elf64_Addr;
+typedef uint16_t	Elf64_Half;
+typedef uint64_t	Elf64_Off;
+typedef int32_t		Elf64_Sword;
+typedef uint32_t	Elf64_Word;
+typedef uint64_t	Elf64_Size;
+
+/*
+ * ELF header.
+ */
+typedef struct {
+	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+	Elf32_Half	e_type;		/* File type. */
+	Elf32_Half	e_machine;	/* Machine architecture. */
+	Elf32_Word	e_version;	/* ELF format version. */
+	Elf32_Addr	e_entry;	/* Entry point. */
+	Elf32_Off	e_phoff;	/* Program header file offset. */
+	Elf32_Off	e_shoff;	/* Section header file offset. */
+	Elf32_Word	e_flags;	/* Architecture-specific flags. */
+	Elf32_Half	e_ehsize;	/* Size of ELF header in bytes. */
+	Elf32_Half	e_phentsize;	/* Size of program header entry. */
+	Elf32_Half	e_phnum;	/* Number of program header entries. */
+	Elf32_Half	e_shentsize;	/* Size of section header entry. */
+	Elf32_Half	e_shnum;	/* Number of section header entries. */
+	Elf32_Half	e_shstrndx;	/* Section name strings section. */
+} Elf32_Ehdr;
+
+typedef struct {
+	unsigned char	e_ident[EI_NIDENT];	/* File identification. */
+	Elf64_Half	e_type;		/* File type. */
+	Elf64_Half	e_machine;	/* Machine architecture. */
+	Elf64_Word	e_version;	/* ELF format version. */
+	Elf64_Addr	e_entry;	/* Entry point. */
+	Elf64_Off	e_phoff;	/* Program header file offset. */
+	Elf64_Off	e_shoff;	/* Section header file offset. */
+	Elf64_Word	e_flags;	/* Architecture-specific flags. */
+	Elf64_Half	e_ehsize;	/* Size of ELF header in bytes. */
+	Elf64_Half	e_phentsize;	/* Size of program header entry. */
+	Elf64_Half	e_phnum;	/* Number of program header entries. */
+	Elf64_Half	e_shentsize;	/* Size of section header entry. */
+	Elf64_Half	e_shnum;	/* Number of section header entries. */
+	Elf64_Half	e_shstrndx;	/* Section name strings section. */
+} Elf64_Ehdr;
+
+/*
+ * Program header.
+ */
+typedef struct {
+	Elf32_Word	p_type;		/* Entry type. */
+	Elf32_Off	p_offset;	/* File offset of contents. */
+	Elf32_Addr	p_vaddr;	/* Virtual address (not used). */
+	Elf32_Addr	p_paddr;	/* Physical address. */
+	Elf32_Size	p_filesz;	/* Size of contents in file. */
+	Elf32_Size	p_memsz;	/* Size of contents in memory. */
+	Elf32_Word	p_flags;	/* Access permission flags. */
+	Elf32_Size	p_align;	/* Alignment in memory and file. */
+} Elf32_Phdr;
+
+typedef struct {
+	Elf64_Word	p_type;		/* Entry type. */
+	Elf64_Word	p_flags;	/* Access permission flags. */
+	Elf64_Off	p_offset;	/* File offset of contents. */
+	Elf64_Addr	p_vaddr;	/* Virtual address (not used). */
+	Elf64_Addr	p_paddr;	/* Physical address. */
+	Elf64_Size	p_filesz;	/* Size of contents in file. */
+	Elf64_Size	p_memsz;	/* Size of contents in memory. */
+	Elf64_Size	p_align;	/* Alignment in memory and file. */
+} Elf64_Phdr;
+
+/* Standardized Elf image notes for booting... The name for all of these is ELFBoot */
+
+
+/* ELF Defines for the current architecture */
+#include "i386_elf.h"
+
+#endif /* ASSEMBLY */
+
+//#include "elf_boot.h"
+
+#endif /* ELF_H */
Index: netboot/in.h
===================================================================
--- netboot/in.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/in.h	(.../trunk)	(revision 112)
@@ -0,0 +1,21 @@
+#ifndef	_IN_H
+#define	_IN_H
+
+#include "types.h"
+
+#define IP		0x0800
+#define ARP		0x0806
+#define	RARP		0x8035
+
+#define IP_ICMP		1
+#define IP_IGMP		2
+#define IP_UDP		17
+
+/* Same after going through htonl */
+#define IP_BROADCAST	0xFFFFFFFF
+
+typedef struct {
+	uint32_t	s_addr;
+} in_addr;
+
+#endif	/* _IN_H */
Index: netboot/i386_byteswap.h
===================================================================
--- netboot/i386_byteswap.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/i386_byteswap.h	(.../trunk)	(revision 112)
@@ -0,0 +1,46 @@
+#ifndef ETHERBOOT_BITS_BYTESWAP_H
+#define ETHERBOOT_BITS_BYTESWAP_H
+
+#include "types.h"
+static inline uint16_t __i386_bswap_16(uint16_t x)
+{
+	__asm__("xchgb %b0,%h0\n\t"
+		: "=q" (x)
+		: "0" (x));
+	return x;
+}
+
+static inline uint32_t __i386_bswap_32(uint32_t x)
+{
+	__asm__("xchgb %b0,%h0\n\t"
+		"rorl $16,%0\n\t"
+		"xchgb %b0,%h0"
+		: "=q" (x)
+		: "0" (x));
+	return x;
+}
+
+
+#define __bswap_constant_16(x) \
+	((uint16_t)((((uint16_t)(x) & 0x00ff) << 8) | \
+		(((uint16_t)(x) & 0xff00) >> 8)))
+
+#define __bswap_constant_32(x) \
+	((uint32_t)((((uint32_t)(x) & 0x000000ffU) << 24) | \
+		(((uint32_t)(x) & 0x0000ff00U) <<  8) | \
+		(((uint32_t)(x) & 0x00ff0000U) >>  8) | \
+		(((uint32_t)(x) & 0xff000000U) >> 24)))
+
+#define __bswap_16(x) \
+	(__builtin_constant_p(x) ? \
+	__bswap_constant_16(x) : \
+	__i386_bswap_16(x))
+
+
+#define __bswap_32(x) \
+	(__builtin_constant_p(x) ? \
+	__bswap_constant_32(x) : \
+	__i386_bswap_32(x))
+
+
+#endif /* ETHERBOOT_BITS_BYTESWAP_H */
Index: netboot/ip.h
===================================================================
--- netboot/ip.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/ip.h	(.../trunk)	(revision 112)
@@ -0,0 +1,36 @@
+#ifndef	_IP_H
+#define	_IP_H
+
+/* We need 'uint16_t' */
+#include "types.h"
+/* We need 'in_addr' */
+#include "in.h"
+
+struct iphdr {
+	uint8_t  verhdrlen;
+	uint8_t  service;
+	uint16_t len;
+	uint16_t ident;
+	uint16_t frags;
+	uint8_t  ttl;
+	uint8_t  protocol;
+	uint16_t chksum;
+	in_addr src;
+	in_addr dest;
+};
+
+extern void build_ip_hdr(unsigned long __destip, int __ttl, int __protocol, 
+			 int __option_len, int __len, const void * __buf);
+
+extern int ip_transmit(int __len, const void * __buf);
+
+extern uint16_t ipchksum(const void * __data, unsigned long __length);
+
+extern uint16_t add_ipchksums(unsigned long __offset, uint16_t __sum, 
+			      uint16_t __new);
+
+
+
+
+
+#endif	/* _IP_H */
Index: netboot/davicom.c
===================================================================
--- netboot/davicom.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/davicom.c	(.../trunk)	(revision 112)
@@ -1,3 +1,6 @@
+#ifdef ALLMULTI
+#error multicast support is not yet implemented
+#endif
 /*  
     DAVICOM DM9009/DM9102/DM9102A Etherboot Driver	V1.00
 
@@ -44,7 +47,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 #undef DAVICOM_DEBUG
 #undef DAVICOM_DEBUG_WHERE
@@ -99,8 +101,10 @@
 #define eeprom_delay()  inl(ee_addr)
 
 /* helpful macro if on a big_endian machine for changing byte order.
-   not strictly needed on Intel */
+   not strictly needed on Intel
+   Already defined in Etherboot includes
 #define le16_to_cpu(val) (val)
+*/
 
 /* transmit and receive descriptor format */
 struct txdesc {
@@ -138,20 +142,12 @@
 /* transmit descriptor and buffer */
 #define NTXD 2
 static struct txdesc txd[NTXD] __attribute__ ((aligned(4)));
-#ifdef	USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - BUFLEN)
-#else
 static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
-#endif
 
 /* receive descriptor(s) and buffer(s) */
 #define NRXD 4
 static struct rxdesc rxd[NRXD] __attribute__ ((aligned(4)));
-#ifdef	USE_LOWMEM_BUFFER
-#define rxb ((char *)0x10000 - NRXD * BUFLEN - BUFLEN)
-#else
 static unsigned char rxb[NRXD * BUFLEN] __attribute__ ((aligned(4)));
-#endif
 static int rxd_tail;
 static int TxPtr;
 
@@ -161,14 +157,13 @@
 /*********************************************************************/
 static void whereami(const char *str);
 static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
-struct nic *davicom_probe(struct nic *nic, unsigned short *io_addrs,
-			struct pci_device *pci);
+static int davicom_probe(struct dev *dev, struct pci_device *pci);
 static void davicom_init_chain(struct nic *nic);	/* Sten 10/9 */
 static void davicom_reset(struct nic *nic);
 static void davicom_transmit(struct nic *nic, const char *d, unsigned int t,
 			   unsigned int s, const char *p);
 static int davicom_poll(struct nic *nic);
-static void davicom_disable(struct nic *nic);
+static void davicom_disable(struct dev *dev);
 static void whereami (const char *str);
 #ifdef	DAVICOM_DEBUG
 static void davicom_more(void);
@@ -360,7 +355,7 @@
 /*
   Sense media mode and set CR6
 */
-static void davicom_media_chk(struct nic * nic)
+static void davicom_media_chk(struct nic * nic __unused)
 {
   unsigned long to, csr6;
 
@@ -446,8 +441,8 @@
   /* Sten: Set 2 TX descriptor but use one TX buffer because
 	   it transmit a packet and wait complete every time. */
   for (i=0; i<NTXD; i++) {
-    txd[i].buf1addr = &txb[0];		/* Used same TX buffer */
-    txd[i].buf2addr = (unsigned char *)&txd[i+1]; /*  Point to Next TX desc */
+    txd[i].buf1addr = virt_to_bus(&txb[0]);	/* Used same TX buffer */
+    txd[i].buf2addr = virt_to_bus(&txd[i+1]);	/*  Point to Next TX desc */
     txd[i].buf1sz   = 0;
     txd[i].buf2sz   = 0;
     txd[i].control  = 0x184;           /* Begin/End/Chain */
@@ -466,8 +461,8 @@
 
   /* setup receive descriptor */
   for (i=0; i<NRXD; i++) {
-    rxd[i].buf1addr = &rxb[i * BUFLEN];
-    rxd[i].buf2addr = (unsigned char *)&rxd[i+1]; /* Point to Next RX desc */
+    rxd[i].buf1addr = virt_to_bus(&rxb[i * BUFLEN]);
+    rxd[i].buf2addr = virt_to_bus(&rxd[i+1]); /* Point to Next RX desc */
     rxd[i].buf1sz   = BUFLEN;
     rxd[i].buf2sz   = 0;        /* not used */
     rxd[i].control  = 0x4;		/* Chain Structure */
@@ -475,8 +470,8 @@
   }
 
   /* Chain the last descriptor to first */
-  txd[NTXD - 1].buf2addr = (unsigned char *)&txd[0];
-  rxd[NRXD - 1].buf2addr = (unsigned char *)&rxd[0];
+  txd[NTXD - 1].buf2addr = virt_to_bus(&txd[0]);
+  rxd[NRXD - 1].buf2addr = virt_to_bus(&rxd[0]);
   TxPtr = 0;
   rxd_tail = 0;
 }
@@ -488,7 +483,6 @@
 static void davicom_reset(struct nic *nic)
 {
   unsigned long to;
-  u32 addr_low, addr_high;
 
   whereami("davicom_reset\n");
 
@@ -507,8 +501,8 @@
   davicom_init_chain(nic);	/* Sten 10/9 */
 
   /* Point to receive descriptor */
-  outl((unsigned long)&rxd[0], ioaddr + CSR3);
-  outl((unsigned long)&txd[0], ioaddr + CSR4);	/* Sten 10/9 */
+  outl(virt_to_bus(&rxd[0]), ioaddr + CSR3);
+  outl(virt_to_bus(&txd[0]), ioaddr + CSR4);	/* Sten 10/9 */
 
   /* According phyxcer media mode to set CR6,
      DM9102/A phyxcer can auto-detect media mode */
@@ -627,10 +621,13 @@
 /*********************************************************************/
 /* eth_disable - Disable the interface                               */
 /*********************************************************************/
-static void davicom_disable(struct nic *nic)
+static void davicom_disable(struct dev *dev)
 {
+  struct nic *nic = (struct nic *)dev;
   whereami("davicom_disable\n");
 
+  davicom_reset(nic);
+
   /* disable interrupts */
   outl(0x00000000, ioaddr + CSR7);
 
@@ -644,20 +641,19 @@
 /*********************************************************************/
 /* eth_probe - Look for an adapter                                   */
 /*********************************************************************/
-struct nic *davicom_probe(struct nic *nic, unsigned short *io_addrs,
-                          struct pci_device *pci)
+static int davicom_probe(struct dev *dev, struct pci_device *pci)
 {
+  struct nic *nic = (struct nic *)dev;
   unsigned int i;
-  u32 l1, l2;
 
   whereami("davicom_probe\n");
 
-  if (io_addrs == 0 || *io_addrs == 0)
+  if (pci->ioaddr == 0)
     return 0;
 
   vendor  = pci->vendor;
   dev_id  = pci->dev_id;
-  ioaddr  = *io_addrs;
+  ioaddr  = pci->ioaddr;
 
   /* wakeup chip */
   pcibios_write_config_dword(pci->bus, pci->devfn, 0x40, 0x00000000);
@@ -683,10 +679,25 @@
   /* initialize device */
   davicom_reset(nic);
 
-  nic->reset    = davicom_reset;
+  dev->disable  = davicom_disable;
   nic->poll     = davicom_poll;
   nic->transmit = davicom_transmit;
-  nic->disable  = davicom_disable;
 
-  return nic;
+  return 1;
 }
+
+static struct pci_id davicom_nics[] = {
+PCI_ROM(0x1282, 0x9100, "davicom9100", "Davicom 9100"),
+PCI_ROM(0x1282, 0x9102, "davicom9102", "Davicom 9102"),
+PCI_ROM(0x1282, 0x9009, "davicom9009", "Davicom 9009"),
+PCI_ROM(0x1282, 0x9132, "davicom9132", "Davicom 9132"),	/* Needs probably some fixing */
+};
+
+struct pci_driver davicom_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "DAVICOM",
+	.probe    = davicom_probe,
+	.ids      = davicom_nics,
+	.id_count = sizeof(davicom_nics)/sizeof(davicom_nics[0]),
+	.class    = 0,
+};
Index: netboot/tftp.h
===================================================================
--- netboot/tftp.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/tftp.h	(.../trunk)	(revision 112)
@@ -0,0 +1,82 @@
+#ifndef	_TFTP_H
+#define	_TFTP_H
+
+#include "if_ether.h"
+#include "ip.h"
+#include "udp.h"
+
+#ifndef	MAX_TFTP_RETRIES
+#define MAX_TFTP_RETRIES	20
+#endif
+
+/* These settings have sense only if compiled with -DCONGESTED */
+/* total retransmission timeout in ticks */
+#define TFTP_TIMEOUT		(30*TICKS_PER_SEC)
+/* packet retransmission timeout in ticks */
+#define TFTP_REXMT		(3*TICKS_PER_SEC)
+
+#define TFTP_PORT	69
+#define	TFTP_DEFAULTSIZE_PACKET	512
+#define	TFTP_MAX_PACKET		1432 /* 512 */
+
+#define TFTP_RRQ	1
+#define TFTP_WRQ	2
+#define TFTP_DATA	3
+#define TFTP_ACK	4
+#define TFTP_ERROR	5
+#define TFTP_OACK	6
+
+#define TFTP_CODE_EOF	1
+#define TFTP_CODE_MORE	2
+#define TFTP_CODE_ERROR	3
+#define TFTP_CODE_BOOT	4
+#define TFTP_CODE_CFG	5
+
+struct tftp_t {
+	struct iphdr ip;
+	struct udphdr udp;
+	uint16_t opcode;
+	union {
+		uint8_t rrq[TFTP_DEFAULTSIZE_PACKET];
+		struct {
+			uint16_t block;
+			uint8_t  download[TFTP_MAX_PACKET];
+		} data;
+		struct {
+			uint16_t block;
+		} ack;
+		struct {
+			uint16_t errcode;
+			uint8_t  errmsg[TFTP_DEFAULTSIZE_PACKET];
+		} err;
+		struct {
+			uint8_t  data[TFTP_DEFAULTSIZE_PACKET+2];
+		} oack;
+	} u;
+};
+
+/* define a smaller tftp packet solely for making requests to conserve stack
+   512 bytes should be enough */
+struct tftpreq_t {
+	struct iphdr ip;
+	struct udphdr udp;
+	uint16_t opcode;
+	union {
+		uint8_t rrq[512];
+		struct {
+			uint16_t block;
+		} ack;
+		struct {
+			uint16_t errcode;
+			uint8_t  errmsg[512-2];
+		} err;
+	} u;
+};
+
+#define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
+
+typedef int (*read_actor_t)(unsigned char *, unsigned int, unsigned int, int);
+
+int tftp_file_read(const char *name, read_actor_t);
+
+#endif	/* _TFTP_H */
Index: netboot/e1000_hw.h
===================================================================
--- netboot/e1000_hw.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/e1000_hw.h	(.../trunk)	(revision 112)
@@ -0,0 +1,1972 @@
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+/* e1000_hw.h
+ * Structures, enums, and macros for the MAC
+ */
+
+#ifndef _E1000_HW_H_
+#define _E1000_HW_H_
+
+/* Forward declarations of structures used by the shared code */
+struct e1000_hw;
+struct e1000_hw_stats;
+
+/* Enumerated types specific to the e1000 hardware */
+/* Media Access Controlers */
+typedef enum {
+    e1000_undefined = 0,
+    e1000_82542_rev2_0,
+    e1000_82542_rev2_1,
+    e1000_82543,
+    e1000_82544,
+    e1000_82540,
+    e1000_82545,
+    e1000_82546,
+    e1000_82541,
+    e1000_82547,
+    e1000_num_macs
+} e1000_mac_type;
+
+typedef enum {
+    e1000_eeprom_uninitialized = 0,
+    e1000_eeprom_spi,
+    e1000_eeprom_microwire,
+    e1000_num_eeprom_types
+} e1000_eeprom_type;
+
+/* Media Types */
+typedef enum {
+	e1000_media_type_copper = 0,
+	e1000_media_type_fiber = 1,
+	e1000_num_media_types
+} e1000_media_type;
+
+typedef enum {
+    e1000_10_half = 0,
+    e1000_10_full = 1,
+    e1000_100_half = 2,
+    e1000_100_full = 3
+} e1000_speed_duplex_type;
+
+/* Flow Control Settings */
+typedef enum {
+	e1000_fc_none = 0,
+	e1000_fc_rx_pause = 1,
+	e1000_fc_tx_pause = 2,
+	e1000_fc_full = 3,
+	e1000_fc_default = 0xFF
+} e1000_fc_type;
+
+/* PCI bus types */
+typedef enum {
+	e1000_bus_type_unknown = 0,
+	e1000_bus_type_pci,
+	e1000_bus_type_pcix
+} e1000_bus_type;
+
+/* PCI bus speeds */
+typedef enum {
+	e1000_bus_speed_unknown = 0,
+	e1000_bus_speed_33,
+	e1000_bus_speed_66,
+	e1000_bus_speed_100,
+	e1000_bus_speed_120,
+	e1000_bus_speed_133,
+	e1000_bus_speed_reserved
+} e1000_bus_speed;
+
+/* PCI bus widths */
+typedef enum {
+	e1000_bus_width_unknown = 0,
+	e1000_bus_width_32,
+	e1000_bus_width_64
+} e1000_bus_width;
+
+/* PHY status info structure and supporting enums */
+typedef enum {
+	e1000_cable_length_50 = 0,
+	e1000_cable_length_50_80,
+	e1000_cable_length_80_110,
+	e1000_cable_length_110_140,
+	e1000_cable_length_140,
+	e1000_cable_length_undefined = 0xFF
+} e1000_cable_length;
+
+typedef enum {
+    e1000_igp_cable_length_10  = 10,
+    e1000_igp_cable_length_20  = 20,
+    e1000_igp_cable_length_30  = 30,
+    e1000_igp_cable_length_40  = 40,
+    e1000_igp_cable_length_50  = 50,
+    e1000_igp_cable_length_60  = 60,
+    e1000_igp_cable_length_70  = 70,
+    e1000_igp_cable_length_80  = 80,
+    e1000_igp_cable_length_90  = 90,
+    e1000_igp_cable_length_100 = 100,
+    e1000_igp_cable_length_110 = 110,
+    e1000_igp_cable_length_120 = 120,
+    e1000_igp_cable_length_130 = 130,
+    e1000_igp_cable_length_140 = 140,
+    e1000_igp_cable_length_150 = 150,
+    e1000_igp_cable_length_160 = 160,
+    e1000_igp_cable_length_170 = 170,
+    e1000_igp_cable_length_180 = 180
+} e1000_igp_cable_length;
+
+typedef enum {
+	e1000_10bt_ext_dist_enable_normal = 0,
+	e1000_10bt_ext_dist_enable_lower,
+	e1000_10bt_ext_dist_enable_undefined = 0xFF
+} e1000_10bt_ext_dist_enable;
+
+typedef enum {
+	e1000_rev_polarity_normal = 0,
+	e1000_rev_polarity_reversed,
+	e1000_rev_polarity_undefined = 0xFF
+} e1000_rev_polarity;
+
+typedef enum {
+    e1000_downshift_normal = 0,
+    e1000_downshift_activated,
+    e1000_downshift_undefined = 0xFF
+} e1000_downshift;
+
+typedef enum {
+	e1000_polarity_reversal_enabled = 0,
+	e1000_polarity_reversal_disabled,
+	e1000_polarity_reversal_undefined = 0xFF
+} e1000_polarity_reversal;
+
+typedef enum {
+	e1000_auto_x_mode_manual_mdi = 0,
+	e1000_auto_x_mode_manual_mdix,
+	e1000_auto_x_mode_auto1,
+	e1000_auto_x_mode_auto2,
+	e1000_auto_x_mode_undefined = 0xFF
+} e1000_auto_x_mode;
+
+typedef enum {
+	e1000_1000t_rx_status_not_ok = 0,
+	e1000_1000t_rx_status_ok,
+	e1000_1000t_rx_status_undefined = 0xFF
+} e1000_1000t_rx_status;
+
+typedef enum {
+    e1000_phy_m88 = 0,
+    e1000_phy_igp,
+    e1000_phy_undefined = 0xFF
+} e1000_phy_type;
+
+struct e1000_phy_info {
+#if 0
+	e1000_cable_length cable_length;
+#endif
+	e1000_10bt_ext_dist_enable extended_10bt_distance;
+	e1000_rev_polarity cable_polarity;
+#if 0
+	e1000_downshift downshift;
+#endif
+	e1000_polarity_reversal polarity_correction;
+	e1000_auto_x_mode mdix_mode;
+	e1000_1000t_rx_status local_rx;
+	e1000_1000t_rx_status remote_rx;
+};
+
+struct e1000_phy_stats {
+	uint32_t idle_errors;
+	uint32_t receive_errors;
+};
+
+struct e1000_eeprom_info {
+    e1000_eeprom_type type;
+    uint16_t word_size;
+    uint16_t opcode_bits;
+    uint16_t address_bits;
+    uint16_t delay_usec;
+    uint16_t page_size;
+};
+
+
+
+/* Error Codes */
+#define E1000_SUCCESS      0
+#define E1000_ERR_EEPROM   1
+#define E1000_ERR_PHY      2
+#define E1000_ERR_CONFIG   3
+#define E1000_ERR_PARAM    4
+#define E1000_ERR_MAC_TYPE 5
+#define E1000_ERR_PHY_TYPE 6
+#define E1000_ERR_NOLINK   7
+#define E1000_ERR_TIMEOUT  8
+
+#define E1000_READ_REG_IO(a, reg) \
+	e1000_read_reg_io((a), E1000_##reg)
+#define E1000_WRITE_REG_IO(a, reg, val) \
+	e1000_write_reg_io((a), E1000_##reg, val)
+
+/* PCI Device IDs */
+#define E1000_DEV_ID_82542               0x1000
+#define E1000_DEV_ID_82543GC_FIBER       0x1001
+#define E1000_DEV_ID_82543GC_COPPER      0x1004
+#define E1000_DEV_ID_82544EI_COPPER      0x1008
+#define E1000_DEV_ID_82544EI_FIBER       0x1009
+#define E1000_DEV_ID_82544GC_COPPER      0x100C
+#define E1000_DEV_ID_82544GC_LOM         0x100D
+#define E1000_DEV_ID_82540EM             0x100E
+#define E1000_DEV_ID_82540EM_LOM         0x1015
+#define E1000_DEV_ID_82540EP_LOM         0x1016
+#define E1000_DEV_ID_82540EP             0x1017
+#define E1000_DEV_ID_82540EP_LP          0x101E
+#define E1000_DEV_ID_82545EM_COPPER      0x100F
+#define E1000_DEV_ID_82545EM_FIBER       0x1011
+#define E1000_DEV_ID_82546EB_COPPER      0x1010
+#define E1000_DEV_ID_82546EB_FIBER       0x1012
+#define E1000_DEV_ID_82546EB_QUAD_COPPER 0x101D
+#define E1000_DEV_ID_82541EI             0x1013
+#define E1000_DEV_ID_82541EP             0x1018
+#define E1000_DEV_ID_82547EI             0x1019
+#define NUM_DEV_IDS 20
+
+#define NODE_ADDRESS_SIZE 6
+#define ETH_LENGTH_OF_ADDRESS 6
+
+/* MAC decode size is 128K - This is the size of BAR0 */
+#define MAC_DECODE_SIZE (128 * 1024)
+
+#define E1000_82542_2_0_REV_ID 2
+#define E1000_82542_2_1_REV_ID 3
+
+#define SPEED_10    10
+#define SPEED_100   100
+#define SPEED_1000  1000
+#define HALF_DUPLEX 1
+#define FULL_DUPLEX 2
+
+/* The sizes (in bytes) of a ethernet packet */
+#define ENET_HEADER_SIZE             14
+#define MAXIMUM_ETHERNET_FRAME_SIZE  1518 /* With FCS */
+#define MINIMUM_ETHERNET_FRAME_SIZE  64   /* With FCS */
+#define ETHERNET_FCS_SIZE            4
+#define MAXIMUM_ETHERNET_PACKET_SIZE \
+    (MAXIMUM_ETHERNET_FRAME_SIZE - ETHERNET_FCS_SIZE)
+#define MINIMUM_ETHERNET_PACKET_SIZE \
+    (MINIMUM_ETHERNET_FRAME_SIZE - ETHERNET_FCS_SIZE)
+#define CRC_LENGTH                   ETHERNET_FCS_SIZE
+#define MAX_JUMBO_FRAME_SIZE         0x3F00
+
+
+/* 802.1q VLAN Packet Sizes */
+#define VLAN_TAG_SIZE                     4     /* 802.3ac tag (not DMAed) */
+
+/* Ethertype field values */
+#define ETHERNET_IEEE_VLAN_TYPE 0x8100  /* 802.3ac packet */
+#define ETHERNET_IP_TYPE        0x0800  /* IP packets */
+#define ETHERNET_ARP_TYPE       0x0806  /* Address Resolution Protocol (ARP) */
+
+/* Packet Header defines */
+#define IP_PROTOCOL_TCP    6
+#define IP_PROTOCOL_UDP    0x11
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error 
+ */
+#define POLL_IMS_ENABLE_MASK ( \
+    E1000_IMS_RXDMT0 |         \
+    E1000_IMS_RXSEQ)
+
+/* This defines the bits that are set in the Interrupt Mask
+ * Set/Read Register.  Each bit is documented below:
+ *   o RXT0   = Receiver Timer Interrupt (ring 0)
+ *   o TXDW   = Transmit Descriptor Written Back
+ *   o RXDMT0 = Receive Descriptor Minimum Threshold hit (ring 0)
+ *   o RXSEQ  = Receive Sequence Error
+ *   o LSC    = Link Status Change
+ */
+#define IMS_ENABLE_MASK ( \
+    E1000_IMS_RXT0   |    \
+    E1000_IMS_TXDW   |    \
+    E1000_IMS_RXDMT0 |    \
+    E1000_IMS_RXSEQ  |    \
+    E1000_IMS_LSC)
+
+/* The number of high/low register pairs in the RAR. The RAR (Receive Address
+ * Registers) holds the directed and multicast addresses that we monitor. We
+ * reserve one of these spots for our directed address, allowing us room for
+ * E1000_RAR_ENTRIES - 1 multicast addresses. 
+ */
+#define E1000_RAR_ENTRIES 15
+
+#define MIN_NUMBER_OF_DESCRIPTORS 8
+#define MAX_NUMBER_OF_DESCRIPTORS 0xFFF8
+
+/* Receive Descriptor */
+struct e1000_rx_desc {
+    uint64_t buffer_addr; /* Address of the descriptor's data buffer */
+    uint16_t length;     /* Length of data DMAed into data buffer */
+    uint16_t csum;       /* Packet checksum */
+    uint8_t status;      /* Descriptor status */
+    uint8_t errors;      /* Descriptor Errors */
+    uint16_t special;
+};
+
+/* Receive Decriptor bit definitions */
+#define E1000_RXD_STAT_DD       0x01    /* Descriptor Done */
+#define E1000_RXD_STAT_EOP      0x02    /* End of Packet */
+#define E1000_RXD_STAT_IXSM     0x04    /* Ignore checksum */
+#define E1000_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
+#define E1000_RXD_STAT_TCPCS    0x20    /* TCP xsum calculated */
+#define E1000_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
+#define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
+#define E1000_RXD_ERR_CE        0x01    /* CRC Error */
+#define E1000_RXD_ERR_SE        0x02    /* Symbol Error */
+#define E1000_RXD_ERR_SEQ       0x04    /* Sequence Error */
+#define E1000_RXD_ERR_CXE       0x10    /* Carrier Extension Error */
+#define E1000_RXD_ERR_TCPE      0x20    /* TCP/UDP Checksum Error */
+#define E1000_RXD_ERR_IPE       0x40    /* IP Checksum Error */
+#define E1000_RXD_ERR_RXE       0x80    /* Rx Data Error */
+#define E1000_RXD_SPC_VLAN_MASK 0x0FFF  /* VLAN ID is in lower 12 bits */
+#define E1000_RXD_SPC_PRI_MASK  0xE000  /* Priority is in upper 3 bits */
+#define E1000_RXD_SPC_PRI_SHIFT 0x000D  /* Priority is in upper 3 of 16 */
+#define E1000_RXD_SPC_CFI_MASK  0x1000  /* CFI is bit 12 */
+#define E1000_RXD_SPC_CFI_SHIFT 0x000C  /* CFI is bit 12 */
+
+/* mask to determine if packets should be dropped due to frame errors */
+#define E1000_RXD_ERR_FRAME_ERR_MASK ( \
+    E1000_RXD_ERR_CE  |                \
+    E1000_RXD_ERR_SE  |                \
+    E1000_RXD_ERR_SEQ |                \
+    E1000_RXD_ERR_CXE |                \
+    E1000_RXD_ERR_RXE)
+
+/* Transmit Descriptor */
+struct e1000_tx_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's data buffer */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t cso;        /* Checksum offset */
+            uint8_t cmd;        /* Descriptor control */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t css;        /* Checksum start */
+            uint16_t special;
+        } fields;
+    } upper;
+};
+
+/* Transmit Descriptor bit definitions */
+#define E1000_TXD_DTYP_D     0x00100000 /* Data Descriptor */
+#define E1000_TXD_DTYP_C     0x00000000 /* Context Descriptor */
+#define E1000_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
+#define E1000_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
+#define E1000_TXD_CMD_EOP    0x01000000 /* End of Packet */
+#define E1000_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
+#define E1000_TXD_CMD_IC     0x04000000 /* Insert Checksum */
+#define E1000_TXD_CMD_RS     0x08000000 /* Report Status */
+#define E1000_TXD_CMD_RPS    0x10000000 /* Report Packet Sent */
+#define E1000_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
+#define E1000_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
+#define E1000_TXD_CMD_IDE    0x80000000 /* Enable Tidv register */
+#define E1000_TXD_STAT_DD    0x00000001 /* Descriptor Done */
+#define E1000_TXD_STAT_EC    0x00000002 /* Excess Collisions */
+#define E1000_TXD_STAT_LC    0x00000004 /* Late Collisions */
+#define E1000_TXD_STAT_TU    0x00000008 /* Transmit underrun */
+#define E1000_TXD_CMD_TCP    0x01000000 /* TCP packet */
+#define E1000_TXD_CMD_IP     0x02000000 /* IP packet */
+#define E1000_TXD_CMD_TSE    0x04000000 /* TCP Seg enable */
+#define E1000_TXD_STAT_TC    0x00000004 /* Tx Underrun */
+
+/* Offload Context Descriptor */
+struct e1000_context_desc {
+    union {
+        uint32_t ip_config;
+        struct {
+            uint8_t ipcss;      /* IP checksum start */
+            uint8_t ipcso;      /* IP checksum offset */
+            uint16_t ipcse;     /* IP checksum end */
+        } ip_fields;
+    } lower_setup;
+    union {
+        uint32_t tcp_config;
+        struct {
+            uint8_t tucss;      /* TCP checksum start */
+            uint8_t tucso;      /* TCP checksum offset */
+            uint16_t tucse;     /* TCP checksum end */
+        } tcp_fields;
+    } upper_setup;
+    uint32_t cmd_and_length;    /* */
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t hdr_len;    /* Header length */
+            uint16_t mss;       /* Maximum segment size */
+        } fields;
+    } tcp_seg_setup;
+};
+
+/* Offload data descriptor */
+struct e1000_data_desc {
+    uint64_t buffer_addr;       /* Address of the descriptor's buffer address */
+    union {
+        uint32_t data;
+        struct {
+            uint16_t length;    /* Data buffer length */
+            uint8_t typ_len_ext;        /* */
+            uint8_t cmd;        /* */
+        } flags;
+    } lower;
+    union {
+        uint32_t data;
+        struct {
+            uint8_t status;     /* Descriptor status */
+            uint8_t popts;      /* Packet Options */
+            uint16_t special;   /* */
+        } fields;
+    } upper;
+};
+
+/* Filters */
+#define E1000_NUM_UNICAST          16   /* Unicast filter entries */
+#define E1000_MC_TBL_SIZE          128  /* Multicast Filter Table (4096 bits) */
+#define E1000_VLAN_FILTER_TBL_SIZE 128  /* VLAN Filter Table (4096 bits) */
+
+
+/* Receive Address Register */
+struct e1000_rar {
+    volatile uint32_t low;      /* receive address low */
+    volatile uint32_t high;     /* receive address high */
+};
+
+/* The number of entries in the Multicast Table Array (MTA). */
+#define E1000_NUM_MTA_REGISTERS 128
+
+/* IPv4 Address Table Entry */
+struct e1000_ipv4_at_entry {
+    volatile uint32_t ipv4_addr;        /* IP Address (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four wakeup IP addresses are supported */
+#define E1000_WAKEUP_IP_ADDRESS_COUNT_MAX 4
+#define E1000_IP4AT_SIZE                  E1000_WAKEUP_IP_ADDRESS_COUNT_MAX
+#define E1000_IP6AT_SIZE                  1
+
+/* IPv6 Address Table Entry */
+struct e1000_ipv6_at_entry {
+    volatile uint8_t ipv6_addr[16];
+};
+
+/* Flexible Filter Length Table Entry */
+struct e1000_fflt_entry {
+    volatile uint32_t length;   /* Flexible Filter Length (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Mask Table Entry */
+struct e1000_ffmt_entry {
+    volatile uint32_t mask;     /* Flexible Filter Mask (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Flexible Filter Value Table Entry */
+struct e1000_ffvt_entry {
+    volatile uint32_t value;    /* Flexible Filter Value (RW) */
+    volatile uint32_t reserved;
+};
+
+/* Four Flexible Filters are supported */
+#define E1000_FLEXIBLE_FILTER_COUNT_MAX 4
+
+/* Each Flexible Filter is at most 128 (0x80) bytes in length */
+#define E1000_FLEXIBLE_FILTER_SIZE_MAX  128
+
+#define E1000_FFLT_SIZE E1000_FLEXIBLE_FILTER_COUNT_MAX
+#define E1000_FFMT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+#define E1000_FFVT_SIZE E1000_FLEXIBLE_FILTER_SIZE_MAX
+
+/* Register Set. (82543, 82544)
+ *
+ * Registers are defined to be 32 bits and  should be accessed as 32 bit values.
+ * These registers are physically located on the NIC, but are mapped into the 
+ * host memory address space.
+ *
+ * RW - register is both readable and writable
+ * RO - register is read only
+ * WO - register is write only
+ * R/clr - register is read only and is cleared when read
+ * A - register array
+ */
+#define E1000_CTRL     0x00000  /* Device Control - RW */
+#define E1000_STATUS   0x00008  /* Device Status - RO */
+#define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
+#define E1000_EERD     0x00014  /* EEPROM Read - RW */
+#define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
+#define E1000_FLA      0x0001C  /* Flash Access - RW */
+#define E1000_MDIC     0x00020  /* MDI Control - RW */
+#define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
+#define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
+#define E1000_FCT      0x00030  /* Flow Control Type - RW */
+#define E1000_VET      0x00038  /* VLAN Ether Type - RW */
+#define E1000_ICR      0x000C0  /* Interrupt Cause Read - R/clr */
+#define E1000_ITR      0x000C4  /* Interrupt Throttling Rate - RW */
+#define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
+#define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
+#define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
+#define E1000_RCTL     0x00100  /* RX Control - RW */
+#define E1000_FCTTV    0x00170  /* Flow Control Transmit Timer Value - RW */
+#define E1000_TXCW     0x00178  /* TX Configuration Word - RW */
+#define E1000_RXCW     0x00180  /* RX Configuration Word - RO */
+#define E1000_TCTL     0x00400  /* TX Control - RW */
+#define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
+#define E1000_TBT      0x00448  /* TX Burst Timer - RW */
+#define E1000_AIT      0x00458  /* Adaptive Interframe Spacing Throttle - RW */
+#define E1000_LEDCTL   0x00E00  /* LED Control - RW */
+#define E1000_PBA      0x01000  /* Packet Buffer Allocation - RW */
+#define E1000_FCRTL    0x02160  /* Flow Control Receive Threshold Low - RW */
+#define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
+#define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
+#define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
+#define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
+#define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
+#define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
+#define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
+#define E1000_RXDCTL   0x02828  /* RX Descriptor Control - RW */
+#define E1000_RADV     0x0282C  /* RX Interrupt Absolute Delay Timer - RW */
+#define E1000_RSRPD    0x02C00  /* RX Small Packet Detect - RW */
+#define E1000_TXDMAC   0x03000  /* TX DMA Control - RW */
+#define E1000_TDFH     0x03410  /* TX Data FIFO Head - RW */
+#define E1000_TDFT     0x03418  /* TX Data FIFO Tail - RW */
+#define E1000_TDFHS    0x03420  /* TX Data FIFO Head Saved - RW */
+#define E1000_TDFTS    0x03428  /* TX Data FIFO Tail Saved - RW */
+#define E1000_TDFPC    0x03430  /* TX Data FIFO Packet Count - RW */
+#define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
+#define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
+#define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
+#define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
+#define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
+#define E1000_TIDV     0x03820  /* TX Interrupt Delay Value - RW */
+#define E1000_TXDCTL   0x03828  /* TX Descriptor Control - RW */
+#define E1000_TADV     0x0382C  /* TX Interrupt Absolute Delay Val - RW */
+#define E1000_TSPMT    0x03830  /* TCP Segmentation PAD & Min Threshold - RW */
+#define E1000_CRCERRS  0x04000  /* CRC Error Count - R/clr */
+#define E1000_ALGNERRC 0x04004  /* Alignment Error Count - R/clr */
+#define E1000_SYMERRS  0x04008  /* Symbol Error Count - R/clr */
+#define E1000_RXERRC   0x0400C  /* Receive Error Count - R/clr */
+#define E1000_MPC      0x04010  /* Missed Packet Count - R/clr */
+#define E1000_SCC      0x04014  /* Single Collision Count - R/clr */
+#define E1000_ECOL     0x04018  /* Excessive Collision Count - R/clr */
+#define E1000_MCC      0x0401C  /* Multiple Collision Count - R/clr */
+#define E1000_LATECOL  0x04020  /* Late Collision Count - R/clr */
+#define E1000_COLC     0x04028  /* Collision Count - R/clr */
+#define E1000_DC       0x04030  /* Defer Count - R/clr */
+#define E1000_TNCRS    0x04034  /* TX-No CRS - R/clr */
+#define E1000_SEC      0x04038  /* Sequence Error Count - R/clr */
+#define E1000_CEXTERR  0x0403C  /* Carrier Extension Error Count - R/clr */
+#define E1000_RLEC     0x04040  /* Receive Length Error Count - R/clr */
+#define E1000_XONRXC   0x04048  /* XON RX Count - R/clr */
+#define E1000_XONTXC   0x0404C  /* XON TX Count - R/clr */
+#define E1000_XOFFRXC  0x04050  /* XOFF RX Count - R/clr */
+#define E1000_XOFFTXC  0x04054  /* XOFF TX Count - R/clr */
+#define E1000_FCRUC    0x04058  /* Flow Control RX Unsupported Count- R/clr */
+#define E1000_PRC64    0x0405C  /* Packets RX (64 bytes) - R/clr */
+#define E1000_PRC127   0x04060  /* Packets RX (65-127 bytes) - R/clr */
+#define E1000_PRC255   0x04064  /* Packets RX (128-255 bytes) - R/clr */
+#define E1000_PRC511   0x04068  /* Packets RX (255-511 bytes) - R/clr */
+#define E1000_PRC1023  0x0406C  /* Packets RX (512-1023 bytes) - R/clr */
+#define E1000_PRC1522  0x04070  /* Packets RX (1024-1522 bytes) - R/clr */
+#define E1000_GPRC     0x04074  /* Good Packets RX Count - R/clr */
+#define E1000_BPRC     0x04078  /* Broadcast Packets RX Count - R/clr */
+#define E1000_MPRC     0x0407C  /* Multicast Packets RX Count - R/clr */
+#define E1000_GPTC     0x04080  /* Good Packets TX Count - R/clr */
+#define E1000_GORCL    0x04088  /* Good Octets RX Count Low - R/clr */
+#define E1000_GORCH    0x0408C  /* Good Octets RX Count High - R/clr */
+#define E1000_GOTCL    0x04090  /* Good Octets TX Count Low - R/clr */
+#define E1000_GOTCH    0x04094  /* Good Octets TX Count High - R/clr */
+#define E1000_RNBC     0x040A0  /* RX No Buffers Count - R/clr */
+#define E1000_RUC      0x040A4  /* RX Undersize Count - R/clr */
+#define E1000_RFC      0x040A8  /* RX Fragment Count - R/clr */
+#define E1000_ROC      0x040AC  /* RX Oversize Count - R/clr */
+#define E1000_RJC      0x040B0  /* RX Jabber Count - R/clr */
+#define E1000_MGTPRC   0x040B4  /* Management Packets RX Count - R/clr */
+#define E1000_MGTPDC   0x040B8  /* Management Packets Dropped Count - R/clr */
+#define E1000_MGTPTC   0x040BC  /* Management Packets TX Count - R/clr */
+#define E1000_TORL     0x040C0  /* Total Octets RX Low - R/clr */
+#define E1000_TORH     0x040C4  /* Total Octets RX High - R/clr */
+#define E1000_TOTL     0x040C8  /* Total Octets TX Low - R/clr */
+#define E1000_TOTH     0x040CC  /* Total Octets TX High - R/clr */
+#define E1000_TPR      0x040D0  /* Total Packets RX - R/clr */
+#define E1000_TPT      0x040D4  /* Total Packets TX - R/clr */
+#define E1000_PTC64    0x040D8  /* Packets TX (64 bytes) - R/clr */
+#define E1000_PTC127   0x040DC  /* Packets TX (65-127 bytes) - R/clr */
+#define E1000_PTC255   0x040E0  /* Packets TX (128-255 bytes) - R/clr */
+#define E1000_PTC511   0x040E4  /* Packets TX (256-511 bytes) - R/clr */
+#define E1000_PTC1023  0x040E8  /* Packets TX (512-1023 bytes) - R/clr */
+#define E1000_PTC1522  0x040EC  /* Packets TX (1024-1522 Bytes) - R/clr */
+#define E1000_MPTC     0x040F0  /* Multicast Packets TX Count - R/clr */
+#define E1000_BPTC     0x040F4  /* Broadcast Packets TX Count - R/clr */
+#define E1000_TSCTC    0x040F8  /* TCP Segmentation Context TX - R/clr */
+#define E1000_TSCTFC   0x040FC  /* TCP Segmentation Context TX Fail - R/clr */
+#define E1000_RXCSUM   0x05000  /* RX Checksum Control - RW */
+#define E1000_MTA      0x05200  /* Multicast Table Array - RW Array */
+#define E1000_RA       0x05400  /* Receive Address - RW Array */
+#define E1000_VFTA     0x05600  /* VLAN Filter Table Array - RW Array */
+#define E1000_WUC      0x05800  /* Wakeup Control - RW */
+#define E1000_WUFC     0x05808  /* Wakeup Filter Control - RW */
+#define E1000_WUS      0x05810  /* Wakeup Status - RO */
+#define E1000_MANC     0x05820  /* Management Control - RW */
+#define E1000_IPAV     0x05838  /* IP Address Valid - RW */
+#define E1000_IP4AT    0x05840  /* IPv4 Address Table - RW Array */
+#define E1000_IP6AT    0x05880  /* IPv6 Address Table - RW Array */
+#define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
+#define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
+#define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
+#define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
+#define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
+
+/* Register Set (82542)
+ *
+ * Some of the 82542 registers are located at different offsets than they are
+ * in more current versions of the 8254x. Despite the difference in location,
+ * the registers function in the same manner.
+ */
+#define E1000_82542_CTRL     E1000_CTRL
+#define E1000_82542_CTRL_DUP E1000_CTRL_DUP
+#define E1000_82542_STATUS   E1000_STATUS
+#define E1000_82542_EECD     E1000_EECD
+#define E1000_82542_EERD     E1000_EERD
+#define E1000_82542_CTRL_EXT E1000_CTRL_EXT
+#define E1000_82542_FLA      E1000_FLA
+#define E1000_82542_MDIC     E1000_MDIC
+#define E1000_82542_FCAL     E1000_FCAL
+#define E1000_82542_FCAH     E1000_FCAH
+#define E1000_82542_FCT      E1000_FCT
+#define E1000_82542_VET      E1000_VET
+#define E1000_82542_RA       0x00040
+#define E1000_82542_ICR      E1000_ICR
+#define E1000_82542_ITR      E1000_ITR
+#define E1000_82542_ICS      E1000_ICS
+#define E1000_82542_IMS      E1000_IMS
+#define E1000_82542_IMC      E1000_IMC
+#define E1000_82542_RCTL     E1000_RCTL
+#define E1000_82542_RDTR     0x00108
+#define E1000_82542_RDBAL    0x00110
+#define E1000_82542_RDBAH    0x00114
+#define E1000_82542_RDLEN    0x00118
+#define E1000_82542_RDH      0x00120
+#define E1000_82542_RDT      0x00128
+#define E1000_82542_FCRTH    0x00160
+#define E1000_82542_FCRTL    0x00168
+#define E1000_82542_FCTTV    E1000_FCTTV
+#define E1000_82542_TXCW     E1000_TXCW
+#define E1000_82542_RXCW     E1000_RXCW
+#define E1000_82542_MTA      0x00200
+#define E1000_82542_TCTL     E1000_TCTL
+#define E1000_82542_TIPG     E1000_TIPG
+#define E1000_82542_TDBAL    0x00420
+#define E1000_82542_TDBAH    0x00424
+#define E1000_82542_TDLEN    0x00428
+#define E1000_82542_TDH      0x00430
+#define E1000_82542_TDT      0x00438
+#define E1000_82542_TIDV     0x00440
+#define E1000_82542_TBT      E1000_TBT
+#define E1000_82542_AIT      E1000_AIT
+#define E1000_82542_VFTA     0x00600
+#define E1000_82542_LEDCTL   E1000_LEDCTL
+#define E1000_82542_PBA      E1000_PBA
+#define E1000_82542_RXDCTL   E1000_RXDCTL
+#define E1000_82542_RADV     E1000_RADV
+#define E1000_82542_RSRPD    E1000_RSRPD
+#define E1000_82542_TXDMAC   E1000_TXDMAC
+#define E1000_82542_TDFHS    E1000_TDFHS
+#define E1000_82542_TDFTS    E1000_TDFTS
+#define E1000_82542_TDFPC    E1000_TDFPC
+#define E1000_82542_TXDCTL   E1000_TXDCTL
+#define E1000_82542_TADV     E1000_TADV
+#define E1000_82542_TSPMT    E1000_TSPMT
+#define E1000_82542_CRCERRS  E1000_CRCERRS
+#define E1000_82542_ALGNERRC E1000_ALGNERRC
+#define E1000_82542_SYMERRS  E1000_SYMERRS
+#define E1000_82542_RXERRC   E1000_RXERRC
+#define E1000_82542_MPC      E1000_MPC
+#define E1000_82542_SCC      E1000_SCC
+#define E1000_82542_ECOL     E1000_ECOL
+#define E1000_82542_MCC      E1000_MCC
+#define E1000_82542_LATECOL  E1000_LATECOL
+#define E1000_82542_COLC     E1000_COLC
+#define E1000_82542_DC       E1000_DC
+#define E1000_82542_TNCRS    E1000_TNCRS
+#define E1000_82542_SEC      E1000_SEC
+#define E1000_82542_CEXTERR  E1000_CEXTERR
+#define E1000_82542_RLEC     E1000_RLEC
+#define E1000_82542_XONRXC   E1000_XONRXC
+#define E1000_82542_XONTXC   E1000_XONTXC
+#define E1000_82542_XOFFRXC  E1000_XOFFRXC
+#define E1000_82542_XOFFTXC  E1000_XOFFTXC
+#define E1000_82542_FCRUC    E1000_FCRUC
+#define E1000_82542_PRC64    E1000_PRC64
+#define E1000_82542_PRC127   E1000_PRC127
+#define E1000_82542_PRC255   E1000_PRC255
+#define E1000_82542_PRC511   E1000_PRC511
+#define E1000_82542_PRC1023  E1000_PRC1023
+#define E1000_82542_PRC1522  E1000_PRC1522
+#define E1000_82542_GPRC     E1000_GPRC
+#define E1000_82542_BPRC     E1000_BPRC
+#define E1000_82542_MPRC     E1000_MPRC
+#define E1000_82542_GPTC     E1000_GPTC
+#define E1000_82542_GORCL    E1000_GORCL
+#define E1000_82542_GORCH    E1000_GORCH
+#define E1000_82542_GOTCL    E1000_GOTCL
+#define E1000_82542_GOTCH    E1000_GOTCH
+#define E1000_82542_RNBC     E1000_RNBC
+#define E1000_82542_RUC      E1000_RUC
+#define E1000_82542_RFC      E1000_RFC
+#define E1000_82542_ROC      E1000_ROC
+#define E1000_82542_RJC      E1000_RJC
+#define E1000_82542_MGTPRC   E1000_MGTPRC
+#define E1000_82542_MGTPDC   E1000_MGTPDC
+#define E1000_82542_MGTPTC   E1000_MGTPTC
+#define E1000_82542_TORL     E1000_TORL
+#define E1000_82542_TORH     E1000_TORH
+#define E1000_82542_TOTL     E1000_TOTL
+#define E1000_82542_TOTH     E1000_TOTH
+#define E1000_82542_TPR      E1000_TPR
+#define E1000_82542_TPT      E1000_TPT
+#define E1000_82542_PTC64    E1000_PTC64
+#define E1000_82542_PTC127   E1000_PTC127
+#define E1000_82542_PTC255   E1000_PTC255
+#define E1000_82542_PTC511   E1000_PTC511
+#define E1000_82542_PTC1023  E1000_PTC1023
+#define E1000_82542_PTC1522  E1000_PTC1522
+#define E1000_82542_MPTC     E1000_MPTC
+#define E1000_82542_BPTC     E1000_BPTC
+#define E1000_82542_TSCTC    E1000_TSCTC
+#define E1000_82542_TSCTFC   E1000_TSCTFC
+#define E1000_82542_RXCSUM   E1000_RXCSUM
+#define E1000_82542_WUC      E1000_WUC
+#define E1000_82542_WUFC     E1000_WUFC
+#define E1000_82542_WUS      E1000_WUS
+#define E1000_82542_MANC     E1000_MANC
+#define E1000_82542_IPAV     E1000_IPAV
+#define E1000_82542_IP4AT    E1000_IP4AT
+#define E1000_82542_IP6AT    E1000_IP6AT
+#define E1000_82542_WUPL     E1000_WUPL
+#define E1000_82542_WUPM     E1000_WUPM
+#define E1000_82542_FFLT     E1000_FFLT
+#define E1000_82542_TDFH     0x08010
+#define E1000_82542_TDFT     0x08018
+#define E1000_82542_FFMT     E1000_FFMT
+#define E1000_82542_FFVT     E1000_FFVT
+
+/* Statistics counters collected by the MAC */
+struct e1000_hw_stats {
+    uint64_t crcerrs;
+    uint64_t algnerrc;
+    uint64_t symerrs;
+    uint64_t rxerrc;
+    uint64_t mpc;
+    uint64_t scc;
+    uint64_t ecol;
+    uint64_t mcc;
+    uint64_t latecol;
+    uint64_t colc;
+    uint64_t dc;
+    uint64_t tncrs;
+    uint64_t sec;
+    uint64_t cexterr;
+    uint64_t rlec;
+    uint64_t xonrxc;
+    uint64_t xontxc;
+    uint64_t xoffrxc;
+    uint64_t xofftxc;
+    uint64_t fcruc;
+    uint64_t prc64;
+    uint64_t prc127;
+    uint64_t prc255;
+    uint64_t prc511;
+    uint64_t prc1023;
+    uint64_t prc1522;
+    uint64_t gprc;
+    uint64_t bprc;
+    uint64_t mprc;
+    uint64_t gptc;
+    uint64_t gorcl;
+    uint64_t gorch;
+    uint64_t gotcl;
+    uint64_t gotch;
+    uint64_t rnbc;
+    uint64_t ruc;
+    uint64_t rfc;
+    uint64_t roc;
+    uint64_t rjc;
+    uint64_t mgprc;
+    uint64_t mgpdc;
+    uint64_t mgptc;
+    uint64_t torl;
+    uint64_t torh;
+    uint64_t totl;
+    uint64_t toth;
+    uint64_t tpr;
+    uint64_t tpt;
+    uint64_t ptc64;
+    uint64_t ptc127;
+    uint64_t ptc255;
+    uint64_t ptc511;
+    uint64_t ptc1023;
+    uint64_t ptc1522;
+    uint64_t mptc;
+    uint64_t bptc;
+    uint64_t tsctc;
+    uint64_t tsctfc;
+};
+
+/* Structure containing variables used by the shared code (e1000_hw.c) */
+struct e1000_hw {
+	struct pci_device *pdev;
+	uint8_t *hw_addr;
+	e1000_mac_type   mac_type;
+	e1000_phy_type phy_type;
+	uint32_t phy_init_script;
+	e1000_media_type media_type;
+	e1000_fc_type    fc;
+#if 0
+	e1000_bus_speed bus_speed;
+	e1000_bus_width bus_width;
+	e1000_bus_type  bus_type;
+#endif
+	struct e1000_eeprom_info eeprom;
+#if 0
+	uint32_t io_base;
+#endif
+	uint32_t phy_id;
+#ifdef LINUX_DRIVER
+	uint32_t phy_revision;
+#endif
+	uint32_t phy_addr;
+	uint32_t original_fc;
+	uint32_t txcw;
+	uint32_t autoneg_failed;
+#if 0
+	uint32_t max_frame_size;
+	uint32_t min_frame_size;
+	uint32_t mc_filter_type;
+	uint32_t num_mc_addrs;
+	uint32_t collision_delta;
+	uint32_t tx_packet_delta;
+	uint32_t ledctl_default;
+	uint32_t ledctl_mode1;
+	uint32_t ledctl_mode2;
+#endif
+	uint16_t autoneg_advertised;
+	uint16_t pci_cmd_word;
+	uint16_t fc_high_water;
+	uint16_t fc_low_water;
+	uint16_t fc_pause_time;
+#if 0
+	uint16_t current_ifs_val;
+	uint16_t ifs_min_val;
+	uint16_t ifs_max_val;
+	uint16_t ifs_step_size;
+	uint16_t ifs_ratio;
+#endif
+	uint16_t device_id;
+	uint16_t vendor_id;
+	uint16_t subsystem_id;
+	uint16_t subsystem_vendor_id;
+	uint8_t revision_id;
+#if 0
+	uint8_t autoneg;
+	uint8_t mdix;
+	uint8_t forced_speed_duplex;
+	uint8_t wait_autoneg_complete;
+	uint8_t dma_fairness;
+#endif
+	uint8_t mac_addr[NODE_ADDRESS_SIZE];
+#if 0
+	uint8_t perm_mac_addr[NODE_ADDRESS_SIZE];
+	boolean_t disable_polarity_correction;
+	boolean_t speed_downgraded;
+#endif
+	boolean_t get_link_status;
+	boolean_t tbi_compatibility_en;
+	boolean_t tbi_compatibility_on;
+	boolean_t fc_send_xon;
+	boolean_t report_tx_early;
+#if 0
+	boolean_t adaptive_ifs;
+	boolean_t ifs_params_forced;
+	boolean_t in_ifs_mode;
+#endif
+};
+
+
+#define E1000_EEPROM_SWDPIN0   0x0001   /* SWDPIN 0 EEPROM Value */
+#define E1000_EEPROM_LED_LOGIC 0x0020   /* Led Logic Word */
+
+/* Register Bit Masks */
+/* Device Control */
+#define E1000_CTRL_FD       0x00000001  /* Full duplex.0=half; 1=full */
+#define E1000_CTRL_BEM      0x00000002  /* Endian Mode.0=little,1=big */
+#define E1000_CTRL_PRIOR    0x00000004  /* Priority on PCI. 0=rx,1=fair */
+#define E1000_CTRL_LRST     0x00000008  /* Link reset. 0=normal,1=reset */
+#define E1000_CTRL_TME      0x00000010  /* Test mode. 0=normal,1=test */
+#define E1000_CTRL_SLE      0x00000020  /* Serial Link on 0=dis,1=en */
+#define E1000_CTRL_ASDE     0x00000020  /* Auto-speed detect enable */
+#define E1000_CTRL_SLU      0x00000040  /* Set link up (Force Link) */
+#define E1000_CTRL_ILOS     0x00000080  /* Invert Loss-Of Signal */
+#define E1000_CTRL_SPD_SEL  0x00000300  /* Speed Select Mask */
+#define E1000_CTRL_SPD_10   0x00000000  /* Force 10Mb */
+#define E1000_CTRL_SPD_100  0x00000100  /* Force 100Mb */
+#define E1000_CTRL_SPD_1000 0x00000200  /* Force 1Gb */
+#define E1000_CTRL_BEM32    0x00000400  /* Big Endian 32 mode */
+#define E1000_CTRL_FRCSPD   0x00000800  /* Force Speed */
+#define E1000_CTRL_FRCDPX   0x00001000  /* Force Duplex */
+#define E1000_CTRL_SWDPIN0  0x00040000  /* SWDPIN 0 value */
+#define E1000_CTRL_SWDPIN1  0x00080000  /* SWDPIN 1 value */
+#define E1000_CTRL_SWDPIN2  0x00100000  /* SWDPIN 2 value */
+#define E1000_CTRL_SWDPIN3  0x00200000  /* SWDPIN 3 value */
+#define E1000_CTRL_SWDPIO0  0x00400000  /* SWDPIN 0 Input or output */
+#define E1000_CTRL_SWDPIO1  0x00800000  /* SWDPIN 1 input or output */
+#define E1000_CTRL_SWDPIO2  0x01000000  /* SWDPIN 2 input or output */
+#define E1000_CTRL_SWDPIO3  0x02000000  /* SWDPIN 3 input or output */
+#define E1000_CTRL_RST      0x04000000  /* Global reset */
+#define E1000_CTRL_RFCE     0x08000000  /* Receive Flow Control enable */
+#define E1000_CTRL_TFCE     0x10000000  /* Transmit flow control enable */
+#define E1000_CTRL_RTE      0x20000000  /* Routing tag enable */
+#define E1000_CTRL_VME      0x40000000  /* IEEE VLAN mode enable */
+#define E1000_CTRL_PHY_RST  0x80000000  /* PHY Reset */
+
+/* Device Status */
+#define E1000_STATUS_FD         0x00000001      /* Full duplex.0=half,1=full */
+#define E1000_STATUS_LU         0x00000002      /* Link up.0=no,1=link */
+#define E1000_STATUS_FUNC_MASK  0x0000000C      /* PCI Function Mask */
+#define E1000_STATUS_FUNC_0     0x00000000      /* Function 0 */
+#define E1000_STATUS_FUNC_1     0x00000004      /* Function 1 */
+#define E1000_STATUS_TXOFF      0x00000010      /* transmission paused */
+#define E1000_STATUS_TBIMODE    0x00000020      /* TBI mode */
+#define E1000_STATUS_SPEED_MASK 0x000000C0
+#define E1000_STATUS_SPEED_10   0x00000000      /* Speed 10Mb/s */
+#define E1000_STATUS_SPEED_100  0x00000040      /* Speed 100Mb/s */
+#define E1000_STATUS_SPEED_1000 0x00000080      /* Speed 1000Mb/s */
+#define E1000_STATUS_ASDV       0x00000300      /* Auto speed detect value */
+#define E1000_STATUS_MTXCKOK    0x00000400      /* MTX clock running OK */
+#define E1000_STATUS_PCI66      0x00000800      /* In 66Mhz slot */
+#define E1000_STATUS_BUS64      0x00001000      /* In 64 bit slot */
+#define E1000_STATUS_PCIX_MODE  0x00002000      /* PCI-X mode */
+#define E1000_STATUS_PCIX_SPEED 0x0000C000      /* PCI-X bus speed */
+
+/* Constants used to intrepret the masked PCI-X bus speed. */
+#define E1000_STATUS_PCIX_SPEED_66  0x00000000 /* PCI-X bus speed  50-66 MHz */
+#define E1000_STATUS_PCIX_SPEED_100 0x00004000 /* PCI-X bus speed  66-100 MHz */
+#define E1000_STATUS_PCIX_SPEED_133 0x00008000 /* PCI-X bus speed 100-133 MHz */
+
+/* EEPROM/Flash Control */
+#define E1000_EECD_SK        0x00000001 /* EEPROM Clock */
+#define E1000_EECD_CS        0x00000002 /* EEPROM Chip Select */
+#define E1000_EECD_DI        0x00000004 /* EEPROM Data In */
+#define E1000_EECD_DO        0x00000008 /* EEPROM Data Out */
+#define E1000_EECD_FWE_MASK  0x00000030 
+#define E1000_EECD_FWE_DIS   0x00000010 /* Disable FLASH writes */
+#define E1000_EECD_FWE_EN    0x00000020 /* Enable FLASH writes */
+#define E1000_EECD_FWE_SHIFT 4
+#define E1000_EECD_REQ       0x00000040 /* EEPROM Access Request */
+#define E1000_EECD_GNT       0x00000080 /* EEPROM Access Grant */
+#define E1000_EECD_PRES      0x00000100 /* EEPROM Present */
+#define E1000_EECD_SIZE      0x00000200 /* EEPROM Size (0=64 word 1=256 word) */
+#define E1000_EECD_ADDR_BITS 0x00000400 /* EEPROM Addressing bits based on type
+                                         * (0-small, 1-large) */
+#define E1000_EECD_TYPE      0x00002000 /* EEPROM Type (1-SPI, 0-Microwire) */
+#ifndef E1000_EEPROM_GRANT_ATTEMPTS
+#define E1000_EEPROM_GRANT_ATTEMPTS 1000 /* EEPROM # attempts to gain grant */
+#endif
+
+/* EEPROM Read */
+#define E1000_EERD_START      0x00000001 /* Start Read */
+#define E1000_EERD_DONE       0x00000010 /* Read Done */
+#define E1000_EERD_ADDR_SHIFT 8
+#define E1000_EERD_ADDR_MASK  0x0000FF00 /* Read Address */
+#define E1000_EERD_DATA_SHIFT 16
+#define E1000_EERD_DATA_MASK  0xFFFF0000 /* Read Data */
+
+/* SPI EEPROM Status Register */
+#define EEPROM_STATUS_RDY_SPI  0x01
+#define EEPROM_STATUS_WEN_SPI  0x02
+#define EEPROM_STATUS_BP0_SPI  0x04
+#define EEPROM_STATUS_BP1_SPI  0x08
+#define EEPROM_STATUS_WPEN_SPI 0x80
+
+/* Extended Device Control */
+#define E1000_CTRL_EXT_GPI0_EN   0x00000001 /* Maps SDP4 to GPI0 */ 
+#define E1000_CTRL_EXT_GPI1_EN   0x00000002 /* Maps SDP5 to GPI1 */
+#define E1000_CTRL_EXT_PHYINT_EN E1000_CTRL_EXT_GPI1_EN
+#define E1000_CTRL_EXT_GPI2_EN   0x00000004 /* Maps SDP6 to GPI2 */
+#define E1000_CTRL_EXT_GPI3_EN   0x00000008 /* Maps SDP7 to GPI3 */
+#define E1000_CTRL_EXT_SDP4_DATA 0x00000010 /* Value of SW Defineable Pin 4 */
+#define E1000_CTRL_EXT_SDP5_DATA 0x00000020 /* Value of SW Defineable Pin 5 */
+#define E1000_CTRL_EXT_PHY_INT   E1000_CTRL_EXT_SDP5_DATA
+#define E1000_CTRL_EXT_SDP6_DATA 0x00000040 /* Value of SW Defineable Pin 6 */
+#define E1000_CTRL_EXT_SDP7_DATA 0x00000080 /* Value of SW Defineable Pin 7 */
+#define E1000_CTRL_EXT_SDP4_DIR  0x00000100 /* Direction of SDP4 0=in 1=out */
+#define E1000_CTRL_EXT_SDP5_DIR  0x00000200 /* Direction of SDP5 0=in 1=out */
+#define E1000_CTRL_EXT_SDP6_DIR  0x00000400 /* Direction of SDP6 0=in 1=out */
+#define E1000_CTRL_EXT_SDP7_DIR  0x00000800 /* Direction of SDP7 0=in 1=out */
+#define E1000_CTRL_EXT_ASDCHK    0x00001000 /* Initiate an ASD sequence */
+#define E1000_CTRL_EXT_EE_RST    0x00002000 /* Reinitialize from EEPROM */
+#define E1000_CTRL_EXT_IPS       0x00004000 /* Invert Power State */
+#define E1000_CTRL_EXT_SPD_BYPS  0x00008000 /* Speed Select Bypass */
+#define E1000_CTRL_EXT_LINK_MODE_MASK 0x00C00000
+#define E1000_CTRL_EXT_LINK_MODE_GMII 0x00000000
+#define E1000_CTRL_EXT_LINK_MODE_TBI  0x00C00000
+#define E1000_CTRL_EXT_WR_WMARK_MASK  0x03000000
+#define E1000_CTRL_EXT_WR_WMARK_256   0x00000000
+#define E1000_CTRL_EXT_WR_WMARK_320   0x01000000
+#define E1000_CTRL_EXT_WR_WMARK_384   0x02000000
+#define E1000_CTRL_EXT_WR_WMARK_448   0x03000000
+
+/* MDI Control */
+#define E1000_MDIC_DATA_MASK 0x0000FFFF
+#define E1000_MDIC_REG_MASK  0x001F0000
+#define E1000_MDIC_REG_SHIFT 16
+#define E1000_MDIC_PHY_MASK  0x03E00000
+#define E1000_MDIC_PHY_SHIFT 21
+#define E1000_MDIC_OP_WRITE  0x04000000
+#define E1000_MDIC_OP_READ   0x08000000
+#define E1000_MDIC_READY     0x10000000
+#define E1000_MDIC_INT_EN    0x20000000
+#define E1000_MDIC_ERROR     0x40000000
+
+/* LED Control */
+#define E1000_LEDCTL_LED0_MODE_MASK  0x0000000F
+#define E1000_LEDCTL_LED0_MODE_SHIFT 0
+#define E1000_LEDCTL_LED0_IVRT       0x00000040
+#define E1000_LEDCTL_LED0_BLINK      0x00000080
+#define E1000_LEDCTL_LED1_MODE_MASK  0x00000F00
+#define E1000_LEDCTL_LED1_MODE_SHIFT 8
+#define E1000_LEDCTL_LED1_IVRT       0x00004000
+#define E1000_LEDCTL_LED1_BLINK      0x00008000
+#define E1000_LEDCTL_LED2_MODE_MASK  0x000F0000
+#define E1000_LEDCTL_LED2_MODE_SHIFT 16
+#define E1000_LEDCTL_LED2_IVRT       0x00400000
+#define E1000_LEDCTL_LED2_BLINK      0x00800000
+#define E1000_LEDCTL_LED3_MODE_MASK  0x0F000000
+#define E1000_LEDCTL_LED3_MODE_SHIFT 24
+#define E1000_LEDCTL_LED3_IVRT       0x40000000
+#define E1000_LEDCTL_LED3_BLINK      0x80000000
+
+#define E1000_LEDCTL_MODE_LINK_10_1000  0x0
+#define E1000_LEDCTL_MODE_LINK_100_1000 0x1
+#define E1000_LEDCTL_MODE_LINK_UP       0x2
+#define E1000_LEDCTL_MODE_ACTIVITY      0x3
+#define E1000_LEDCTL_MODE_LINK_ACTIVITY 0x4
+#define E1000_LEDCTL_MODE_LINK_10       0x5
+#define E1000_LEDCTL_MODE_LINK_100      0x6
+#define E1000_LEDCTL_MODE_LINK_1000     0x7
+#define E1000_LEDCTL_MODE_PCIX_MODE     0x8
+#define E1000_LEDCTL_MODE_FULL_DUPLEX   0x9
+#define E1000_LEDCTL_MODE_COLLISION     0xA
+#define E1000_LEDCTL_MODE_BUS_SPEED     0xB
+#define E1000_LEDCTL_MODE_BUS_SIZE      0xC
+#define E1000_LEDCTL_MODE_PAUSED        0xD
+#define E1000_LEDCTL_MODE_LED_ON        0xE
+#define E1000_LEDCTL_MODE_LED_OFF       0xF
+
+/* Receive Address */
+#define E1000_RAH_AV  0x80000000        /* Receive descriptor valid */
+
+/* Interrupt Cause Read */
+#define E1000_ICR_TXDW    0x00000001    /* Transmit desc written back */
+#define E1000_ICR_TXQE    0x00000002    /* Transmit Queue empty */
+#define E1000_ICR_LSC     0x00000004    /* Link Status Change */
+#define E1000_ICR_RXSEQ   0x00000008    /* rx sequence error */
+#define E1000_ICR_RXDMT0  0x00000010    /* rx desc min. threshold (0) */
+#define E1000_ICR_RXO     0x00000040    /* rx overrun */
+#define E1000_ICR_RXT0    0x00000080    /* rx timer intr (ring 0) */
+#define E1000_ICR_MDAC    0x00000200    /* MDIO access complete */
+#define E1000_ICR_RXCFG   0x00000400    /* RX /c/ ordered set */
+#define E1000_ICR_GPI_EN0 0x00000800    /* GP Int 0 */
+#define E1000_ICR_GPI_EN1 0x00001000    /* GP Int 1 */
+#define E1000_ICR_GPI_EN2 0x00002000    /* GP Int 2 */
+#define E1000_ICR_GPI_EN3 0x00004000    /* GP Int 3 */
+#define E1000_ICR_TXD_LOW 0x00008000
+#define E1000_ICR_SRPD    0x00010000
+
+/* Interrupt Cause Set */
+#define E1000_ICS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_ICS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_ICS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_ICS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_ICS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_ICS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_ICS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_ICS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_ICS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_ICS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_ICS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_ICS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_ICS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_ICS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_ICS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Set */
+#define E1000_IMS_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMS_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMS_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMS_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMS_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMS_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMS_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMS_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMS_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMS_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMS_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMS_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMS_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMS_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMS_SRPD    E1000_ICR_SRPD
+
+/* Interrupt Mask Clear */
+#define E1000_IMC_TXDW    E1000_ICR_TXDW        /* Transmit desc written back */
+#define E1000_IMC_TXQE    E1000_ICR_TXQE        /* Transmit Queue empty */
+#define E1000_IMC_LSC     E1000_ICR_LSC         /* Link Status Change */
+#define E1000_IMC_RXSEQ   E1000_ICR_RXSEQ       /* rx sequence error */
+#define E1000_IMC_RXDMT0  E1000_ICR_RXDMT0      /* rx desc min. threshold */
+#define E1000_IMC_RXO     E1000_ICR_RXO         /* rx overrun */
+#define E1000_IMC_RXT0    E1000_ICR_RXT0        /* rx timer intr */
+#define E1000_IMC_MDAC    E1000_ICR_MDAC        /* MDIO access complete */
+#define E1000_IMC_RXCFG   E1000_ICR_RXCFG       /* RX /c/ ordered set */
+#define E1000_IMC_GPI_EN0 E1000_ICR_GPI_EN0     /* GP Int 0 */
+#define E1000_IMC_GPI_EN1 E1000_ICR_GPI_EN1     /* GP Int 1 */
+#define E1000_IMC_GPI_EN2 E1000_ICR_GPI_EN2     /* GP Int 2 */
+#define E1000_IMC_GPI_EN3 E1000_ICR_GPI_EN3     /* GP Int 3 */
+#define E1000_IMC_TXD_LOW E1000_ICR_TXD_LOW
+#define E1000_IMC_SRPD    E1000_ICR_SRPD
+
+/* Receive Control */
+#define E1000_RCTL_RST          0x00000001      /* Software reset */
+#define E1000_RCTL_EN           0x00000002      /* enable */
+#define E1000_RCTL_SBP          0x00000004      /* store bad packet */
+#define E1000_RCTL_UPE          0x00000008      /* unicast promiscuous enable */
+#define E1000_RCTL_MPE          0x00000010      /* multicast promiscuous enab */
+#define E1000_RCTL_LPE          0x00000020      /* long packet enable */
+#define E1000_RCTL_LBM_NO       0x00000000      /* no loopback mode */
+#define E1000_RCTL_LBM_MAC      0x00000040      /* MAC loopback mode */
+#define E1000_RCTL_LBM_SLP      0x00000080      /* serial link loopback mode */
+#define E1000_RCTL_LBM_TCVR     0x000000C0      /* tcvr loopback mode */
+#define E1000_RCTL_RDMTS_HALF   0x00000000      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_QUAT   0x00000100      /* rx desc min threshold size */
+#define E1000_RCTL_RDMTS_EIGTH  0x00000200      /* rx desc min threshold size */
+#define E1000_RCTL_MO_SHIFT     12              /* multicast offset shift */
+#define E1000_RCTL_MO_0         0x00000000      /* multicast offset 11:0 */
+#define E1000_RCTL_MO_1         0x00001000      /* multicast offset 12:1 */
+#define E1000_RCTL_MO_2         0x00002000      /* multicast offset 13:2 */
+#define E1000_RCTL_MO_3         0x00003000      /* multicast offset 15:4 */
+#define E1000_RCTL_MDR          0x00004000      /* multicast desc ring 0 */
+#define E1000_RCTL_BAM          0x00008000      /* broadcast enable */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 0 */
+#define E1000_RCTL_SZ_2048      0x00000000      /* rx buffer size 2048 */
+#define E1000_RCTL_SZ_1024      0x00010000      /* rx buffer size 1024 */
+#define E1000_RCTL_SZ_512       0x00020000      /* rx buffer size 512 */
+#define E1000_RCTL_SZ_256       0x00030000      /* rx buffer size 256 */
+/* these buffer sizes are valid if E1000_RCTL_BSEX is 1 */
+#define E1000_RCTL_SZ_16384     0x00010000      /* rx buffer size 16384 */
+#define E1000_RCTL_SZ_8192      0x00020000      /* rx buffer size 8192 */
+#define E1000_RCTL_SZ_4096      0x00030000      /* rx buffer size 4096 */
+#define E1000_RCTL_VFE          0x00040000      /* vlan filter enable */
+#define E1000_RCTL_CFIEN        0x00080000      /* canonical form enable */
+#define E1000_RCTL_CFI          0x00100000      /* canonical form indicator */
+#define E1000_RCTL_DPF          0x00400000      /* discard pause frames */
+#define E1000_RCTL_PMCF         0x00800000      /* pass MAC control frames */
+#define E1000_RCTL_BSEX         0x02000000      /* Buffer size extension */
+
+/* Receive Descriptor */
+#define E1000_RDT_DELAY 0x0000ffff      /* Delay timer (1=1024us) */
+#define E1000_RDT_FPDB  0x80000000      /* Flush descriptor block */
+#define E1000_RDLEN_LEN 0x0007ff80      /* descriptor length */
+#define E1000_RDH_RDH   0x0000ffff      /* receive descriptor head */
+#define E1000_RDT_RDT   0x0000ffff      /* receive descriptor tail */
+
+/* Flow Control */
+#define E1000_FCRTH_RTH  0x0000FFF8     /* Mask Bits[15:3] for RTH */
+#define E1000_FCRTH_XFCE 0x80000000     /* External Flow Control Enable */
+#define E1000_FCRTL_RTL  0x0000FFF8     /* Mask Bits[15:3] for RTL */
+#define E1000_FCRTL_XONE 0x80000000     /* Enable XON frame transmission */
+
+/* Receive Descriptor Control */
+#define E1000_RXDCTL_PTHRESH 0x0000003F /* RXDCTL Prefetch Threshold */
+#define E1000_RXDCTL_HTHRESH 0x00003F00 /* RXDCTL Host Threshold */
+#define E1000_RXDCTL_WTHRESH 0x003F0000 /* RXDCTL Writeback Threshold */
+#define E1000_RXDCTL_GRAN    0x01000000 /* RXDCTL Granularity */
+
+/* Transmit Descriptor Control */
+#define E1000_TXDCTL_PTHRESH 0x000000FF /* TXDCTL Prefetch Threshold */
+#define E1000_TXDCTL_HTHRESH 0x0000FF00 /* TXDCTL Host Threshold */
+#define E1000_TXDCTL_WTHRESH 0x00FF0000 /* TXDCTL Writeback Threshold */
+#define E1000_TXDCTL_GRAN    0x01000000 /* TXDCTL Granularity */
+#define E1000_TXDCTL_LWTHRESH 0xFE000000 /* TXDCTL Low Threshold */
+#define E1000_TXDCTL_FULL_TX_DESC_WB 0x01010000 /* GRAN=1, WTHRESH=1 */
+
+/* Transmit Configuration Word */
+#define E1000_TXCW_FD         0x00000020        /* TXCW full duplex */
+#define E1000_TXCW_HD         0x00000040        /* TXCW half duplex */
+#define E1000_TXCW_PAUSE      0x00000080        /* TXCW sym pause request */
+#define E1000_TXCW_ASM_DIR    0x00000100        /* TXCW astm pause direction */
+#define E1000_TXCW_PAUSE_MASK 0x00000180        /* TXCW pause request mask */
+#define E1000_TXCW_RF         0x00003000        /* TXCW remote fault */
+#define E1000_TXCW_NP         0x00008000        /* TXCW next page */
+#define E1000_TXCW_CW         0x0000ffff        /* TxConfigWord mask */
+#define E1000_TXCW_TXC        0x40000000        /* Transmit Config control */
+#define E1000_TXCW_ANE        0x80000000        /* Auto-neg enable */
+
+/* Receive Configuration Word */
+#define E1000_RXCW_CW    0x0000ffff     /* RxConfigWord mask */
+#define E1000_RXCW_NC    0x04000000     /* Receive config no carrier */
+#define E1000_RXCW_IV    0x08000000     /* Receive config invalid */
+#define E1000_RXCW_CC    0x10000000     /* Receive config change */
+#define E1000_RXCW_C     0x20000000     /* Receive config */
+#define E1000_RXCW_SYNCH 0x40000000     /* Receive config synch */
+#define E1000_RXCW_ANC   0x80000000     /* Auto-neg complete */
+
+/* Transmit Control */
+#define E1000_TCTL_RST    0x00000001    /* software reset */
+#define E1000_TCTL_EN     0x00000002    /* enable tx */
+#define E1000_TCTL_BCE    0x00000004    /* busy check enable */
+#define E1000_TCTL_PSP    0x00000008    /* pad short packets */
+#define E1000_TCTL_CT     0x00000ff0    /* collision threshold */
+#define E1000_TCTL_COLD   0x003ff000    /* collision distance */
+#define E1000_TCTL_SWXOFF 0x00400000    /* SW Xoff transmission */
+#define E1000_TCTL_PBE    0x00800000    /* Packet Burst Enable */
+#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
+#define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
+
+/* Receive Checksum Control */
+#define E1000_RXCSUM_PCSS_MASK 0x000000FF   /* Packet Checksum Start */
+#define E1000_RXCSUM_IPOFL     0x00000100   /* IPv4 checksum offload */
+#define E1000_RXCSUM_TUOFL     0x00000200   /* TCP / UDP checksum offload */
+#define E1000_RXCSUM_IPV6OFL   0x00000400   /* IPv6 checksum offload */
+
+/* Definitions for power management and wakeup registers */
+/* Wake Up Control */
+#define E1000_WUC_APME       0x00000001 /* APM Enable */
+#define E1000_WUC_PME_EN     0x00000002 /* PME Enable */
+#define E1000_WUC_PME_STATUS 0x00000004 /* PME Status */
+#define E1000_WUC_APMPME     0x00000008 /* Assert PME on APM Wakeup */
+#define E1000_WUC_SPM        0x80000000 /* Enable SPM */
+
+/* Wake Up Filter Control */
+#define E1000_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
+#define E1000_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
+#define E1000_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
+#define E1000_WUFC_MC   0x00000008 /* Directed Multicast Wakeup Enable */
+#define E1000_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
+#define E1000_WUFC_ARP  0x00000020 /* ARP Request Packet Wakeup Enable */
+#define E1000_WUFC_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Enable */
+#define E1000_WUFC_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Enable */
+#define E1000_WUFC_FLX0 0x00010000 /* Flexible Filter 0 Enable */
+#define E1000_WUFC_FLX1 0x00020000 /* Flexible Filter 1 Enable */
+#define E1000_WUFC_FLX2 0x00040000 /* Flexible Filter 2 Enable */
+#define E1000_WUFC_FLX3 0x00080000 /* Flexible Filter 3 Enable */
+#define E1000_WUFC_ALL_FILTERS 0x000F00FF /* Mask for all wakeup filters */
+#define E1000_WUFC_FLX_OFFSET 16       /* Offset to the Flexible Filters bits */
+#define E1000_WUFC_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Wake Up Status */
+#define E1000_WUS_LNKC 0x00000001 /* Link Status Changed */
+#define E1000_WUS_MAG  0x00000002 /* Magic Packet Received */
+#define E1000_WUS_EX   0x00000004 /* Directed Exact Received */
+#define E1000_WUS_MC   0x00000008 /* Directed Multicast Received */
+#define E1000_WUS_BC   0x00000010 /* Broadcast Received */
+#define E1000_WUS_ARP  0x00000020 /* ARP Request Packet Received */
+#define E1000_WUS_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Received */
+#define E1000_WUS_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Received */
+#define E1000_WUS_FLX0 0x00010000 /* Flexible Filter 0 Match */
+#define E1000_WUS_FLX1 0x00020000 /* Flexible Filter 1 Match */
+#define E1000_WUS_FLX2 0x00040000 /* Flexible Filter 2 Match */
+#define E1000_WUS_FLX3 0x00080000 /* Flexible Filter 3 Match */
+#define E1000_WUS_FLX_FILTERS 0x000F0000 /* Mask for the 4 flexible filters */
+
+/* Management Control */
+#define E1000_MANC_SMBUS_EN      0x00000001 /* SMBus Enabled - RO */
+#define E1000_MANC_ASF_EN        0x00000002 /* ASF Enabled - RO */
+#define E1000_MANC_R_ON_FORCE    0x00000004 /* Reset on Force TCO - RO */
+#define E1000_MANC_RMCP_EN       0x00000100 /* Enable RCMP 026Fh Filtering */
+#define E1000_MANC_0298_EN       0x00000200 /* Enable RCMP 0298h Filtering */
+#define E1000_MANC_IPV4_EN       0x00000400 /* Enable IPv4 */
+#define E1000_MANC_IPV6_EN       0x00000800 /* Enable IPv6 */
+#define E1000_MANC_SNAP_EN       0x00001000 /* Accept LLC/SNAP */
+#define E1000_MANC_ARP_EN        0x00002000 /* Enable ARP Request Filtering */
+#define E1000_MANC_NEIGHBOR_EN   0x00004000 /* Enable Neighbor Discovery 
+                                             * Filtering */
+#define E1000_MANC_TCO_RESET     0x00010000 /* TCO Reset Occurred */
+#define E1000_MANC_RCV_TCO_EN    0x00020000 /* Receive TCO Packets Enabled */
+#define E1000_MANC_REPORT_STATUS 0x00040000 /* Status Reporting Enabled */
+#define E1000_MANC_SMB_REQ       0x01000000 /* SMBus Request */
+#define E1000_MANC_SMB_GNT       0x02000000 /* SMBus Grant */
+#define E1000_MANC_SMB_CLK_IN    0x04000000 /* SMBus Clock In */
+#define E1000_MANC_SMB_DATA_IN   0x08000000 /* SMBus Data In */
+#define E1000_MANC_SMB_DATA_OUT  0x10000000 /* SMBus Data Out */
+#define E1000_MANC_SMB_CLK_OUT   0x20000000 /* SMBus Clock Out */
+
+#define E1000_MANC_SMB_DATA_OUT_SHIFT  28 /* SMBus Data Out Shift */
+#define E1000_MANC_SMB_CLK_OUT_SHIFT   29 /* SMBus Clock Out Shift */
+
+/* Wake Up Packet Length */
+#define E1000_WUPL_LENGTH_MASK 0x0FFF   /* Only the lower 12 bits are valid */
+
+#define E1000_MDALIGN          4096
+
+/* EEPROM Commands - Microwire */
+#define EEPROM_READ_OPCODE_MICROWIRE  0x6  /* EEPROM read opcode */
+#define EEPROM_WRITE_OPCODE_MICROWIRE 0x5  /* EEPROM write opcode */
+#define EEPROM_ERASE_OPCODE_MICROWIRE 0x7  /* EEPROM erase opcode */
+#define EEPROM_EWEN_OPCODE_MICROWIRE  0x13 /* EEPROM erase/write enable */
+#define EEPROM_EWDS_OPCODE_MICROWIRE  0x10 /* EEPROM erast/write disable */
+
+/* EEPROM Commands - SPI */
+#define EEPROM_MAX_RETRY_SPI    5000 /* Max wait of 5ms, for RDY signal */
+#define EEPROM_READ_OPCODE_SPI  0x3  /* EEPROM read opcode */
+#define EEPROM_WRITE_OPCODE_SPI 0x2  /* EEPROM write opcode */
+#define EEPROM_A8_OPCODE_SPI    0x8  /* opcode bit-3 = address bit-8 */
+#define EEPROM_WREN_OPCODE_SPI  0x6  /* EEPROM set Write Enable latch */
+#define EEPROM_WRDI_OPCODE_SPI  0x4  /* EEPROM reset Write Enable latch */
+#define EEPROM_RDSR_OPCODE_SPI  0x5  /* EEPROM read Status register */
+#define EEPROM_WRSR_OPCODE_SPI  0x1  /* EEPROM write Status register */
+
+/* EEPROM Size definitions */
+#define EEPROM_SIZE_16KB        0x1800
+#define EEPROM_SIZE_8KB         0x1400
+#define EEPROM_SIZE_4KB         0x1000
+#define EEPROM_SIZE_2KB         0x0C00
+#define EEPROM_SIZE_1KB         0x0800
+#define EEPROM_SIZE_512B        0x0400
+#define EEPROM_SIZE_128B        0x0000
+#define EEPROM_SIZE_MASK        0x1C00
+
+
+/* EEPROM Word Offsets */
+#define EEPROM_COMPAT              0x0003
+#define EEPROM_ID_LED_SETTINGS     0x0004
+#define EEPROM_INIT_CONTROL1_REG   0x000A
+#define EEPROM_INIT_CONTROL2_REG   0x000F
+#define EEPROM_CFG                 0x0012
+#define EEPROM_FLASH_VERSION       0x0032
+#define EEPROM_CHECKSUM_REG        0x003F
+
+/* Word definitions for ID LED Settings */
+#define ID_LED_RESERVED_0000 0x0000
+#define ID_LED_RESERVED_FFFF 0xFFFF
+#define ID_LED_DEFAULT       ((ID_LED_OFF1_ON2 << 12) | \
+                              (ID_LED_OFF1_OFF2 << 8) | \
+                              (ID_LED_DEF1_DEF2 << 4) | \
+                              (ID_LED_DEF1_DEF2))
+#define ID_LED_DEF1_DEF2     0x1
+#define ID_LED_DEF1_ON2      0x2
+#define ID_LED_DEF1_OFF2     0x3
+#define ID_LED_ON1_DEF2      0x4
+#define ID_LED_ON1_ON2       0x5
+#define ID_LED_ON1_OFF2      0x6
+#define ID_LED_OFF1_DEF2     0x7
+#define ID_LED_OFF1_ON2      0x8
+#define ID_LED_OFF1_OFF2     0x9
+
+#define IGP_ACTIVITY_LED_MASK   0xFFFFF0FF
+#define IGP_ACTIVITY_LED_ENABLE 0x0300
+#define IGP_LED3_MODE           0x07000000
+
+
+/* Mask bits for fields in Word 0x0a of the EEPROM */
+#define EEPROM_WORD0A_ILOS   0x0010
+#define EEPROM_WORD0A_SWDPIO 0x01E0
+#define EEPROM_WORD0A_LRST   0x0200
+#define EEPROM_WORD0A_FD     0x0400
+#define EEPROM_WORD0A_66MHZ  0x0800
+
+/* Mask bits for fields in Word 0x0f of the EEPROM */
+#define EEPROM_WORD0F_PAUSE_MASK 0x3000
+#define EEPROM_WORD0F_PAUSE      0x1000
+#define EEPROM_WORD0F_ASM_DIR    0x2000
+#define EEPROM_WORD0F_ANE        0x0800
+#define EEPROM_WORD0F_SWPDIO_EXT 0x00F0
+
+/* For checksumming, the sum of all words in the EEPROM should equal 0xBABA. */
+#define EEPROM_SUM 0xBABA
+
+/* EEPROM Map defines (WORD OFFSETS)*/
+#define EEPROM_NODE_ADDRESS_BYTE_0 0
+#define EEPROM_PBA_BYTE_1          8
+
+/* EEPROM Map Sizes (Byte Counts) */
+#define PBA_SIZE 4
+
+/* Collision related configuration parameters */
+#define E1000_COLLISION_THRESHOLD       16
+#define E1000_CT_SHIFT                  4
+#define E1000_COLLISION_DISTANCE        64
+#define E1000_FDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
+#define E1000_HDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
+#define E1000_COLD_SHIFT                12
+
+/* The number of Transmit and Receive Descriptors must be a multiple of 8 */
+#define REQ_TX_DESCRIPTOR_MULTIPLE  8
+#define REQ_RX_DESCRIPTOR_MULTIPLE  8
+
+/* Default values for the transmit IPG register */
+#define DEFAULT_82542_TIPG_IPGT        10
+#define DEFAULT_82543_TIPG_IPGT_FIBER  9
+#define DEFAULT_82543_TIPG_IPGT_COPPER 8
+
+#define E1000_TIPG_IPGT_MASK  0x000003FF
+#define E1000_TIPG_IPGR1_MASK 0x000FFC00
+#define E1000_TIPG_IPGR2_MASK 0x3FF00000
+
+#define DEFAULT_82542_TIPG_IPGR1 2
+#define DEFAULT_82543_TIPG_IPGR1 8
+#define E1000_TIPG_IPGR1_SHIFT  10
+
+#define DEFAULT_82542_TIPG_IPGR2 10
+#define DEFAULT_82543_TIPG_IPGR2 6
+#define E1000_TIPG_IPGR2_SHIFT  20
+
+#define E1000_TXDMAC_DPP 0x00000001
+
+/* Adaptive IFS defines */
+#define TX_THRESHOLD_START     8
+#define TX_THRESHOLD_INCREMENT 10
+#define TX_THRESHOLD_DECREMENT 1
+#define TX_THRESHOLD_STOP      190
+#define TX_THRESHOLD_DISABLE   0
+#define TX_THRESHOLD_TIMER_MS  10000
+#define MIN_NUM_XMITS          1000
+#define IFS_MAX                80
+#define IFS_STEP               10
+#define IFS_MIN                40
+#define IFS_RATIO              4
+
+/* PBA constants */
+#define E1000_PBA_16K 0x0010    /* 16KB, default TX allocation */
+#define E1000_PBA_22K 0x0016
+#define E1000_PBA_24K 0x0018
+#define E1000_PBA_30K 0x001E
+#define E1000_PBA_40K 0x0028
+#define E1000_PBA_48K 0x0030    /* 48KB, default RX allocation */
+
+/* Flow Control Constants */
+#define FLOW_CONTROL_ADDRESS_LOW  0x00C28001
+#define FLOW_CONTROL_ADDRESS_HIGH 0x00000100
+#define FLOW_CONTROL_TYPE         0x8808
+
+/* The historical defaults for the flow control values are given below. */
+#define FC_DEFAULT_HI_THRESH        (0x8000)    /* 32KB */
+#define FC_DEFAULT_LO_THRESH        (0x4000)    /* 16KB */
+#define FC_DEFAULT_TX_TIMER         (0x100)     /* ~130 us */
+
+/* PCIX Config space */
+#define PCIX_COMMAND_REGISTER    0xE6
+#define PCIX_STATUS_REGISTER_LO  0xE8
+#define PCIX_STATUS_REGISTER_HI  0xEA
+
+#define PCIX_COMMAND_MMRBC_MASK      0x000C
+#define PCIX_COMMAND_MMRBC_SHIFT     0x2
+#define PCIX_STATUS_HI_MMRBC_MASK    0x0060
+#define PCIX_STATUS_HI_MMRBC_SHIFT   0x5
+#define PCIX_STATUS_HI_MMRBC_4K      0x3
+#define PCIX_STATUS_HI_MMRBC_2K      0x2
+
+
+/* The number of bits that we need to shift right to move the "pause"
+ * bits from the EEPROM (bits 13:12) to the "pause" (bits 8:7) field
+ * in the TXCW register 
+ */
+#define PAUSE_SHIFT 5
+
+/* The number of bits that we need to shift left to move the "SWDPIO"
+ * bits from the EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field
+ * in the CTRL register 
+ */
+#define SWDPIO_SHIFT 17
+
+/* The number of bits that we need to shift left to move the "SWDPIO_EXT"
+ * bits from the EEPROM word F (bits 7:4) to the bits 11:8 of The
+ * Extended CTRL register.
+ * in the CTRL register 
+ */
+#define SWDPIO__EXT_SHIFT 4
+
+/* The number of bits that we need to shift left to move the "ILOS"
+ * bit from the EEPROM (bit 4) to the "ILOS" (bit 7) field
+ * in the CTRL register 
+ */
+#define ILOS_SHIFT  3
+
+
+#define RECEIVE_BUFFER_ALIGN_SIZE  (256)
+
+/* The number of milliseconds we wait for auto-negotiation to complete */
+#define LINK_UP_TIMEOUT             500
+
+#define E1000_TX_BUFFER_SIZE ((uint32_t)1514)
+
+/* The carrier extension symbol, as received by the NIC. */
+#define CARRIER_EXTENSION   0x0F
+
+/* TBI_ACCEPT macro definition:
+ *
+ * This macro requires:
+ *      adapter = a pointer to struct e1000_hw 
+ *      status = the 8 bit status field of the RX descriptor with EOP set
+ *      error = the 8 bit error field of the RX descriptor with EOP set
+ *      length = the sum of all the length fields of the RX descriptors that
+ *               make up the current frame
+ *      last_byte = the last byte of the frame DMAed by the hardware
+ *      max_frame_length = the maximum frame length we want to accept.
+ *      min_frame_length = the minimum frame length we want to accept.
+ *
+ * This macro is a conditional that should be used in the interrupt 
+ * handler's Rx processing routine when RxErrors have been detected.
+ *
+ * Typical use:
+ *  ...
+ *  if (TBI_ACCEPT) {
+ *      accept_frame = TRUE;
+ *      e1000_tbi_adjust_stats(adapter, MacAddress);
+ *      frame_length--;
+ *  } else {
+ *      accept_frame = FALSE;
+ *  }
+ *  ...
+ */
+
+#define TBI_ACCEPT(adapter, status, errors, length, last_byte) \
+    ((adapter)->tbi_compatibility_on && \
+     (((errors) & E1000_RXD_ERR_FRAME_ERR_MASK) == E1000_RXD_ERR_CE) && \
+     ((last_byte) == CARRIER_EXTENSION) && \
+     (((status) & E1000_RXD_STAT_VP) ? \
+          (((length) > ((adapter)->min_frame_size - VLAN_TAG_SIZE)) && \
+           ((length) <= ((adapter)->max_frame_size + 1))) : \
+          (((length) > (adapter)->min_frame_size) && \
+           ((length) <= ((adapter)->max_frame_size + VLAN_TAG_SIZE + 1)))))
+
+
+/* Structures, enums, and macros for the PHY */
+
+/* Bit definitions for the Management Data IO (MDIO) and Management Data
+ * Clock (MDC) pins in the Device Control Register.
+ */
+#define E1000_CTRL_PHY_RESET_DIR  E1000_CTRL_SWDPIO0
+#define E1000_CTRL_PHY_RESET      E1000_CTRL_SWDPIN0
+#define E1000_CTRL_MDIO_DIR       E1000_CTRL_SWDPIO2
+#define E1000_CTRL_MDIO           E1000_CTRL_SWDPIN2
+#define E1000_CTRL_MDC_DIR        E1000_CTRL_SWDPIO3
+#define E1000_CTRL_MDC            E1000_CTRL_SWDPIN3
+#define E1000_CTRL_PHY_RESET_DIR4 E1000_CTRL_EXT_SDP4_DIR
+#define E1000_CTRL_PHY_RESET4     E1000_CTRL_EXT_SDP4_DATA
+
+/* PHY 1000 MII Register/Bit Definitions */
+/* PHY Registers defined by IEEE */
+#define PHY_CTRL         0x00 /* Control Register */
+#define PHY_STATUS       0x01 /* Status Regiser */
+#define PHY_ID1          0x02 /* Phy Id Reg (word 1) */
+#define PHY_ID2          0x03 /* Phy Id Reg (word 2) */
+#define PHY_AUTONEG_ADV  0x04 /* Autoneg Advertisement */
+#define PHY_LP_ABILITY   0x05 /* Link Partner Ability (Base Page) */
+#define PHY_AUTONEG_EXP  0x06 /* Autoneg Expansion Reg */
+#define PHY_NEXT_PAGE_TX 0x07 /* Next Page TX */
+#define PHY_LP_NEXT_PAGE 0x08 /* Link Partner Next Page */
+#define PHY_1000T_CTRL   0x09 /* 1000Base-T Control Reg */
+#define PHY_1000T_STATUS 0x0A /* 1000Base-T Status Reg */
+#define PHY_EXT_STATUS   0x0F /* Extended Status Reg */
+
+/* M88E1000 Specific Registers */
+#define M88E1000_PHY_SPEC_CTRL     0x10  /* PHY Specific Control Register */
+#define M88E1000_PHY_SPEC_STATUS   0x11  /* PHY Specific Status Register */
+#define M88E1000_INT_ENABLE        0x12  /* Interrupt Enable Register */
+#define M88E1000_INT_STATUS        0x13  /* Interrupt Status Register */
+#define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
+#define M88E1000_RX_ERR_CNTR       0x15  /* Receive Error Counter */
+
+#define IGP01E1000_IEEE_REGS_PAGE  0x0000
+/* IGP01E1000 Specific Registers */
+#define IGP01E1000_PHY_PORT_CONFIG 0x10 /* PHY Specific Port Config Register */
+#define IGP01E1000_PHY_PORT_STATUS 0x11 /* PHY Specific Status Register */
+#define IGP01E1000_PHY_PORT_CTRL   0x12 /* PHY Specific Control Register */
+#define IGP01E1000_PHY_LINK_HEALTH 0x13 /* PHY Link Health Register */
+#define IGP01E1000_GMII_FIFO       0x14 /* GMII FIFO Register */
+#define IGP01E1000_PHY_CHANNEL_QUALITY 0x15 /* PHY Channel Quality Register */
+#define IGP01E1000_PHY_PAGE_SELECT     0x1F /* PHY Page Select Core Register */
+
+/* IGP01E1000 AGC Registers - stores the cable length values*/
+#define IGP01E1000_PHY_AGC_A        0x1172
+#define IGP01E1000_PHY_AGC_B        0x1272
+#define IGP01E1000_PHY_AGC_C        0x1472
+#define IGP01E1000_PHY_AGC_D        0x1872
+
+/* Number of AGC registers */
+#define IGP01E1000_PHY_AGC_NUM     4
+
+/* IGP01E1000 PCS Initialization register - stores the polarity status when
+ * speed = 1000 Mbps. */
+#define IGP01E1000_PHY_PCS_INIT_REG  0x00B4
+
+#define IGP01E1000_ANALOG_REGS_PAGE  0x20C0
+  
+#define MAX_PHY_REG_ADDRESS 0x1F        /* 5 bit address bus (0-0x1F) */
+
+/* PHY Control Register */
+#define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
+#define MII_CR_FULL_DUPLEX      0x0100  /* FDX =1, half duplex =0 */
+#define MII_CR_RESTART_AUTO_NEG 0x0200  /* Restart auto negotiation */
+#define MII_CR_ISOLATE          0x0400  /* Isolate PHY from MII */
+#define MII_CR_POWER_DOWN       0x0800  /* Power down */
+#define MII_CR_AUTO_NEG_EN      0x1000  /* Auto Neg Enable */
+#define MII_CR_SPEED_SELECT_LSB 0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_LOOPBACK         0x4000  /* 0 = normal, 1 = loopback */
+#define MII_CR_RESET            0x8000  /* 0 = normal, 1 = PHY reset */
+
+/* PHY Status Register */
+#define MII_SR_EXTENDED_CAPS     0x0001 /* Extended register capabilities */
+#define MII_SR_JABBER_DETECT     0x0002 /* Jabber Detected */
+#define MII_SR_LINK_STATUS       0x0004 /* Link Status 1 = link */
+#define MII_SR_AUTONEG_CAPS      0x0008 /* Auto Neg Capable */
+#define MII_SR_REMOTE_FAULT      0x0010 /* Remote Fault Detect */
+#define MII_SR_AUTONEG_COMPLETE  0x0020 /* Auto Neg Complete */
+#define MII_SR_PREAMBLE_SUPPRESS 0x0040 /* Preamble may be suppressed */
+#define MII_SR_EXTENDED_STATUS   0x0100 /* Ext. status info in Reg 0x0F */
+#define MII_SR_100T2_HD_CAPS     0x0200 /* 100T2 Half Duplex Capable */
+#define MII_SR_100T2_FD_CAPS     0x0400 /* 100T2 Full Duplex Capable */
+#define MII_SR_10T_HD_CAPS       0x0800 /* 10T   Half Duplex Capable */
+#define MII_SR_10T_FD_CAPS       0x1000 /* 10T   Full Duplex Capable */
+#define MII_SR_100X_HD_CAPS      0x2000 /* 100X  Half Duplex Capable */
+#define MII_SR_100X_FD_CAPS      0x4000 /* 100X  Full Duplex Capable */
+#define MII_SR_100T4_CAPS        0x8000 /* 100T4 Capable */
+
+/* Autoneg Advertisement Register */
+#define NWAY_AR_SELECTOR_FIELD 0x0001   /* indicates IEEE 802.3 CSMA/CD */
+#define NWAY_AR_10T_HD_CAPS    0x0020   /* 10T   Half Duplex Capable */
+#define NWAY_AR_10T_FD_CAPS    0x0040   /* 10T   Full Duplex Capable */
+#define NWAY_AR_100TX_HD_CAPS  0x0080   /* 100TX Half Duplex Capable */
+#define NWAY_AR_100TX_FD_CAPS  0x0100   /* 100TX Full Duplex Capable */
+#define NWAY_AR_100T4_CAPS     0x0200   /* 100T4 Capable */
+#define NWAY_AR_PAUSE          0x0400   /* Pause operation desired */
+#define NWAY_AR_ASM_DIR        0x0800   /* Asymmetric Pause Direction bit */
+#define NWAY_AR_REMOTE_FAULT   0x2000   /* Remote Fault detected */
+#define NWAY_AR_NEXT_PAGE      0x8000   /* Next Page ability supported */
+
+/* Link Partner Ability Register (Base Page) */
+#define NWAY_LPAR_SELECTOR_FIELD 0x0000 /* LP protocol selector field */
+#define NWAY_LPAR_10T_HD_CAPS    0x0020 /* LP is 10T   Half Duplex Capable */
+#define NWAY_LPAR_10T_FD_CAPS    0x0040 /* LP is 10T   Full Duplex Capable */
+#define NWAY_LPAR_100TX_HD_CAPS  0x0080 /* LP is 100TX Half Duplex Capable */
+#define NWAY_LPAR_100TX_FD_CAPS  0x0100 /* LP is 100TX Full Duplex Capable */
+#define NWAY_LPAR_100T4_CAPS     0x0200 /* LP is 100T4 Capable */
+#define NWAY_LPAR_PAUSE          0x0400 /* LP Pause operation desired */
+#define NWAY_LPAR_ASM_DIR        0x0800 /* LP Asymmetric Pause Direction bit */
+#define NWAY_LPAR_REMOTE_FAULT   0x2000 /* LP has detected Remote Fault */
+#define NWAY_LPAR_ACKNOWLEDGE    0x4000 /* LP has rx'd link code word */
+#define NWAY_LPAR_NEXT_PAGE      0x8000 /* Next Page ability supported */
+
+/* Autoneg Expansion Register */
+#define NWAY_ER_LP_NWAY_CAPS      0x0001 /* LP has Auto Neg Capability */
+#define NWAY_ER_PAGE_RXD          0x0002 /* LP is 10T   Half Duplex Capable */
+#define NWAY_ER_NEXT_PAGE_CAPS    0x0004 /* LP is 10T   Full Duplex Capable */
+#define NWAY_ER_LP_NEXT_PAGE_CAPS 0x0008 /* LP is 100TX Half Duplex Capable */
+#define NWAY_ER_PAR_DETECT_FAULT  0x0010 /* LP is 100TX Full Duplex Capable */
+
+/* Next Page TX Register */
+#define NPTX_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define NPTX_TOGGLE         0x0800 /* Toggles between exchanges
+                                    * of different NP
+                                    */
+#define NPTX_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg
+                                    * 0 = cannot comply with msg
+                                    */
+#define NPTX_MSG_PAGE       0x2000 /* formatted(1)/unformatted(0) pg */
+#define NPTX_NEXT_PAGE      0x8000 /* 1 = addition NP will follow 
+                                    * 0 = sending last NP
+                                    */
+
+/* Link Partner Next Page Register */
+#define LP_RNPR_MSG_CODE_FIELD 0x0001 /* NP msg code or unformatted data */
+#define LP_RNPR_TOGGLE         0x0800 /* Toggles between exchanges
+                                       * of different NP
+                                       */
+#define LP_RNPR_ACKNOWLDGE2    0x1000 /* 1 = will comply with msg 
+                                       * 0 = cannot comply with msg
+                                       */
+#define LP_RNPR_MSG_PAGE       0x2000  /* formatted(1)/unformatted(0) pg */
+#define LP_RNPR_ACKNOWLDGE     0x4000  /* 1 = ACK / 0 = NO ACK */
+#define LP_RNPR_NEXT_PAGE      0x8000  /* 1 = addition NP will follow
+                                        * 0 = sending last NP 
+                                        */
+
+/* 1000BASE-T Control Register */
+#define CR_1000T_ASYM_PAUSE      0x0080 /* Advertise asymmetric pause bit */
+#define CR_1000T_HD_CAPS         0x0100 /* Advertise 1000T HD capability */
+#define CR_1000T_FD_CAPS         0x0200 /* Advertise 1000T FD capability  */
+#define CR_1000T_REPEATER_DTE    0x0400 /* 1=Repeater/switch device port */
+                                        /* 0=DTE device */
+#define CR_1000T_MS_VALUE        0x0800 /* 1=Configure PHY as Master */
+                                        /* 0=Configure PHY as Slave */
+#define CR_1000T_MS_ENABLE       0x1000 /* 1=Master/Slave manual config value */
+                                        /* 0=Automatic Master/Slave config */
+#define CR_1000T_TEST_MODE_NORMAL 0x0000 /* Normal Operation */
+#define CR_1000T_TEST_MODE_1     0x2000 /* Transmit Waveform test */
+#define CR_1000T_TEST_MODE_2     0x4000 /* Master Transmit Jitter test */
+#define CR_1000T_TEST_MODE_3     0x6000 /* Slave Transmit Jitter test */
+#define CR_1000T_TEST_MODE_4     0x8000 /* Transmitter Distortion test */
+
+/* 1000BASE-T Status Register */
+#define SR_1000T_IDLE_ERROR_CNT   0x00FF /* Num idle errors since last read */
+#define SR_1000T_ASYM_PAUSE_DIR   0x0100 /* LP asymmetric pause direction bit */
+#define SR_1000T_LP_HD_CAPS       0x0400 /* LP is 1000T HD capable */
+#define SR_1000T_LP_FD_CAPS       0x0800 /* LP is 1000T FD capable */
+#define SR_1000T_REMOTE_RX_STATUS 0x1000 /* Remote receiver OK */
+#define SR_1000T_LOCAL_RX_STATUS  0x2000 /* Local receiver OK */
+#define SR_1000T_MS_CONFIG_RES    0x4000 /* 1=Local TX is Master, 0=Slave */
+#define SR_1000T_MS_CONFIG_FAULT  0x8000 /* Master/Slave config fault */
+#define SR_1000T_REMOTE_RX_STATUS_SHIFT 12
+#define SR_1000T_LOCAL_RX_STATUS_SHIFT  13
+
+/* Extended Status Register */
+#define IEEE_ESR_1000T_HD_CAPS 0x1000 /* 1000T HD capable */
+#define IEEE_ESR_1000T_FD_CAPS 0x2000 /* 1000T FD capable */
+#define IEEE_ESR_1000X_HD_CAPS 0x4000 /* 1000X HD capable */
+#define IEEE_ESR_1000X_FD_CAPS 0x8000 /* 1000X FD capable */
+
+#define PHY_TX_POLARITY_MASK   0x0100 /* register 10h bit 8 (polarity bit) */
+#define PHY_TX_NORMAL_POLARITY 0      /* register 10h bit 8 (normal polarity) */
+
+#define AUTO_POLARITY_DISABLE  0x0010 /* register 11h bit 4 */
+                                      /* (0=enable, 1=disable) */
+
+/* M88E1000 PHY Specific Control Register */
+#define M88E1000_PSCR_JABBER_DISABLE    0x0001 /* 1=Jabber Function disabled */
+#define M88E1000_PSCR_POLARITY_REVERSAL 0x0002 /* 1=Polarity Reversal enabled */
+#define M88E1000_PSCR_SQE_TEST          0x0004 /* 1=SQE Test enabled */
+#define M88E1000_PSCR_CLK125_DISABLE    0x0010 /* 1=CLK125 low, 
+                                                * 0=CLK125 toggling
+                                                */
+#define M88E1000_PSCR_MDI_MANUAL_MODE  0x0000  /* MDI Crossover Mode bits 6:5 */
+                                               /* Manual MDI configuration */
+#define M88E1000_PSCR_MDIX_MANUAL_MODE 0x0020  /* Manual MDIX configuration */
+#define M88E1000_PSCR_AUTO_X_1000T     0x0040  /* 1000BASE-T: Auto crossover,
+                                                *  100BASE-TX/10BASE-T: 
+                                                *  MDI Mode
+                                                */
+#define M88E1000_PSCR_AUTO_X_MODE      0x0060  /* Auto crossover enabled 
+                                                * all speeds. 
+                                                */
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE 0x0080 
+                                        /* 1=Enable Extended 10BASE-T distance
+                                         * (Lower 10BASE-T RX Threshold)
+                                         * 0=Normal 10BASE-T RX Threshold */
+#define M88E1000_PSCR_MII_5BIT_ENABLE      0x0100
+                                        /* 1=5-Bit interface in 100BASE-TX
+                                         * 0=MII interface in 100BASE-TX */
+#define M88E1000_PSCR_SCRAMBLER_DISABLE    0x0200 /* 1=Scrambler disable */
+#define M88E1000_PSCR_FORCE_LINK_GOOD      0x0400 /* 1=Force link good */
+#define M88E1000_PSCR_ASSERT_CRS_ON_TX     0x0800 /* 1=Assert CRS on Transmit */
+
+#define M88E1000_PSCR_POLARITY_REVERSAL_SHIFT    1
+#define M88E1000_PSCR_AUTO_X_MODE_SHIFT          5
+#define M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT 7
+
+/* M88E1000 PHY Specific Status Register */
+#define M88E1000_PSSR_JABBER             0x0001 /* 1=Jabber */
+#define M88E1000_PSSR_REV_POLARITY       0x0002 /* 1=Polarity reversed */
+#define M88E1000_PSSR_DOWNSHIFT          0x0020 /* 1=Downshifted */
+#define M88E1000_PSSR_MDIX               0x0040 /* 1=MDIX; 0=MDI */
+#define M88E1000_PSSR_CABLE_LENGTH       0x0380 /* 0=<50M;1=50-80M;2=80-110M;
+                                            * 3=110-140M;4=>140M */
+#define M88E1000_PSSR_LINK               0x0400 /* 1=Link up, 0=Link down */
+#define M88E1000_PSSR_SPD_DPLX_RESOLVED  0x0800 /* 1=Speed & Duplex resolved */
+#define M88E1000_PSSR_PAGE_RCVD          0x1000 /* 1=Page received */
+#define M88E1000_PSSR_DPLX               0x2000 /* 1=Duplex 0=Half Duplex */
+#define M88E1000_PSSR_SPEED              0xC000 /* Speed, bits 14:15 */
+#define M88E1000_PSSR_10MBS              0x0000 /* 00=10Mbs */
+#define M88E1000_PSSR_100MBS             0x4000 /* 01=100Mbs */
+#define M88E1000_PSSR_1000MBS            0x8000 /* 10=1000Mbs */
+
+#define M88E1000_PSSR_REV_POLARITY_SHIFT 1
+#define M88E1000_PSSR_DOWNSHIFT_SHIFT    5
+#define M88E1000_PSSR_MDIX_SHIFT         6
+#define M88E1000_PSSR_CABLE_LENGTH_SHIFT 7
+
+/* M88E1000 Extended PHY Specific Control Register */
+#define M88E1000_EPSCR_FIBER_LOOPBACK 0x4000 /* 1=Fiber loopback */
+#define M88E1000_EPSCR_DOWN_NO_IDLE   0x8000 /* 1=Lost lock detect enabled.
+                                              * Will assert lost lock and bring
+                                              * link down if idle not seen
+                                              * within 1ms in 1000BASE-T 
+                                              */
+/* Number of times we will attempt to autonegotiate before downshifting if we
+ * are the master */
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK 0x0C00
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_1X   0x0000    
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_2X   0x0400
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_3X   0x0800
+#define M88E1000_EPSCR_MASTER_DOWNSHIFT_4X   0x0C00
+/* Number of times we will attempt to autonegotiate before downshifting if we
+ * are the slave */
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK  0x0300
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_DIS   0x0000
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X    0x0100
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_2X    0x0200
+#define M88E1000_EPSCR_SLAVE_DOWNSHIFT_3X    0x0300
+#define M88E1000_EPSCR_TX_CLK_2_5     0x0060 /* 2.5 MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_25      0x0070 /* 25  MHz TX_CLK */
+#define M88E1000_EPSCR_TX_CLK_0       0x0000 /* NO  TX_CLK */
+
+
+/* IGP01E1000 Specific Port Config Register - R/W */
+#define IGP01E1000_PSCFR_AUTO_MDIX_PAR_DETECT  0x0010
+#define IGP01E1000_PSCFR_PRE_EN                0x0020
+#define IGP01E1000_PSCFR_SMART_SPEED           0x0080
+#define IGP01E1000_PSCFR_DISABLE_TPLOOPBACK    0x0100
+#define IGP01E1000_PSCFR_DISABLE_JABBER        0x0400
+#define IGP01E1000_PSCFR_DISABLE_TRANSMIT      0x2000
+
+/* IGP01E1000 Specific Port Status Register - R/O */
+#define IGP01E1000_PSSR_AUTONEG_FAILED         0x0001 /* RO LH SC */
+#define IGP01E1000_PSSR_POLARITY_REVERSED      0x0002
+#define IGP01E1000_PSSR_CABLE_LENGTH           0x007C
+#define IGP01E1000_PSSR_FULL_DUPLEX            0x0200
+#define IGP01E1000_PSSR_LINK_UP                0x0400
+#define IGP01E1000_PSSR_MDIX                   0x0800
+#define IGP01E1000_PSSR_SPEED_MASK             0xC000 /* speed bits mask */
+#define IGP01E1000_PSSR_SPEED_10MBPS           0x4000
+#define IGP01E1000_PSSR_SPEED_100MBPS          0x8000
+#define IGP01E1000_PSSR_SPEED_1000MBPS         0xC000
+#define IGP01E1000_PSSR_CABLE_LENGTH_SHIFT     0x0002 /* shift right 2 */
+#define IGP01E1000_PSSR_MDIX_SHIFT             0x000B /* shift right 11 */
+
+/* IGP01E1000 Specific Port Control Register - R/W */
+#define IGP01E1000_PSCR_TP_LOOPBACK            0x0001
+#define IGP01E1000_PSCR_CORRECT_NC_SCMBLR      0x0200
+#define IGP01E1000_PSCR_TEN_CRS_SELECT         0x0400
+#define IGP01E1000_PSCR_FLIP_CHIP              0x0800
+#define IGP01E1000_PSCR_AUTO_MDIX              0x1000
+#define IGP01E1000_PSCR_FORCE_MDI_MDIX         0x2000 /* 0-MDI, 1-MDIX */
+
+/* IGP01E1000 Specific Port Link Health Register */
+#define IGP01E1000_PLHR_SS_DOWNGRADE           0x8000
+#define IGP01E1000_PLHR_GIG_SCRAMBLER_ERROR    0x4000
+#define IGP01E1000_PLHR_GIG_REM_RCVR_NOK       0x0800 /* LH */
+#define IGP01E1000_PLHR_IDLE_ERROR_CNT_OFLOW   0x0400 /* LH */
+#define IGP01E1000_PLHR_DATA_ERR_1             0x0200 /* LH */
+#define IGP01E1000_PLHR_DATA_ERR_0             0x0100
+#define IGP01E1000_PLHR_AUTONEG_FAULT          0x0010
+#define IGP01E1000_PLHR_AUTONEG_ACTIVE         0x0008
+#define IGP01E1000_PLHR_VALID_CHANNEL_D        0x0004
+#define IGP01E1000_PLHR_VALID_CHANNEL_C        0x0002
+#define IGP01E1000_PLHR_VALID_CHANNEL_B        0x0001
+#define IGP01E1000_PLHR_VALID_CHANNEL_A        0x0000
+
+/* IGP01E1000 Channel Quality Register */
+#define IGP01E1000_MSE_CHANNEL_D        0x000F
+#define IGP01E1000_MSE_CHANNEL_C        0x00F0
+#define IGP01E1000_MSE_CHANNEL_B        0x0F00
+#define IGP01E1000_MSE_CHANNEL_A        0xF000
+
+/* IGP01E1000 AGC Registers */
+
+#define IGP01E1000_AGC_LENGTH_SHIFT 7         /* Coarse - 13:11, Fine - 10:7 */
+
+/* 7 bits (3 Coarse + 4 Fine) --> 128 optional values */
+#define IGP01E1000_AGC_LENGTH_TABLE_SIZE 128
+
+/* The precision of the length is +/- 10 meters */
+#define IGP01E1000_AGC_RANGE    10
+
+/* IGP01E1000 PCS Initialization register */
+/* bits 3:6 in the PCS registers stores the channels polarity */
+#define IGP01E1000_PHY_POLARITY_MASK    0x0078
+
+/* IGP01E1000 GMII FIFO Register */
+#define IGP01E1000_GMII_FLEX_SPD               0x10 /* Enable flexible speed
+                                                     * on Link-Up */
+#define IGP01E1000_GMII_SPD                    0x20 /* Enable SPD */
+/* IGP01E1000 Analog Register */
+#define IGP01E1000_ANALOG_SPARE_FUSE_STATUS         0x0011
+#define IGP01E1000_ANALOG_FUSE_STATUS               0x0010
+#define IGP01E1000_ANALOG_FUSE_CONTROL              0x001C
+#define IGP01E1000_ANALOG_FUSE_BYPASS               0x001E
+
+#define IGP01E1000_ANALOG_FUSE_POLY_MASK            0xF000
+#define IGP01E1000_ANALOG_FUSE_FINE_MASK            0x0F80
+#define IGP01E1000_ANALOG_FUSE_COARSE_MASK          0x0070
+#define IGP01E1000_ANALOG_SPARE_FUSE_ENABLED        0x0100
+#define IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL    0x0002
+
+#define IGP01E1000_ANALOG_FUSE_COARSE_THRESH        0x0040
+#define IGP01E1000_ANALOG_FUSE_COARSE_10            0x0010
+#define IGP01E1000_ANALOG_FUSE_FINE_1               0x0080
+#define IGP01E1000_ANALOG_FUSE_FINE_10              0x0500
+
+/* Bit definitions for valid PHY IDs. */
+#define M88E1000_E_PHY_ID  0x01410C50
+#define M88E1000_I_PHY_ID  0x01410C30
+#define M88E1011_I_PHY_ID  0x01410C20
+#define IGP01E1000_I_PHY_ID  0x02A80380
+#define M88E1000_12_PHY_ID M88E1000_E_PHY_ID
+#define M88E1000_14_PHY_ID M88E1000_E_PHY_ID
+#define M88E1011_I_REV_4   0x04
+
+/* Miscellaneous PHY bit definitions. */
+#define PHY_PREAMBLE        0xFFFFFFFF
+#define PHY_SOF             0x01
+#define PHY_OP_READ         0x02
+#define PHY_OP_WRITE        0x01
+#define PHY_TURNAROUND      0x02
+#define PHY_PREAMBLE_SIZE   32
+#define MII_CR_SPEED_1000   0x0040
+#define MII_CR_SPEED_100    0x2000
+#define MII_CR_SPEED_10     0x0000
+#define E1000_PHY_ADDRESS   0x01
+#define PHY_AUTO_NEG_TIME   45  /* 4.5 Seconds */
+#define PHY_FORCE_TIME      20  /* 2.0 Seconds */
+#define PHY_REVISION_MASK   0xFFFFFFF0
+#define DEVICE_SPEED_MASK   0x00000300  /* Device Ctrl Reg Speed Mask */
+#define REG4_SPEED_MASK     0x01E0
+#define REG9_SPEED_MASK     0x0300
+#define ADVERTISE_10_HALF   0x0001
+#define ADVERTISE_10_FULL   0x0002
+#define ADVERTISE_100_HALF  0x0004
+#define ADVERTISE_100_FULL  0x0008
+#define ADVERTISE_1000_HALF 0x0010
+#define ADVERTISE_1000_FULL 0x0020
+#define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F  /* Everything but 1000-Half */
+
+#endif /* _E1000_HW_H_ */
Index: netboot/r8169.c
===================================================================
--- netboot/r8169.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/r8169.c	(.../trunk)	(revision 112)
@@ -0,0 +1,796 @@
+/**************************************************************************
+*    r8169.c: Etherboot device driver for the RealTek RTL-8169 Gigabit
+*    Written 2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*	r8169.c: A RealTek RTL-8169 Gigabit Ethernet driver 
+* 		for Linux kernel 2.4.x.
+*
+*    Written 2002 ShuChen <shuchen@realtek.com.tw>
+*	  See Linux Driver for full information
+*	
+*    Linux Driver Version 1.27a, 10.02.2002
+* 
+*    Thanks to:
+*    	Jean Chen of RealTek Semiconductor Corp. for
+*    	providing the evaluation NIC used to develop 
+*    	this driver.  RealTek's support for Etherboot 
+*    	is appreciated.
+*    	
+*    REVISION HISTORY:
+*    ================
+*
+*    v1.0	11-26-2003	timlegge	Initial port of Linux driver
+*    v1.5	01-17-2004	timlegge	Initial driver output cleanup
+*    
+*    Indent Options: indent -kr -i8
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+#include "timer.h"
+
+#define drv_version "v1.5"
+#define drv_date "01-17-2004"
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+static u32 ioaddr;
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+/* media options */
+#define MAX_UNITS 8
+static int media[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+
+/* Maximum events (Rx packets, etc.) to handle at each interrupt. */
+static int max_interrupt_work = 20;
+
+/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
+   The RTL chips use a 64 element hash table based on the Ethernet CRC.  */
+static int multicast_filter_limit = 32;
+
+/* MAC address length*/
+#define MAC_ADDR_LEN	6
+
+/* max supported gigabit ethernet frame size -- must be at least (dev->mtu+14+4).*/
+#define MAX_ETH_FRAME_SIZE	1536
+
+#define TX_FIFO_THRESH 256	/* In bytes */
+
+#define RX_FIFO_THRESH	7	/* 7 means NO threshold, Rx buffer level before first PCI xfer.  */
+#define RX_DMA_BURST	6	/* Maximum PCI burst, '6' is 1024 */
+#define TX_DMA_BURST	6	/* Maximum PCI burst, '6' is 1024 */
+#define EarlyTxThld 	0x3F	/* 0x3F means NO early transmit */
+#define RxPacketMaxSize	0x0800	/* Maximum size supported is 16K-1 */
+#define InterFrameGap	0x03	/* 3 means InterFrameGap = the shortest one */
+
+#define NUM_TX_DESC	1	/* Number of Tx descriptor registers */
+#define NUM_RX_DESC	4	/* Number of Rx descriptor registers */
+#define RX_BUF_SIZE	1536	/* Rx Buffer size */
+
+#define RTL_MIN_IO_SIZE 0x80
+#define TX_TIMEOUT  (6*HZ)
+
+/* write/read MMIO register */
+#define RTL_W8(reg, val8)	writeb ((val8), ioaddr + (reg))
+#define RTL_W16(reg, val16)	writew ((val16), ioaddr + (reg))
+#define RTL_W32(reg, val32)	writel ((val32), ioaddr + (reg))
+#define RTL_R8(reg)		readb (ioaddr + (reg))
+#define RTL_R16(reg)		readw (ioaddr + (reg))
+#define RTL_R32(reg)		((unsigned long) readl (ioaddr + (reg)))
+
+enum RTL8169_registers {
+	MAC0 = 0,		/* Ethernet hardware address. */
+	MAR0 = 8,		/* Multicast filter. */
+	TxDescStartAddr = 0x20,
+	TxHDescStartAddr = 0x28,
+	FLASH = 0x30,
+	ERSR = 0x36,
+	ChipCmd = 0x37,
+	TxPoll = 0x38,
+	IntrMask = 0x3C,
+	IntrStatus = 0x3E,
+	TxConfig = 0x40,
+	RxConfig = 0x44,
+	RxMissed = 0x4C,
+	Cfg9346 = 0x50,
+	Config0 = 0x51,
+	Config1 = 0x52,
+	Config2 = 0x53,
+	Config3 = 0x54,
+	Config4 = 0x55,
+	Config5 = 0x56,
+	MultiIntr = 0x5C,
+	PHYAR = 0x60,
+	TBICSR = 0x64,
+	TBI_ANAR = 0x68,
+	TBI_LPAR = 0x6A,
+	PHYstatus = 0x6C,
+	RxMaxSize = 0xDA,
+	CPlusCmd = 0xE0,
+	RxDescStartAddr = 0xE4,
+	EarlyTxThres = 0xEC,
+	FuncEvent = 0xF0,
+	FuncEventMask = 0xF4,
+	FuncPresetState = 0xF8,
+	FuncForceEvent = 0xFC,
+};
+
+enum RTL8169_register_content {
+	/*InterruptStatusBits */
+	SYSErr = 0x8000,
+	PCSTimeout = 0x4000,
+	SWInt = 0x0100,
+	TxDescUnavail = 0x80,
+	RxFIFOOver = 0x40,
+	RxUnderrun = 0x20,
+	RxOverflow = 0x10,
+	TxErr = 0x08,
+	TxOK = 0x04,
+	RxErr = 0x02,
+	RxOK = 0x01,
+
+	/*RxStatusDesc */
+	RxRES = 0x00200000,
+	RxCRC = 0x00080000,
+	RxRUNT = 0x00100000,
+	RxRWT = 0x00400000,
+
+	/*ChipCmdBits */
+	CmdReset = 0x10,
+	CmdRxEnb = 0x08,
+	CmdTxEnb = 0x04,
+	RxBufEmpty = 0x01,
+
+	/*Cfg9346Bits */
+	Cfg9346_Lock = 0x00,
+	Cfg9346_Unlock = 0xC0,
+
+	/*rx_mode_bits */
+	AcceptErr = 0x20,
+	AcceptRunt = 0x10,
+	AcceptBroadcast = 0x08,
+	AcceptMulticast = 0x04,
+	AcceptMyPhys = 0x02,
+	AcceptAllPhys = 0x01,
+
+	/*RxConfigBits */
+	RxCfgFIFOShift = 13,
+	RxCfgDMAShift = 8,
+
+	/*TxConfigBits */
+	TxInterFrameGapShift = 24,
+	TxDMAShift = 8,		/* DMA burst value (0-7) is shift this many bits */
+
+	/*rtl8169_PHYstatus */
+	TBI_Enable = 0x80,
+	TxFlowCtrl = 0x40,
+	RxFlowCtrl = 0x20,
+	_1000bpsF = 0x10,
+	_100bps = 0x08,
+	_10bps = 0x04,
+	LinkStatus = 0x02,
+	FullDup = 0x01,
+
+	/*GIGABIT_PHY_registers */
+	PHY_CTRL_REG = 0,
+	PHY_STAT_REG = 1,
+	PHY_AUTO_NEGO_REG = 4,
+	PHY_1000_CTRL_REG = 9,
+
+	/*GIGABIT_PHY_REG_BIT */
+	PHY_Restart_Auto_Nego = 0x0200,
+	PHY_Enable_Auto_Nego = 0x1000,
+
+	//PHY_STAT_REG = 1;
+	PHY_Auto_Neco_Comp = 0x0020,
+
+	//PHY_AUTO_NEGO_REG = 4;
+	PHY_Cap_10_Half = 0x0020,
+	PHY_Cap_10_Full = 0x0040,
+	PHY_Cap_100_Half = 0x0080,
+	PHY_Cap_100_Full = 0x0100,
+
+	//PHY_1000_CTRL_REG = 9;
+	PHY_Cap_1000_Full = 0x0200,
+
+	PHY_Cap_Null = 0x0,
+
+	/*_MediaType*/
+	_10_Half = 0x01,
+	_10_Full = 0x02,
+	_100_Half = 0x04,
+	_100_Full = 0x08,
+	_1000_Full = 0x10,
+
+	/*_TBICSRBit*/
+	TBILinkOK = 0x02000000,
+};
+
+static struct {
+	const char *name;
+	u8 version;		/* depend on RTL8169 docs */
+	u32 RxConfigMask;	/* should clear the bits supported by this chip */
+} rtl_chip_info[] = {
+	{
+"RTL-8169", 0x00, 0xff7e1880,},};
+
+enum _DescStatusBit {
+	OWNbit = 0x80000000,
+	EORbit = 0x40000000,
+	FSbit = 0x20000000,
+	LSbit = 0x10000000,
+};
+
+struct TxDesc {
+	u32 status;
+	u32 vlan_tag;
+	u32 buf_addr;
+	u32 buf_Haddr;
+};
+
+struct RxDesc {
+	u32 status;
+	u32 vlan_tag;
+	u32 buf_addr;
+	u32 buf_Haddr;
+};
+
+/* Define the TX Descriptor */
+static u8 tx_ring[NUM_TX_DESC * sizeof(struct TxDesc) + 256];
+//	__attribute__ ((aligned(256)));
+
+/* Create a static buffer of size RX_BUF_SZ for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[NUM_TX_DESC * RX_BUF_SIZE];
+
+/* Define the RX Descriptor */
+static u8 rx_ring[NUM_RX_DESC * sizeof(struct TxDesc) + 256];
+  //  __attribute__ ((aligned(256)));
+
+/* Create a static buffer of size RX_BUF_SZ for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE];
+
+struct rtl8169_private {
+	void *mmio_addr;	/* memory map physical address */
+	int chipset;
+	unsigned long cur_rx;	/* Index into the Rx descriptor buffer of next Rx pkt. */
+	unsigned long cur_tx;	/* Index into the Tx descriptor buffer of next Rx pkt. */
+	unsigned long dirty_tx;
+	unsigned char *TxDescArrays;	/* Index of Tx Descriptor buffer */
+	unsigned char *RxDescArrays;	/* Index of Rx Descriptor buffer */
+	struct TxDesc *TxDescArray;	/* Index of 256-alignment Tx Descriptor buffer */
+	struct RxDesc *RxDescArray;	/* Index of 256-alignment Rx Descriptor buffer */
+	unsigned char *RxBufferRings;	/* Index of Rx Buffer  */
+	unsigned char *RxBufferRing[NUM_RX_DESC];	/* Index of Rx Buffer array */
+	unsigned char *Tx_skbuff[NUM_TX_DESC];
+} tpx;
+
+static struct rtl8169_private *tpc;
+
+static const u16 rtl8169_intr_mask =
+    SYSErr | PCSTimeout | RxUnderrun | RxOverflow | RxFIFOOver | TxErr |
+    TxOK | RxErr | RxOK;
+static const unsigned int rtl8169_rx_config =
+    (RX_FIFO_THRESH << RxCfgFIFOShift) | (RX_DMA_BURST << RxCfgDMAShift);
+
+void mdio_write(int RegAddr, int value)
+{
+	int i;
+
+	RTL_W32(PHYAR, 0x80000000 | (RegAddr & 0xFF) << 16 | value);
+	udelay(1000);
+
+	for (i = 2000; i > 0; i--) {
+		// Check if the RTL8169 has completed writing to the specified MII register
+		if (!(RTL_R32(PHYAR) & 0x80000000)) {
+			break;
+		} else {
+			udelay(100);
+		}
+	}
+}
+
+int mdio_read(int RegAddr)
+{
+	int i, value = -1;
+
+	RTL_W32(PHYAR, 0x0 | (RegAddr & 0xFF) << 16);
+	udelay(1000);
+
+	for (i = 2000; i > 0; i--) {
+		// Check if the RTL8169 has completed retrieving data from the specified MII register
+		if (RTL_R32(PHYAR) & 0x80000000) {
+			value = (int) (RTL_R32(PHYAR) & 0xFFFF);
+			break;
+		} else {
+			udelay(100);
+		}
+	}
+	return value;
+}
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+static int rtl8169_init_board(struct pci_device *pdev)
+{
+	int i, pm_cap;
+	unsigned long rtreg_base, rtreg_len;
+	u32 tmp;
+
+	rtreg_base = pci_bar_start(pdev, PCI_BASE_ADDRESS_1);
+	rtreg_len = pci_bar_size(pdev, PCI_BASE_ADDRESS_1);
+
+	// check for weird/broken PCI region reporting
+	if (rtreg_len < RTL_MIN_IO_SIZE) {
+		printf("Invalid PCI region size(s), aborting\n");
+	}
+
+	adjust_pci_device(pdev);
+	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+
+	// ioremap MMIO region 
+	ioaddr = (unsigned long) ioremap(rtreg_base, rtreg_len);
+	if (ioaddr == 0)
+		printf("Error cannot remap MMIO, aborting\n");
+
+	tpc->mmio_addr = &ioaddr;
+	// Soft reset the chip. 
+	RTL_W8(ChipCmd, CmdReset);
+
+	// Check that the chip has finished the reset.
+	for (i = 1000; i > 0; i--)
+		if ((RTL_R8(ChipCmd) & CmdReset) == 0)
+			break;
+		else
+			udelay(10);
+
+	// identify chip attached to board
+	tmp = RTL_R32(TxConfig);
+	tmp = ((tmp & 0x7c000000) + ((tmp & 0x00800000) << 2)) >> 24;
+
+	for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--)
+		if (tmp == rtl_chip_info[i].version) {
+			tpc->chipset = i;
+			goto match;
+		}
+	//if unknown chip, assume array element #0, original RTL-8169 in this case
+	printf("PCI device %s: unknown chip version, assuming RTL-8169\n");
+	printf("PCI device: TxConfig = 0x%hX\n",
+	       (unsigned long) RTL_R32(TxConfig));
+	tpc->chipset = 0;
+
+      match:
+	return 0;
+
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int r8169_poll(struct nic *nic)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	int cur_rx;
+	cur_rx = tpc->cur_rx;
+	if ((tpc->RxDescArray[cur_rx].status & OWNbit) == 0) {
+		if (!(tpc->RxDescArray[cur_rx].status & RxRES)) {
+			nic->packetlen = (int) (tpc->RxDescArray[cur_rx].
+						status & 0x00001FFF) - 4;
+			memcpy(nic->packet, tpc->RxBufferRing[cur_rx],
+			       nic->packetlen);
+			if (cur_rx == NUM_RX_DESC - 1)
+				tpc->RxDescArray[cur_rx].status =
+				    (OWNbit | EORbit) + RX_BUF_SIZE;
+			else
+				tpc->RxDescArray[cur_rx].status =
+				    OWNbit + RX_BUF_SIZE;
+			tpc->RxDescArray[cur_rx].buf_addr =
+			    virt_to_bus(tpc->RxBufferRing[cur_rx]);
+		} else
+			printf("Error Rx");
+		cur_rx = (cur_rx + 1) % NUM_RX_DESC;
+		tpc->cur_rx = cur_rx;
+		return 1;
+
+	}
+	tpc->cur_rx = cur_rx;
+	return (0);		/* initially as this is called to flush the input */
+
+}
+
+#define HZ 1000
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void r8169_transmit(struct nic *nic, const char *d,	/* Destination */
+			    unsigned int t,	/* Type */
+			    unsigned int s,	/* size */
+			    const char *p)
+{				/* Packet */
+	/* send the packet to destination */
+
+	u16 nstype;
+	u32 to;
+	u8 *ptxb;
+	int entry = tpc->cur_tx % NUM_TX_DESC;
+
+	/* point to the current txb incase multiple tx_rings are used */
+	ptxb = tpc->Tx_skbuff[entry * MAX_ETH_FRAME_SIZE];
+	memcpy(ptxb, d, ETH_ALEN);
+	memcpy(ptxb + ETH_ALEN, nic->node_addr, ETH_ALEN);
+	nstype = htons((u16) t);
+	memcpy(ptxb + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+	memcpy(ptxb + ETH_HLEN, p, s);
+	s += ETH_HLEN;
+	s &= 0x0FFF;
+	while (s < ETH_ZLEN)
+		ptxb[s++] = '\0';
+
+	tpc->TxDescArray[entry].buf_addr = virt_to_bus(ptxb);
+	if (entry != (NUM_TX_DESC - 1))
+		tpc->TxDescArray[entry].status =
+		    (OWNbit | FSbit | LSbit) | ((s > ETH_ZLEN) ?
+						s : ETH_ZLEN);
+	else
+		tpc->TxDescArray[entry].status =
+		    (OWNbit | EORbit | FSbit | LSbit) |
+		    ((s > ETH_ZLEN) ? s : ETH_ZLEN);
+	RTL_W8(TxPoll, 0x40);	//set polling bit
+
+	tpc->cur_tx++;
+	to = currticks() + TX_TIMEOUT;
+	while ((tpc->TxDescArray[entry].status & OWNbit) && (currticks() < to));	/* wait */
+
+	if (currticks() >= to) {
+		printf("TX Time Out");
+	}
+}
+
+static void rtl8169_set_rx_mode(struct nic *nic __unused)
+{
+	u32 mc_filter[2];	/* Multicast hash filter */
+	int rx_mode;
+	u32 tmp = 0;
+
+	/* IFF_ALLMULTI */
+	/* Too many to filter perfectly -- accept all multicasts. */
+	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+	mc_filter[1] = mc_filter[0] = 0xffffffff;
+
+	tmp =
+	    rtl8169_rx_config | rx_mode | (RTL_R32(RxConfig) &
+					   rtl_chip_info[tpc->chipset].
+					   RxConfigMask);
+
+	RTL_W32(RxConfig, tmp);
+	RTL_W32(MAR0 + 0, mc_filter[0]);
+	RTL_W32(MAR0 + 4, mc_filter[1]);
+}
+static void rtl8169_hw_start(struct nic *nic)
+{
+	u32 i;
+
+	/* Soft reset the chip. */
+	RTL_W8(ChipCmd, CmdReset);
+
+	/* Check that the chip has finished the reset. */
+	for (i = 1000; i > 0; i--) {
+		if ((RTL_R8(ChipCmd) & CmdReset) == 0)
+			break;
+		else
+			udelay(10);
+	}
+
+	RTL_W8(Cfg9346, Cfg9346_Unlock);
+	RTL_W8(ChipCmd, CmdTxEnb | CmdRxEnb);
+	RTL_W8(EarlyTxThres, EarlyTxThld);
+
+	// For gigabit rtl8169
+	RTL_W16(RxMaxSize, RxPacketMaxSize);
+
+	// Set Rx Config register
+	i = rtl8169_rx_config | (RTL_R32(RxConfig) &
+				 rtl_chip_info[tpc->chipset].RxConfigMask);
+	RTL_W32(RxConfig, i);
+
+	/* Set DMA burst size and Interframe Gap Time */
+	RTL_W32(TxConfig,
+		(TX_DMA_BURST << TxDMAShift) | (InterFrameGap <<
+						TxInterFrameGapShift));
+
+
+	tpc->cur_rx = 0;
+
+	RTL_W32(TxDescStartAddr, virt_to_le32desc(tpc->TxDescArray));
+	RTL_W32(RxDescStartAddr, virt_to_le32desc(tpc->RxDescArray));
+	RTL_W8(Cfg9346, Cfg9346_Lock);
+	udelay(10);
+
+	RTL_W32(RxMissed, 0);
+
+	rtl8169_set_rx_mode(nic);
+
+	/* no early-rx interrupts */
+	RTL_W16(MultiIntr, RTL_R16(MultiIntr) & 0xF000);
+}
+
+static void rtl8169_init_ring(struct nic *nic __unused)
+{
+	int i;
+
+	tpc->cur_rx = 0;
+	tpc->cur_tx = 0;
+	tpc->dirty_tx = 0;
+	memset(tpc->TxDescArray, 0x0, NUM_TX_DESC * sizeof(struct TxDesc));
+	memset(tpc->RxDescArray, 0x0, NUM_RX_DESC * sizeof(struct RxDesc));
+
+	for (i = 0; i < NUM_TX_DESC; i++) {
+		tpc->Tx_skbuff[i] = &txb[i];
+	}
+
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		if (i == (NUM_RX_DESC - 1))
+			tpc->RxDescArray[i].status =
+			    (OWNbit | EORbit) + RX_BUF_SIZE;
+		else
+			tpc->RxDescArray[i].status = OWNbit + RX_BUF_SIZE;
+
+		tpc->RxBufferRing[i] = &rxb[i * RX_BUF_SIZE];
+		tpc->RxDescArray[i].buf_addr =
+		    virt_to_bus(tpc->RxBufferRing[i]);
+	}
+}
+
+/**************************************************************************
+RESET - Finish setting up the ethernet interface
+***************************************************************************/
+static void r8169_reset(struct nic *nic)
+{
+	int i;
+	u8 diff;
+	u32 TxPhyAddr, RxPhyAddr;
+
+	tpc->TxDescArrays = tx_ring; 
+	if (tpc->TxDescArrays == 0)
+		printf("Allot Error");
+	// Tx Desscriptor needs 256 bytes alignment;
+	TxPhyAddr = virt_to_bus(tpc->TxDescArrays);
+	diff = 256 - (TxPhyAddr - ((TxPhyAddr >> 8) << 8));
+	TxPhyAddr += diff;
+	tpc->TxDescArray = (struct TxDesc *) (tpc->TxDescArrays + diff);
+
+	tpc->RxDescArrays = rx_ring;
+	// Rx Desscriptor needs 256 bytes alignment;
+	RxPhyAddr = virt_to_bus(tpc->RxDescArrays);
+	diff = 256 - (RxPhyAddr - ((RxPhyAddr >> 8) << 8));
+	RxPhyAddr += diff;
+	tpc->RxDescArray = (struct RxDesc *) (tpc->RxDescArrays + diff);
+
+	if (tpc->TxDescArrays == NULL || tpc->RxDescArrays == NULL) {
+		printf("Allocate RxDescArray or TxDescArray failed\n");
+		return;
+	}
+
+	rtl8169_init_ring(nic);
+	rtl8169_hw_start(nic);
+	/* Construct a perfect filter frame with the mac address as first match
+	 * and broadcast for all others */
+	for (i = 0; i < 192; i++)
+		txb[i] = 0xFF;
+
+	txb[0] = nic->node_addr[0];
+	txb[1] = nic->node_addr[1];
+	txb[2] = nic->node_addr[2];
+	txb[3] = nic->node_addr[3];
+	txb[4] = nic->node_addr[4];
+	txb[5] = nic->node_addr[5];
+
+
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void r8169_disable(struct dev *dev __unused)
+{
+	int i;
+	/* Stop the chip's Tx and Rx DMA processes. */
+	RTL_W8(ChipCmd, 0x00);
+
+	/* Disable interrupts by clearing the interrupt mask. */
+	RTL_W16(IntrMask, 0x0000);
+
+	RTL_W32(RxMissed, 0);
+
+	tpc->TxDescArrays = NULL;
+	tpc->RxDescArrays = NULL;
+	tpc->TxDescArray = NULL;
+	tpc->RxDescArray = NULL;
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		tpc->RxBufferRing[i] = NULL;
+	}
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+
+#define board_found 1
+#define valid_link 0
+static int r8169_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+	static int board_idx = -1;
+	static int printed_version = 0;
+	int i, rc;
+	int option = -1, Cap10_100 = 0, Cap1000 = 0;
+
+	/* BASE is used throughout to address the card */
+	printf("\n");
+	printf
+	    ("r8169.c: %s, %s\n", drv_version, drv_date);
+	printf("%s: Probing for Vendor=%hX   Device=%hX, %s\n", pci->name,
+	       pci->vendor, pci->dev_id);
+
+	board_idx++;
+
+	printed_version = 1;
+
+	/* point to private storage */
+	tpc = &tpx;
+
+	rc = rtl8169_init_board(pci);
+	if (rc)
+		return rc;
+
+	// Get MAC address.  FIXME: read EEPROM
+	for (i = 0; i < MAC_ADDR_LEN; i++)
+		nic->node_addr[i] = RTL_R8(MAC0 + i);
+
+	printf("%s: Identified chip type is '%s'.\n", pci->name,
+	       rtl_chip_info[tpc->chipset].name);
+	/* Print out some hardware info */
+	printf("%s%s: %! at ioaddr %hX\n", pci->name, nic->node_addr, ioaddr);
+
+	// if TBI is not endbled
+	if (!(RTL_R8(PHYstatus) & TBI_Enable)) {
+		int val = mdio_read(PHY_AUTO_NEGO_REG);
+
+		option = (board_idx >= MAX_UNITS) ? 0 : media[board_idx];
+		// Force RTL8169 in 10/100/1000 Full/Half mode.
+		if (option > 0) {
+			printf("%s: Force-mode Enabled.\n", pci->name);
+			Cap10_100 = 0, Cap1000 = 0;
+			switch (option) {
+			case _10_Half:
+				Cap10_100 = PHY_Cap_10_Half;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _10_Full:
+				Cap10_100 = PHY_Cap_10_Full;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _100_Half:
+				Cap10_100 = PHY_Cap_100_Half;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _100_Full:
+				Cap10_100 = PHY_Cap_100_Full;
+				Cap1000 = PHY_Cap_Null;
+				break;
+			case _1000_Full:
+				Cap10_100 = PHY_Cap_Null;
+				Cap1000 = PHY_Cap_1000_Full;
+				break;
+			default:
+				break;
+			}
+			mdio_write(PHY_AUTO_NEGO_REG, Cap10_100 | (val & 0x1F));	//leave PHY_AUTO_NEGO_REG bit4:0 unchanged
+			mdio_write(PHY_1000_CTRL_REG, Cap1000);
+		} else {
+			printf("%s: Auto-negotiation Enabled.\n",
+			       pci->name);
+
+			// enable 10/100 Full/Half Mode, leave PHY_AUTO_NEGO_REG bit4:0 unchanged
+			mdio_write(PHY_AUTO_NEGO_REG,
+				   PHY_Cap_10_Half | PHY_Cap_10_Full |
+				   PHY_Cap_100_Half | PHY_Cap_100_Full |
+				   (val & 0x1F));
+
+			// enable 1000 Full Mode
+			mdio_write(PHY_1000_CTRL_REG, PHY_Cap_1000_Full);
+
+		}
+
+		// Enable auto-negotiation and restart auto-nigotiation
+		mdio_write(PHY_CTRL_REG,
+			   PHY_Enable_Auto_Nego | PHY_Restart_Auto_Nego);
+		udelay(100);
+
+		// wait for auto-negotiation process
+		for (i = 10000; i > 0; i--) {
+			//check if auto-negotiation complete
+			if (mdio_read(PHY_STAT_REG) & PHY_Auto_Neco_Comp) {
+				udelay(100);
+				option = RTL_R8(PHYstatus);
+				if (option & _1000bpsF) {
+					printf
+					    ("%s: 1000Mbps Full-duplex operation.\n",
+					     pci->name);
+				} else {
+					printf
+					    ("%s: %sMbps %s-duplex operation.\n",
+					     pci->name,
+					     (option & _100bps) ? "100" :
+					     "10",
+					     (option & FullDup) ? "Full" :
+					     "Half");
+				}
+				break;
+			} else {
+				udelay(100);
+			}
+		}		// end for-loop to wait for auto-negotiation process
+
+	} else {
+		udelay(100);
+		printf
+		    ("%s: 1000Mbps Full-duplex operation, TBI Link %s!\n",
+		     pci->name,
+		     (RTL_R32(TBICSR) & TBILinkOK) ? "OK" : "Failed");
+
+	}
+
+	r8169_reset(nic);
+	/* point to NIC specific routines */
+	dev->disable = r8169_disable;
+	nic->poll = r8169_poll;
+	nic->transmit = r8169_transmit;
+	return 1;
+
+}
+
+static struct pci_id r8169_nics[] = {
+	PCI_ROM(0x10ec, 0x8169, "r8169", "RealTek RTL8169 Gigabit Ethernet"),
+};
+
+struct pci_driver r8169_driver = {
+	.type = NIC_DRIVER,
+	.name = "r8169/PCI",
+	.probe = r8169_probe,
+	.ids = r8169_nics,
+	.id_count = sizeof(r8169_nics) / sizeof(r8169_nics[0]),
+	.class = 0,
+};
Index: netboot/i386_timer.c
===================================================================
--- netboot/i386_timer.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/i386_timer.c	(.../trunk)	(revision 112)
@@ -0,0 +1,192 @@
+/* A couple of routines to implement a low-overhead timer for drivers */
+
+ /*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+#include "grub.h"
+#include "osdep.h"
+#include "io.h"
+#include "timer.h"
+#include "latch.h"
+
+void __load_timer2(unsigned int ticks)
+{
+	/*
+	 * Now let's take care of PPC channel 2
+	 *
+	 * Set the Gate high, program PPC channel 2 for mode 0,
+	 * (interrupt on terminal count mode), binary count,
+	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.
+	 *
+	 * Note some implementations have a bug where the high bits byte
+	 * of channel 2 is ignored.
+	 */
+	/* Set up the timer gate, turn off the speaker */
+	/* Set the Gate high, disable speaker */
+	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
+	/* binary, mode 0, LSB/MSB, Ch 2 */
+	outb(TIMER2_SEL|WORD_ACCESS|MODE0|BINARY_COUNT, TIMER_MODE_PORT);
+	/* LSB of ticks */
+	outb(ticks & 0xFF, TIMER2_PORT);
+	/* MSB of ticks */
+	outb(ticks >> 8, TIMER2_PORT);
+}
+
+static int __timer2_running(void)
+{
+	return ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
+}
+
+#if !defined(CONFIG_TSC_CURRTICKS)
+void setup_timers(void)
+{
+	return;
+}
+
+void load_timer2(unsigned int ticks)
+{
+	return __load_timer2(ticks);
+}
+
+int timer2_running(void)
+{
+	return __timer2_running();
+}
+
+void ndelay(unsigned int nsecs)
+{
+	waiton_timer2((nsecs * CLOCK_TICK_RATE)/1000000000);
+}
+void udelay(unsigned int usecs)
+{
+	waiton_timer2((usecs * TICKS_PER_MS)/1000);
+}
+#endif /* !defined(CONFIG_TSC_CURRTICKS) */
+
+#if defined(CONFIG_TSC_CURRTICKS)
+
+#define rdtsc(low,high) \
+     __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
+
+#define rdtscll(val) \
+     __asm__ __volatile__ ("rdtsc" : "=A" (val))
+
+
+/* Number of clock ticks to time with the rtc */
+#define LATCH 0xFF
+
+#define LATCHES_PER_SEC ((CLOCK_TICK_RATE + (LATCH/2))/LATCH)
+#define TICKS_PER_LATCH ((LATCHES_PER_SEC + (TICKS_PER_SEC/2))/TICKS_PER_SEC)
+
+static void sleep_latch(void)
+{
+	__load_timer2(LATCH);
+	while(__timer2_running());
+}
+
+/* ------ Calibrate the TSC ------- 
+ * Time how long it takes to excute a loop that runs in known time.
+ * And find the convertion needed to get to CLOCK_TICK_RATE
+ */
+
+
+static unsigned long long calibrate_tsc(void)
+{
+	unsigned long startlow, starthigh;
+	unsigned long endlow, endhigh;
+	
+	rdtsc(startlow,starthigh);
+	sleep_latch();
+	rdtsc(endlow,endhigh);
+
+	/* 64-bit subtract - gcc just messes up with long longs */
+	__asm__("subl %2,%0\n\t"
+		"sbbl %3,%1"
+		:"=a" (endlow), "=d" (endhigh)
+		:"g" (startlow), "g" (starthigh),
+		"0" (endlow), "1" (endhigh));
+	
+	/* Error: ECPUTOOFAST */
+	if (endhigh)
+		goto bad_ctc;
+	
+	endlow *= TICKS_PER_LATCH;
+	return endlow;
+
+	/*
+	 * The CTC wasn't reliable: we got a hit on the very first read,
+	 * or the CPU was so fast/slow that the quotient wouldn't fit in
+	 * 32 bits..
+	 */
+bad_ctc:
+	printf("bad_ctc\n");
+	return 0;
+}
+
+static unsigned long clocks_per_tick;
+void setup_timers(void)
+{
+	if (!clocks_per_tick) {
+		clocks_per_tick = calibrate_tsc();
+		/* Display the CPU Mhz to easily test if the calibration was bad */
+		printf("CPU %ld Mhz\n", (clocks_per_tick/1000 * TICKS_PER_SEC)/1000);
+	}
+}
+
+unsigned long currticks(void)
+{
+	unsigned long clocks_high, clocks_low;
+	unsigned long currticks;
+	/* Read the Time Stamp Counter */
+	rdtsc(clocks_low, clocks_high);
+
+	/* currticks = clocks / clocks_per_tick; */
+	__asm__("divl %1"
+		:"=a" (currticks)
+		:"r" (clocks_per_tick), "0" (clocks_low), "d" (clocks_high));
+
+
+	return currticks;
+}
+
+static unsigned long long timer_timeout;
+static int __timer_running(void)
+{
+	unsigned long long now;
+	rdtscll(now);
+	return now < timer_timeout;
+}
+
+void udelay(unsigned int usecs)
+{
+	unsigned long long now;
+	rdtscll(now);
+	timer_timeout = now + usecs * ((clocks_per_tick * TICKS_PER_SEC)/(1000*1000));
+	while(__timer_running());
+}
+void ndelay(unsigned int nsecs)
+{
+	unsigned long long now;
+	rdtscll(now);
+	timer_timeout = now + nsecs * ((clocks_per_tick * TICKS_PER_SEC)/(1000*1000*1000));
+	while(__timer_running());
+}
+
+void load_timer2(unsigned int timer2_ticks)
+{
+	unsigned long long now;
+	unsigned long clocks;
+	rdtscll(now);
+	clocks = timer2_ticks * ((clocks_per_tick * TICKS_PER_SEC)/CLOCK_TICK_RATE);
+	timer_timeout = now + clocks;
+}
+
+int timer2_running(void)
+{
+	return __timer_running();
+}
+
+#endif /* RTC_CURRTICKS */
Index: netboot/nfs.h
===================================================================
--- netboot/nfs.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/nfs.h	(.../trunk)	(revision 112)
@@ -0,0 +1,63 @@
+#ifndef	_NFS_H
+#define	_NFS_H
+
+#define SUNRPC_PORT	111
+
+#define PROG_PORTMAP	100000
+#define PROG_NFS	100003
+#define PROG_MOUNT	100005
+
+#define MSG_CALL	0
+#define MSG_REPLY	1
+
+#define PORTMAP_GETPORT	3
+
+#define MOUNT_ADDENTRY	1
+#define MOUNT_UMOUNTALL	4
+
+#define NFS_LOOKUP	4
+#define	NFS_READLINK	5
+#define NFS_READ	6
+
+#define NFS_FHSIZE	32
+
+#define NFSERR_PERM	1
+#define NFSERR_NOENT	2
+#define NFSERR_ACCES	13
+#define	NFSERR_ISDIR	21
+#define	NFSERR_INVAL	22
+
+/* Block size used for NFS read accesses.  A RPC reply packet (including  all
+ * headers) must fit within a single Ethernet frame to avoid fragmentation.
+ * Chosen to be a power of two, as most NFS servers are optimized for this.  */
+#define NFS_READ_SIZE	1024
+
+#define NFS_MAXLINKDEPTH 16
+
+struct rpc_t {
+	struct iphdr ip;
+	struct udphdr udp;
+	union {
+		uint8_t  data[300];		/* longest RPC call must fit!!!! */
+		struct {
+			uint32_t id;
+			uint32_t type;
+			uint32_t rpcvers;
+			uint32_t prog;
+			uint32_t vers;
+			uint32_t proc;
+			uint32_t data[1];
+		} call;
+		struct {
+			uint32_t id;
+			uint32_t type;
+			uint32_t rstatus;
+			uint32_t verifier;
+			uint32_t v2;
+			uint32_t astatus;
+			uint32_t data[1];
+		} reply;
+	} u;
+};
+
+#endif	/* _NFS_H */
Index: netboot/udp.h
===================================================================
--- netboot/udp.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/udp.h	(.../trunk)	(revision 112)
@@ -0,0 +1,30 @@
+#ifndef	_UDP_H
+#define	_UDP_H
+
+/* We need 'uint16_t' and 'uint8_t'  */
+#include "types.h"
+/* We need 'in_addr' */
+#include "in.h"
+
+struct udp_pseudo_hdr {
+	in_addr  src;
+	in_addr  dest;
+	uint8_t  unused;
+	uint8_t  protocol;
+	uint16_t len;
+};
+struct udphdr {
+	uint16_t src;
+	uint16_t dest;
+	uint16_t len;
+	uint16_t chksum;
+};
+
+extern void build_udp_hdr(unsigned long __destip, unsigned int __srcsock, 
+	      unsigned int __destsock, int __ttl, int __len, 
+	      const void * __buf);
+
+extern int udp_transmit(unsigned long __destip, unsigned int __srcsock,
+			unsigned int __destsock, int __len, const void * __buf);
+
+#endif	/* _UDP_H */
Index: netboot/natsemi.c
===================================================================
--- netboot/natsemi.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/natsemi.c	(.../trunk)	(revision 112)
@@ -47,6 +47,7 @@
 /* Revision History */
 
 /*
+  13 Dec 2003 timlegge 1.1 Enabled Multicast Support
   29 May 2001  mdc     1.0
      Initial Release.  Tested with Netgear FA311 and FA312 boards
 */
@@ -55,7 +56,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 /* defines */
 
@@ -71,21 +71,18 @@
 
 #define NUM_RX_DESC    4              /* Number of Rx descriptor registers. */
 
-typedef unsigned char  u8;
-typedef   signed char  s8;
-typedef unsigned short u16;
-typedef   signed short s16;
-typedef unsigned int   u32;
-typedef   signed int   s32;
+typedef uint8_t    u8;
+typedef int8_t     s8;
+typedef uint16_t   u16;
+typedef int16_t    s16;
+typedef uint32_t   u32;
+typedef int32_t    s32;
 
 /* helpful macroes if on a big_endian machine for changing byte order.
    not strictly needed on Intel */
-#define le16_to_cpu(val) (val)
-#define cpu_to_le32(val) (val)
 #define get_unaligned(ptr) (*(ptr))
 #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
 #define get_u16(ptr) (*(u16 *)(ptr))
-#define virt_to_bus(x) ((unsigned long)x)
 #define virt_to_le32desc(addr)  virt_to_bus(addr)
 
 enum pcistuff {
@@ -161,7 +158,8 @@
     AcceptMulticast    = 0x00200000, 
     AcceptAllMulticast = 0x20000000,
     AcceptAllPhys      = 0x10000000, 
-    AcceptMyPhys       = 0x08000000
+    AcceptMyPhys       = 0x08000000,
+    RxFilterEnable     = 0x80000000
 };
 
 typedef struct _BufferDesc {
@@ -207,17 +205,12 @@
 static BufferDesc txd              __attribute__ ((aligned(4)));
 static BufferDesc rxd[NUM_RX_DESC] __attribute__ ((aligned(4)));
 
-#ifdef USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - TX_BUF_SIZE)
-#define rxb ((char *)0x10000 - NUM_RX_DESC*RX_BUF_SIZE - TX_BUF_SIZE)
-#else
 static unsigned char txb[TX_BUF_SIZE] __attribute__ ((aligned(4)));
 static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE] __attribute__ ((aligned(4)));
-#endif
 
 /* Function Prototypes */
 
-struct nic *natsemi_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci);
+static int natsemi_probe(struct dev *dev, struct pci_device *pci);
 static int eeprom_read(long addr, int location);
 static int mdio_read(int phy_id, int location);
 static void natsemi_init(struct nic *nic);
@@ -229,7 +222,7 @@
 static void natsemi_check_duplex(struct nic *nic);
 static void natsemi_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p);
 static int  natsemi_poll(struct nic *nic);
-static void natsemi_disable(struct nic *nic);
+static void natsemi_disable(struct dev *dev);
 
 /* 
  * Function: natsemi_probe
@@ -245,19 +238,20 @@
  * Returns:   struct nic *:          pointer to NIC data structure
  */
 
-struct nic *
-natsemi_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
+static int
+natsemi_probe(struct dev *dev, struct pci_device *pci)
 {
+    struct nic *nic = (struct nic *)dev;
     int i;
     int prev_eedata;
     u32 tmp;
 
-    if (io_addrs == 0 || *io_addrs == 0)
-        return NULL;
+    if (pci->ioaddr == 0)
+        return 0;
 
     /* initialize some commonly used globals */
 	
-    ioaddr     = *io_addrs & ~3;
+    ioaddr     = pci->ioaddr & ~3;
     vendor     = pci->vendor;
     dev_id     = pci->dev_id;
     nic_name   = pci->name;
@@ -317,12 +311,11 @@
     /* initialize device */
     natsemi_init(nic);
 
-    nic->reset    = natsemi_init;
+    dev->disable  = natsemi_disable;
     nic->poll     = natsemi_poll;
     nic->transmit = natsemi_transmit;
-    nic->disable  = natsemi_disable;
 
-    return nic;
+    return 1;
 }
 
 /* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.
@@ -452,7 +445,7 @@
  * Returns:   void.
  */
 static void 
-natsemi_reset(struct nic *nic)
+natsemi_reset(struct nic *nic __unused)
 {
     outl(ChipReset, ioaddr + ChipCmd);
 	
@@ -504,14 +497,14 @@
  */
 
 static void
-natsemi_init_txd(struct nic *nic)
+natsemi_init_txd(struct nic *nic __unused)
 {
     txd.link   = (u32) 0;
     txd.cmdsts = (u32) 0;
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + TxRingPtr); 
+    outl(virt_to_bus(&txd), ioaddr + TxRingPtr); 
     if (natsemi_debug > 1)
         printf("natsemi_init_txd: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + TxRingPtr));
@@ -527,7 +520,7 @@
  */
  
 static void 
-natsemi_init_rxd(struct nic *nic) 
+natsemi_init_rxd(struct nic *nic __unused) 
 { 
     int i;
 
@@ -535,16 +528,16 @@
 
     /* init RX descriptor */
     for (i = 0; i < NUM_RX_DESC; i++) {
-        rxd[i].link   = (i+1 < NUM_RX_DESC) ? (u32) &rxd[i+1] : (u32) &rxd[0];
+        rxd[i].link   = virt_to_bus((i+1 < NUM_RX_DESC) ? &rxd[i+1] : &rxd[0]);
         rxd[i].cmdsts = (u32) RX_BUF_SIZE;
-        rxd[i].bufptr = (u32) &rxb[i*RX_BUF_SIZE];
+        rxd[i].bufptr = virt_to_bus(&rxb[i*RX_BUF_SIZE]);
         if (natsemi_debug > 1)
             printf("natsemi_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
                    i, &rxd[i], rxd[i].link, rxd[i].cmdsts, rxd[i].bufptr);
     }
 
     /* load Receive Descriptor Register */
-    outl((u32) &rxd[0], ioaddr + RxRingPtr);
+    outl(virt_to_bus(&rxd[0]), ioaddr + RxRingPtr);
 
     if (natsemi_debug > 1)
         printf("natsemi_init_rxd: RX descriptor register loaded with: %X\n", 
@@ -562,14 +555,15 @@
  * Returns:   void.
  */
 
-static void natsemi_set_rx_mode(struct nic *nic)
+static void natsemi_set_rx_mode(struct nic *nic __unused)
 {
-    u32 rx_mode = AcceptBroadcast | AcceptMyPhys;
+    u32 rx_mode = RxFilterEnable | AcceptBroadcast |
+	    AcceptAllMulticast | AcceptMyPhys;
 	
     outl(rx_mode, ioaddr + RxFilterAddr);
 }
 
-static void natsemi_check_duplex(struct nic *nic)
+static void natsemi_check_duplex(struct nic *nic __unused)
 {
     int duplex = inl(ioaddr + ChipConfig) & 0x20000000 ? 1 : 0;
 	
@@ -607,14 +601,14 @@
 		 unsigned int s,     /* size */
 		 const char  *p)     /* Packet */
 {
-    u32 status, to, nstype;
+    u32 to, nstype;
     volatile u32 tx_status;
     
     /* Stop the transmitter */
     outl(TxOff, ioaddr + ChipCmd);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + TxRingPtr);
+    outl(virt_to_bus(&txd), ioaddr + TxRingPtr);
     if (natsemi_debug > 1)
         printf("natsemi_transmit: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + TxRingPtr));
@@ -636,7 +630,7 @@
         txb[s++] = '\0';
 
     /* set the transmit buffer descriptor and enable Transmit State Machine */
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
     txd.cmdsts = (u32) OWN | s;
 
     /* restart the transmitter */
@@ -704,7 +698,7 @@
 
     /* return the descriptor and buffer to receive ring */
     rxd[cur_rx].cmdsts = RX_BUF_SIZE;
-    rxd[cur_rx].bufptr = (u32) &rxb[cur_rx*RX_BUF_SIZE];
+    rxd[cur_rx].bufptr = virt_to_bus(&rxb[cur_rx*RX_BUF_SIZE]);
         
     if (++cur_rx == NUM_RX_DESC)
         cur_rx = 0;
@@ -725,8 +719,12 @@
  */
 
 static void
-natsemi_disable(struct nic *nic)
+natsemi_disable(struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
+    /* merge reset and disable */
+    natsemi_init(nic);
+
     /* Disable interrupts using the mask. */
     outl(0, ioaddr + IntrMask);
     outl(0, ioaddr + IntrEnable);
@@ -737,3 +735,16 @@
     /* Restore PME enable bit */
     outl(SavedClkRun, ioaddr + ClkRun);
 }
+
+static struct pci_id natsemi_nics[] = {
+PCI_ROM(0x100b, 0x0020, "dp83815", "DP83815"),
+};
+
+struct pci_driver natsemi_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "NATSEMI",
+	.probe    = natsemi_probe,
+	.ids      = natsemi_nics,
+	.id_count = sizeof(natsemi_nics)/sizeof(natsemi_nics[0]),
+	.class    = 0,
+};
Index: netboot/latch.h
===================================================================
--- netboot/latch.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/latch.h	(.../trunk)	(revision 112)
@@ -0,0 +1,10 @@
+#ifndef LATCH_H
+#define LATCH_H
+
+#define	TICKS_PER_SEC		18
+
+/* For different calibrators of the TSC move the declaration of
+ * sleep_latch and the definitions of it's length here...
+ */
+
+#endif /* LATCH_H */
Index: netboot/etherboot.h
===================================================================
--- netboot/etherboot.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/etherboot.h	(.../trunk)	(revision 112)
@@ -1,544 +1,15 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
 
-/* RULE: You must define the macro ``GRUB'' when including this header
-   file in GRUB code.  */
+#include "osdep.h"
+#include "if_ether.h"
+#include "in.h"
+#include "if_arp.h"
+#include "ip.h"
+#include "udp.h"
+#include "bootp.h"
+#include "tftp.h"
+#include "igmp.h"
+//#include "nfs.h"
+//#include "nic.h"
+#include "pci.h"
+#include "grub.h"
 
-/* Based on "src/etherboot.h" in etherboot-5.0.5.  */
-
-/**************************************************************************
-ETHERBOOT -  BOOTP/TFTP Bootstrap Program
-
-Author: Martin Renters
-  Date: Dec/93
-
-**************************************************************************/
-
-/* Include GRUB-specific macros and prototypes here.  */
-#include <shared.h>
-
-/* FIXME: For now, enable the DHCP support. Perhaps I should segregate
-   the DHCP support from the BOOTP support, and permit both to
-   co-exist.  */
-#undef NO_DHCP_SUPPORT
-
-/* In GRUB, the relocated address in Etherboot doesn't have any sense.
-   Just define it as a bogus value.  */
-#define RELOC	0
-
-/* FIXME: Should be an option.  */
-#define BACKOFF_LIMIT	7
-
-#include <osdep.h>
-
-#define CTRL_C		3
-
-#ifndef	MAX_TFTP_RETRIES
-# define MAX_TFTP_RETRIES	20
-#endif
-
-#ifndef	MAX_BOOTP_RETRIES
-# define MAX_BOOTP_RETRIES	20
-#endif
-
-#define MAX_BOOTP_EXTLEN	(ETH_FRAME_LEN - ETH_HLEN - \
-				 sizeof (struct bootp_t))
-
-#ifndef	MAX_ARP_RETRIES
-# define MAX_ARP_RETRIES	20
-#endif
-
-#ifndef	MAX_RPC_RETRIES
-# define MAX_RPC_RETRIES	20
-#endif
-
-#define	TICKS_PER_SEC		18
-
-/* Inter-packet retry in ticks */
-#define TIMEOUT			(10 * TICKS_PER_SEC)
-
-/* These settings have sense only if compiled with -DCONGESTED */
-/* total retransmission timeout in ticks */
-#define TFTP_TIMEOUT		(30 * TICKS_PER_SEC)
-/* packet retransmission timeout in ticks */
-#define TFTP_REXMT		(3 * TICKS_PER_SEC)
-
-#ifndef	NULL
-# define NULL			((void *) 0)
-#endif
-
-/*
-   I'm moving towards the defined names in linux/if_ether.h for clarity.
-   The confusion between 60/64 and 1514/1518 arose because the NS8390
-   counts the 4 byte frame checksum in the incoming packet, but not
-   in the outgoing packet. 60/1514 are the correct numbers for most
-   if not all of the other NIC controllers. I will be retiring the
-   64/1518 defines in the lead-up to 5.0.
-*/
-
-#define ETH_ALEN		6	/* Size of Ethernet address */
-#define ETH_HLEN		14	/* Size of ethernet header */
-#define	ETH_ZLEN		60	/* Minimum packet */
-/*#define ETH_MIN_PACKET		64*/
-#define	ETH_FRAME_LEN		1514	/* Maximum packet */
-/*#define ETH_MAX_PACKET		1518*/
-/* Because some DHCP/BOOTP servers don't treat the maximum length the same
-   as Etherboot, subtract the size of an IP header and that of an UDP
-   header.  */
-#define	ETH_MAX_MTU		(ETH_FRAME_LEN - ETH_HLEN \
-				- sizeof (struct iphdr) \
-				- sizeof (struct udphdr))
-
-#define ARP_CLIENT	0
-#define ARP_SERVER	1
-#define ARP_GATEWAY	2
-#define ARP_ROOTSERVER	3
-#define ARP_SWAPSERVER	4
-#define MAX_ARP		ARP_SWAPSERVER+1
-
-#define	RARP_REQUEST	3
-#define	RARP_REPLY	4
-
-#define IP		0x0800
-#define ARP		0x0806
-#define	RARP		0x8035
-
-#define BOOTP_SERVER	67
-#define BOOTP_CLIENT	68
-#define TFTP_PORT	69
-#define SUNRPC_PORT	111
-
-#define IP_UDP		17
-/* Same after going through htonl */
-#define IP_BROADCAST	0xFFFFFFFF
-
-#define ARP_REQUEST	1
-#define ARP_REPLY	2
-
-#define BOOTP_REQUEST	1
-#define BOOTP_REPLY	2
-
-#define TAG_LEN(p)		(*((p) + 1))
-#define RFC1533_COOKIE		99, 130, 83, 99
-#define RFC1533_PAD		0
-#define RFC1533_NETMASK		1
-#define RFC1533_TIMEOFFSET	2
-#define RFC1533_GATEWAY		3
-#define RFC1533_TIMESERVER	4
-#define RFC1533_IEN116NS	5
-#define RFC1533_DNS		6
-#define RFC1533_LOGSERVER	7
-#define RFC1533_COOKIESERVER	8
-#define RFC1533_LPRSERVER	9
-#define RFC1533_IMPRESSSERVER	10
-#define RFC1533_RESOURCESERVER	11
-#define RFC1533_HOSTNAME	12
-#define RFC1533_BOOTFILESIZE	13
-#define RFC1533_MERITDUMPFILE	14
-#define RFC1533_DOMAINNAME	15
-#define RFC1533_SWAPSERVER	16
-#define RFC1533_ROOTPATH	17
-#define RFC1533_EXTENSIONPATH	18
-#define RFC1533_IPFORWARDING	19
-#define RFC1533_IPSOURCEROUTING	20
-#define RFC1533_IPPOLICYFILTER	21
-#define RFC1533_IPMAXREASSEMBLY	22
-#define RFC1533_IPTTL		23
-#define RFC1533_IPMTU		24
-#define RFC1533_IPMTUPLATEAU	25
-#define RFC1533_INTMTU		26
-#define RFC1533_INTLOCALSUBNETS	27
-#define RFC1533_INTBROADCAST	28
-#define RFC1533_INTICMPDISCOVER	29
-#define RFC1533_INTICMPRESPOND	30
-#define RFC1533_INTROUTEDISCOVER 31
-#define RFC1533_INTROUTESOLICIT	32
-#define RFC1533_INTSTATICROUTES	33
-#define RFC1533_LLTRAILERENCAP	34
-#define RFC1533_LLARPCACHETMO	35
-#define RFC1533_LLETHERNETENCAP	36
-#define RFC1533_TCPTTL		37
-#define RFC1533_TCPKEEPALIVETMO	38
-#define RFC1533_TCPKEEPALIVEGB	39
-#define RFC1533_NISDOMAIN	40
-#define RFC1533_NISSERVER	41
-#define RFC1533_NTPSERVER	42
-#define RFC1533_VENDOR		43
-#define RFC1533_NBNS		44
-#define RFC1533_NBDD		45
-#define RFC1533_NBNT		46
-#define RFC1533_NBSCOPE		47
-#define RFC1533_XFS		48
-#define RFC1533_XDM		49
-#ifndef	NO_DHCP_SUPPORT
-#define RFC2132_REQ_ADDR	50
-#define RFC2132_MSG_TYPE	53
-#define RFC2132_SRV_ID		54
-#define RFC2132_PARAM_LIST	55
-#define RFC2132_MAX_SIZE	57
-#define RFC2132_VENDOR_CLASS_ID	60
-
-#define DHCPDISCOVER		1
-#define DHCPOFFER		2
-#define DHCPREQUEST		3
-#define DHCPACK			5
-#endif	/* NO_DHCP_SUPPORT */
-
-#define RFC1533_VENDOR_MAJOR	0
-#define RFC1533_VENDOR_MINOR	0
-
-#define RFC1533_VENDOR_MAGIC	128
-#define RFC1533_VENDOR_ADDPARM	129
-#define RFC1533_VENDOR_MNUOPTS	160
-#define RFC1533_VENDOR_SELECTION 176
-#define RFC1533_VENDOR_MOTD	184
-#define RFC1533_VENDOR_NUMOFMOTD 8
-#define RFC1533_VENDOR_IMG	192
-#define RFC1533_VENDOR_NUMOFIMG	16
-
-#define RFC1533_VENDOR_CONFIGFILE	150
-
-#define RFC1533_END		255
-
-#define BOOTP_VENDOR_LEN	64
-#ifndef	NO_DHCP_SUPPORT
-#define DHCP_OPT_LEN		312
-#endif	/* NO_DHCP_SUPPORT */
-
-#define	TFTP_DEFAULTSIZE_PACKET	512
-#define	TFTP_MAX_PACKET		1432 /* 512 */
-
-#define TFTP_RRQ	1
-#define TFTP_WRQ	2
-#define TFTP_DATA	3
-#define TFTP_ACK	4
-#define TFTP_ERROR	5
-#define TFTP_OACK	6
-
-#define TFTP_CODE_EOF	1
-#define TFTP_CODE_MORE	2
-#define TFTP_CODE_ERROR	3
-#define TFTP_CODE_BOOT	4
-#define TFTP_CODE_CFG	5
-
-#define AWAIT_ARP	0
-#define AWAIT_BOOTP	1
-#define AWAIT_TFTP	2
-#define AWAIT_RARP	3
-#define AWAIT_RPC	4
-#define AWAIT_QDRAIN	5	/* drain queue, process ARP requests */
-
-typedef struct
-{
-  unsigned long	s_addr;
-}
-in_addr;
-
-struct arptable_t
-{
-  in_addr ipaddr;
-  unsigned char node[6];
-};
-
-/*
- * A pity sipaddr and tipaddr are not longword aligned or we could use
- * in_addr. No, I don't want to use #pragma packed.
- */
-struct arprequest
-{
-  unsigned short hwtype;
-  unsigned short protocol;
-  char hwlen;
-  char protolen;
-  unsigned short opcode;
-  char shwaddr[6];
-  char sipaddr[4];
-  char thwaddr[6];
-  char tipaddr[4];
-};
-
-struct iphdr
-{
-  char verhdrlen;
-  char service;
-  unsigned short len;
-  unsigned short ident;
-  unsigned short frags;
-  char ttl;
-  char protocol;
-  unsigned short chksum;
-  in_addr src;
-  in_addr dest;
-};
-
-struct udphdr
-{
-  unsigned short src;
-  unsigned short dest;
-  unsigned short len;
-  unsigned short chksum;
-};
-
-/* Format of a bootp packet.  */
-struct bootp_t
-{
-  char bp_op;
-  char bp_htype;
-  char bp_hlen;
-  char bp_hops;
-  unsigned long bp_xid;
-  unsigned short bp_secs;
-  unsigned short unused;
-  in_addr bp_ciaddr;
-  in_addr bp_yiaddr;
-  in_addr bp_siaddr;
-  in_addr bp_giaddr;
-  char bp_hwaddr[16];
-  char bp_sname[64];
-  char bp_file[128];
-#ifdef	NO_DHCP_SUPPORT
-  char bp_vend[BOOTP_VENDOR_LEN];
-#else
-  char bp_vend[DHCP_OPT_LEN];
-#endif	/* NO_DHCP_SUPPORT */
-};
-
-/* Format of a bootp IP packet.  */
-struct bootpip_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  struct bootp_t bp;
-};
-
-/* Format of bootp packet with extensions.  */
-struct bootpd_t
-{
-  struct bootp_t bootp_reply;
-  unsigned char  bootp_extension[MAX_BOOTP_EXTLEN];
-};
-
-struct tftp_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  unsigned short opcode;
-  union
-  {
-    char rrq[TFTP_DEFAULTSIZE_PACKET];
-    
-    struct
-    {
-      unsigned short block;
-      char download[TFTP_MAX_PACKET];
-    }
-    data;
-    
-    struct
-    {
-      unsigned short block;
-    }
-    ack;
-    
-    struct
-    {
-      unsigned short errcode;
-      char errmsg[TFTP_DEFAULTSIZE_PACKET];
-    }
-    err;
-    
-    struct
-    {
-      char data[TFTP_DEFAULTSIZE_PACKET+2];
-    }
-    oack;
-  }
-  u;
-};
-
-/* Define a smaller tftp packet solely for making requests to conserve stack
-   512 bytes should be enough.  */
-struct tftpreq_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  unsigned short opcode;
-  union
-  {
-    char rrq[512];
-    
-    struct
-    {
-      unsigned short block;
-    }
-    ack;
-    
-    struct
-    {
-      unsigned short errcode;
-      char errmsg[512-2];
-    }
-    err;
-  }
-  u;
-};
-
-#define TFTP_MIN_PACKET	(sizeof(struct iphdr) + sizeof(struct udphdr) + 4)
-
-struct rpc_t
-{
-  struct iphdr ip;
-  struct udphdr udp;
-  union
-  {
-    char data[300];		/* longest RPC call must fit!!!! */
-    
-    struct
-    {
-      long id;
-      long type;
-      long rpcvers;
-      long prog;
-      long vers;
-      long proc;
-      long data[1];
-    }
-    call;
-    
-    struct
-    {
-      long id;
-      long type;
-      long rstatus;
-      long verifier;
-      long v2;
-      long astatus;
-      long data[1];
-    }
-    reply;
-  }
-  u;
-};
-
-#define PROG_PORTMAP	100000
-#define PROG_NFS	100003
-#define PROG_MOUNT	100005
-
-#define MSG_CALL	0
-#define MSG_REPLY	1
-
-#define PORTMAP_GETPORT	3
-
-#define MOUNT_ADDENTRY	1
-#define MOUNT_UMOUNTALL	4
-
-#define NFS_LOOKUP	4
-#define NFS_READ	6
-
-#define NFS_FHSIZE	32
-
-#define NFSERR_PERM	1
-#define NFSERR_NOENT	2
-#define NFSERR_ACCES	13
-
-/* Block size used for NFS read accesses.  A RPC reply packet (including  all
- * headers) must fit within a single Ethernet frame to avoid fragmentation.
- * Chosen to be a power of two, as most NFS servers are optimized for this.  */
-#define NFS_READ_SIZE	1024
-
-#define	FLOPPY_BOOT_LOCATION	0x7c00
-/* Must match offsets in loader.S */
-#define ROM_SEGMENT		0x1fa
-#define ROM_LENGTH		0x1fc
-
-#define	ROM_INFO_LOCATION	(FLOPPY_BOOT_LOCATION + ROM_SEGMENT)
-/* at end of floppy boot block */
-
-struct rom_info
-{
-  unsigned short	rom_segment;
-  unsigned short	rom_length;
-};
-
-static inline int
-rom_address_ok (struct rom_info *rom, int assigned_rom_segment)
-{
-  return (assigned_rom_segment < 0xC000
-	  || assigned_rom_segment == rom->rom_segment);
-}
-
-/* Define a type for passing info to a loaded program.  */
-struct ebinfo
-{
-  unsigned char	major, minor;	/* Version */
-  unsigned short	flags;		/* Bit flags */
-};
-
-/***************************************************************************
-External prototypes
-***************************************************************************/
-/* main.c */
-extern void print_network_configuration (void);
-extern int ifconfig (char *ip, char *sm, char *gw, char *svr);
-extern int udp_transmit (unsigned long destip, unsigned int srcsock,
-			 unsigned int destsock, int len, const void *buf);
-extern int await_reply (int type, int ival, void *ptr, int timeout);
-extern int decode_rfc1533 (unsigned char *, int, int, int);
-extern long rfc2131_sleep_interval (int base, int exp);
-extern void cleanup (void);
-extern int rarp (void);
-extern int bootp (void);
-extern void cleanup_net (void);
-
-/* config.c */
-extern void print_config (void);
-extern void eth_reset (void);
-extern int eth_probe (void);
-extern int eth_poll (void);
-extern void eth_transmit (const char *d, unsigned int t,
-			  unsigned int s, const void *p);
-extern void eth_disable (void);
-
-/* misc.c */
-extern void twiddle (void);
-extern void sleep (int secs);
-extern int getdec (char **s);
-extern void etherboot_printf (const char *, ...);
-extern int etherboot_sprintf (char *, const char *, ...);
-extern int inet_aton (char *p, in_addr *i);
-
-/***************************************************************************
-External variables
-***************************************************************************/
-/* main.c */
-extern int ip_abort;
-extern int network_ready;
-extern struct rom_info rom;
-extern struct arptable_t arptable[MAX_ARP];
-
-/* config.c */
-extern struct nic nic;
-
-/* Local hack - define some macros to use etherboot source files "as is".  */
-#ifndef GRUB
-# undef printf
-# define printf	etherboot_printf
-# undef sprintf
-# define sprintf etherboot_sprintf
-#endif /* GRUB */
Index: netboot/epic100.c
===================================================================
--- netboot/epic100.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/epic100.c	(.../trunk)	(revision 112)
@@ -1,15 +1,17 @@
 /* epic100.c: A SMC 83c170 EPIC/100 fast ethernet driver for Etherboot */
 
+/* 05/06/2003	timlegge	Fixed relocation and implemented Multicast */
 #define LINUX_OUT_MACROS
 
 #include "etherboot.h"
+#include "pci.h"
 #include "nic.h"
-#include "cards.h"
 #include "timer.h"
 #include "epic100.h"
 
-#undef	virt_to_bus
-#define	virt_to_bus(x)	((unsigned long)x)
+/* Condensed operations for readability */
+#define virt_to_le32desc(addr)	cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)	bus_to_virt(le32_to_cpu(addr))
 
 #define TX_RING_SIZE	2	/* use at least 2 buffers for TX */
 #define RX_RING_SIZE	2
@@ -26,23 +28,18 @@
 
 /* The EPIC100 Rx and Tx buffer descriptors. */
 struct epic_rx_desc {
-    unsigned short status;
-    unsigned short rxlength;
-    unsigned long  bufaddr;
-    unsigned short buflength;
-    unsigned short control;
-    unsigned long  next;
+    unsigned long status;
+    unsigned long bufaddr;
+    unsigned long buflength;
+    unsigned long next;
 };
-
 /* description of the tx descriptors control bits commonly used */
 #define TD_STDFLAGS	TD_LASTDESC
 
 struct epic_tx_desc {
-    unsigned short status;
-    unsigned short txlength;
-    unsigned long  bufaddr;
-    unsigned short buflength;
-    unsigned short control;
+    unsigned long status;
+    unsigned long bufaddr;
+    unsigned long buflength;
     unsigned long  next;
 };
 
@@ -51,11 +48,13 @@
 
 static void	epic100_open(void);
 static void	epic100_init_ring(void);
-static void	epic100_disable(struct nic *nic);
+static void	epic100_disable(struct dev *dev);
 static int	epic100_poll(struct nic *nic);
 static void	epic100_transmit(struct nic *nic, const char *destaddr,
 				 unsigned int type, unsigned int len, const char *data);
+#ifdef	DEBUG_EEPROM
 static int	read_eeprom(int location);
+#endif
 static int	mii_read(int phy_id, int location);
 
 static int	ioaddr;
@@ -69,6 +68,7 @@
 static int	mmctl  ;
 static int	mmdata ;
 static int	lan0   ;
+static int	mc0    ;
 static int	rxcon  ;
 static int	txcon  ;
 static int	prcdar ;
@@ -80,37 +80,27 @@
 static unsigned short	eeprom[64];
 #endif
 static signed char	phys[4];		/* MII device addresses. */
-static struct epic_rx_desc	rx_ring[RX_RING_SIZE];
-static struct epic_tx_desc	tx_ring[TX_RING_SIZE];
-#ifdef	USE_LOWMEM_BUFFER
-#define rx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE)
-#define tx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE - PKT_BUF_SZ * TX_RING_SIZE)
-#else
-static char		rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
-static char		tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
-#endif
+static struct epic_rx_desc	rx_ring[RX_RING_SIZE]
+	__attribute__ ((aligned(4)));
+static struct epic_tx_desc	tx_ring[TX_RING_SIZE]
+	__attribute__ ((aligned(4)));
+static unsigned char	 	rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
+static unsigned char		tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
 
 /***********************************************************************/
 /*                    Externally visible functions                     */
 /***********************************************************************/
 
-    static void
-epic100_reset(struct nic *nic)
-{
-    /* Soft reset the chip. */
-    outl(GC_SOFT_RESET, genctl);
-}
 
-    struct nic*
-epic100_probe(struct nic *nic, unsigned short *probeaddrs)
+    static int
+epic100_probe(struct dev *dev, struct pci_device *pci)
 {
-    unsigned short sum = 0;
-    unsigned short value;
+    struct nic *nic = (struct nic *)dev;
     int i;
     unsigned short* ap;
     unsigned int phy, phy_idx;
 
-    if (probeaddrs == 0 || probeaddrs[0] == 0)
+    if (pci->ioaddr == 0)
 	return 0;
 
     /* Ideally we would detect all network cards in slot order.  That would
@@ -118,7 +108,7 @@
        well with the current structure.  So instead we detect just the
        Epic cards in slot order. */
 
-    ioaddr = probeaddrs[0] & ~3; /* Mask the bit that says "this is an io addr" */
+    ioaddr = pci->ioaddr;
 
     /* compute all used static epic100 registers address */
     command = ioaddr + COMMAND;		/* Control Register */
@@ -130,6 +120,7 @@
     mmctl   = ioaddr + MMCTL;		/* MII Management Interface Control */
     mmdata  = ioaddr + MMDATA;		/* MII Management Interface Data */
     lan0    = ioaddr + LAN0;		/* MAC address. (0x40-0x48) */
+    mc0     = ioaddr + MC0; 		/* Multicast Control */
     rxcon   = ioaddr + RXCON;		/* Receive Control */
     txcon   = ioaddr + TXCON;		/* Transmit Control */
     prcdar  = ioaddr + PRCDAR;		/* PCI Receive Current Descr Address */
@@ -160,11 +151,15 @@
     }
 
 #ifdef	DEBUG_EEPROM
+{
+    unsigned short sum = 0;
+    unsigned short value;
     for (i = 0; i < 64; i++) {
 	value = read_eeprom(i);
 	eeprom[i] = value;
 	sum += value;
     }
+}
 
 #if	(EPIC_DEBUG > 1)
     printf("EEPROM contents\n");
@@ -202,15 +197,25 @@
 
     epic100_open();
 
-    nic->reset    = epic100_reset;
+    dev->disable  = epic100_disable;
     nic->poll     = epic100_poll;
     nic->transmit = epic100_transmit;
-    nic->disable  = epic100_disable;
 
-    return nic;
+    return 1;
 }
 
-    static void
+static void set_rx_mode(void)
+{
+	unsigned char mc_filter[8];
+	int i;
+	memset(mc_filter, 0xff, sizeof(mc_filter));
+	outl(0x0C, rxcon);
+	for(i = 0; i < 4; i++)
+		outw(((unsigned short *)mc_filter)[i], mc0 + i*4);
+	return;
+}
+	
+   static void
 epic100_open(void)
 {
     int mii_reg5;
@@ -237,11 +242,11 @@
     outl(tmp, txcon);
 
     /* Give adress of RX and TX ring to the chip */
-    outl(virt_to_bus(&rx_ring), prcdar);
-    outl(virt_to_bus(&tx_ring), ptcdar);
+    outl(virt_to_le32desc(&rx_ring), prcdar);
+    outl(virt_to_le32desc(&tx_ring), ptcdar);
 
     /* Start the chip's Rx process: receive unicast and broadcast */
-    outl(0x04, rxcon);
+    set_rx_mode();
     outl(CR_START_RX | CR_QUEUE_RX, command);
 
     putchar('\n');
@@ -252,34 +257,30 @@
 epic100_init_ring(void)
 {
     int i;
-    char* p;
 
     cur_rx = cur_tx = 0;
 
-    p = &rx_packet[0];
     for (i = 0; i < RX_RING_SIZE; i++) {
-	rx_ring[i].status    = RRING_OWN;	/* Owned by Epic chip */
-	rx_ring[i].buflength = PKT_BUF_SZ;
-	rx_ring[i].bufaddr   = virt_to_bus(p + (PKT_BUF_SZ * i));
-	rx_ring[i].control   = 0;
-	rx_ring[i].next      = virt_to_bus(&(rx_ring[i + 1]) );
+	rx_ring[i].status    = cpu_to_le32(RRING_OWN);	/* Owned by Epic chip */
+	rx_ring[i].buflength = cpu_to_le32(PKT_BUF_SZ);
+	rx_ring[i].bufaddr   = virt_to_bus(&rx_packet[i * PKT_BUF_SZ]);
+	rx_ring[i].next      = virt_to_le32desc(&rx_ring[i + 1]) ;
     }
     /* Mark the last entry as wrapping the ring. */
-    rx_ring[i-1].next = virt_to_bus(&rx_ring[0]);
+    rx_ring[i-1].next = virt_to_le32desc(&rx_ring[0]);
 
     /*
      *The Tx buffer descriptor is filled in as needed,
      * but we do need to clear the ownership bit.
      */
-    p = &tx_packet[0];
 
     for (i = 0; i < TX_RING_SIZE; i++) {
-	tx_ring[i].status  = 0;			/* Owned by CPU */
-	tx_ring[i].bufaddr = virt_to_bus(p + (PKT_BUF_SZ * i));
-	tx_ring[i].control = TD_STDFLAGS;
-	tx_ring[i].next    = virt_to_bus(&(tx_ring[i + 1]) );
+	tx_ring[i].status  = 0x0000;			/* Owned by CPU */
+    	tx_ring[i].buflength = 0x0000 | cpu_to_le32(TD_STDFLAGS << 16);
+	tx_ring[i].bufaddr = virt_to_bus(&tx_packet[i * PKT_BUF_SZ]);
+	tx_ring[i].next    = virt_to_le32desc(&tx_ring[i + 1]);
     }
-    tx_ring[i-1].next = virt_to_bus(&tx_ring[0]);
+	tx_ring[i-1].next    = virt_to_le32desc(&tx_ring[0]);
 }
 
 /* function: epic100_transmit
@@ -296,7 +297,7 @@
 		 unsigned int len, const char *data)
 {
     unsigned short nstype;
-    char* txp;
+    unsigned char *txp;
     int entry;
 
     /* Calculate the next Tx descriptor entry. */
@@ -310,7 +311,7 @@
 	return;
     }
 
-    txp = (char*)tx_ring[entry].bufaddr;
+    txp = tx_packet + (entry * PKT_BUF_SZ);
 
     memcpy(txp, destaddr, ETH_ALEN);
     memcpy(txp + ETH_ALEN, nic->node_addr, ETH_ALEN);
@@ -319,26 +320,29 @@
     memcpy(txp + ETH_HLEN, data, len);
 
     len += ETH_HLEN;
-
+	len &= 0x0FFF;
+	while(len < ETH_ZLEN)
+		txp[len++] = '\0';
     /*
      * Caution: the write order is important here,
      * set the base address with the "ownership"
      * bits last.
      */
-    tx_ring[entry].txlength  = (len >= 60 ? len : 60);
-    tx_ring[entry].buflength = len;
-    tx_ring[entry].status    = TRING_OWN;	/* Pass ownership to the chip. */
+    
+    tx_ring[entry].buflength |= cpu_to_le32(len);
+    tx_ring[entry].status = cpu_to_le32(len << 16) | 
+	    cpu_to_le32(TRING_OWN);	/* Pass ownership to the chip. */
 
     cur_tx++;
 
     /* Trigger an immediate transmit demand. */
-    outl(CR_QUEUE_TX, command);
-
+    outl(CR_QUEUE_TX, command); 
+    
     load_timer2(10*TICKS_PER_MS);         /* timeout 10 ms for transmit */
-    while ((tx_ring[entry].status & TRING_OWN) && timer2_running())
+    while ((le32_to_cpu(tx_ring[entry].status) & (TRING_OWN)) && timer2_running())
 	/* Wait */;
 
-    if ((tx_ring[entry].status & TRING_OWN) != 0)
+    if ((le32_to_cpu(tx_ring[entry].status) & TRING_OWN) != 0)
 	printf("Oops, transmitter timeout, status=%hX\n",
 	    tx_ring[entry].status);
 }
@@ -359,14 +363,14 @@
 epic100_poll(struct nic *nic)
 {
     int entry;
+    int retcode;
     int status;
-    int retcode;
-
     entry = cur_rx % RX_RING_SIZE;
 
-    if ((status = rx_ring[entry].status & RRING_OWN) == RRING_OWN)
+    if ((rx_ring[entry].status & cpu_to_le32(RRING_OWN)) == RRING_OWN)
 	return (0);
 
+    status = le32_to_cpu(rx_ring[entry].status);
     /* We own the next entry, it's a new packet. Send it up. */
 
 #if	(EPIC_DEBUG > 4)
@@ -383,8 +387,8 @@
 	retcode = 0;
     } else {
 	/* Omit the four octet CRC from the length. */
-	nic->packetlen = rx_ring[entry].rxlength - 4;
-	memcpy(nic->packet, (char*)rx_ring[entry].bufaddr, nic->packetlen);
+	nic->packetlen = le32_to_cpu((rx_ring[entry].buflength))- 4;
+	memcpy(nic->packet, &rx_packet[entry * PKT_BUF_SZ], nic->packetlen);
 	retcode = 1;
     }
 
@@ -395,15 +399,17 @@
     rx_ring[entry].status = RRING_OWN;
 
     /* Restart Receiver */
-    outl(CR_START_RX | CR_QUEUE_RX, command);
+    outl(CR_START_RX | CR_QUEUE_RX, command); 
 
     return retcode;
 }
 
 
     static void
-epic100_disable(struct nic *nic)
+epic100_disable(struct dev *dev __unused)
 {
+	/* Soft reset the chip. */
+	outl(GC_SOFT_RESET, genctl);
 }
 
 
@@ -479,3 +485,18 @@
 	    break;
     return inw(mmdata);
 }
+
+
+static struct pci_id epic100_nics[] = {
+PCI_ROM(0x10b8, 0x0005, "epic100",    "SMC EtherPowerII"),		/* SMC 83c170 EPIC/100 */
+PCI_ROM(0x10b8, 0x0006, "smc-83c175", "SMC EPIC/C 83c175"),
+};
+
+struct pci_driver epic100_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "EPIC100",
+	.probe    = epic100_probe,
+	.ids      = epic100_nics,
+	.id_count = sizeof(epic100_nics)/sizeof(epic100_nics[0]),
+	.class    = 0,
+};
Index: netboot/ntulip.txt
===================================================================
--- netboot/ntulip.txt	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/ntulip.txt	(.../trunk)	(revision 112)
@@ -0,0 +1,48 @@
+This software may be used and distributed according to the terms of
+the GNU Public License, incorporated herein by reference.
+
+Of course you have to have all the usual Etherboot environment
+(bootp/dhcp/NFS) set up, and you need a Linux kernel with v0.91g
+(7.16.99) or later of the tulip.c driver compiled in to support some
+MX98715 based cards.  That file is available at:
+
+  http://cesdis.gsfc.nasa.gov/linux/drivers/test/tulip.c
+
+See the comments at the beginning of ntulip.c for more information
+on the code.  
+
+NOTES
+
+I've tested this driver with a SOHOware Fast 10/100 Model SDA110A,
+a Linksys LNE100TX v2.0, and a Netgear FA310TX card, and it worked at
+both 10 and 100 mbits. Other cards based on the tulip family may work as
+well.
+
+These cards are about 20$US, are supported by Linux and now Etherboot,
+and being PCI, they auto-configure IRQ and IOADDR and auto-negotiate
+10/100 half/full duplex. It seems like a pretty good value compared to
+some of the pricier cards, and can lower the cost of building/adapting
+thin client workstations substantially while giving a considerable
+performance increase.
+
+On some PCI tulip clone chipsets (MX987x5, LC82C115, LC82C168) this driver 
+lets the card choose the fastest speed it can negotiate with the peer
+device.  On other cards, it chooses 10mbit half-duplex.
+
+I burned an AM27C256 (32KByte) EPROM with mx987x5.lzrom and it worked.
+According to the data sheet the MX98715A supports up to 64K (27C512)
+EPROMs, 
+
+I've liberally commented the code and header files in the hope that it
+will help the next person who hacks the code or needs to support some
+tulip clone card, or wishes to add functionality.
+
+Anyway, please test this if you can on your tulip based card, and let
+me (mdc@thinguin.org) and the netboot list (netboot@baghira.han.de)
+know how things go.  I also would appreciate code review by people who
+program.  I'm a strong believer in "another set of eyes".
+
+Regards,
+
+Marty Connor
+mdc@thinguin.org
Index: netboot/nic.c
===================================================================
--- netboot/nic.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/nic.c	(.../trunk)	(revision 112)
@@ -0,0 +1,1211 @@
+/**************************************************************************
+Etherboot -  Network Bootstrap Program
+
+Literature dealing with the network protocols:
+	ARP - RFC826
+	RARP - RFC903
+        IP - RFC791
+	UDP - RFC768
+	BOOTP - RFC951, RFC2132 (vendor extensions)
+	DHCP - RFC2131, RFC2132 (options)
+	TFTP - RFC1350, RFC2347 (options), RFC2348 (blocksize), RFC2349 (tsize)
+	RPC - RFC1831, RFC1832 (XDR), RFC1833 (rpcbind/portmapper)
+	NFS - RFC1094, RFC1813 (v3, useful for clarifications, not implemented)
+	IGMP - RFC1112, RFC2113, RFC2365, RFC2236, RFC3171
+
+**************************************************************************/
+
+#include "grub.h"
+#include "nic.h"
+#include "elf.h" /* FOR EM_CURRENT */
+#include "bootp.h"
+#include "if_arp.h"
+#include "tftp.h"
+#include "timer.h"
+#include "ip.h"
+#include "udp.h"
+#include "pxe_tftp.h"
+
+/* Currently no other module uses rom, but it is available */
+struct rom_info		rom;
+struct arptable_t	arptable[MAX_ARP];
+#ifdef MULTICAST_LEVEL2
+unsigned long last_igmpv1 = 0;
+struct igmptable_t	igmptable[MAX_IGMP];
+#endif
+static unsigned long	netmask;
+/* Used by nfs.c */
+char *hostname = "";
+int hostnamelen = 0;
+static uint32_t xid;
+static unsigned char *end_of_rfc1533 = NULL;
+static const unsigned char broadcast[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+static const in_addr zeroIP = { 0L };
+static char rfc1533_venddata[MAX_RFC1533_VENDLEN];
+static unsigned char rfc1533_cookie[4] = { RFC1533_COOKIE };
+static unsigned char rfc1533_cookie_bootp[5] = { RFC1533_COOKIE, RFC1533_END };
+static unsigned char rfc1533_cookie_dhcp[] = { RFC1533_COOKIE };
+static int dhcp_reply;
+static in_addr dhcp_server = { 0L };
+static in_addr dhcp_addr = { 0L };
+
+static const unsigned char dhcpdiscover[] = {
+	RFC2132_MSG_TYPE, 1, DHCPDISCOVER,
+	RFC2132_MAX_SIZE, 2,	/* request as much as we can */
+	ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
+	RFC2132_PARAM_LIST, 4, RFC1533_NETMASK, RFC1533_GATEWAY,
+	RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH, RFC1533_END
+};
+static const unsigned char dhcprequest [] = {
+	RFC2132_MSG_TYPE,1,DHCPREQUEST,
+	RFC2132_SRV_ID,4,0,0,0,0,
+	RFC2132_REQ_ADDR,4,0,0,0,0,
+	RFC2132_MAX_SIZE,2,	/* request as much as we can */
+	ETH_MAX_MTU / 256, ETH_MAX_MTU % 256,
+	RFC2132_PARAM_LIST,
+	/* 5 standard + 6 vendortags + 8 motd + 16 menu items */
+	4 + 2,
+	/* Standard parameters */
+	RFC1533_NETMASK, RFC1533_GATEWAY,
+	RFC1533_HOSTNAME, RFC1533_EXTENSIONPATH,
+	/* Etherboot vendortags */
+	RFC1533_VENDOR_MAGIC,
+	RFC1533_VENDOR_CONFIGFILE,
+	RFC1533_END
+};
+
+/* See nic.h */
+int user_abort = 0;
+int network_ready = 0;
+
+#ifdef	REQUIRE_VCI_ETHERBOOT
+int	vci_etherboot;
+#endif
+
+static int dummy(void *unused __unused)
+{
+	return (0);
+}
+
+/* Careful.  We need an aligned buffer to avoid problems on machines
+ * that care about alignment.  To trivally align the ethernet data
+ * (the ip hdr and arp requests) we offset the packet by 2 bytes.
+ * leaving the ethernet data 16 byte aligned.  Beyond this
+ * we use memmove but this makes the common cast simple and fast.
+ */
+static char	packet[ETH_FRAME_LEN + ETH_DATA_ALIGN] __aligned;
+
+struct nic	nic =
+{
+	{
+		0,				/* dev.disable */
+		{
+			0,
+			0,
+			PCI_BUS_TYPE,
+		},				/* dev.devid */
+		0,				/* index */
+		0,				/* type */
+		PROBE_FIRST,			/* how_pobe */
+		PROBE_NONE,			/* to_probe */
+		0,				/* failsafe */
+		0,				/* type_index */
+		{},				/* state */
+	},
+	(int (*)(struct nic *))dummy,		/* poll */
+	(void (*)(struct nic *, const char *,
+		unsigned int, unsigned int,
+		const char *))dummy,		/* transmit */
+	0,					/* flags */
+	&rom,					/* rom_info */
+	arptable[ARP_CLIENT].node,		/* node_addr */
+	packet + ETH_DATA_ALIGN,		/* packet */
+	0,					/* packetlen */
+	0,					/* priv_data */
+};
+
+int eth_probe(void)
+{
+	static int probed = 0;
+	struct dev *dev;
+
+	EnterFunction("eth_probe");
+
+	if (probed)
+		return 1;
+
+	network_ready = 0;
+	grub_memset((char *)arptable, 0, MAX_ARP * sizeof(struct arptable_t));
+	dev = &nic.dev;
+	dev->how_probe = -1;
+	dev->type = NIC_DRIVER;
+	dev->failsafe = 1;
+	rom = *((struct rom_info *)ROM_INFO_LOCATION);
+
+	probed = (probe(dev) == PROBE_WORKED);
+
+	LeaveFunction("eth_probe");
+	return probed;
+}
+
+int eth_poll(void)
+{
+	return ((*nic.poll)(&nic));
+}
+
+void eth_transmit(const char *d, unsigned int t, unsigned int s, const void *p)
+{
+	(*nic.transmit)(&nic, d, t, s, p);
+	if (t == IP) twiddle();
+}
+
+void eth_disable(void)
+{
+#ifdef MULTICAST_LEVEL2
+	int i;
+	for(i = 0; i < MAX_IGMP; i++) {
+		leave_group(i);
+	}
+#endif
+	disable(&nic.dev);
+}
+
+void store_ip_in_var(in_addr client_ip)
+{
+	char s[16];
+	etherboot_sprintf(s, "%@", client_ip.s_addr);
+	var_set("CLIENT_IP", s, 0, 1);
+}
+
+/**************************************************************************
+IPCHKSUM - Checksum IP Header
+**************************************************************************/
+uint16_t ipchksum(const void *data, unsigned long length)
+{
+	unsigned long sum;
+	unsigned long i;
+	const uint8_t *ptr;
+
+	/* In the most straight forward way possible,
+	 * compute an ip style checksum.
+	 */
+	sum = 0;
+	ptr = data;
+	for(i = 0; i < length; i++) {
+		unsigned long value;
+		value = ptr[i];
+		if (i & 1) {
+			value <<= 8;
+		}
+		/* Add the new value */
+		sum += value;
+		/* Wrap around the carry */
+		if (sum > 0xFFFF) {
+			sum = (sum + (sum >> 16)) & 0xFFFF;
+		}
+	}
+	return (~cpu_to_le16(sum)) & 0xFFFF;
+}
+
+uint16_t add_ipchksums(unsigned long offset, uint16_t sum, uint16_t new)
+{
+	unsigned long checksum;
+	sum = ~sum & 0xFFFF;
+	new = ~new & 0xFFFF;
+	if (offset & 1) {
+		/* byte swap the sum if it came from an odd offset 
+		 * since the computation is endian independant this
+		 * works.
+		 */
+		new = bswap_16(new);
+	}
+	checksum = sum + new;
+	if (checksum > 0xFFFF) {
+		checksum -= 0xFFFF;
+	}
+	return (~checksum) & 0xFFFF;
+}
+
+/**************************************************************************
+DEFAULT_NETMASK - Return default netmask for IP address
+**************************************************************************/
+static inline unsigned long default_netmask(void)
+{
+	int net = ntohl(arptable[ARP_CLIENT].ipaddr.s_addr) >> 24;
+	if (net <= 127)
+		return(htonl(0xff000000));
+	else if (net < 192)
+		return(htonl(0xffff0000));
+	else
+		return(htonl(0xffffff00));
+}
+
+/**************************************************************************
+IP_TRANSMIT - Send an IP datagram
+**************************************************************************/
+static int await_arp(int ival, void *ptr,
+	unsigned short ptype, struct iphdr *ip __unused, struct udphdr *udp __unused)
+{
+	struct	arprequest *arpreply;
+	if (ptype != ARP)
+		return 0;
+	if (nic.packetlen < ETH_HLEN + sizeof(struct arprequest))
+		return 0;
+	arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+
+	if (arpreply->opcode != htons(ARP_REPLY)) 
+		return 0;
+	if (memcmp(arpreply->sipaddr, ptr, sizeof(in_addr)) != 0)
+		return 0;
+	memcpy(arptable[ival].node, arpreply->shwaddr, ETH_ALEN);
+	return 1;
+}
+
+int ip_transmit(int len, const void *buf)
+{
+	unsigned long destip;
+	struct iphdr *ip;
+	struct arprequest arpreq;
+	int arpentry, i;
+	int retry;
+
+	ip = (struct iphdr *)buf;
+	destip = ip->dest.s_addr;
+	if (destip == IP_BROADCAST) {
+		eth_transmit(broadcast, IP, len, buf);
+#ifdef MULTICAST_LEVEL1 
+	} else if ((destip & htonl(MULTICAST_MASK)) == htonl(MULTICAST_NETWORK)) {
+		unsigned char multicast[6];
+		unsigned long hdestip;
+		hdestip = ntohl(destip);
+		multicast[0] = 0x01;
+		multicast[1] = 0x00;
+		multicast[2] = 0x5e;
+		multicast[3] = (hdestip >> 16) & 0x7;
+		multicast[4] = (hdestip >> 8) & 0xff;
+		multicast[5] = hdestip & 0xff;
+		eth_transmit(multicast, IP, len, buf);
+#endif
+	} else {
+		if (((destip & netmask) !=
+		     (arptable[ARP_CLIENT].ipaddr.s_addr & netmask)) &&
+		    arptable[ARP_GATEWAY].ipaddr.s_addr)
+			destip = arptable[ARP_GATEWAY].ipaddr.s_addr;
+		for(arpentry = 0; arpentry<MAX_ARP; arpentry++)
+			if (arptable[arpentry].ipaddr.s_addr == destip) break;
+		if (arpentry == MAX_ARP) {
+			printf("%@ is not in my arp table!\n", destip);
+			return(0);
+		}
+		for (i = 0; i < ETH_ALEN; i++)
+			if (arptable[arpentry].node[i])
+				break;
+		if (i == ETH_ALEN) {	/* Need to do arp request */
+			arpreq.hwtype = htons(1);
+			arpreq.protocol = htons(IP);
+			arpreq.hwlen = ETH_ALEN;
+			arpreq.protolen = 4;
+			arpreq.opcode = htons(ARP_REQUEST);
+			memcpy(arpreq.shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+			memcpy(arpreq.sipaddr, &arptable[ARP_CLIENT].ipaddr, sizeof(in_addr));
+			memset(arpreq.thwaddr, 0, ETH_ALEN);
+			memcpy(arpreq.tipaddr, &destip, sizeof(in_addr));
+			for (retry = 1; retry <= MAX_ARP_RETRIES; retry++) {
+				long timeout;
+				eth_transmit(broadcast, ARP, sizeof(arpreq),
+					&arpreq);
+				timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+				if (await_reply(await_arp, arpentry,
+					arpreq.tipaddr, timeout)) goto xmit;
+			}
+			return(0);
+		}
+xmit:
+		eth_transmit(arptable[arpentry].node, IP, len, buf);
+	}
+	return 1;
+}
+
+void build_ip_hdr(unsigned long destip, int ttl, int protocol, int option_len,
+	int len, const void *buf)
+{
+	struct iphdr *ip;
+	ip = (struct iphdr *)buf;
+	ip->verhdrlen = 0x45;
+	ip->verhdrlen += (option_len/4);
+	ip->service = 0;
+	ip->len = htons(len);
+	ip->ident = 0;
+	ip->frags = 0; /* Should we set don't fragment? */
+	ip->ttl = ttl;
+	ip->protocol = protocol;
+	ip->chksum = 0;
+	ip->src.s_addr = arptable[ARP_CLIENT].ipaddr.s_addr;
+	ip->dest.s_addr = destip;
+	ip->chksum = ipchksum(buf, sizeof(struct iphdr) + option_len);
+}
+
+static uint16_t udpchksum(struct iphdr *ip, struct udphdr *udp)
+{
+	struct udp_pseudo_hdr pseudo;
+	uint16_t checksum;
+
+	/* Compute the pseudo header */
+	pseudo.src.s_addr  = ip->src.s_addr;
+	pseudo.dest.s_addr = ip->dest.s_addr;
+	pseudo.unused      = 0;
+	pseudo.protocol    = IP_UDP;
+	pseudo.len         = udp->len;
+
+	/* Sum the pseudo header */
+	checksum = ipchksum(&pseudo, 12);
+
+	/* Sum the rest of the udp packet */
+	checksum = add_ipchksums(12, checksum, ipchksum(udp, ntohs(udp->len)));
+	return checksum;
+}
+
+
+void build_udp_hdr(unsigned long destip, 
+	unsigned int srcsock, unsigned int destsock, int ttl,
+	int len, const void *buf)
+{
+	struct iphdr *ip;
+	struct udphdr *udp;
+	ip = (struct iphdr *)buf;
+	build_ip_hdr(destip, ttl, IP_UDP, 0, len, buf);
+	udp = (struct udphdr *)((char *)buf + sizeof(struct iphdr));
+	udp->src = htons(srcsock);
+	udp->dest = htons(destsock);
+	udp->len = htons(len - sizeof(struct iphdr));
+	udp->chksum = 0;
+	if ((udp->chksum = udpchksum(ip, udp)) == 0)
+		udp->chksum = 0xffff;
+}
+
+
+/**************************************************************************
+UDP_TRANSMIT - Send an UDP datagram
+**************************************************************************/
+int udp_transmit(unsigned long destip, unsigned int srcsock,
+	unsigned int destsock, int len, const void *buf)
+{
+	build_udp_hdr(destip, srcsock, destsock, 60, len, buf);
+	return ip_transmit(len, buf);
+}
+
+/**************************************************************************
+QDRAIN - clear the nic's receive queue
+**************************************************************************/
+static int await_qdrain(int ival __unused, void *ptr __unused,
+	unsigned short ptype __unused, 
+	struct iphdr *ip __unused, struct udphdr *udp __unused)
+{
+	return 0;
+}
+
+void rx_qdrain(void)
+{
+	/* Clear out the Rx queue first.  It contains nothing of interest,
+	 * except possibly ARP requests from the DHCP/TFTP server.  We use
+	 * polling throughout Etherboot, so some time may have passed since we
+	 * last polled the receive queue, which may now be filled with
+	 * broadcast packets.  This will cause the reply to the packets we are
+	 * about to send to be lost immediately.  Not very clever.  */
+	await_reply(await_qdrain, 0, NULL, 0);
+}
+
+/**
+ * rarp
+ *
+ * Get IP address by rarp. Just copy from etherboot
+ **/
+static int await_rarp(int ival, void *ptr, unsigned short ptype, 
+		      struct iphdr *ip, struct udphdr *udp)
+{
+	struct arprequest *arpreply;
+	if (ptype != RARP)
+		return 0;
+	if (nic.packetlen < ETH_HLEN + sizeof(struct arprequest))
+		return 0;
+	arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+	if (arpreply->opcode != htons(RARP_REPLY))
+		return 0;
+	if (memcmp(arpreply->thwaddr, ptr, ETH_ALEN) == 0){
+		memcpy(arptable[ARP_SERVER].node, arpreply->shwaddr, ETH_ALEN);
+		memcpy(&arptable[ARP_SERVER].ipaddr, arpreply->sipaddr, sizeof(in_addr));
+		memcpy(&arptable[ARP_CLIENT].ipaddr, arpreply->tipaddr, sizeof(in_addr));
+		return 1;
+	}
+	return 0;
+}
+
+int rarp(void)
+{
+	int retry;
+
+	/* arp and rarp requests share the same packet structure. */
+	struct arprequest rarpreq;
+
+	if(!eth_probe())
+		return 0;
+	network_ready = 0;
+
+#ifdef INCLUDE_PXE_TFTP
+	if (pxe_tftp_driver_active())
+	  {
+	    printf("%s called in PXE TFTP mode\n", __func__);
+	    return 0;
+	  }
+#endif
+
+	memset(&rarpreq, 0, sizeof(rarpreq));
+
+	rarpreq.hwtype = htons(1);
+	rarpreq.protocol = htons(IP);
+	rarpreq.hwlen = ETH_ALEN;
+	rarpreq.protolen = 4;
+	rarpreq.opcode = htons(RARP_REQUEST);
+	memcpy(&rarpreq.shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	/* sipaddr is already zeroed out */
+	memcpy(&rarpreq.thwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	/* tipaddr is already zeroed out */
+
+	for (retry = 0; retry < MAX_ARP_RETRIES; ++retry) {
+		long timeout;
+		eth_transmit(broadcast, RARP, sizeof(rarpreq), &rarpreq);
+
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+		if (await_reply(await_rarp, 0, rarpreq.shwaddr, timeout))
+			break;
+		if (user_abort)
+			return 0;
+	}
+
+	if (retry < MAX_ARP_RETRIES) {
+		network_ready = 1;
+		return (1);
+	}
+	return (0);
+}
+
+/**
+ * bootp
+ *
+ * Get IP address by bootp, segregate from bootp in etherboot.
+ **/
+static int await_bootp(int ival __unused, void *ptr __unused,
+	unsigned short ptype __unused, struct iphdr *ip __unused, 
+	struct udphdr *udp)
+{
+	struct	bootp_t *bootpreply;
+	int len;		/* Length of vendor */
+
+	if (!udp) {
+		return 0;
+	}
+	bootpreply = (struct bootp_t *)
+		&nic.packet[ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr)];
+	len = nic.packetlen - (ETH_HLEN + sizeof(struct iphdr) + 
+		sizeof(struct udphdr) + sizeof(struct bootp_t) - BOOTP_VENDOR_LEN);
+	if (len < 0) {
+		return 0;
+	}
+	if (udp->dest != htons(BOOTP_CLIENT))
+		return 0;
+	if (bootpreply->bp_op != BOOTP_REPLY)
+		return 0;
+	if (bootpreply->bp_xid != xid)
+		return 0;
+	if (memcmp((char *)&bootpreply->bp_siaddr, (char *)&zeroIP, sizeof(in_addr)) == 0)
+		return 0;
+	if ((memcmp(broadcast, bootpreply->bp_hwaddr, ETH_ALEN) != 0) &&
+	    (memcmp(arptable[ARP_CLIENT].node, bootpreply->bp_hwaddr, ETH_ALEN) != 0)) {
+		return 0;
+	}
+	arptable[ARP_CLIENT].ipaddr.s_addr = bootpreply->bp_yiaddr.s_addr;
+	store_ip_in_var(arptable[ARP_CLIENT].ipaddr);
+	netmask = default_netmask();
+	arptable[ARP_SERVER].ipaddr.s_addr = bootpreply->bp_siaddr.s_addr;
+	memset(arptable[ARP_SERVER].node, 0, ETH_ALEN);  /* Kill arp */
+	arptable[ARP_GATEWAY].ipaddr.s_addr = bootpreply->bp_giaddr.s_addr;
+	memset(arptable[ARP_GATEWAY].node, 0, ETH_ALEN);  /* Kill arp */
+	/* We don't care bootpreply->bp_file, it must be 'pxegrub':-) */
+	memcpy((char *)rfc1533_venddata, (char *)(bootpreply->bp_vend), len);
+	decode_rfc1533(rfc1533_venddata, 0, len, 1);
+	return(1);
+}
+
+int bootp(void)
+{
+	int retry;
+	struct bootpip_t ip;
+	unsigned long  starttime;
+	
+	EnterFunction("bootp");
+
+	if(!eth_probe())
+		return 0;
+	network_ready = 0;
+
+	if (pxe_tftp_driver_active())
+	  {
+	    printf("%s called in PXE TFTP mode\n", __func__);
+	    return 0;
+	  }
+
+	memset(&ip, 0, sizeof(struct bootpip_t));
+	ip.bp.bp_op = BOOTP_REQUEST;
+	ip.bp.bp_htype = 1;
+	ip.bp.bp_hlen = ETH_ALEN;
+	starttime = currticks();
+	/* Use lower 32 bits of node address, more likely to be
+	   distinct than the time since booting */
+	memcpy(&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
+	ip.bp.bp_xid = xid += htonl(starttime);
+	/* bp_secs defaults to zero */
+	memcpy(ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	memcpy(ip.bp.bp_vend, rfc1533_cookie_bootp, sizeof(rfc1533_cookie_bootp)); /* request RFC-style options */
+
+	for (retry = 0; retry < MAX_BOOTP_RETRIES; ) {
+		long timeout;
+
+		rx_qdrain();
+
+		udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+			sizeof(struct bootpip_t), &ip);
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry++);
+		if (await_reply(await_bootp, 0, NULL, timeout)){
+			network_ready = 1;
+			return(1);
+		}
+		if (user_abort)
+			return 0;
+		ip.bp.bp_secs = htons((currticks()-starttime)/TICKS_PER_SEC);
+	}
+	return(0);
+}
+
+/**
+ * dhcp
+ *
+ * Get IP address by dhcp, segregate from bootp in etherboot.
+ **/
+static int await_dhcp(int ival __unused, void *ptr __unused,
+	unsigned short ptype __unused, struct iphdr *ip __unused, 
+	struct udphdr *udp)
+{
+	struct	dhcp_t *dhcpreply;
+	int len;
+
+	if (!udp) {
+		return 0;
+	}
+	dhcpreply = (struct dhcp_t *)
+		&nic.packet[ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr)];
+	len = nic.packetlen - (ETH_HLEN + sizeof(struct iphdr) + 
+		sizeof(struct udphdr) + sizeof(struct dhcp_t) - DHCP_OPT_LEN);
+	if (len < 0){
+		return 0;
+	}
+	if (udp->dest != htons(BOOTP_CLIENT))
+		return 0;
+	if (dhcpreply->bp_op != BOOTP_REPLY)
+		return 0;
+	if (dhcpreply->bp_xid != xid)
+		return 0;
+	if (memcmp((char *)&dhcpreply->bp_siaddr, (char *)&zeroIP, sizeof(in_addr)) == 0)
+		return 0;
+	if ((memcmp(broadcast, dhcpreply->bp_hwaddr, ETH_ALEN) != 0) &&
+	    (memcmp(arptable[ARP_CLIENT].node, dhcpreply->bp_hwaddr, ETH_ALEN) != 0)) {
+		return 0;
+	}
+	arptable[ARP_CLIENT].ipaddr.s_addr = dhcpreply->bp_yiaddr.s_addr;
+	dhcp_addr.s_addr = dhcpreply->bp_yiaddr.s_addr;
+	store_ip_in_var(dhcp_addr);
+	netmask = default_netmask();
+	arptable[ARP_SERVER].ipaddr.s_addr = dhcpreply->bp_siaddr.s_addr;
+	memset(arptable[ARP_SERVER].node, 0, ETH_ALEN);  /* Kill arp */
+	arptable[ARP_GATEWAY].ipaddr.s_addr = dhcpreply->bp_giaddr.s_addr;
+	memset(arptable[ARP_GATEWAY].node, 0, ETH_ALEN);  /* Kill arp */
+	/* We don't care bootpreply->bp_file. It must be 'pxegrub' */
+	memcpy((char *)rfc1533_venddata, (char *)(dhcpreply->bp_vend), len);
+	decode_rfc1533(rfc1533_venddata, 0, len, 1);
+	return(1);
+}
+
+int dhcp(void)
+{
+	int retry;
+	int reqretry;
+	struct dhcpip_t ip;
+	unsigned long  starttime;
+
+	if(!eth_probe())
+		return 0;
+
+	network_ready = 0;
+
+	if (pxe_tftp_driver_active())
+	  {
+	    printf("%s called in PXE TFTP mode\n", __func__);
+	    network_ready = 1;
+	    return 1;
+	  }
+
+	memset(&ip, 0, sizeof(struct dhcpip_t));
+	ip.bp.bp_op = BOOTP_REQUEST;
+	ip.bp.bp_htype = 1;
+	ip.bp.bp_hlen = ETH_ALEN;
+	starttime = currticks();
+	/* Use lower 32 bits of node address, more likely to be
+	   distinct than the time since booting */
+	memcpy(&xid, &arptable[ARP_CLIENT].node[2], sizeof(xid));
+	ip.bp.bp_xid = xid += htonl(starttime);
+	memcpy(ip.bp.bp_hwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+	memcpy(ip.bp.bp_vend, rfc1533_cookie_dhcp, sizeof rfc1533_cookie_dhcp); /* request RFC-style options */
+	memcpy(ip.bp.bp_vend + sizeof rfc1533_cookie_dhcp, dhcpdiscover, sizeof dhcpdiscover);
+
+	for (retry = 0; retry < MAX_BOOTP_RETRIES; ) {
+		long timeout;
+
+		rx_qdrain();
+
+		udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+			     sizeof(struct bootpip_t), &ip);
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry++);
+		if (await_reply(await_dhcp, 0, NULL, timeout)) {
+			/* If not a DHCPOFFER then must be just a
+			   BOOTP reply, be backward compatible with
+			   BOOTP then. Jscott report a bug here, but I
+			   don't know how it happened */
+			if (dhcp_reply != DHCPOFFER){
+				network_ready = 1;
+				return(1);
+			}
+			dhcp_reply = 0;
+			memcpy(ip.bp.bp_vend, rfc1533_cookie_dhcp, sizeof rfc1533_cookie_dhcp);
+			memcpy(ip.bp.bp_vend + sizeof rfc1533_cookie_dhcp, dhcprequest, sizeof dhcprequest);
+			/* Beware: the magic numbers 9 and 15 depend on
+			   the layout of dhcprequest */
+			memcpy(&ip.bp.bp_vend[9], &dhcp_server, sizeof(in_addr));
+			memcpy(&ip.bp.bp_vend[15], &dhcp_addr, sizeof(in_addr));
+			for (reqretry = 0; reqretry < MAX_BOOTP_RETRIES; ) {
+				udp_transmit(IP_BROADCAST, BOOTP_CLIENT, BOOTP_SERVER,
+					     sizeof(struct bootpip_t), &ip);
+				dhcp_reply=0;
+				timeout = rfc2131_sleep_interval(TIMEOUT, reqretry++);
+				if (await_reply(await_dhcp, 0, NULL, timeout))
+					if (dhcp_reply == DHCPACK){
+						network_ready = 1;
+						return(1);
+					}
+				if (user_abort)
+					return 0;
+			}
+		}
+		if (user_abort)
+			return 0;
+		ip.bp.bp_secs = htons((currticks()-starttime)/TICKS_PER_SEC);
+	}
+	return(0);
+}
+
+#ifdef MULTICAST_LEVEL2
+static void send_igmp_reports(unsigned long now)
+{
+	int i;
+	for(i = 0; i < MAX_IGMP; i++) {
+		if (igmptable[i].time && (now >= igmptable[i].time)) {
+			struct igmp_ip_t igmp;
+			igmp.router_alert[0] = 0x94;
+			igmp.router_alert[1] = 0x04;
+			igmp.router_alert[2] = 0;
+			igmp.router_alert[3] = 0;
+			build_ip_hdr(igmptable[i].group.s_addr, 
+				1, IP_IGMP, sizeof(igmp.router_alert), sizeof(igmp), &igmp);
+			igmp.igmp.type = IGMPv2_REPORT;
+			if (last_igmpv1 && 
+				(now < last_igmpv1 + IGMPv1_ROUTER_PRESENT_TIMEOUT)) {
+				igmp.igmp.type = IGMPv1_REPORT;
+			}
+			igmp.igmp.response_time = 0;
+			igmp.igmp.chksum = 0;
+			igmp.igmp.group.s_addr = igmptable[i].group.s_addr;
+			igmp.igmp.chksum = ipchksum(&igmp.igmp, sizeof(igmp.igmp));
+			ip_transmit(sizeof(igmp), &igmp);
+#ifdef	MDEBUG
+			printf("Sent IGMP report to: %@\n", igmp.igmp.group.s_addr);
+#endif
+			/* Don't send another igmp report until asked */
+			igmptable[i].time = 0;
+		}
+	}
+}
+
+static void process_igmp(struct iphdr *ip, unsigned long now)
+{
+	struct igmp *igmp;
+	int i;
+	unsigned iplen = 0;
+	if (!ip || (ip->protocol == IP_IGMP) ||
+		(nic.packetlen < sizeof(struct iphdr) + sizeof(struct igmp))) {
+		return;
+	}
+	iplen = (ip->verhdrlen & 0xf)*4;
+	igmp = (struct igmp *)&nic.packet[sizeof(struct iphdr)];
+	if (ipchksum(igmp, ntohs(ip->len) - iplen) != 0)
+		return;
+	if ((igmp->type == IGMP_QUERY) && 
+		(ip->dest.s_addr == htonl(GROUP_ALL_HOSTS))) {
+		unsigned long interval = IGMP_INTERVAL;
+		if (igmp->response_time == 0) {
+			last_igmpv1 = now;
+		} else {
+			interval = (igmp->response_time * TICKS_PER_SEC)/10;
+		}
+		
+#ifdef	MDEBUG
+		printf("Received IGMP query for: %@\n", igmp->group.s_addr);
+#endif			       
+		for(i = 0; i < MAX_IGMP; i++) {
+			uint32_t group = igmptable[i].group.s_addr;
+			if ((group == 0) || (group == igmp->group.s_addr)) {
+				unsigned long time;
+				time = currticks() + rfc1112_sleep_interval(interval, 0);
+				if (time < igmptable[i].time) {
+					igmptable[i].time = time;
+				}
+			}
+		}
+	}
+	if (((igmp->type == IGMPv1_REPORT) || (igmp->type == IGMPv2_REPORT)) &&
+		(ip->dest.s_addr == igmp->group.s_addr)) {
+#ifdef	MDEBUG
+		printf("Received IGMP report for: %@\n", igmp->group.s_addr);
+#endif			       
+		for(i = 0; i < MAX_IGMP; i++) {
+			if ((igmptable[i].group.s_addr == igmp->group.s_addr) &&
+				igmptable[i].time != 0) {
+				igmptable[i].time = 0;
+			}
+		}
+	}
+}
+
+void leave_group(int slot)
+{
+	/* Be very stupid and always send a leave group message if 
+	 * I have subscribed.  Imperfect but it is standards
+	 * compliant, easy and reliable to implement.
+	 *
+	 * The optimal group leave method is to only send leave when,
+	 * we were the last host to respond to a query on this group,
+	 * and igmpv1 compatibility is not enabled.
+	 */
+	if (igmptable[slot].group.s_addr) {
+		struct igmp_ip_t igmp;
+		igmp.router_alert[0] = 0x94;
+		igmp.router_alert[1] = 0x04;
+		igmp.router_alert[2] = 0;
+		igmp.router_alert[3] = 0;
+		build_ip_hdr(htonl(GROUP_ALL_HOSTS),
+			1, IP_IGMP, sizeof(igmp.router_alert), sizeof(igmp), &igmp);
+		igmp.igmp.type = IGMP_LEAVE;
+		igmp.igmp.response_time = 0;
+		igmp.igmp.chksum = 0;
+		igmp.igmp.group.s_addr = igmptable[slot].group.s_addr;
+		igmp.igmp.chksum = ipchksum(&igmp.igmp, sizeof(igmp));
+		ip_transmit(sizeof(igmp), &igmp);
+#ifdef	MDEBUG
+		printf("Sent IGMP leave for: %@\n", igmp.igmp.group.s_addr);
+#endif	
+	}
+	memset(&igmptable[slot], 0, sizeof(igmptable[0]));
+}
+
+void join_group(int slot, unsigned long group)
+{
+	/* I have already joined */
+	if (igmptable[slot].group.s_addr == group)
+		return;
+	if (igmptable[slot].group.s_addr) {
+		leave_group(slot);
+	}
+	/* Only join a group if we are given a multicast ip, this way
+	 * code can be given a non-multicast (broadcast or unicast ip)
+	 * and still work... 
+	 */
+	if ((group & htonl(MULTICAST_MASK)) == htonl(MULTICAST_NETWORK)) {
+		igmptable[slot].group.s_addr = group;
+		igmptable[slot].time = currticks();
+	}
+}
+#else
+#define send_igmp_reports(now);
+#define process_igmp(ip, now)
+#endif
+
+/**************************************************************************
+AWAIT_REPLY - Wait until we get a response for our request
+************f**************************************************************/
+int await_reply(reply_t reply, int ival, void *ptr, long timeout)
+{
+	unsigned long time, now;
+	struct	iphdr *ip;
+	unsigned iplen = 0;
+	struct	udphdr *udp;
+	unsigned short ptype;
+	int result;
+
+	user_abort = 0;
+
+	time = timeout + currticks();
+	/* The timeout check is done below.  The timeout is only checked if
+	 * there is no packet in the Rx queue.  This assumes that eth_poll()
+	 * needs a negligible amount of time.  
+	 */
+	for (;;) {
+		now = currticks();
+		send_igmp_reports(now);
+		result = eth_poll();
+		if (result == 0) {
+			/* We don't have anything */
+		
+			/* Check for abort key only if the Rx queue is empty -
+			 * as long as we have something to process, don't
+			 * assume that something failed.  It is unlikely that
+			 * we have no processing time left between packets.  */
+			poll_interruptions();
+			/* Do the timeout after at least a full queue walk.  */
+			if ((timeout == 0) || (currticks() > time) || user_abort == 1) {
+				break;
+			}
+			continue;
+		}
+	
+		/* We have something! */
+
+		/* Find the Ethernet packet type */
+		if (nic.packetlen >= ETH_HLEN) {
+			ptype = ((unsigned short) nic.packet[12]) << 8
+				| ((unsigned short) nic.packet[13]);
+		} else continue; /* what else could we do with it? */
+		/* Verify an IP header */
+		ip = 0;
+		if ((ptype == IP) && (nic.packetlen >= ETH_HLEN + sizeof(struct iphdr))) {
+			unsigned ipoptlen;
+			ip = (struct iphdr *)&nic.packet[ETH_HLEN];
+			if ((ip->verhdrlen < 0x45) || (ip->verhdrlen > 0x4F)) 
+				continue;
+			iplen = (ip->verhdrlen & 0xf) * 4;
+			if (ipchksum(ip, iplen) != 0)
+				continue;
+			if (ip->frags & htons(0x3FFF)) {
+				static int warned_fragmentation = 0;
+				if (!warned_fragmentation) {
+					printf("ALERT: got a fragmented packet - reconfigure your server\n");
+					warned_fragmentation = 1;
+				}
+				continue;
+			}
+			if (ntohs(ip->len) > ETH_MAX_MTU)
+				continue;
+
+			ipoptlen = iplen - sizeof(struct iphdr);
+			if (ipoptlen) {
+				/* Delete the ip options, to guarantee
+				 * good alignment, and make etherboot simpler.
+				 */
+				memmove(&nic.packet[ETH_HLEN + sizeof(struct iphdr)], 
+					&nic.packet[ETH_HLEN + iplen],
+					nic.packetlen - ipoptlen);
+				nic.packetlen -= ipoptlen;
+			}
+		}
+		udp = 0;
+		if (ip && (ip->protocol == IP_UDP) && 
+		    (nic.packetlen >= ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr))) {
+			udp = (struct udphdr *)&nic.packet[ETH_HLEN + sizeof(struct iphdr)];
+			
+			/* Make certain we have a reasonable packet length */
+			if (ntohs(udp->len) > (ntohs(ip->len) - iplen))
+				continue;
+
+			if (udp->chksum && udpchksum(ip, udp)) {
+				printf("UDP checksum error\n");
+				continue;
+			}
+		}
+		result = reply(ival, ptr, ptype, ip, udp);
+		if (result > 0) {
+			return result;
+		}
+		
+		/* If it isn't a packet the upper layer wants see if there is a default
+		 * action.  This allows us reply to arp and igmp queryies.
+		 */
+		if ((ptype == ARP) &&
+		    (nic.packetlen >= ETH_HLEN + sizeof(struct arprequest))) {
+			struct	arprequest *arpreply;
+			unsigned long tmp;
+			
+			arpreply = (struct arprequest *)&nic.packet[ETH_HLEN];
+			memcpy(&tmp, arpreply->tipaddr, sizeof(in_addr));
+			if ((arpreply->opcode == htons(ARP_REQUEST)) &&
+			    (tmp == arptable[ARP_CLIENT].ipaddr.s_addr)) {
+				arpreply->opcode = htons(ARP_REPLY);
+				memcpy(arpreply->tipaddr, arpreply->sipaddr, sizeof(in_addr));
+				memcpy(arpreply->thwaddr, arpreply->shwaddr, ETH_ALEN);
+				memcpy(arpreply->sipaddr, &arptable[ARP_CLIENT].ipaddr, sizeof(in_addr));
+				memcpy(arpreply->shwaddr, arptable[ARP_CLIENT].node, ETH_ALEN);
+				eth_transmit(arpreply->thwaddr, ARP,
+					     sizeof(struct  arprequest),
+					     arpreply);
+#ifdef	MDEBUG
+				memcpy(&tmp, arpreply->tipaddr, sizeof(in_addr));
+				printf("Sent ARP reply to: %@\n",tmp);
+#endif	/* MDEBUG */
+			}
+		}
+		process_igmp(ip, now);
+	}
+	return(0);
+}
+
+#ifdef	REQUIRE_VCI_ETHERBOOT
+/**************************************************************************
+FIND_VCI_ETHERBOOT - Looks for "Etherboot" in Vendor Encapsulated Identifiers
+On entry p points to byte count of VCI options
+**************************************************************************/
+static int find_vci_etherboot(unsigned char *p)
+{
+	unsigned char	*end = p + 1 + *p;
+
+	for (p++; p < end; ) {
+		if (*p == RFC2132_VENDOR_CLASS_ID) {
+			if (strncmp("Etherboot", p + 2, sizeof("Etherboot") - 1) == 0)
+				return (1);
+		} else if (*p == RFC1533_END)
+			return (0);
+		p += TAG_LEN(p) + 2;
+	}
+	return (0);
+}
+#endif	/* REQUIRE_VCI_ETHERBOOT */
+
+/**
+ * decode_rfc1533
+ *
+ * Decodes RFC1533 header
+ **/
+int decode_rfc1533(unsigned char *p, unsigned int block, unsigned int len, int eof)
+{
+	static unsigned char *extdata = NULL, *extend = NULL;
+	unsigned char        *extpath = NULL;
+	unsigned char        *endp;
+
+	if (block == 0) {
+		end_of_rfc1533 = NULL;
+		if (memcmp(p, rfc1533_cookie, sizeof(rfc1533_cookie)))
+			return(0); /* no RFC 1533 header found */
+		p += 4;
+		endp = p + len;
+	} else {
+		if (block == 1) {
+			if (memcmp(p, rfc1533_cookie, sizeof(rfc1533_cookie)))
+				return(0); /* no RFC 1533 header found */
+			p += 4;
+			len -= 4; }
+		if (extend + len <= (unsigned char *)
+		    rfc1533_venddata + sizeof(rfc1533_venddata)) {
+			memcpy(extend, p, len);
+			extend += len;
+		} else {
+			printf("Overflow in vendor data buffer! Aborting...\n");
+			*extdata = RFC1533_END;
+			return(0);
+		}
+		p = extdata; endp = extend;
+	}
+	if (!eof)
+		return 1;
+	while (p < endp) {
+		unsigned char c = *p;
+		if (c == RFC1533_PAD) {
+			p++;
+			continue;
+		}
+		else if (c == RFC1533_END) {
+			end_of_rfc1533 = endp = p;
+			continue;
+		}
+		else if (c == RFC1533_NETMASK)
+			memcpy(&netmask, p+2, sizeof(in_addr));
+		else if (c == RFC1533_GATEWAY) {
+			/* This is a little simplistic, but it will
+			   usually be sufficient.
+			   Take only the first entry */
+			if (TAG_LEN(p) >= sizeof(in_addr))
+				memcpy(&arptable[ARP_GATEWAY].ipaddr, p+2, sizeof(in_addr));
+		}
+		else if (c == RFC1533_EXTENSIONPATH)
+			extpath = p;
+		else if (c == RFC2132_MSG_TYPE)
+			dhcp_reply=*(p+2);
+		else if (c == RFC2132_SRV_ID)
+			memcpy(&dhcp_server, p+2, sizeof(in_addr));
+		else if (c == RFC1533_HOSTNAME) {
+			hostname = p + 2;
+			hostnamelen = *(p + 1);
+		}
+		else if (c == RFC1533_VENDOR_CONFIGFILE){
+			int l = TAG_LEN (p);
+	  
+			/* Eliminate the trailing NULs according to RFC 2132.  */
+			while (*(p + 2 + l - 1) == '\000' && l > 0)
+				l--;
+	  
+			/* XXX: Should check if LEN is less than the maximum length
+			   of CONFIG_FILE. This kind of robustness will be a goal
+			   in GRUB 1.0.  */
+			memcpy (config_file, p + 2, l);
+			config_file[l] = 0;
+		}
+		else {
+			;
+		}
+		p += TAG_LEN(p) + 2;
+	}
+	extdata = extend = endp;
+	if (block <= 0 && extpath != NULL) {
+		char fname[64];
+		if (TAG_LEN(extpath) >= sizeof(fname)){
+			printf("Overflow in vendor data buffer! Aborting...\n");
+			*extdata = RFC1533_END;
+			return(0);
+		}
+		memcpy(fname, extpath+2, TAG_LEN(extpath));
+		fname[(int)TAG_LEN(extpath)] = '\0';
+		printf("Loading BOOTP-extension file: %s\n",fname);
+		tftp_file_read(fname, decode_rfc1533);
+	}
+	return 1;	/* proceed with next block */
+}
+
+
+/* FIXME double check TWO_SECOND_DIVISOR */
+#define TWO_SECOND_DIVISOR (RAND_MAX/TICKS_PER_SEC)
+/**************************************************************************
+RFC2131_SLEEP_INTERVAL - sleep for expotentially longer times (base << exp) +- 1 sec)
+**************************************************************************/
+long rfc2131_sleep_interval(long base, int exp)
+{
+	unsigned long tmo;
+#ifdef BACKOFF_LIMIT
+	if (exp > BACKOFF_LIMIT)
+		exp = BACKOFF_LIMIT;
+#endif
+	tmo = (base << exp) + (TICKS_PER_SEC - (random()/TWO_SECOND_DIVISOR));
+	return tmo;
+}
+
+#ifdef MULTICAST_LEVEL2
+/**************************************************************************
+RFC1112_SLEEP_INTERVAL - sleep for expotentially longer times, up to (base << exp)
+**************************************************************************/
+long rfc1112_sleep_interval(long base, int exp)
+{
+	unsigned long divisor, tmo;
+#ifdef BACKOFF_LIMIT
+	if (exp > BACKOFF_LIMIT)
+		exp = BACKOFF_LIMIT;
+#endif
+	divisor = RAND_MAX/(base << exp);
+	tmo = random()/divisor;
+	return tmo;
+}
+#endif /* MULTICAST_LEVEL_2 */
+
+/* ifconfig - configure network interface.  */
+int
+ifconfig (char *ip, char *sm, char *gw, char *svr)
+{
+  in_addr tmp;
+
+  if (sm)
+    {
+      if (! inet_aton (sm, &tmp))
+	return 0;
+
+      netmask = tmp.s_addr;
+    }
+
+  if (ip)
+    {
+      if (! inet_aton (ip, &arptable[ARP_CLIENT].ipaddr))
+	return 0;
+
+      if (! netmask && ! sm)
+	netmask = default_netmask ();
+    }
+
+  if (gw && ! inet_aton (gw, &arptable[ARP_GATEWAY].ipaddr))
+    return 0;
+
+  /* Clear out the ARP entry.  */
+  grub_memset (arptable[ARP_GATEWAY].node, 0, ETH_ALEN);
+
+  if (svr && ! inet_aton (svr, &arptable[ARP_SERVER].ipaddr))
+    return 0;
+
+  /* Likewise.  */
+  grub_memset (arptable[ARP_SERVER].node, 0, ETH_ALEN);
+
+  if (ip || sm)
+    {
+      if (IP_BROADCAST == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
+	  || netmask == (netmask | arptable[ARP_CLIENT].ipaddr.s_addr)
+	  || ! netmask)
+	network_ready = 0;
+      else
+	network_ready = 1;
+    }
+
+  return 1;
+}
+
+/*
+ * print_network_configuration
+ *
+ * Output the network configuration. It may broke the graphic console now.:-(
+ */
+void print_network_configuration (void)
+{
+	EnterFunction("print_network_configuration");
+	if (! eth_probe ())
+		grub_printf ("No ethernet card found.\n");
+	else if (! network_ready)
+		grub_printf ("Not initialized yet.\n");
+	else {
+		etherboot_printf ("Address: %@\n", arptable[ARP_CLIENT].ipaddr.s_addr);
+		etherboot_printf ("Netmask: %@\n", netmask);
+		etherboot_printf ("Server: %@\n", arptable[ARP_SERVER].ipaddr.s_addr);
+		etherboot_printf ("Gateway: %@\n", arptable[ARP_GATEWAY].ipaddr.s_addr);
+	}
+	LeaveFunction("print_network_configuration");
+}
+
+/**
+ * cleanup_net
+ *
+ * Mark network unusable, and disable NICs
+ */
+void cleanup_net (void)
+{
+	if (network_ready){
+		/* Stop receiving packets.  */
+		eth_disable ();
+		network_ready = 0;
+	}
+}
Index: netboot/ntulip.c
===================================================================
--- netboot/ntulip.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/ntulip.c	(.../trunk)	(revision 112)
@@ -0,0 +1,866 @@
+/*
+    Tulip and clone Etherboot Driver
+    By Marty Connor (mdc@thinguin.org) 
+    This software may be used and distributed according to the terms
+    of the GNU Public License, incorporated herein by reference.
+
+    Based on Ken Yap's Tulip Etherboot Driver and Donald Becker's
+    Linux Tulip Driver. Supports N-Way speed auto-configuration on
+    MX98715, MX98715A and MX98725. Support inexpensive PCI 10/100 cards
+    based on the Macronix MX987x5 chip, such as the SOHOware Fast
+    model SFA110A, and the LinkSYS model LNE100TX. The NetGear
+    model FA310X, based on the LC82C168 chip is supported.
+    The TRENDnet TE100-PCIA NIC which uses a genuine Intel 21143-PD
+    chipset is supported.
+
+    Documentation and source code used:  
+      Source for Etherboot driver at
+        http://www.slug.org.au/etherboot/
+      MX98715A Data Sheet and MX98715A Application Note
+        on http://www.macronix.com/  (PDF format files)
+      Source for Linux tulip driver at
+        http://cesdis.gsfc.nasa.gov/linux/drivers/tulip.html
+
+    Adapted by Ken Yap from
+    FreeBSD netboot DEC 21143 driver
+    Author: David Sharp
+      date: Nov/98
+
+    Some code fragments were taken from verious places, Ken Yap's
+    etherboot, FreeBSD's if_de.c, and various Linux related files.
+    DEC's manuals for the 21143 and SROM format were very helpful.
+    The Linux de driver development page has a number of links to
+    useful related information.  Have a look at:
+    ftp://cesdis.gsfc.nasa.gov/pub/linux/drivers/tulip-devel.html 
+*/
+
+/*********************************************************************/
+/* Revision History                                                  */
+/*********************************************************************/
+
+/*
+  29 Feb 2000   mdc     0.75b7
+     Increased reset delay to 3 seconds because Macronix cards seem to
+     need more reset time before card comes back to a usable state.
+  26 Feb 2000   mdc     0.75b6
+     Added a 1 second delay after initializing the transmitter because
+     some cards seem to need the time or they drop the first packet
+     transmitted.
+  23 Feb 2000   mdc     0.75b5
+     removed udelay code and used currticks() for more reliable delay
+     code in reset pause and sanity timeouts.  Added function prototypes
+     and TX debugging code.
+  21 Feb 2000   mdc     patch to Etherboot 4.4.3
+     Incorporated patches from Bob Edwards and Paul Mackerras of
+     Linuxcare's OZLabs to deal with inefficiencies in ntulip_transmit
+     and udelay.  We now wait for packet transmission to complete
+     (or sanity timeout).
+  04 Feb 2000   Robert.Edwards@anu.edu.au patch to Etherboot 4.4.2
+     patch to ntulip.c that implements the automatic selection of the MII
+     interface on cards using the Intel/DEC 21143 reference design, in
+     particular, the TRENDnet TE100-PCIA NIC which uses a genuine Intel
+     21143-PD chipset.
+  11 Jan 2000   mdc     0.75b4
+     Added support for NetGear FA310TX card based on the LC82C168
+     chip.  This should also support Lite-On LC82C168 boards.
+     Added simple MII support. Re-arranged code to better modularize 
+     initializations.
+  04 Dec 1999   mdc     0.75b3  
+     Added preliminary support for LNE100TX PCI cards.  Should work for
+     PNIC2 cards. No MII support, but single interface (RJ45) tulip
+     cards seem to not care.
+  03 Dec 1999   mdc     0.75b2
+     Renamed from mx987x5 to ntulip, merged in original tulip init code
+     from tulip.c to support other tulip compatible cards.
+  02 Dec 1999   mdc     0.75b1
+     Released Beta MX987x5 Driver for code review and testing to netboot
+     and thinguin mailing lists.
+*/
+
+
+/*********************************************************************/
+/* Declarations                                                      */
+/*********************************************************************/
+
+#include "etherboot.h"
+#include "nic.h"
+#include "pci.h"
+#include "cards.h"
+
+#undef NTULIP_DEBUG
+#undef NTULIP_DEBUG_WHERE
+#undef NTULIP_FORCE_BNC
+
+#define TX_TIME_OUT       2*TICKS_PER_SEC
+
+static int tulip_id = 0;
+
+#define DC21140		1
+#define DC21143		2
+#define COMET		3
+#define LC82C168	4
+#define DC21142		5
+
+typedef unsigned char  u8;
+typedef   signed char  s8;
+typedef unsigned short u16;
+typedef   signed short s16;
+typedef unsigned int   u32;
+typedef   signed int   s32;
+
+/* Register offsets for tulip device */
+enum ntulip_offsets {
+   CSR0=0,     CSR1=0x08,  CSR2=0x10,  CSR3=0x18,  CSR4=0x20,  CSR5=0x28,
+   CSR6=0x30,  CSR7=0x38,  CSR8=0x40,  CSR9=0x48, CSR10=0x50, CSR11=0x58,
+  CSR12=0x60, CSR13=0x68, CSR14=0x70, CSR15=0x78, CSR16=0x80, CSR20=0xA0 
+};
+
+#define DEC_21142_CSR6_TTM     0x00400000      /* Transmit Threshold Mode */
+#define DEC_21142_CSR6_HBD     0x00080000      /* Heartbeat Disable */
+#define DEC_21142_CSR6_PS      0x00040000      /* Port Select */
+
+/* EEPROM Address width definitions */
+#define EEPROM_ADDRLEN 6
+#define EEPROM_SIZE    128              /* 2 << EEPROM_ADDRLEN */
+
+/* Data Read from the EEPROM */
+static unsigned char ee_data[EEPROM_SIZE];
+
+/* The EEPROM commands include the alway-set leading bit. */
+#define EE_WRITE_CMD    (5 << addr_len)
+#define EE_READ_CMD     (6 << addr_len)
+#define EE_ERASE_CMD    (7 << addr_len)
+
+/* EEPROM_Ctrl bits. */
+#define EE_SHIFT_CLK    0x02    /* EEPROM shift clock. */
+#define EE_CS           0x01    /* EEPROM chip select. */
+#define EE_DATA_WRITE   0x04    /* EEPROM chip data in. */
+#define EE_WRITE_0      0x01
+#define EE_WRITE_1      0x05
+#define EE_DATA_READ    0x08    /* EEPROM chip data out. */
+#define EE_ENB          (0x4800 | EE_CS)
+
+/* Delay between EEPROM clock transitions.  Even at 33Mhz current PCI
+   implementations don't overrun the EEPROM clock.  We add a bus
+   turn-around to insure that this remains true.  */
+#define eeprom_delay()  inl(ee_addr)
+
+/* helpful macro if on a big_endian machine for changing byte order.
+   not strictly needed on Intel */
+#define le16_to_cpu(val) (val)
+
+/* transmit and receive descriptor format */
+struct txrxdesc {
+  volatile unsigned long   status;         /* owner, status */
+  unsigned long   buf1sz:11,      /* size of buffer 1 */
+    buf2sz:11,                    /* size of buffer 2 */
+    control:10;                   /* control bits */
+  unsigned char *buf1addr;      /* buffer 1 address */
+  unsigned char *buf2addr;      /* buffer 2 address */
+};
+
+/* Size of transmit and receive buffers */
+#define BUFLEN 1600
+
+/*********************************************************************/
+/* Global Storage                                                    */
+/*********************************************************************/
+
+/* PCI Bus parameters */
+static unsigned short vendor, dev_id;
+static unsigned long ioaddr;
+
+/* Note: transmit and receive buffers must be longword aligned and
+   longword divisable */
+
+/* transmit descriptor and buffer */
+static volatile struct txrxdesc txd __attribute__ ((aligned(4)));
+static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
+ 
+/* receive descriptor(s) and buffer(s) */
+#define NRXD 4
+static volatile struct txrxdesc rxd[NRXD] __attribute__ ((aligned(4)));
+static unsigned char rxb[NRXD][BUFLEN] __attribute__ ((aligned(4)));
+static int rxd_tail;
+
+/* buffer for ethernet header */
+static unsigned char ehdr[ETH_HLEN];
+
+/*********************************************************************/
+/* Function Prototypes                                               */
+/*********************************************************************/
+static void inline whereami (char *str);
+static int mdio_read(int phy_id, int location);
+static void mdio_write(int phy_id, int location, int value);
+static void do_mii();
+static int read_eeprom(int location, int addr_len);
+struct nic *ntulip_probe(struct nic *card, unsigned short *io_addrs,
+			 struct pci_device *pci);
+static void ntulip_init_ring(struct nic *card);
+static void ntulip_reset(struct nic *card);
+static void ntulip_transmit(struct nic *card, const char *d, unsigned int t,
+                           unsigned int s, const char *p);
+static int ntulip_poll(struct nic *card);
+static void ntulip_disable(struct nic *card);
+
+
+/*********************************************************************/
+/* Utility Routines                                                  */
+/*********************************************************************/
+
+static void inline whereami (char *str)
+{
+#ifdef NTULIP_DEBUG_WHERE
+  printf("%s\n", str);
+  //  sleep(2);
+#endif
+}
+
+static void ntulip_wait(unsigned int nticks)
+{
+  unsigned int to = currticks() + nticks;
+  while (currticks() < to)
+    /* wait */ ;
+}
+
+
+/*********************************************************************/
+/* Media Descriptor Code                                             */
+/*********************************************************************/
+/* The maximum data clock rate is 2.5 Mhz.  The minimum timing is usually
+   met by back-to-back PCI I/O cycles, but we insert a delay to avoid
+   "overclocking" issues or future 66Mhz PCI. */
+#define mdio_delay() inl(mdio_addr)
+
+/* Read and write the MII registers using software-generated serial
+   MDIO protocol.  It is just different enough from the EEPROM protocol
+   to not share code.  The maxium data clock rate is 2.5 Mhz. */
+#define MDIO_SHIFT_CLK		0x10000
+#define MDIO_DATA_WRITE0	0x00000
+#define MDIO_DATA_WRITE1	0x20000
+#define MDIO_ENB		0x00000	/* Ignore the 0x02000 databook setting. */
+#define MDIO_ENB_IN		0x40000
+#define MDIO_DATA_READ		0x80000
+
+static int mdio_read(int phy_id, int location)
+{
+  int i;
+  int read_cmd = (0xf6 << 10) | (phy_id << 5) | location;
+  int retval = 0;
+  long mdio_addr = ioaddr + CSR9;
+
+  if (tulip_id == LC82C168) {
+    i = 1000;
+    outl(0x60020000 + (phy_id<<23) + (location<<18), ioaddr + 0xA0);
+    inl(ioaddr + 0xA0);
+    inl(ioaddr + 0xA0);
+    while (--i > 0)
+    if ( ! ((retval = inl(ioaddr + 0xA0)) & 0x80000000))
+      return retval & 0xffff;
+    return 0xffff;
+  }
+
+  if (tulip_id == COMET) {
+    if (phy_id == 1) {
+      if (location < 7)
+        return inl(ioaddr + 0xB4 + (location<<2));
+      else if (location == 17)
+        return inl(ioaddr + 0xD0);
+      else if (location >= 29 && location <= 31)
+        return inl(ioaddr + 0xD4 + ((location-29)<<2));
+    }
+    return 0xffff;
+  }
+
+  /* Establish sync by sending at least 32 logic ones. */
+  for (i = 32; i >= 0; i--) {
+    outl(MDIO_ENB | MDIO_DATA_WRITE1, mdio_addr);
+    mdio_delay();
+    outl(MDIO_ENB | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);
+    mdio_delay();
+  }
+  /* Shift the read command bits out. */
+  for (i = 15; i >= 0; i--) {
+    int dataval = (read_cmd & (1 << i)) ? MDIO_DATA_WRITE1 : 0;
+
+    outl(MDIO_ENB | dataval, mdio_addr);
+    mdio_delay();
+    outl(MDIO_ENB | dataval | MDIO_SHIFT_CLK, mdio_addr);
+    mdio_delay();
+  }
+  /* Read the two transition, 16 data, and wire-idle bits. */
+  for (i = 19; i > 0; i--) {
+    outl(MDIO_ENB_IN, mdio_addr);
+    mdio_delay();
+    retval = (retval << 1) | ((inl(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);
+    outl(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);
+    mdio_delay();
+  }
+  return (retval>>1) & 0xffff;
+}
+
+static void mdio_write(int phy_id, int location, int value)
+{
+  int i;
+  int cmd = (0x5002 << 16) | (phy_id << 23) | (location<<18) | value;
+  long mdio_addr = ioaddr + CSR9;
+
+  if (tulip_id == LC82C168) {
+    i = 1000;
+    outl(cmd, ioaddr + 0xA0);
+    do
+      if ( ! (inl(ioaddr + 0xA0) & 0x80000000))
+        break;
+    while (--i > 0);
+    return;
+  }
+
+  if (tulip_id == COMET) {
+    if (phy_id != 1)
+      return;
+    if (location < 7)
+      outl(value, ioaddr + 0xB4 + (location<<2));
+    else if (location == 17)
+      outl(value, ioaddr + 0xD0);
+    else if (location >= 29 && location <= 31)
+      outl(value, ioaddr + 0xD4 + ((location-29)<<2));
+    return;
+  }
+
+  /* Establish sync by sending 32 logic ones. */
+  for (i = 32; i >= 0; i--) {
+    outl(MDIO_ENB | MDIO_DATA_WRITE1, mdio_addr);
+    mdio_delay();
+    outl(MDIO_ENB | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);
+    mdio_delay();
+  }
+  /* Shift the command bits out. */
+  for (i = 31; i >= 0; i--) {
+    int dataval = (cmd & (1 << i)) ? MDIO_DATA_WRITE1 : 0;
+    outl(MDIO_ENB | dataval, mdio_addr);
+    mdio_delay();
+    outl(MDIO_ENB | dataval | MDIO_SHIFT_CLK, mdio_addr);
+    mdio_delay();
+  }
+  /* Clear out extra bits. */
+  for (i = 2; i > 0; i--) {
+    outl(MDIO_ENB_IN, mdio_addr);
+    mdio_delay();
+    outl(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);
+    mdio_delay();
+  }
+  return;
+}
+
+static void do_mii(void)
+{
+  int phy, phy_idx, mii_cnt;
+
+  whereami("do_mii\n");
+
+  mii_cnt = 0;
+  for (phy = 0, phy_idx = 0; phy < 32 && phy_idx < 4; phy++) {
+
+    int mii_status = mdio_read(phy, 1);
+
+    if ((mii_status & 0x8301) == 0x8001 ||
+        ((mii_status & 0x8000) == 0  && (mii_status & 0x7800) != 0)) {
+
+      int mii_reg0 = mdio_read(phy, 0);
+      int mii_advert = mdio_read(phy, 4);
+      int mii_reg4 = ((mii_status >> 6) & 0x01E1) | 1;
+
+      phy_idx++;
+      printf("MII trcvr #%d "
+             "config %x status %x advertising %x reg4 %x.\n",
+             phy, mii_reg0, mii_status, mii_advert, mii_reg4);
+      
+      mdio_write(phy, 0, mii_reg0 | 0x1000);
+      if (mii_advert != mii_reg4)
+        mdio_write(phy, 4, mii_reg4);
+    }
+  }
+  mii_cnt = phy_idx;
+
+#ifdef NTULIP_DEBUG
+  printf("mii_cnt = %d\n", mii_cnt);
+#endif
+
+}
+
+/*********************************************************************/
+/* EEPROM Reading Code                                               */
+/*********************************************************************/
+/* EEPROM routines adapted from the Linux Tulip Code */
+/* Reading a serial EEPROM is a "bit" grungy, but we work our way
+   through:->.
+*/
+static int read_eeprom(int location, int addr_len)
+{
+  int i;
+  unsigned short retval = 0;
+  long ee_addr = ioaddr + CSR9;
+  int read_cmd = location | EE_READ_CMD;
+
+  whereami("read_eeprom\n");
+
+  outl(EE_ENB & ~EE_CS, ee_addr);
+  outl(EE_ENB, ee_addr);
+
+  /* Shift the read command bits out. */
+  for (i = 4 + addr_len; i >= 0; i--) {
+    short dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;
+    outl(EE_ENB | dataval, ee_addr);
+    eeprom_delay();
+    outl(EE_ENB | dataval | EE_SHIFT_CLK, ee_addr);
+    eeprom_delay();
+  }
+  outl(EE_ENB, ee_addr);
+
+  for (i = 16; i > 0; i--) {
+    outl(EE_ENB | EE_SHIFT_CLK, ee_addr);
+    eeprom_delay();
+    retval = (retval << 1) | ((inl(ee_addr) & EE_DATA_READ) ? 1 : 0);
+    outl(EE_ENB, ee_addr);
+    eeprom_delay();
+  }
+
+  /* Terminate the EEPROM access. */
+  outl(EE_ENB & ~EE_CS, ee_addr);
+  return retval;
+}
+
+
+/*********************************************************************/
+/* ntulip_init_ring - setup the tx and rx descriptors                */
+/*********************************************************************/
+static void ntulip_init_ring(struct nic *card)
+{
+  int i;
+
+  /* setup the transmit descriptor */
+  txd.buf1addr = &txb[0];
+  txd.buf2addr = 0;
+  txd.buf1sz   = 192;             /* setup packet must be 192 bytes */
+  txd.buf2sz   = 0;
+  txd.control  = 0x028;           /* setup packet + TER */
+  txd.status   = 0x80000000;      /* give ownership to device */
+
+  /* construct perfect filter frame with mac address as first match
+     and broadcast address for all others */
+  for (i=0; i<192; i++) txb[i] = 0xFF;
+  txb[0] = card->node_addr[0];
+  txb[1] = card->node_addr[1];
+  txb[4] = card->node_addr[2];
+  txb[5] = card->node_addr[3];
+  txb[8] = card->node_addr[4];
+  txb[9] = card->node_addr[5];
+
+  /* setup receive descriptor */
+  for (i=0; i<NRXD; i++) {
+    rxd[i].buf1addr = &rxb[i][0];
+    rxd[i].buf2addr = 0;        /* not used */
+    rxd[i].buf1sz   = BUFLEN;
+    rxd[i].buf2sz   = 0;        /* not used */
+    rxd[i].control  = 0x0;
+    rxd[i].status   = 0x80000000;   /* give ownership to device */
+  }
+
+  /* Set Receive end of ring on last descriptor */
+  rxd[NRXD - 1].control = 0x008;
+  rxd_tail = 0;
+
+}
+
+/*********************************************************************/
+/* eth_reset - Reset adapter                                         */
+/*********************************************************************/
+static void ntulip_reset(struct nic *card)
+{
+  unsigned long to, csr6;
+  
+  whereami("ntulip_reset\n");
+  
+  tulip_id = 0;
+
+  /* Stop Tx and RX */
+  outl(inl(ioaddr + CSR6) & ~0x00002002, ioaddr + CSR6);
+
+  if (vendor == PCI_VENDOR_ID_MACRONIX && dev_id == PCI_DEVICE_ID_MX987x5) {
+    /* set up 10-BASE-T Control Port */
+    outl(0xFFFFFFFF, ioaddr + CSR14);
+    /* set up 10-BASE-T Status Port  */
+    outl(0x00001000, ioaddr + CSR12);
+    /* Set Operation Control Register (CSR6) for MX987x5 
+       to allow N-Way Active Speed selection, and
+       start the chip's Tx to process setup frame. 
+       While it is possible to force speed selection,
+       this is probably more useful most of the time.
+    */
+    outl(0x01A80200, ioaddr + CSR6);
+
+  } else if (vendor == PCI_VENDOR_ID_LINKSYS && dev_id == PCI_DEVICE_ID_LC82C115) {
+    /* This is MX987x5 init code. It seems to work for the LNE100TX 
+       but should be replaced when we figure out the right way
+       to do this initialization
+    */
+    outl(0xFFFFFFFF, ioaddr + CSR14);
+    outl(0x00001000, ioaddr + CSR12);
+    outl(0x01A80200, ioaddr + CSR6);
+
+  } else if (vendor == PCI_VENDOR_ID_LINKSYS && dev_id == PCI_DEVICE_ID_DEC_TULIP) {
+
+    tulip_id = LC82C168;
+    do_mii();
+
+  } else if (vendor == PCI_VENDOR_ID_DEC) {
+
+    char sbuf[64];
+    char *s;
+    int offset;
+    
+    sprintf(sbuf, "(unknown, ID=0x%x)", ((unsigned int *)ee_data)[0]);
+    s = sbuf;
+    
+    switch (((unsigned int *)ee_data)[0]) 
+    {
+      case 0x11001186:
+      case 0x91001282:
+        s = "21140";
+        tulip_id = DC21140;
+        offset = ee_data [27] + (ee_data [28] << 8);
+        do_mii();
+        outl(ee_data[offset+2] | 0x100, ioaddr + CSR12);
+        outl(0x00040000, ioaddr + CSR6);
+        break;
+      case 0x11111011:
+      case 0x12071113:
+        s = "21143-PD";
+        tulip_id = DC21143;
+        break;
+      case 0: // Hack
+      case 0x1430146c:
+      case 0x423511f0:
+	s = "21142";
+	tulip_id = DC21142;
+	do_mii();
+	outl(0x82020000, ioaddr + CSR6);
+	outl(0x00000000, ioaddr + CSR13);
+	outl(0x00000000, ioaddr + CSR14);
+	outl(0x820e0000, ioaddr + CSR6);
+	outl(0x00040000, ioaddr + CSR6);
+	break;
+      default:
+        break;
+    }
+    printf("Network card is a DEC Tulip %s\n", s);
+
+  } else {
+    /* If we don't know what to do with the card, set to 10Mbps half-duplex */
+
+    outl(0x00000000, ioaddr + CSR13);
+    outl(0x7F3F0000, ioaddr + CSR14);
+    outl(0x08000008, ioaddr + CSR15);
+    outl(0x00000000, ioaddr + CSR13);
+    outl(0x00000001, ioaddr + CSR13);
+    outl(0x02404000, ioaddr + CSR6);
+    outl(0x08AF0008, ioaddr + CSR15);
+    outl(0x00050008, ioaddr + CSR15);
+
+  }
+
+  /* Reset the chip, holding bit 0 set at least 50 PCI cycles. */
+  outl(0x00000001, ioaddr + CSR0);
+  ntulip_wait(TICKS_PER_SEC/2);
+  
+  /* turn off reset and set cache align=16lword, burst=unlimit */
+  if (tulip_id == DC21143 || tulip_id == DC21142)
+    outl(0x00A08000, ioaddr + CSR0);  // 21143 Bugfix
+  else       
+    outl(0x01A08000, ioaddr + CSR0);  // default
+
+  /* set up transmit and receive descriptors */
+  ntulip_init_ring(card);
+
+  /* Point to receive descriptor */
+  outl((unsigned long)&rxd[0], ioaddr + CSR3);
+  outl((unsigned long)&txd   , ioaddr + CSR4);
+
+  csr6 = 0x02404000;
+
+  /* Chip specific init code */
+
+  if (vendor == PCI_VENDOR_ID_MACRONIX && dev_id == PCI_DEVICE_ID_MX987x5) {
+    csr6 = 0x01880200;
+    /* Set CSR16 and CSR20 to values that allow device modification */
+    outl(0x0B3C0000 | inl(ioaddr + CSR16), ioaddr + CSR16);
+    outl(0x00011000 | inl(ioaddr + CSR20), ioaddr + CSR20);
+
+  } else if (vendor == PCI_VENDOR_ID_LINKSYS && dev_id == PCI_DEVICE_ID_LC82C115) {
+    /* This is MX987x5 init code. It seems to work for the LNE100TX 
+       but should be replaced when we figure out the right way
+       to do this initialization.
+    */
+    csr6 = 0x01880200;
+    outl(0x0B3C0000 | inl(ioaddr + CSR16), ioaddr + CSR16);
+    outl(0x00011000 | inl(ioaddr + CSR20), ioaddr + CSR20);
+
+  } else if (vendor == PCI_VENDOR_ID_LINKSYS && dev_id == PCI_DEVICE_ID_DEC_TULIP) {
+
+    csr6 = 0x814C0000;
+    outl(0x00000001, ioaddr + CSR15);
+
+#if 0
+  } else if (vendor == PCI_VENDOR_ID_DEC && dev_id == PCI_DEVICE_ID_DEC_21142) {
+     /* check SROM for evidence of an MII interface */
+     /* get Controller_0 Info Leaf Offset from SROM - assume already in ee_data */
+     int offset = ee_data [27] + (ee_data [28] << 8);
+
+     /* check offset range and if we have an extended type 3 Info Block */
+     if ((offset >= 30) && (offset < 120) && (ee_data [offset + 3] > 128) &&
+	(ee_data [offset + 4] == 3)) {
+	/* must have an MII interface - disable heartbeat, select port etc. */
+	csr6 |= (DEC_21142_CSR6_HBD | DEC_21142_CSR6_PS);
+	csr6 &= ~(DEC_21142_CSR6_TTM);
+     }
+#endif
+
+  } else if (vendor == PCI_VENDOR_ID_DEC) {
+
+    int offset;
+    switch (tulip_id) 
+    {
+      case DC21140:
+        offset = ee_data [27] + (ee_data [28] << 8);
+        outl(ee_data[offset+2] | 0x100, ioaddr + CSR12);
+        csr6 = 0x020E0000;
+        break;
+
+      case DC21143:
+        outl(0x00000001, ioaddr + CSR13);
+        outl(0x0003ffff, ioaddr + CSR14);
+#ifdef NTULIP_FORCE_BNC
+        outl(0x82420200, ioaddr + CSR6);
+        outl(0x08af0000, ioaddr + CSR15);
+        outl(0x00a50000, ioaddr + CSR15);
+        outl(0x00001301, ioaddr + CSR12);
+        csr6 = 0x82420200;
+#else
+        outl(0x83860000, ioaddr + CSR6);
+        outl(0x08af0008, ioaddr + CSR15);
+        outl(0x00a50008, ioaddr + CSR15);
+        outl(0x00001301, ioaddr + CSR12);
+        csr6 = 0x83860000;
+#endif
+        break;
+
+      case DC21142:
+	outl(0x82020000, ioaddr + CSR6);
+	outl(0x00000000, ioaddr + CSR13);
+	outl(0x00000000, ioaddr + CSR14);
+	csr6 = 0x820e0000;
+	break;
+    }
+  }
+  
+  ntulip_wait(2*TICKS_PER_SEC);
+
+  /* Start the chip's Tx to process setup frame. */
+  outl(csr6, ioaddr + CSR6);
+
+  /* Start Tx */
+  outl(inl(ioaddr + CSR6) | 0x00002000, ioaddr + CSR6);
+  /* immediate transmit demand */
+  outl(0, ioaddr + CSR1);
+
+  to = currticks() + TX_TIME_OUT;
+  while ((txd.status & 0x80000000) && (currticks() < to))
+    /* wait */ ;
+
+  if (currticks() >= to) {
+    printf ("TX Setup Timeout!\n");
+  }
+
+#ifdef NTULIP_DEBUG
+  printf("txd.status = %X\n", txd.status);
+  printf("ticks = %d\n", currticks() - (to - TX_TIME_OUT));
+#endif
+
+  /* enable RX */
+  outl(inl(ioaddr + CSR6) | 0x00000002, ioaddr + CSR6);
+  /* immediate poll demand */
+  outl(0, ioaddr + CSR2);
+
+}
+
+
+/*********************************************************************/
+/* eth_transmit - Transmit a frame                                   */
+/*********************************************************************/
+static void ntulip_transmit(struct nic *card, const char *d, unsigned int t,
+                             unsigned int s, const char *p)
+{
+  unsigned long to;
+
+  whereami("ntulip_transmit\n");
+
+  /* Stop Tx */
+  outl(inl(ioaddr + CSR6) & ~0x00002000, ioaddr + CSR6);
+
+  /* setup ethernet header */
+  memcpy(ehdr, d, ETH_ALEN);
+  memcpy(&ehdr[ETH_ALEN], card->node_addr, ETH_ALEN);
+  ehdr[ETH_ALEN*2] = (t >> 8) & 0xFF;
+  ehdr[ETH_ALEN*2+1] = t & 0xFF;
+
+  /* setup the transmit descriptor */
+  txd.buf1addr = &ehdr[0];        /* ethernet header */
+  txd.buf1sz   = ETH_HLEN;
+  txd.buf2addr = (unsigned char*)p; /* packet to transmit */
+  txd.buf2sz   = s;
+  txd.control  = 0x00000188;      /* LS+FS+TER */
+  txd.status   = 0x80000000;      /* give it the device */
+
+  /* Point to transmit descriptor */
+  outl((unsigned long)&txd, ioaddr + CSR4);
+
+  /* Start Tx */
+  outl(inl(ioaddr + CSR6) |  0x00002000, ioaddr + CSR6);
+
+  /* immediate transmit demand */
+  outl(0, ioaddr + CSR1);
+
+  to = currticks() + TX_TIME_OUT;
+  while ((txd.status & 0x80000000) && (currticks() < to))
+    /* wait */ ;
+
+  if (currticks() >= to) {
+    printf ("TX Timeout!\n");
+  }
+}
+
+/*********************************************************************/
+/* eth_poll - Wait for a frame                                       */
+/*********************************************************************/
+static int ntulip_poll(struct nic *card)
+{
+
+  whereami("ntulip_poll\n");
+  if (rxd[rxd_tail].status & 0x80000000)
+    return 0;
+
+  whereami("ntulip_poll got one\n");
+
+  card->packetlen = (rxd[rxd_tail].status & 0x3FFF0000) >> 16;
+
+  if (rxd[rxd_tail].status & 0x00008000) {
+      /* CRC error */
+      rxd[rxd_tail].status = 0x80000000;
+      rxd_tail++;
+      if (rxd_tail == NRXD) rxd_tail = 0;
+      return 0;
+  }
+
+  /* copy packet to working buffer */
+  /* XXX - this copy could be avoided with a little more work
+     but for now we are content with it because the optimised
+     memcpy is quite fast */
+
+  memcpy(card->packet, &rxb[rxd_tail][0], card->packetlen);
+
+  /* return the descriptor and buffer to receive ring */
+  rxd[rxd_tail].status = 0x80000000;
+  rxd_tail++;
+  if (rxd_tail == NRXD) rxd_tail = 0;
+
+  return 1;
+}
+
+/*********************************************************************/
+/* eth_disable - Disable the interface                               */
+/*********************************************************************/
+static void ntulip_disable(struct nic *card)
+{
+  whereami("ntulip_disable\n");
+
+  /* The other Etherboot drivers don't seem to do anything here,
+     so for now, we will not either */
+  
+  /* disable interrupts */
+  outl(0x00000000, ioaddr + CSR7);
+
+  /* Stop the chip's Tx and Rx processes. */
+  outl(inl(ioaddr + CSR6) & ~0x00002002, ioaddr + CSR6);
+
+  /* Clear the missed-packet counter. */
+  (volatile unsigned long)inl(ioaddr + CSR8);
+}
+
+/*********************************************************************/
+/* eth_probe - Look for an adapter                                   */
+/*********************************************************************/
+struct nic *ntulip_probe(struct nic *card, unsigned short *io_addrs,
+                          struct pci_device *pci)
+{               
+  int i;
+  unsigned char chip_rev;
+
+  whereami("ntulip_probe\n");
+
+  if (io_addrs == 0 || *io_addrs == 0)
+    return 0;
+
+  vendor  = pci->vendor;
+  dev_id  = pci->dev_id;
+  ioaddr  = *io_addrs;
+
+  /* read chip revision */
+  pcibios_read_config_byte(pci->bus, pci->devfn, 0x08, &chip_rev);
+
+  /* wakeup chip */
+  pcibios_write_config_dword(pci->bus, pci->devfn, 0x40, 0x00000000);
+
+  /* Stop the chip's Tx and Rx processes. */
+  outl(inl(ioaddr + CSR6) & ~0x00002002, ioaddr + CSR6);
+
+  /* Clear the missed-packet counter. */
+  (volatile unsigned long)inl(ioaddr + CSR8);
+
+  /* Get MAC Address */
+
+  /* Hardware Address retrieval method for LC82C168 */
+  if (vendor == PCI_VENDOR_ID_LINKSYS && dev_id == PCI_DEVICE_ID_DEC_TULIP) {
+    for (i = 0; i < 3; i++) {
+      int value, boguscnt = 100000;
+      outl(0x600 | i, ioaddr + 0x98);
+      do
+        value = inl(ioaddr + CSR9);
+      while (value < 0  && --boguscnt > 0);
+      card->node_addr[i*2]     = (u8)((value >> 8) & 0xFF);
+      card->node_addr[i*2 + 1] = (u8)( value       & 0xFF);
+    }
+  } else {
+    /* read EEPROM data */
+    for (i = 0; i < sizeof(ee_data)/2; i++)
+      ((unsigned short *)ee_data)[i] =
+        le16_to_cpu(read_eeprom(i, EEPROM_ADDRLEN));
+
+    /* extract MAC address from EEPROM buffer */
+    for (i=0; i<6; i++)
+      card->node_addr[i] = ee_data[20+i];
+  }
+
+  printf("Tulip %b:%b:%b:%b:%b:%b rev 0x%b at ioaddr 0x%x\n",
+    card->node_addr[0],card->node_addr[1],card->node_addr[2],card->node_addr[3],
+    card->node_addr[4],card->node_addr[5],chip_rev,ioaddr);
+
+  /* initialize device */
+  ntulip_reset(card);
+
+  card->reset    = ntulip_reset;
+  card->poll     = ntulip_poll;
+  card->transmit = ntulip_transmit;
+  card->disable  = ntulip_disable;
+
+  return card;
+}
Index: netboot/pcnet32.c
===================================================================
--- netboot/pcnet32.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/pcnet32.c	(.../trunk)	(revision 112)
@@ -0,0 +1,926 @@
+#define EB52
+
+#ifdef EB50
+#define __unused __attribute__((unused))
+#endif
+/**************************************************************************
+*
+*    pcnet32.c -- Etherboot device driver for the AMD PCnet32
+*    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*		pcnet32.c: An AMD PCnet32 ethernet driver for linux:
+*
+*	(C) 1996-1999 Thomas Bogendoerfer
+*		See Linux Driver for full information
+*	
+*	The transmit and poll functions were written with reference to:
+*	lance.c - LANCE NIC driver for Etherboot written by Ken Yap 
+*	
+*	Linux Driver Version 1.27a, 10.02.2002
+* 
+* 
+*    $Revision$
+*    $Author$
+*    $Date 2003/08/06 $
+* 
+*    REVISION HISTORY:
+*    ================
+*    v1.0	08-06-2003	timlegge	Initial port of Linux driver
+*    v1.1	08-23-2003	timlegge	Add multicast support
+*
+*    Indent Options: indent -kr -i8
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+/* Include the time functions */
+#include "timer.h"
+
+/* void hex_dump(const char *data, const unsigned int len); */
+
+/* Etherboot Specific definations */
+#define drv_version "v1.1"
+#define drv_date "08-23-2003"
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+static u32 ioaddr;		/* Globally used for the card's io address */
+
+#ifdef EB50
+#define cpu_to_le32(val) (val)
+#define le16_to_cpu(val) (val)
+#define le32_to_cpu(val) (val)
+#define virt_to_bus(x) ((unsigned long)x)
+#define bus_to_virt(x) ((unsigned long) x)
+#endif
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+/* End Etherboot Specific */
+
+int cards_found /* __initdata */ ;
+
+#ifdef REMOVE
+/* FIXME: Remove these they are probably pointless */
+
+/* 
+ * VLB I/O addresses 
+ */
+static unsigned int pcnet32_portlist[] /*__initdata */  =
+{ 0x300, 0x320, 0x340, 0x360, 0 };
+
+static int pcnet32_debug = 1;
+static int tx_start = 1;	/* Mapping -- 0:20, 1:64, 2:128, 3:~220 (depends on chip vers) */
+static int pcnet32vlb;		/* check for VLB cards ? */
+
+static struct net_device *pcnet32_dev;
+
+static int max_interrupt_work = 80;
+static int rx_copybreak = 200;
+#endif
+#define PCNET32_PORT_AUI      0x00
+#define PCNET32_PORT_10BT     0x01
+#define PCNET32_PORT_GPSI     0x02
+#define PCNET32_PORT_MII      0x03
+
+#define PCNET32_PORT_PORTSEL  0x03
+#define PCNET32_PORT_ASEL     0x04
+#define PCNET32_PORT_100      0x40
+#define PCNET32_PORT_FD	      0x80
+
+#define PCNET32_DMA_MASK 0xffffffff
+
+/*
+ * table to translate option values from tulip
+ * to internal options
+ */
+static unsigned char options_mapping[] = {
+	PCNET32_PORT_ASEL,	/*  0 Auto-select      */
+	PCNET32_PORT_AUI,	/*  1 BNC/AUI          */
+	PCNET32_PORT_AUI,	/*  2 AUI/BNC          */
+	PCNET32_PORT_ASEL,	/*  3 not supported    */
+	PCNET32_PORT_10BT | PCNET32_PORT_FD,	/*  4 10baseT-FD       */
+	PCNET32_PORT_ASEL,	/*  5 not supported    */
+	PCNET32_PORT_ASEL,	/*  6 not supported    */
+	PCNET32_PORT_ASEL,	/*  7 not supported    */
+	PCNET32_PORT_ASEL,	/*  8 not supported    */
+	PCNET32_PORT_MII,	/*  9 MII 10baseT      */
+	PCNET32_PORT_MII | PCNET32_PORT_FD,	/* 10 MII 10baseT-FD   */
+	PCNET32_PORT_MII,	/* 11 MII (autosel)    */
+	PCNET32_PORT_10BT,	/* 12 10BaseT          */
+	PCNET32_PORT_MII | PCNET32_PORT_100,	/* 13 MII 100BaseTx    */
+	PCNET32_PORT_MII | PCNET32_PORT_100 | PCNET32_PORT_FD,	/* 14 MII 100BaseTx-FD */
+	PCNET32_PORT_ASEL	/* 15 not supported    */
+};
+
+#define MAX_UNITS 8		/* More are supported, limit only on options */
+static int options[MAX_UNITS];
+static int full_duplex[MAX_UNITS];
+
+/*
+ *				Theory of Operation
+ * 
+ * This driver uses the same software structure as the normal lance
+ * driver. So look for a verbose description in lance.c. The differences
+ * to the normal lance driver is the use of the 32bit mode of PCnet32
+ * and PCnetPCI chips. Because these chips are 32bit chips, there is no
+ * 16MB limitation and we don't need bounce buffers.
+ */
+
+
+
+/*
+ * Set the number of Tx and Rx buffers, using Log_2(# buffers).
+ * Reasonable default values are 4 Tx buffers, and 16 Rx buffers.
+ * That translates to 2 (4 == 2^^2) and 4 (16 == 2^^4).
+ */
+#ifndef PCNET32_LOG_TX_BUFFERS
+#define PCNET32_LOG_TX_BUFFERS 1
+#define PCNET32_LOG_RX_BUFFERS 2
+#endif
+
+#define TX_RING_SIZE		(1 << (PCNET32_LOG_TX_BUFFERS))
+#define TX_RING_MOD_MASK	(TX_RING_SIZE - 1)
+/* FIXME: Fix this to allow multiple tx_ring descriptors */
+#define TX_RING_LEN_BITS	0x0000	/*PCNET32_LOG_TX_BUFFERS) << 12) */
+
+#define RX_RING_SIZE		(1 << (PCNET32_LOG_RX_BUFFERS))
+#define RX_RING_MOD_MASK	(RX_RING_SIZE - 1)
+#define RX_RING_LEN_BITS	((PCNET32_LOG_RX_BUFFERS) << 4)
+
+#define PKT_BUF_SZ		1544
+
+/* Offsets from base I/O address. */
+#define PCNET32_WIO_RDP		0x10
+#define PCNET32_WIO_RAP		0x12
+#define PCNET32_WIO_RESET	0x14
+#define PCNET32_WIO_BDP		0x16
+
+#define PCNET32_DWIO_RDP	0x10
+#define PCNET32_DWIO_RAP	0x14
+#define PCNET32_DWIO_RESET	0x18
+#define PCNET32_DWIO_BDP	0x1C
+
+#define PCNET32_TOTAL_SIZE	0x20
+
+/* Buffers for the tx and Rx */
+
+/* Create a static buffer of size PKT_BUF_SZ for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[PKT_BUF_SZ * TX_RING_SIZE]
+    __attribute__ ((aligned(16)));
+
+/* Create a static buffer of size PKT_BUF_SZ for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[RX_RING_SIZE * PKT_BUF_SZ]
+    __attribute__ ((aligned(16)));
+
+/* The PCNET32 Rx and Tx ring descriptors. */
+struct pcnet32_rx_head {
+	u32 base;
+	s16 buf_length;
+	s16 status;
+	u32 msg_length;
+	u32 reserved;
+};
+
+struct pcnet32_tx_head {
+	u32 base;
+	s16 length;
+	s16 status;
+	u32 misc;
+	u32 reserved;
+};
+
+/* The PCNET32 32-Bit initialization block, described in databook. */
+struct pcnet32_init_block {
+	u16 mode;
+	u16 tlen_rlen;
+	u8 phys_addr[6];
+	u16 reserved;
+	u32 filter[2];
+	/* Receive and transmit ring base, along with extra bits. */
+	u32 rx_ring;
+	u32 tx_ring;
+};
+/* PCnet32 access functions */
+struct pcnet32_access {
+	u16(*read_csr) (unsigned long, int);
+	void (*write_csr) (unsigned long, int, u16);
+	 u16(*read_bcr) (unsigned long, int);
+	void (*write_bcr) (unsigned long, int, u16);
+	 u16(*read_rap) (unsigned long);
+	void (*write_rap) (unsigned long, u16);
+	void (*reset) (unsigned long);
+};
+
+/* Define the TX Descriptor */
+static struct pcnet32_tx_head tx_ring[TX_RING_SIZE]
+    __attribute__ ((aligned(16)));
+
+
+/* Define the RX Descriptor */
+static struct pcnet32_rx_head rx_ring[RX_RING_SIZE]
+    __attribute__ ((aligned(16)));
+/*
+ * The first three fields of pcnet32_private are read by the ethernet device 
+ * so we allocate the structure should be allocated by pci_alloc_consistent().
+ */
+struct pcnet32_private {
+	struct pcnet32_init_block init_block;
+	struct pci_dev *pci_dev;	/* Pointer to the associated pci device structure */
+	const char *name;
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	struct sk_buff *tx_skbuff[TX_RING_SIZE];
+	struct sk_buff *rx_skbuff[RX_RING_SIZE];
+	struct pcnet32_access a;
+	unsigned int cur_rx, cur_tx;	/* The next free ring entry */
+	unsigned int dirty_rx, dirty_tx;	/* The ring entries to be free()ed. */
+	char tx_full;
+	int options;
+	int shared_irq:1,	/* shared irq possible */
+	 ltint:1,		/* enable TxDone-intr inhibitor */
+	 dxsuflo:1,		/* disable transmit stop on uflo */
+	 mii:1;			/* mii port available */
+	struct net_device *next;
+	int full_duplex:1;
+} lpx;
+
+static struct pcnet32_private *lp;
+
+enum pci_flags_bit {
+	PCI_USES_IO = 1, PCI_USES_MEM = 2, PCI_USES_MASTER = 4,
+	PCI_ADDR0 = 0x10 << 0, PCI_ADDR1 = 0x10 << 1, PCI_ADDR2 =
+	    0x10 << 2, PCI_ADDR3 = 0x10 << 3,
+};
+
+
+static u16 pcnet32_wio_read_csr(unsigned long addr, int index)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	return inw(addr + PCNET32_WIO_RDP);
+}
+
+static void pcnet32_wio_write_csr(unsigned long addr, int index, u16 val)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	outw(val, addr + PCNET32_WIO_RDP);
+}
+
+static u16 pcnet32_wio_read_bcr(unsigned long addr, int index)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	return inw(addr + PCNET32_WIO_BDP);
+}
+
+static void pcnet32_wio_write_bcr(unsigned long addr, int index, u16 val)
+{
+	outw(index, addr + PCNET32_WIO_RAP);
+	outw(val, addr + PCNET32_WIO_BDP);
+}
+
+static u16 pcnet32_wio_read_rap(unsigned long addr)
+{
+	return inw(addr + PCNET32_WIO_RAP);
+}
+
+static void pcnet32_wio_write_rap(unsigned long addr, u16 val)
+{
+	outw(val, addr + PCNET32_WIO_RAP);
+}
+
+static void pcnet32_wio_reset(unsigned long addr)
+{
+	inw(addr + PCNET32_WIO_RESET);
+}
+
+static int pcnet32_wio_check(unsigned long addr)
+{
+	outw(88, addr + PCNET32_WIO_RAP);
+	return (inw(addr + PCNET32_WIO_RAP) == 88);
+}
+
+static struct pcnet32_access pcnet32_wio = {
+	read_csr:pcnet32_wio_read_csr,
+	write_csr:pcnet32_wio_write_csr,
+	read_bcr:pcnet32_wio_read_bcr,
+	write_bcr:pcnet32_wio_write_bcr,
+	read_rap:pcnet32_wio_read_rap,
+	write_rap:pcnet32_wio_write_rap,
+	reset:pcnet32_wio_reset
+};
+
+static u16 pcnet32_dwio_read_csr(unsigned long addr, int index)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	return (inl(addr + PCNET32_DWIO_RDP) & 0xffff);
+}
+
+static void pcnet32_dwio_write_csr(unsigned long addr, int index, u16 val)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	outl(val, addr + PCNET32_DWIO_RDP);
+}
+
+static u16 pcnet32_dwio_read_bcr(unsigned long addr, int index)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	return (inl(addr + PCNET32_DWIO_BDP) & 0xffff);
+}
+
+static void pcnet32_dwio_write_bcr(unsigned long addr, int index, u16 val)
+{
+	outl(index, addr + PCNET32_DWIO_RAP);
+	outl(val, addr + PCNET32_DWIO_BDP);
+}
+
+static u16 pcnet32_dwio_read_rap(unsigned long addr)
+{
+	return (inl(addr + PCNET32_DWIO_RAP) & 0xffff);
+}
+
+static void pcnet32_dwio_write_rap(unsigned long addr, u16 val)
+{
+	outl(val, addr + PCNET32_DWIO_RAP);
+}
+
+static void pcnet32_dwio_reset(unsigned long addr)
+{
+	inl(addr + PCNET32_DWIO_RESET);
+}
+
+static int pcnet32_dwio_check(unsigned long addr)
+{
+	outl(88, addr + PCNET32_DWIO_RAP);
+	return ((inl(addr + PCNET32_DWIO_RAP) & 0xffff) == 88);
+}
+
+static struct pcnet32_access pcnet32_dwio = {
+	read_csr:pcnet32_dwio_read_csr,
+	write_csr:pcnet32_dwio_write_csr,
+	read_bcr:pcnet32_dwio_read_bcr,
+	write_bcr:pcnet32_dwio_write_bcr,
+	read_rap:pcnet32_dwio_read_rap,
+	write_rap:pcnet32_dwio_write_rap,
+	reset:pcnet32_dwio_reset
+};
+
+
+/* Initialize the PCNET32 Rx and Tx rings. */
+static int pcnet32_init_ring(struct nic *nic)
+{
+	int i;
+
+	lp->tx_full = 0;
+	lp->cur_rx = lp->cur_tx = 0;
+	lp->dirty_rx = lp->dirty_tx = 0;
+
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		rx_ring[i].base = (u32) virt_to_le32desc(&rxb[i]);
+		rx_ring[i].buf_length = le16_to_cpu(-PKT_BUF_SZ);
+		rx_ring[i].status = le16_to_cpu(0x8000);
+	}
+
+	/* The Tx buffer address is filled in as needed, but we do need to clear
+	   the upper ownership bit. */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		tx_ring[i].base = 0;
+		tx_ring[i].status = 0;
+	}
+
+
+	lp->init_block.tlen_rlen =
+	    le16_to_cpu(TX_RING_LEN_BITS | RX_RING_LEN_BITS);
+	for (i = 0; i < 6; i++)
+		lp->init_block.phys_addr[i] = nic->node_addr[i];
+	lp->init_block.rx_ring = (u32) virt_to_le32desc(&rx_ring[0]);
+	lp->init_block.tx_ring = (u32) virt_to_le32desc(&tx_ring[0]);
+	return 0;
+}
+
+/**************************************************************************
+RESET - Reset adapter
+***************************************************************************/
+static void pcnet32_reset(struct nic *nic)
+{
+	/* put the card in its initial state */
+	u16 val;
+	int i;
+
+	/* Reset the PCNET32 */
+	lp->a.reset(ioaddr);
+
+	/* switch pcnet32 to 32bit mode */
+	lp->a.write_bcr(ioaddr, 20, 2);
+
+	/* set/reset autoselect bit */
+	val = lp->a.read_bcr(ioaddr, 2) & ~2;
+	if (lp->options & PCNET32_PORT_ASEL)
+		val |= 2;
+	lp->a.write_bcr(ioaddr, 2, val);
+	/* handle full duplex setting */
+	if (lp->full_duplex) {
+		val = lp->a.read_bcr(ioaddr, 9) & ~3;
+		if (lp->options & PCNET32_PORT_FD) {
+			val |= 1;
+			if (lp->options ==
+			    (PCNET32_PORT_FD | PCNET32_PORT_AUI))
+				val |= 2;
+		} else if (lp->options & PCNET32_PORT_ASEL) {
+			/* workaround of xSeries250, turn on for 79C975 only */
+			i = ((lp->a.
+			      read_csr(ioaddr,
+				       88) | (lp->a.read_csr(ioaddr,
+							     89) << 16)) >>
+			     12) & 0xffff;
+			if (i == 0x2627)
+				val |= 3;
+		}
+		lp->a.write_bcr(ioaddr, 9, val);
+	}
+
+	/* set/reset GPSI bit in test register */
+	val = lp->a.read_csr(ioaddr, 124) & ~0x10;
+	if ((lp->options & PCNET32_PORT_PORTSEL) == PCNET32_PORT_GPSI)
+		val |= 0x10;
+	lp->a.write_csr(ioaddr, 124, val);
+
+	if (lp->mii && !(lp->options & PCNET32_PORT_ASEL)) {
+		val = lp->a.read_bcr(ioaddr, 32) & ~0x38;	/* disable Auto Negotiation, set 10Mpbs, HD */
+		if (lp->options & PCNET32_PORT_FD)
+			val |= 0x10;
+		if (lp->options & PCNET32_PORT_100)
+			val |= 0x08;
+		lp->a.write_bcr(ioaddr, 32, val);
+	} else {
+		if (lp->options & PCNET32_PORT_ASEL) {	/* enable auto negotiate, setup, disable fd */
+			val = lp->a.read_bcr(ioaddr, 32) & ~0x98;
+			val |= 0x20;
+			lp->a.write_bcr(ioaddr, 32, val);
+		}
+	}
+
+#ifdef DO_DXSUFLO
+	if (lp->dxsuflo) {	/* Disable transmit stop on underflow */
+		val = lp->a.read_csr(ioaddr, 3);
+		val |= 0x40;
+		lp->a.write_csr(ioaddr, 3, val);
+	}
+#endif
+
+	if (lp->ltint) {	/* Enable TxDone-intr inhibitor */
+		val = lp->a.read_csr(ioaddr, 5);
+		val |= (1 << 14);
+		lp->a.write_csr(ioaddr, 5, val);
+	}
+	lp->init_block.mode =
+	    le16_to_cpu((lp->options & PCNET32_PORT_PORTSEL) << 7);
+	lp->init_block.filter[0] = 0xffffffff;
+	lp->init_block.filter[1] = 0xffffffff;
+
+	pcnet32_init_ring(nic);
+
+
+	/* Re-initialize the PCNET32, and start it when done. */
+	lp->a.write_csr(ioaddr, 1,
+			(virt_to_bus(&lp->init_block)) & 0xffff);
+	lp->a.write_csr(ioaddr, 2, (virt_to_bus(&lp->init_block)) >> 16);
+	lp->a.write_csr(ioaddr, 4, 0x0915);
+	lp->a.write_csr(ioaddr, 0, 0x0001);
+
+
+	i = 0;
+	while (i++ < 100)
+		if (lp->a.read_csr(ioaddr, 0) & 0x0100)
+			break;
+	/* 
+	 * We used to clear the InitDone bit, 0x0100, here but Mark Stockton
+	 * reports that doing so triggers a bug in the '974.
+	 */
+	lp->a.write_csr(ioaddr, 0, 0x0042);
+
+	printf("pcnet32 open, csr0 %hX.\n", lp->a.read_csr(ioaddr, 0));
+
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int pcnet32_poll(struct nic *nic __unused)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+
+	int status;
+	int entry;
+
+	entry = lp->cur_rx & RX_RING_MOD_MASK;
+	status = ((short) le16_to_cpu(rx_ring[entry].status) >> 8);
+
+	if (status < 0)
+		return 0;
+
+	if (status == 0x03) {
+		nic->packetlen =
+		    (le32_to_cpu(rx_ring[entry].msg_length) & 0xfff) - 4;
+		memcpy(nic->packet, &rxb[entry], nic->packetlen);
+
+		/* Andrew Boyd of QNX reports that some revs of the 79C765
+		 * clear the buffer length */
+		rx_ring[entry].buf_length = le16_to_cpu(-PKT_BUF_SZ);
+		rx_ring[entry].status |= le16_to_cpu(0x8000);	/* prime for next receive */
+		/* Switch to the next Rx ring buffer */
+		lp->cur_rx++;
+
+	} else {
+		return 0;
+	}
+
+	return 1;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void pcnet32_transmit(struct nic *nic __unused, const char *d,	/* Destination */
+			     unsigned int t,	/* Type */
+			     unsigned int s,	/* size */
+			     const char *p)
+{				/* Packet */
+	/* send the packet to destination */
+	unsigned long time;
+	u8 *ptxb;
+	u16 nstype;
+	u16 status;
+	int entry = 0;		/*lp->cur_tx & TX_RING_MOD_MASK; */
+
+	status = 0x8300;
+	/* point to the current txb incase multiple tx_rings are used */
+	ptxb = txb + (lp->cur_tx * PKT_BUF_SZ);
+
+	/* copy the packet to ring buffer */
+	memcpy(ptxb, d, ETH_ALEN);	/* dst */
+	memcpy(ptxb + ETH_ALEN, nic->node_addr, ETH_ALEN);	/* src */
+	nstype = htons((u16) t);	/* type */
+	memcpy(ptxb + 2 * ETH_ALEN, (u8 *) & nstype, 2);	/* type */
+	memcpy(ptxb + ETH_HLEN, p, s);
+
+	s += ETH_HLEN;
+	while (s < ETH_ZLEN)	/* pad to min length */
+		ptxb[s++] = '\0';
+
+	tx_ring[entry].length = le16_to_cpu(-s);
+	tx_ring[entry].misc = 0x00000000;
+	tx_ring[entry].base = (u32) virt_to_le32desc(ptxb);
+
+	/* we set the top byte as the very last thing */
+	tx_ring[entry].status = le16_to_cpu(status);
+
+
+	/* Trigger an immediate send poll */
+	lp->a.write_csr(ioaddr, 0, 0x0048);
+
+	/* wait for transmit complete */
+	lp->cur_tx = 0;		/* (lp->cur_tx + 1); */
+	time = currticks() + TICKS_PER_SEC;	/* wait one second */
+	while (currticks() < time &&
+	       ((short) le16_to_cpu(tx_ring[entry].status) < 0));
+
+	if ((short) le16_to_cpu(tx_ring[entry].status) < 0)
+		printf("PCNET32 timed out on transmit\n");
+
+	/* Stop pointing at the current txb
+	 * otherwise the card continues to send the packet */
+	tx_ring[entry].base = 0;
+
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+#ifdef EB50
+static void pcnet32_disable(struct nic *nic __unused)
+#else
+static void pcnet32_disable(struct dev *dev __unused)
+#endif
+{
+	/* Stop the PCNET32 here -- it ocassionally polls memory if we don't */
+	lp->a.write_csr(ioaddr, 0, 0x0004);
+
+	/*
+	 * Switch back to 16-bit mode to avoid problesm with dumb 
+	 * DOS packet driver after a warm reboot
+	 */
+	lp->a.write_bcr(ioaddr, 20, 4);
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+You should omit the last argument struct pci_device * for a non-PCI NIC
+***************************************************************************/
+#ifdef EB50
+struct nic *pcnet32_probe(struct nic *nic, unsigned short *io_addr, struct pci_device *pci)
+{
+#else
+static int pcnet32_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+#endif
+
+	int i, media;
+	int fdx, mii, fset, dxsuflo, ltint;
+	int chip_version;
+	char *chipname;
+	/* struct net_device *dev; */
+	struct pcnet32_access *a = NULL;
+	u8 promaddr[6];
+
+	int shared = 1;
+	if (pci->ioaddr == 0)
+		return 0;
+
+	/* BASE is used throughout to address the card */
+	ioaddr = pci->ioaddr;
+	printf("\n");	
+	printf("pcnet32.c: %s, %s Written by Timothy Legge (tlegge@rogers.com)\n", drv_version, drv_date);
+	printf("%s: Probing for Vendor=%hX   Device=%hX\n",
+	       pci->name, pci->vendor, pci->dev_id);
+
+	/* reset the chip */
+	pcnet32_wio_reset(ioaddr);
+
+	/* NOTE: 16-bit check is first, otherwise some older PCnet chips fail */
+	if (pcnet32_wio_read_csr(ioaddr, 0) == 4
+	    && pcnet32_wio_check(ioaddr)) {
+		a = &pcnet32_wio;
+	} else {
+		pcnet32_dwio_reset(ioaddr);
+		if (pcnet32_dwio_read_csr(ioaddr, 0) == 4
+		    && pcnet32_dwio_check(ioaddr)) {
+			a = &pcnet32_dwio;
+		} else
+			/* return -ENODEV; */
+			return 0;
+	}
+
+	chip_version =
+	    a->read_csr(ioaddr, 88) | (a->read_csr(ioaddr, 89) << 16);
+
+	printf("PCnet chip version is %#x.\n", chip_version);
+	if ((chip_version & 0xfff) != 0x003)
+		/*return -ENODEV; */
+		return 0;
+
+	/* initialize variables */
+	fdx = mii = fset = dxsuflo = ltint = 0;
+	chip_version = (chip_version >> 12) & 0xffff;
+
+	switch (chip_version) {
+	case 0x2420:
+		chipname = "PCnet/PCI 79C970";	/* PCI */
+		break;
+	case 0x2430:
+		if (shared)
+			chipname = "PCnet/PCI 79C970";	/* 970 gives the wrong chip id back */
+		else
+			chipname = "PCnet/32 79C965";	/* 486/VL bus */
+		break;
+	case 0x2621:
+		chipname = "PCnet/PCI II 79C970A";	/* PCI */
+		fdx = 1;
+		break;
+	case 0x2623:
+		chipname = "PCnet/FAST 79C971";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		fset = 1;
+		ltint = 1;
+		break;
+	case 0x2624:
+		chipname = "PCnet/FAST+ 79C972";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		fset = 1;
+		break;
+	case 0x2625:
+		chipname = "PCnet/FAST III 79C973";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		break;
+	case 0x2626:
+		chipname = "PCnet/Home 79C978";	/* PCI */
+		fdx = 1;
+		/* 
+		 * This is based on specs published at www.amd.com.  This section
+		 * assumes that a card with a 79C978 wants to go into 1Mb HomePNA
+		 * mode.  The 79C978 can also go into standard ethernet, and there
+		 * probably should be some sort of module option to select the
+		 * mode by which the card should operate
+		 */
+		/* switch to home wiring mode */
+		media = a->read_bcr(ioaddr, 49);
+
+		printf("media reset to %#x.\n", media);
+		a->write_bcr(ioaddr, 49, media);
+		break;
+	case 0x2627:
+		chipname = "PCnet/FAST III 79C975";	/* PCI */
+		fdx = 1;
+		mii = 1;
+		break;
+	default:
+		printf("PCnet version %#x, no PCnet32 chip.\n",
+		       chip_version);
+		/* return -ENODEV; */
+		return 0;
+	}
+
+	/*
+	 *  On selected chips turn on the BCR18:NOUFLO bit. This stops transmit
+	 *  starting until the packet is loaded. Strike one for reliability, lose
+	 *  one for latency - although on PCI this isnt a big loss. Older chips 
+	 *  have FIFO's smaller than a packet, so you can't do this.
+	 */
+
+	if (fset) {
+		a->write_bcr(ioaddr, 18,
+			     (a->read_bcr(ioaddr, 18) | 0x0800));
+		a->write_csr(ioaddr, 80,
+			     (a->read_csr(ioaddr, 80) & 0x0C00) | 0x0c00);
+		dxsuflo = 1;
+		ltint = 1;
+	}
+
+	printf("%s at %hX,", chipname, ioaddr);
+
+	/* read PROM address */
+	for (i = 0; i < 6; i++)
+		promaddr[i] = inb(ioaddr + i);
+
+	/* Update the nic structure with the MAC Address */
+	for (i = 0; i < ETH_ALEN; i++) {
+		nic->node_addr[i] = promaddr[i];
+	}
+	/* Print out some hardware info */
+	printf("%s: %! at ioaddr %hX\n", pci->name, nic->node_addr,
+	       ioaddr);
+
+	/* I really must find out what this does */
+	adjust_pci_device(pci);
+
+	/* point to private storage */
+	lp = &lpx;
+
+	if (((chip_version + 1) & 0xfffe) == 0x2624) {	/* Version 0x2623 or 0x2624 */
+		i = a->read_csr(ioaddr, 80) & 0x0C00;	/* Check tx_start_pt */
+		printf("    tx_start_pt(0x%hX):", i);
+		switch (i >> 10) {
+		case 0:
+			printf("  20 bytes,");
+			break;
+		case 1:
+			printf("  64 bytes,");
+			break;
+		case 2:
+			printf(" 128 bytes,");
+			break;
+		case 3:
+			printf("~220 bytes,");
+			break;
+		}
+		i = a->read_bcr(ioaddr, 18);	/* Check Burst/Bus control */
+		printf(" BCR18(%hX):", i & 0xffff);
+		if (i & (1 << 5))
+			printf("BurstWrEn ");
+		if (i & (1 << 6))
+			printf("BurstRdEn ");
+		if (i & (1 << 7))
+			printf("DWordIO ");
+		if (i & (1 << 11))
+			printf("NoUFlow ");
+		i = a->read_bcr(ioaddr, 25);
+		printf("    SRAMSIZE=0x%hX,", i << 8);
+		i = a->read_bcr(ioaddr, 26);
+		printf(" SRAM_BND=0x%hX,", i << 8);
+		i = a->read_bcr(ioaddr, 27);
+		if (i & (1 << 14))
+			printf("LowLatRx");
+	}
+
+	lp = &lpx;
+	lp->name = chipname;
+	lp->shared_irq = shared;
+	lp->full_duplex = fdx;
+	lp->dxsuflo = dxsuflo;
+	lp->ltint = ltint;
+	lp->mii = mii;
+	if ((cards_found >= MAX_UNITS)
+	    || (options[cards_found] > sizeof(options_mapping)))
+		lp->options = PCNET32_PORT_ASEL;
+	else
+		lp->options = options_mapping[options[cards_found]];
+
+	if (fdx && !(lp->options & PCNET32_PORT_ASEL) &&
+	    ((cards_found >= MAX_UNITS) || full_duplex[cards_found]))
+		lp->options |= PCNET32_PORT_FD;
+
+	if (!a) {
+		printf("No access methods\n");
+		return 0;
+	}
+	lp->a = *a;
+
+	/* detect special T1/E1 WAN card by checking for MAC address */
+	if (nic->node_addr[0] == 0x00 && nic->node_addr[1] == 0xe0
+	    && nic->node_addr[2] == 0x75)
+		lp->options = PCNET32_PORT_FD | PCNET32_PORT_GPSI;
+
+	lp->init_block.mode = le16_to_cpu(0x0003); 	/* Disable Rx and Tx. */
+	lp->init_block.tlen_rlen =
+	    le16_to_cpu(TX_RING_LEN_BITS | RX_RING_LEN_BITS);
+	for (i = 0; i < 6; i++)
+		lp->init_block.phys_addr[i] = nic->node_addr[i];
+	lp->init_block.filter[0] = 0xffffffff;
+	lp->init_block.filter[1] = 0xffffffff;
+	lp->init_block.rx_ring = virt_to_bus(&rx_ring);
+	lp->init_block.tx_ring = virt_to_bus(&tx_ring);
+
+	/* switch pcnet32 to 32bit mode */
+	a->write_bcr(ioaddr, 20, 2);
+
+
+	a->write_csr(ioaddr, 1, (virt_to_bus(&lp->init_block)) & 0xffff);
+	a->write_csr(ioaddr, 2, (virt_to_bus(&lp->init_block)) >> 16);
+
+	/* 
+	 * To auto-IRQ we enable the initialization-done and DMA error
+	 * interrupts. For ISA boards we get a DMA error, but VLB and PCI
+	 * boards will work.
+	 */
+	/* Trigger an initialization just for the interrupt. */
+
+	a->write_csr(ioaddr, 0, 0x41);
+	mdelay(1);
+
+	cards_found++;
+	
+	/* point to NIC specific routines */
+	pcnet32_reset(nic);
+
+#ifdef EB50
+	nic->poll = pcnet32_poll;
+	nic->transmit = pcnet32_transmit;
+	nic->disable = pcnet32_disable;
+	return nic;
+#else
+	nic->poll = pcnet32_poll;
+	nic->transmit = pcnet32_transmit;
+	dev->disable = pcnet32_disable;
+	return 1;
+#endif
+}
+#ifndef EB50
+static struct pci_id pcnet32_nics[] = {
+	PCI_ROM(0x1022, 0x2000, "lancepci", "AMD Lance/PCI"),
+	PCI_ROM(0x1022, 0x2625, "pcnetfastiii", "AMD Lance/PCI PCNet/32"),
+	PCI_ROM(0x1022, 0x2001, "amdhomepna", "AMD Lance/HomePNA"),
+};
+
+struct pci_driver pcnet32_driver = {
+	.type = NIC_DRIVER,
+	.name = "PCNET32/PCI",
+	.probe = pcnet32_probe,
+	.ids = pcnet32_nics,
+	.id_count = sizeof(pcnet32_nics) / sizeof(pcnet32_nics[0]),
+	.class = 0,
+};
+#endif
Index: netboot/nic.h
===================================================================
--- netboot/nic.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/nic.h	(.../trunk)	(revision 112)
@@ -8,24 +8,64 @@
 #ifndef	NIC_H
 #define NIC_H
 
+#include "dev.h"
+
+/* The 'rom_info' maybe arch depended. It must be moved to some other
+ * place */
+struct rom_info {
+	unsigned short	rom_segment;
+	unsigned short	rom_length;
+};
+
 /*
  *	Structure returned from eth_probe and passed to other driver
  *	functions.
  */
-
 struct nic
 {
-	void		(*reset)P((struct nic *));
+	struct dev	dev;  /* This must come first */
 	int		(*poll)P((struct nic *));
 	void		(*transmit)P((struct nic *, const char *d,
 				unsigned int t, unsigned int s, const char *p));
-	void		(*disable)P((struct nic *));
 	int		flags;	/* driver specific flags */
 	struct rom_info	*rom_info;	/* -> rom_info from main */
 	unsigned char	*node_addr;
-	char		*packet;
+	unsigned char	*packet;
 	unsigned int	packetlen;
 	void		*priv_data;	/* driver can hang private data here */
 };
 
+extern char *hostname;
+
+extern int hostnamelen;
+
+/* Current Network Interface Card */
+extern struct nic nic;
+
+/* Whether network is ready */
+extern int network_ready;
+
+/* User aborted in await_reply if not zero */
+extern int user_abort;
+
+/** 
+ * Some network functions.
+ **/
+extern int  eth_probe(void);
+
+extern int  eth_poll(void);
+
+extern void eth_transmit(const char * __d, unsigned int __t, 
+			 unsigned int __s, const void * __p);
+
+extern void eth_disable(void);
+
+
+
+extern int rarp(void);
+
+extern int bootp(void);
+
+extern int dhcp(void);
+
 #endif	/* NIC_H */
Index: netboot/pci_ids.h
===================================================================
--- netboot/pci_ids.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/pci_ids.h	(.../trunk)	(revision 112)
@@ -0,0 +1,1809 @@
+/*
+ *	PCI Class, Vendor and Device IDs
+ *
+ *	Please keep sorted.
+ */
+
+/* Device classes and subclasses */
+
+#define PCI_CLASS_NOT_DEFINED		0x0000
+#define PCI_CLASS_NOT_DEFINED_VGA	0x0001
+
+#define PCI_BASE_CLASS_STORAGE		0x01
+#define PCI_CLASS_STORAGE_SCSI		0x0100
+#define PCI_CLASS_STORAGE_IDE		0x0101
+#define PCI_CLASS_STORAGE_FLOPPY	0x0102
+#define PCI_CLASS_STORAGE_IPI		0x0103
+#define PCI_CLASS_STORAGE_RAID		0x0104
+#define PCI_CLASS_STORAGE_OTHER		0x0180
+
+#define PCI_BASE_CLASS_NETWORK		0x02
+#define PCI_CLASS_NETWORK_ETHERNET	0x0200
+#define PCI_CLASS_NETWORK_TOKEN_RING	0x0201
+#define PCI_CLASS_NETWORK_FDDI		0x0202
+#define PCI_CLASS_NETWORK_ATM		0x0203
+#define PCI_CLASS_NETWORK_OTHER		0x0280
+
+#define PCI_BASE_CLASS_DISPLAY		0x03
+#define PCI_CLASS_DISPLAY_VGA		0x0300
+#define PCI_CLASS_DISPLAY_XGA		0x0301
+#define PCI_CLASS_DISPLAY_3D		0x0302
+#define PCI_CLASS_DISPLAY_OTHER		0x0380
+
+#define PCI_BASE_CLASS_MULTIMEDIA	0x04
+#define PCI_CLASS_MULTIMEDIA_VIDEO	0x0400
+#define PCI_CLASS_MULTIMEDIA_AUDIO	0x0401
+#define PCI_CLASS_MULTIMEDIA_PHONE	0x0402
+#define PCI_CLASS_MULTIMEDIA_OTHER	0x0480
+
+#define PCI_BASE_CLASS_MEMORY		0x05
+#define PCI_CLASS_MEMORY_RAM		0x0500
+#define PCI_CLASS_MEMORY_FLASH		0x0501
+#define PCI_CLASS_MEMORY_OTHER		0x0580
+
+#define PCI_BASE_CLASS_BRIDGE		0x06
+#define PCI_CLASS_BRIDGE_HOST		0x0600
+#define PCI_CLASS_BRIDGE_ISA		0x0601
+#define PCI_CLASS_BRIDGE_EISA		0x0602
+#define PCI_CLASS_BRIDGE_MC		0x0603
+#define PCI_CLASS_BRIDGE_PCI		0x0604
+#define PCI_CLASS_BRIDGE_PCMCIA		0x0605
+#define PCI_CLASS_BRIDGE_NUBUS		0x0606
+#define PCI_CLASS_BRIDGE_CARDBUS	0x0607
+#define PCI_CLASS_BRIDGE_RACEWAY	0x0608
+#define PCI_CLASS_BRIDGE_OTHER		0x0680
+
+#define PCI_BASE_CLASS_COMMUNICATION	0x07
+#define PCI_CLASS_COMMUNICATION_SERIAL	0x0700
+#define PCI_CLASS_COMMUNICATION_PARALLEL 0x0701
+#define PCI_CLASS_COMMUNICATION_MULTISERIAL 0x0702
+#define PCI_CLASS_COMMUNICATION_MODEM	0x0703
+#define PCI_CLASS_COMMUNICATION_OTHER	0x0780
+
+#define PCI_BASE_CLASS_SYSTEM		0x08
+#define PCI_CLASS_SYSTEM_PIC		0x0800
+#define PCI_CLASS_SYSTEM_DMA		0x0801
+#define PCI_CLASS_SYSTEM_TIMER		0x0802
+#define PCI_CLASS_SYSTEM_RTC		0x0803
+#define PCI_CLASS_SYSTEM_PCI_HOTPLUG	0x0804
+#define PCI_CLASS_SYSTEM_OTHER		0x0880
+
+#define PCI_BASE_CLASS_INPUT		0x09
+#define PCI_CLASS_INPUT_KEYBOARD	0x0900
+#define PCI_CLASS_INPUT_PEN		0x0901
+#define PCI_CLASS_INPUT_MOUSE		0x0902
+#define PCI_CLASS_INPUT_SCANNER		0x0903
+#define PCI_CLASS_INPUT_GAMEPORT	0x0904
+#define PCI_CLASS_INPUT_OTHER		0x0980
+
+#define PCI_BASE_CLASS_DOCKING		0x0a
+#define PCI_CLASS_DOCKING_GENERIC	0x0a00
+#define PCI_CLASS_DOCKING_OTHER		0x0a80
+
+#define PCI_BASE_CLASS_PROCESSOR	0x0b
+#define PCI_CLASS_PROCESSOR_386		0x0b00
+#define PCI_CLASS_PROCESSOR_486		0x0b01
+#define PCI_CLASS_PROCESSOR_PENTIUM	0x0b02
+#define PCI_CLASS_PROCESSOR_ALPHA	0x0b10
+#define PCI_CLASS_PROCESSOR_POWERPC	0x0b20
+#define PCI_CLASS_PROCESSOR_MIPS	0x0b30
+#define PCI_CLASS_PROCESSOR_CO		0x0b40
+
+#define PCI_BASE_CLASS_SERIAL		0x0c
+#define PCI_CLASS_SERIAL_FIREWIRE	0x0c00
+#define PCI_CLASS_SERIAL_ACCESS		0x0c01
+#define PCI_CLASS_SERIAL_SSA		0x0c02
+#define PCI_CLASS_SERIAL_USB		0x0c03
+#define PCI_CLASS_SERIAL_FIBER		0x0c04
+#define PCI_CLASS_SERIAL_SMBUS		0x0c05
+
+#define PCI_BASE_CLASS_INTELLIGENT	0x0e
+#define PCI_CLASS_INTELLIGENT_I2O	0x0e00
+
+#define PCI_BASE_CLASS_SATELLITE	0x0f
+#define PCI_CLASS_SATELLITE_TV		0x0f00
+#define PCI_CLASS_SATELLITE_AUDIO	0x0f01
+#define PCI_CLASS_SATELLITE_VOICE	0x0f03
+#define PCI_CLASS_SATELLITE_DATA	0x0f04
+
+#define PCI_BASE_CLASS_CRYPT		0x10
+#define PCI_CLASS_CRYPT_NETWORK		0x1000
+#define PCI_CLASS_CRYPT_ENTERTAINMENT	0x1001
+#define PCI_CLASS_CRYPT_OTHER		0x1080
+
+#define PCI_BASE_CLASS_SIGNAL_PROCESSING 0x11
+#define PCI_CLASS_SP_DPIO		0x1100
+#define PCI_CLASS_SP_OTHER		0x1180
+
+#define PCI_CLASS_OTHERS		0xff
+
+/* Vendors and devices.  Sort key: vendor first, device next. */
+
+#define PCI_VENDOR_ID_DYNALINK		0x0675
+#define PCI_DEVICE_ID_DYNALINK_IS64PH	0x1702
+
+#define PCI_VENDOR_ID_BERKOM			0x0871
+#define PCI_DEVICE_ID_BERKOM_A1T		0xffa1
+#define PCI_DEVICE_ID_BERKOM_T_CONCEPT		0xffa2
+#define PCI_DEVICE_ID_BERKOM_A4T		0xffa4
+#define PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO	0xffa8
+
+#define PCI_VENDOR_ID_COMPAQ		0x0e11
+#define PCI_DEVICE_ID_COMPAQ_TOKENRING	0x0508
+#define PCI_DEVICE_ID_COMPAQ_1280	0x3033
+#define PCI_DEVICE_ID_COMPAQ_TRIFLEX	0x4000
+#define PCI_DEVICE_ID_COMPAQ_6010	0x6010
+#define PCI_DEVICE_ID_COMPAQ_SMART2P	0xae10
+#define PCI_DEVICE_ID_COMPAQ_NETEL100	0xae32
+#define PCI_DEVICE_ID_COMPAQ_NETEL10	0xae34
+#define PCI_DEVICE_ID_COMPAQ_NETFLEX3I	0xae35
+#define PCI_DEVICE_ID_COMPAQ_NETEL100D	0xae40
+#define PCI_DEVICE_ID_COMPAQ_NETEL100PI	0xae43
+#define PCI_DEVICE_ID_COMPAQ_NETEL100I	0xb011
+#define PCI_DEVICE_ID_COMPAQ_CISS	0xb060
+#define PCI_DEVICE_ID_COMPAQ_CISSB	0xb178
+#define PCI_DEVICE_ID_COMPAQ_THUNDER	0xf130
+#define PCI_DEVICE_ID_COMPAQ_NETFLEX3B	0xf150
+
+#define PCI_VENDOR_ID_NCR		0x1000
+#define PCI_VENDOR_ID_LSI_LOGIC		0x1000
+#define PCI_DEVICE_ID_NCR_53C810	0x0001
+#define PCI_DEVICE_ID_NCR_53C820	0x0002
+#define PCI_DEVICE_ID_NCR_53C825	0x0003
+#define PCI_DEVICE_ID_NCR_53C815	0x0004
+#define PCI_DEVICE_ID_LSI_53C810AP	0x0005
+#define PCI_DEVICE_ID_NCR_53C860	0x0006
+#define PCI_DEVICE_ID_LSI_53C1510	0x000a
+#define PCI_DEVICE_ID_NCR_53C896	0x000b
+#define PCI_DEVICE_ID_NCR_53C895	0x000c
+#define PCI_DEVICE_ID_NCR_53C885	0x000d
+#define PCI_DEVICE_ID_NCR_53C875	0x000f
+#define PCI_DEVICE_ID_NCR_53C1510	0x0010
+#define PCI_DEVICE_ID_LSI_53C895A	0x0012
+#define PCI_DEVICE_ID_LSI_53C875A	0x0013
+#define PCI_DEVICE_ID_LSI_53C1010_33	0x0020
+#define PCI_DEVICE_ID_LSI_53C1010_66	0x0021
+#define PCI_DEVICE_ID_LSI_53C1030	0x0030
+#define PCI_DEVICE_ID_LSI_53C1035	0x0040
+#define PCI_DEVICE_ID_NCR_53C875J	0x008f
+#define PCI_DEVICE_ID_LSI_FC909		0x0621
+#define PCI_DEVICE_ID_LSI_FC929		0x0622
+#define PCI_DEVICE_ID_LSI_FC929_LAN	0x0623
+#define PCI_DEVICE_ID_LSI_FC919		0x0624
+#define PCI_DEVICE_ID_LSI_FC919_LAN	0x0625
+#define PCI_DEVICE_ID_NCR_YELLOWFIN	0x0701
+#define PCI_DEVICE_ID_LSI_61C102	0x0901
+#define PCI_DEVICE_ID_LSI_63C815	0x1000
+
+#define PCI_VENDOR_ID_ATI		0x1002
+/* Mach64 */
+#define PCI_DEVICE_ID_ATI_68800		0x4158
+#define PCI_DEVICE_ID_ATI_215CT222	0x4354
+#define PCI_DEVICE_ID_ATI_210888CX	0x4358
+#define PCI_DEVICE_ID_ATI_215ET222	0x4554
+/* Mach64 / Rage */
+#define PCI_DEVICE_ID_ATI_215GB		0x4742
+#define PCI_DEVICE_ID_ATI_215GD		0x4744
+#define PCI_DEVICE_ID_ATI_215GI		0x4749
+#define PCI_DEVICE_ID_ATI_215GP		0x4750
+#define PCI_DEVICE_ID_ATI_215GQ		0x4751
+#define PCI_DEVICE_ID_ATI_215XL		0x4752
+#define PCI_DEVICE_ID_ATI_215GT		0x4754
+#define PCI_DEVICE_ID_ATI_215GTB	0x4755
+#define PCI_DEVICE_ID_ATI_215_IV	0x4756
+#define PCI_DEVICE_ID_ATI_215_IW	0x4757
+#define PCI_DEVICE_ID_ATI_215_IZ	0x475A
+#define PCI_DEVICE_ID_ATI_210888GX	0x4758
+#define PCI_DEVICE_ID_ATI_215_LB	0x4c42
+#define PCI_DEVICE_ID_ATI_215_LD	0x4c44
+#define PCI_DEVICE_ID_ATI_215_LG	0x4c47
+#define PCI_DEVICE_ID_ATI_215_LI	0x4c49
+#define PCI_DEVICE_ID_ATI_215_LM	0x4c4D
+#define PCI_DEVICE_ID_ATI_215_LN	0x4c4E
+#define PCI_DEVICE_ID_ATI_215_LR	0x4c52
+#define PCI_DEVICE_ID_ATI_215_LS	0x4c53
+#define PCI_DEVICE_ID_ATI_264_LT	0x4c54
+/* Mach64 VT */
+#define PCI_DEVICE_ID_ATI_264VT		0x5654
+#define PCI_DEVICE_ID_ATI_264VU		0x5655
+#define PCI_DEVICE_ID_ATI_264VV		0x5656
+/* Rage128 Pro GL */
+#define PCI_DEVICE_ID_ATI_Rage128_PA	0x5041
+#define PCI_DEVICE_ID_ATI_Rage128_PB	0x5042
+#define PCI_DEVICE_ID_ATI_Rage128_PC	0x5043
+#define PCI_DEVICE_ID_ATI_Rage128_PD	0x5044
+#define PCI_DEVICE_ID_ATI_Rage128_PE	0x5045
+#define PCI_DEVICE_ID_ATI_RAGE128_PF	0x5046
+/* Rage128 Pro VR */
+#define PCI_DEVICE_ID_ATI_RAGE128_PG	0x5047
+#define PCI_DEVICE_ID_ATI_RAGE128_PH	0x5048
+#define PCI_DEVICE_ID_ATI_RAGE128_PI	0x5049
+#define PCI_DEVICE_ID_ATI_RAGE128_PJ	0x504A
+#define PCI_DEVICE_ID_ATI_RAGE128_PK	0x504B
+#define PCI_DEVICE_ID_ATI_RAGE128_PL	0x504C
+#define PCI_DEVICE_ID_ATI_RAGE128_PM	0x504D
+#define PCI_DEVICE_ID_ATI_RAGE128_PN	0x504E
+#define PCI_DEVICE_ID_ATI_RAGE128_PO	0x504F
+#define PCI_DEVICE_ID_ATI_RAGE128_PP	0x5050
+#define PCI_DEVICE_ID_ATI_RAGE128_PQ	0x5051
+#define PCI_DEVICE_ID_ATI_RAGE128_PR	0x5052
+#define PCI_DEVICE_ID_ATI_RAGE128_TR	0x5452
+#define PCI_DEVICE_ID_ATI_RAGE128_PS	0x5053
+#define PCI_DEVICE_ID_ATI_RAGE128_PT	0x5054
+#define PCI_DEVICE_ID_ATI_RAGE128_PU	0x5055
+#define PCI_DEVICE_ID_ATI_RAGE128_PV	0x5056
+#define PCI_DEVICE_ID_ATI_RAGE128_PW	0x5057
+#define PCI_DEVICE_ID_ATI_RAGE128_PX	0x5058
+/* Rage128 GL */
+#define PCI_DEVICE_ID_ATI_RAGE128_RE	0x5245
+#define PCI_DEVICE_ID_ATI_RAGE128_RF	0x5246
+#define PCI_DEVICE_ID_ATI_RAGE128_RG	0x534b
+#define PCI_DEVICE_ID_ATI_RAGE128_RH	0x534c
+#define PCI_DEVICE_ID_ATI_RAGE128_RI	0x534d
+/* Rage128 VR */
+#define PCI_DEVICE_ID_ATI_RAGE128_RK	0x524b
+#define PCI_DEVICE_ID_ATI_RAGE128_RL	0x524c
+#define PCI_DEVICE_ID_ATI_RAGE128_RM	0x5345
+#define PCI_DEVICE_ID_ATI_RAGE128_RN	0x5346
+#define PCI_DEVICE_ID_ATI_RAGE128_RO	0x5347
+/* Rage128 M3 */
+#define PCI_DEVICE_ID_ATI_RAGE128_LE	0x4c45
+#define PCI_DEVICE_ID_ATI_RAGE128_LF	0x4c46
+/* Rage128 Pro Ultra */
+#define PCI_DEVICE_ID_ATI_RAGE128_U1	0x5446
+#define PCI_DEVICE_ID_ATI_RAGE128_U2	0x544C
+#define PCI_DEVICE_ID_ATI_RAGE128_U3	0x5452
+/* Radeon M4 */
+#define PCI_DEVICE_ID_ATI_RADEON_LE	0x4d45
+#define PCI_DEVICE_ID_ATI_RADEON_LF	0x4d46
+/* Radeon NV-100 */
+#define PCI_DEVICE_ID_ATI_RADEON_N1	0x5159
+#define PCI_DEVICE_ID_ATI_RADEON_N2	0x515a
+/* Radeon */
+#define PCI_DEVICE_ID_ATI_RADEON_RA	0x5144
+#define PCI_DEVICE_ID_ATI_RADEON_RB	0x5145
+#define PCI_DEVICE_ID_ATI_RADEON_RC	0x5146
+#define PCI_DEVICE_ID_ATI_RADEON_RD	0x5147
+
+#define PCI_VENDOR_ID_VLSI		0x1004
+#define PCI_DEVICE_ID_VLSI_82C592	0x0005
+#define PCI_DEVICE_ID_VLSI_82C593	0x0006
+#define PCI_DEVICE_ID_VLSI_82C594	0x0007
+#define PCI_DEVICE_ID_VLSI_82C597	0x0009
+#define PCI_DEVICE_ID_VLSI_82C541	0x000c
+#define PCI_DEVICE_ID_VLSI_82C543	0x000d
+#define PCI_DEVICE_ID_VLSI_82C532	0x0101
+#define PCI_DEVICE_ID_VLSI_82C534	0x0102
+#define PCI_DEVICE_ID_VLSI_82C535	0x0104
+#define PCI_DEVICE_ID_VLSI_82C147	0x0105
+#define PCI_DEVICE_ID_VLSI_VAS96011	0x0702
+
+#define PCI_VENDOR_ID_ADL		0x1005
+#define PCI_DEVICE_ID_ADL_2301		0x2301
+
+#define PCI_VENDOR_ID_NS		0x100b
+#define PCI_DEVICE_ID_NS_87415		0x0002
+#define PCI_DEVICE_ID_NS_87560_LIO	0x000e
+#define PCI_DEVICE_ID_NS_87560_USB	0x0012
+#define PCI_DEVICE_ID_NS_83815		0x0020
+#define	PCI_DEVICE_ID_DP83815		0x0020
+#define PCI_DEVICE_ID_NS_83820		0x0022
+#define PCI_DEVICE_ID_NS_87410		0xd001
+
+#define PCI_VENDOR_ID_TSENG		0x100c
+#define PCI_DEVICE_ID_TSENG_W32P_2	0x3202
+#define PCI_DEVICE_ID_TSENG_W32P_b	0x3205
+#define PCI_DEVICE_ID_TSENG_W32P_c	0x3206
+#define PCI_DEVICE_ID_TSENG_W32P_d	0x3207
+#define PCI_DEVICE_ID_TSENG_ET6000	0x3208
+
+#define PCI_VENDOR_ID_WEITEK		0x100e
+#define PCI_DEVICE_ID_WEITEK_P9000	0x9001
+#define PCI_DEVICE_ID_WEITEK_P9100	0x9100
+
+#define PCI_VENDOR_ID_DEC		0x1011
+#define PCI_DEVICE_ID_DEC_BRD		0x0001
+#define PCI_DEVICE_ID_DEC_TULIP		0x0002
+#define PCI_DEVICE_ID_DEC_TGA		0x0004
+#define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
+#define PCI_DEVICE_ID_DEC_TGA2		0x000D
+#define PCI_DEVICE_ID_DEC_FDDI		0x000F
+#define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
+#define PCI_DEVICE_ID_DEC_21142		0x0019
+#define PCI_DEVICE_ID_DEC_21052		0x0021
+#define PCI_DEVICE_ID_DEC_21150		0x0022
+#define PCI_DEVICE_ID_DEC_21152		0x0024
+#define PCI_DEVICE_ID_DEC_21153		0x0025
+#define PCI_DEVICE_ID_DEC_21154		0x0026
+#define PCI_DEVICE_ID_DEC_21285		0x1065
+#define PCI_DEVICE_ID_COMPAQ_42XX	0x0046
+
+#define PCI_VENDOR_ID_CIRRUS		0x1013
+#define PCI_DEVICE_ID_CIRRUS_7548	0x0038
+#define PCI_DEVICE_ID_CIRRUS_5430	0x00a0
+#define PCI_DEVICE_ID_CIRRUS_5434_4	0x00a4
+#define PCI_DEVICE_ID_CIRRUS_5434_8	0x00a8
+#define PCI_DEVICE_ID_CIRRUS_5436	0x00ac
+#define PCI_DEVICE_ID_CIRRUS_5446	0x00b8
+#define PCI_DEVICE_ID_CIRRUS_5480	0x00bc
+#define PCI_DEVICE_ID_CIRRUS_5462	0x00d0
+#define PCI_DEVICE_ID_CIRRUS_5464	0x00d4
+#define PCI_DEVICE_ID_CIRRUS_5465	0x00d6
+#define PCI_DEVICE_ID_CIRRUS_6729	0x1100
+#define PCI_DEVICE_ID_CIRRUS_6832	0x1110
+#define PCI_DEVICE_ID_CIRRUS_7542	0x1200
+#define PCI_DEVICE_ID_CIRRUS_7543	0x1202
+#define PCI_DEVICE_ID_CIRRUS_7541	0x1204
+
+#define PCI_VENDOR_ID_IBM		0x1014
+#define PCI_DEVICE_ID_IBM_FIRE_CORAL	0x000a
+#define PCI_DEVICE_ID_IBM_TR		0x0018
+#define PCI_DEVICE_ID_IBM_82G2675	0x001d
+#define PCI_DEVICE_ID_IBM_MCA		0x0020
+#define PCI_DEVICE_ID_IBM_82351		0x0022
+#define PCI_DEVICE_ID_IBM_PYTHON	0x002d
+#define PCI_DEVICE_ID_IBM_SERVERAID	0x002e
+#define PCI_DEVICE_ID_IBM_TR_WAKE	0x003e
+#define PCI_DEVICE_ID_IBM_MPIC		0x0046
+#define PCI_DEVICE_ID_IBM_3780IDSP	0x007d
+#define PCI_DEVICE_ID_IBM_CHUKAR	0x0096
+#define	PCI_DEVICE_ID_IBM_405GP		0x0156
+#define PCI_DEVICE_ID_IBM_SERVERAIDI960	0x01bd
+#define PCI_DEVICE_ID_IBM_MPIC_2	0xffff
+
+#define PCI_VENDOR_ID_COMPEX2		0x101a // pci.ids says "AT&T GIS (NCR)"
+#define PCI_DEVICE_ID_COMPEX2_100VG	0x0005
+
+#define PCI_VENDOR_ID_WD		0x101c
+#define PCI_DEVICE_ID_WD_7197		0x3296
+
+#define PCI_VENDOR_ID_AMI		0x101e
+#define PCI_DEVICE_ID_AMI_MEGARAID3	0x1960
+#define PCI_DEVICE_ID_AMI_MEGARAID	0x9010
+#define PCI_DEVICE_ID_AMI_MEGARAID2	0x9060
+
+#define PCI_VENDOR_ID_AMD		0x1022
+
+#define PCI_DEVICE_ID_AMD_LANCE		0x2000
+#define PCI_DEVICE_ID_AMD_LANCE_HOME	0x2001
+#define PCI_DEVICE_ID_AMD_HOMEPNA	0x2001
+#define PCI_DEVICE_ID_AMD_SCSI		0x2020
+#define PCI_DEVICE_ID_AMD_FE_GATE_7006	0x7006
+#define PCI_DEVICE_ID_AMD_FE_GATE_7007	0x7007
+#define PCI_DEVICE_ID_AMD_FE_GATE_700C	0x700C
+#define PCI_DEVIDE_ID_AMD_FE_GATE_700D	0x700D
+#define PCI_DEVICE_ID_AMD_FE_GATE_700E	0x700E
+#define PCI_DEVICE_ID_AMD_FE_GATE_700F	0x700F
+#define PCI_DEVICE_ID_AMD_COBRA_7400	0x7400
+#define PCI_DEVICE_ID_AMD_COBRA_7401	0x7401
+#define PCI_DEVICE_ID_AMD_COBRA_7403	0x7403
+#define PCI_DEVICE_ID_AMD_COBRA_7404	0x7404
+#define PCI_DEVICE_ID_AMD_VIPER_7408	0x7408
+#define PCI_DEVICE_ID_AMD_VIPER_7409	0x7409
+#define PCI_DEVICE_ID_AMD_VIPER_740B	0x740B
+#define PCI_DEVICE_ID_AMD_VIPER_740C	0x740C
+#define PCI_DEVICE_ID_AMD_VIPER_7410	0x7410
+#define PCI_DEVICE_ID_AMD_VIPER_7411	0x7411
+#define PCI_DEVICE_ID_AMD_VIPER_7413	0x7413
+#define PCI_DEVICE_ID_AMD_VIPER_7414	0x7414
+#define PCI_DEVICE_ID_AMD_VIPER_7440	0x7440
+#define PCI_DEVICE_ID_AMD_VIPER_7441	0x7441
+#define PCI_DEVICE_ID_AMD_VIPER_7443	0x7443
+#define PCI_DEVICE_ID_AMD_VIPER_7448	0x7448
+#define PCI_DEVICE_ID_AMD_VIPER_7449	0x7449
+
+#define PCI_VENDOR_ID_TRIDENT		0x1023
+#define PCI_DEVICE_ID_TRIDENT_4DWAVE_DX	0x2000
+#define PCI_DEVICE_ID_TRIDENT_4DWAVE_NX	0x2001
+#define PCI_DEVICE_ID_TRIDENT_9320	0x9320
+#define PCI_DEVICE_ID_TRIDENT_9388	0x9388
+#define PCI_DEVICE_ID_TRIDENT_9397	0x9397
+#define PCI_DEVICE_ID_TRIDENT_939A	0x939A
+#define PCI_DEVICE_ID_TRIDENT_9520	0x9520
+#define PCI_DEVICE_ID_TRIDENT_9525	0x9525
+#define PCI_DEVICE_ID_TRIDENT_9420	0x9420
+#define PCI_DEVICE_ID_TRIDENT_9440	0x9440
+#define PCI_DEVICE_ID_TRIDENT_9660	0x9660
+#define PCI_DEVICE_ID_TRIDENT_9750	0x9750
+#define PCI_DEVICE_ID_TRIDENT_9850	0x9850
+#define PCI_DEVICE_ID_TRIDENT_9880	0x9880
+#define PCI_DEVICE_ID_TRIDENT_8400	0x8400
+#define PCI_DEVICE_ID_TRIDENT_8420	0x8420
+#define PCI_DEVICE_ID_TRIDENT_8500	0x8500
+
+#define PCI_VENDOR_ID_AI		0x1025
+#define PCI_DEVICE_ID_AI_M1435		0x1435
+
+#define PCI_VENDOR_ID_DELL              0x1028
+
+#define PCI_VENDOR_ID_MATROX		0x102B
+#define PCI_DEVICE_ID_MATROX_MGA_2	0x0518
+#define PCI_DEVICE_ID_MATROX_MIL	0x0519
+#define PCI_DEVICE_ID_MATROX_MYS	0x051A
+#define PCI_DEVICE_ID_MATROX_MIL_2	0x051b
+#define PCI_DEVICE_ID_MATROX_MIL_2_AGP	0x051f
+#define PCI_DEVICE_ID_MATROX_MGA_IMP	0x0d10
+#define PCI_DEVICE_ID_MATROX_G100_MM	0x1000
+#define PCI_DEVICE_ID_MATROX_G100_AGP	0x1001
+#define PCI_DEVICE_ID_MATROX_G200_PCI	0x0520
+#define PCI_DEVICE_ID_MATROX_G200_AGP	0x0521
+#define	PCI_DEVICE_ID_MATROX_G400	0x0525
+#define PCI_DEVICE_ID_MATROX_G550	0x2527
+#define PCI_DEVICE_ID_MATROX_VIA	0x4536
+
+#define PCI_VENDOR_ID_CT		0x102c
+#define PCI_DEVICE_ID_CT_65545		0x00d8
+#define PCI_DEVICE_ID_CT_65548		0x00dc
+#define PCI_DEVICE_ID_CT_65550		0x00e0
+#define PCI_DEVICE_ID_CT_65554		0x00e4
+#define PCI_DEVICE_ID_CT_65555		0x00e5
+
+#define PCI_VENDOR_ID_MIRO		0x1031
+#define PCI_DEVICE_ID_MIRO_36050	0x5601
+
+#define PCI_VENDOR_ID_NEC		0x1033
+#define PCI_DEVICE_ID_NEC_PCX2		0x0046
+#define PCI_DEVICE_ID_NEC_NILE4		0x005a
+#define PCI_DEVICE_ID_NEC_VRC5476       0x009b
+
+#define PCI_VENDOR_ID_FD		0x1036
+#define PCI_DEVICE_ID_FD_36C70		0x0000
+
+#define PCI_VENDOR_ID_SIS         	0x1039
+#define PCI_VENDOR_ID_SI		0x1039
+#define PCI_DEVICE_ID_SI_5591_AGP	0x0001
+#define PCI_DEVICE_ID_SI_6202		0x0002
+#define PCI_DEVICE_ID_SI_503		0x0008
+#define PCI_DEVICE_ID_SI_ACPI		0x0009
+#define PCI_DEVICE_ID_SI_5597_VGA	0x0200
+#define PCI_DEVICE_ID_SI_6205		0x0205
+#define PCI_DEVICE_ID_SI_501		0x0406
+#define PCI_DEVICE_ID_SI_496		0x0496
+#define PCI_DEVICE_ID_SI_300		0x0300
+#define PCI_DEVICE_ID_SI_315H		0x0310
+#define PCI_DEVICE_ID_SI_315		0x0315
+#define PCI_DEVICE_ID_SI_315PRO		0x0325
+#define PCI_DEVICE_ID_SI_530		0x0530
+#define PCI_DEVICE_ID_SI_540		0x0540
+#define PCI_DEVICE_ID_SI_550		0x0550
+#define PCI_DEVICE_ID_SI_601		0x0601
+#define PCI_DEVICE_ID_SI_620		0x0620
+#define PCI_DEVICE_ID_SI_630		0x0630
+#define PCI_DEVICE_ID_SI_635		0x0635
+#define PCI_DEVICE_ID_SI_640		0x0640
+#define PCI_DEVICE_ID_SI_645		0x0645
+#define PCI_DEVICE_ID_SI_650		0x0650
+#define PCI_DEVICE_ID_SI_730		0x0730
+#define PCI_DEVICE_ID_SI_735		0x0735
+#define PCI_DEVICE_ID_SI_740		0x0740
+#define PCI_DEVICE_ID_SI_745		0x0745
+#define PCI_DEVICE_ID_SI_750		0x0750
+#define PCI_DEVICE_ID_SI_900		0x0900
+#define PCI_DEVICE_ID_SIS900		0x0900
+#define PCI_DEVICE_ID_SI_5107		0x5107
+#define PCI_DEVICE_ID_SI_5300		0x5300
+#define PCI_DEVICE_ID_SI_540_VGA	0x5300
+#define PCI_DEVICE_ID_SI_550_VGA	0x5315
+#define PCI_DEVICE_ID_SI_5511		0x5511
+#define PCI_DEVICE_ID_SI_5513		0x5513
+#define PCI_DEVICE_ID_SI_5571		0x5571
+#define PCI_DEVICE_ID_SI_5591		0x5591
+#define PCI_DEVICE_ID_SI_5597		0x5597
+#define PCI_DEVICE_ID_SI_5598		0x5598
+#define PCI_DEVICE_ID_SI_5600		0x5600
+#define PCI_DEVICE_ID_SI_6300		0x6300
+#define PCI_DEVICE_ID_SI_630_VGA	0x6300
+#define PCI_DEVICE_ID_SI_6306		0x6306
+#define PCI_DEVICE_ID_SI_6326		0x6326
+#define PCI_DEVICE_ID_SI_7001		0x7001
+#define PCI_DEVICE_ID_SI_7016		0x7016
+#define PCI_DEVICE_ID_SIS7016    	0x7016  
+#define PCI_DEVICE_ID_SI_730_VGA	0x7300
+
+#define PCI_VENDOR_ID_HP		0x103c
+#define PCI_DEVICE_ID_HP_DONNER_GFX	0x1008
+#define PCI_DEVICE_ID_HP_TACHYON	0x1028
+#define PCI_DEVICE_ID_HP_TACHLITE	0x1029
+#define PCI_DEVICE_ID_HP_J2585A		0x1030
+#define PCI_DEVICE_ID_HP_J2585B		0x1031
+#define PCI_DEVICE_ID_HP_SAS		0x1048
+#define PCI_DEVICE_ID_HP_DIVA1		0x1049
+#define PCI_DEVICE_ID_HP_DIVA2		0x104A
+#define PCI_DEVICE_ID_HP_SP2_0		0x104B
+
+#define PCI_VENDOR_ID_PCTECH		0x1042
+#define PCI_DEVICE_ID_PCTECH_RZ1000	0x1000
+#define PCI_DEVICE_ID_PCTECH_RZ1001	0x1001
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_0	0x3000
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_1	0x3010
+#define PCI_DEVICE_ID_PCTECH_SAMURAI_IDE 0x3020
+
+#define PCI_VENDOR_ID_ASUSTEK		0x1043
+#define PCI_DEVICE_ID_ASUSTEK_0675	0x0675
+
+#define PCI_VENDOR_ID_DPT		0x1044
+#define PCI_DEVICE_ID_DPT		0xa400
+
+#define PCI_VENDOR_ID_OPTI		0x1045
+#define PCI_DEVICE_ID_OPTI_92C178	0xc178
+#define PCI_DEVICE_ID_OPTI_82C557	0xc557
+#define PCI_DEVICE_ID_OPTI_82C558	0xc558
+#define PCI_DEVICE_ID_OPTI_82C621	0xc621
+#define PCI_DEVICE_ID_OPTI_82C700	0xc700
+#define PCI_DEVICE_ID_OPTI_82C701	0xc701
+#define PCI_DEVICE_ID_OPTI_82C814	0xc814
+#define PCI_DEVICE_ID_OPTI_82C822	0xc822
+#define PCI_DEVICE_ID_OPTI_82C861	0xc861
+#define PCI_DEVICE_ID_OPTI_82C825	0xd568
+
+#define PCI_VENDOR_ID_ELSA		0x1048
+#define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+#define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+
+#define PCI_VENDOR_ID_ELSA		0x1048
+#define PCI_DEVICE_ID_ELSA_MICROLINK	0x1000
+#define PCI_DEVICE_ID_ELSA_QS3000	0x3000
+
+#define PCI_VENDOR_ID_SGS		0x104a
+#define PCI_DEVICE_ID_SGS_2000		0x0008
+#define PCI_DEVICE_ID_SGS_1764		0x0009
+
+#define PCI_VENDOR_ID_BUSLOGIC		      0x104B
+#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC 0x0140
+#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER    0x1040
+#define PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT     0x8130
+
+#define PCI_VENDOR_ID_TI		0x104c
+#define PCI_DEVICE_ID_TI_TVP4010	0x3d04
+#define PCI_DEVICE_ID_TI_TVP4020	0x3d07
+#define PCI_DEVICE_ID_TI_1130		0xac12
+#define PCI_DEVICE_ID_TI_1031		0xac13
+#define PCI_DEVICE_ID_TI_1131		0xac15
+#define PCI_DEVICE_ID_TI_1250		0xac16
+#define PCI_DEVICE_ID_TI_1220		0xac17
+#define PCI_DEVICE_ID_TI_1221		0xac19
+#define PCI_DEVICE_ID_TI_1210		0xac1a
+#define PCI_DEVICE_ID_TI_1410		0xac50
+#define PCI_DEVICE_ID_TI_1450		0xac1b
+#define PCI_DEVICE_ID_TI_1225		0xac1c
+#define PCI_DEVICE_ID_TI_1251A		0xac1d
+#define PCI_DEVICE_ID_TI_1211		0xac1e
+#define PCI_DEVICE_ID_TI_1251B		0xac1f
+#define PCI_DEVICE_ID_TI_4410		0xac41
+#define PCI_DEVICE_ID_TI_4451		0xac42
+#define PCI_DEVICE_ID_TI_1420		0xac51
+
+#define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_CXD3222	0x8039
+
+#define PCI_VENDOR_ID_OAK		0x104e
+#define PCI_DEVICE_ID_OAK_OTI107	0x0107
+
+/* Winbond have two vendor IDs! See 0x10ad as well */
+#define PCI_VENDOR_ID_WINBOND2		0x1050
+#define PCI_DEVICE_ID_WINBOND2_89C840   0x0840
+#define PCI_DEVICE_ID_WINBOND2_89C940	0x0940
+#define PCI_DEVICE_ID_WINBOND2_89C940F	0x5a5a
+#define PCI_DEVICE_ID_WINBOND2_6692	0x6692
+
+#define PCI_VENDOR_ID_ANIGMA		0x1051
+#define PCI_DEVICE_ID_ANIGMA_MC145575	0x0100
+  
+#define PCI_VENDOR_ID_EFAR		0x1055
+#define PCI_DEVICE_ID_EFAR_SLC90E66_1	0x9130
+#define PCI_DEVICE_ID_EFAR_SLC90E66_0	0x9460
+#define PCI_DEVICE_ID_EFAR_SLC90E66_2	0x9462
+#define PCI_DEVICE_ID_EFAR_SLC90E66_3	0x9463
+
+#define PCI_VENDOR_ID_MOTOROLA		0x1057
+#define PCI_VENDOR_ID_MOTOROLA_OOPS	0x1507
+#define PCI_DEVICE_ID_MOTOROLA_MPC105	0x0001
+#define PCI_DEVICE_ID_MOTOROLA_MPC106	0x0002
+#define PCI_DEVICE_ID_MOTOROLA_RAVEN	0x4801
+#define PCI_DEVICE_ID_MOTOROLA_FALCON	0x4802
+#define PCI_DEVICE_ID_MOTOROLA_CPX8216	0x4806
+
+#define PCI_VENDOR_ID_PROMISE		0x105a
+#define PCI_DEVICE_ID_PROMISE_20265	0x0d30
+#define PCI_DEVICE_ID_PROMISE_20267	0x4d30
+#define PCI_DEVICE_ID_PROMISE_20246	0x4d33
+#define PCI_DEVICE_ID_PROMISE_20262	0x4d38
+#define PCI_DEVICE_ID_PROMISE_20268	0x4d68
+#define PCI_DEVICE_ID_PROMISE_20268R	0x6268
+#define PCI_DEVICE_ID_PROMISE_20269	0x4d69
+#define PCI_DEVICE_ID_PROMISE_20275	0x1275
+#define PCI_DEVICE_ID_PROMISE_5300	0x5300
+
+#define PCI_VENDOR_ID_N9		0x105d
+#define PCI_DEVICE_ID_N9_I128		0x2309
+#define PCI_DEVICE_ID_N9_I128_2		0x2339
+#define PCI_DEVICE_ID_N9_I128_T2R	0x493d
+
+#define PCI_VENDOR_ID_UMC		0x1060
+#define PCI_DEVICE_ID_UMC_UM8673F	0x0101
+#define PCI_DEVICE_ID_UMC_UM8891A	0x0891
+#define PCI_DEVICE_ID_UMC_UM8886BF	0x673a
+#define PCI_DEVICE_ID_UMC_UM8886A	0x886a
+#define PCI_DEVICE_ID_UMC_UM8881F	0x8881
+#define PCI_DEVICE_ID_UMC_UM8886F	0x8886
+#define PCI_DEVICE_ID_UMC_UM9017F	0x9017
+#define PCI_DEVICE_ID_UMC_UM8886N	0xe886
+#define PCI_DEVICE_ID_UMC_UM8891N	0xe891
+
+#define PCI_VENDOR_ID_X			0x1061
+#define PCI_DEVICE_ID_X_AGX016		0x0001
+
+#define PCI_VENDOR_ID_MYLEX		0x1069
+#define PCI_DEVICE_ID_MYLEX_DAC960_P	0x0001
+#define PCI_DEVICE_ID_MYLEX_DAC960_PD	0x0002
+#define PCI_DEVICE_ID_MYLEX_DAC960_PG	0x0010
+#define PCI_DEVICE_ID_MYLEX_DAC960_LA	0x0020
+#define PCI_DEVICE_ID_MYLEX_DAC960_LP	0x0050
+#define PCI_DEVICE_ID_MYLEX_DAC960_BA	0xBA56
+
+#define PCI_VENDOR_ID_PICOP		0x1066
+#define PCI_DEVICE_ID_PICOP_PT86C52X	0x0001
+#define PCI_DEVICE_ID_PICOP_PT80C524	0x8002
+
+#define PCI_VENDOR_ID_APPLE		0x106b
+#define PCI_DEVICE_ID_APPLE_BANDIT	0x0001
+#define PCI_DEVICE_ID_APPLE_GC		0x0002
+#define PCI_DEVICE_ID_APPLE_HYDRA	0x000e
+#define PCI_DEVICE_ID_APPLE_UNI_N_FW	0x0018
+#define PCI_DEVICE_ID_APPLE_KL_USB	0x0019
+#define PCI_DEVICE_ID_APPLE_UNI_N_AGP	0x0020
+#define PCI_DEVICE_ID_APPLE_UNI_N_GMAC	0x0021
+#define PCI_DEVICE_ID_APPLE_UNI_N_FW2	0x0030
+
+#define PCI_VENDOR_ID_YAMAHA		0x1073
+#define PCI_DEVICE_ID_YAMAHA_724	0x0004
+#define PCI_DEVICE_ID_YAMAHA_724F	0x000d
+#define PCI_DEVICE_ID_YAMAHA_740	0x000a
+#define PCI_DEVICE_ID_YAMAHA_740C	0x000c
+#define PCI_DEVICE_ID_YAMAHA_744	0x0010
+#define PCI_DEVICE_ID_YAMAHA_754	0x0012
+
+#define PCI_VENDOR_ID_NEXGEN		0x1074
+#define PCI_DEVICE_ID_NEXGEN_82C501	0x4e78
+
+#define PCI_VENDOR_ID_QLOGIC		0x1077
+#define PCI_DEVICE_ID_QLOGIC_ISP1020	0x1020
+#define PCI_DEVICE_ID_QLOGIC_ISP1022	0x1022
+#define PCI_DEVICE_ID_QLOGIC_ISP2100	0x2100
+#define PCI_DEVICE_ID_QLOGIC_ISP2200	0x2200
+
+#define PCI_VENDOR_ID_CYRIX		0x1078
+#define PCI_DEVICE_ID_CYRIX_5510	0x0000
+#define PCI_DEVICE_ID_CYRIX_PCI_MASTER	0x0001
+#define PCI_DEVICE_ID_CYRIX_5520	0x0002
+#define PCI_DEVICE_ID_CYRIX_5530_LEGACY	0x0100
+#define PCI_DEVICE_ID_CYRIX_5530_SMI	0x0101
+#define PCI_DEVICE_ID_CYRIX_5530_IDE	0x0102
+#define PCI_DEVICE_ID_CYRIX_5530_AUDIO	0x0103
+#define PCI_DEVICE_ID_CYRIX_5530_VIDEO	0x0104
+
+#define PCI_VENDOR_ID_LEADTEK		0x107d
+#define PCI_DEVICE_ID_LEADTEK_805	0x0000
+
+#define PCI_VENDOR_ID_INTERPHASE	0x107e
+#define PCI_DEVICE_ID_INTERPHASE_5526	0x0004
+#define PCI_DEVICE_ID_INTERPHASE_55x6	0x0005
+#define PCI_DEVICE_ID_INTERPHASE_5575	0x0008
+
+#define PCI_VENDOR_ID_CONTAQ		0x1080
+#define PCI_DEVICE_ID_CONTAQ_82C599	0x0600
+#define PCI_DEVICE_ID_CONTAQ_82C693	0xc693
+
+#define PCI_VENDOR_ID_FOREX		0x1083
+
+#define PCI_VENDOR_ID_OLICOM		0x108d
+#define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
+#define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
+#define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
+#define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
+#define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
+#define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
+
+#define PCI_VENDOR_ID_SUN		0x108e
+#define PCI_DEVICE_ID_SUN_EBUS		0x1000
+#define PCI_DEVICE_ID_SUN_HAPPYMEAL	0x1001
+#define PCI_DEVICE_ID_SUN_RIO_EBUS	0x1100
+#define PCI_DEVICE_ID_SUN_RIO_GEM	0x1101
+#define PCI_DEVICE_ID_SUN_RIO_1394	0x1102
+#define PCI_DEVICE_ID_SUN_RIO_USB	0x1103
+#define PCI_DEVICE_ID_SUN_GEM		0x2bad
+#define PCI_DEVICE_ID_SUN_SIMBA		0x5000
+#define PCI_DEVICE_ID_SUN_PBM		0x8000
+#define PCI_DEVICE_ID_SUN_SCHIZO	0x8001
+#define PCI_DEVICE_ID_SUN_SABRE		0xa000
+#define PCI_DEVICE_ID_SUN_HUMMINGBIRD	0xa001
+
+#define PCI_VENDOR_ID_CMD		0x1095
+#define PCI_DEVICE_ID_CMD_640		0x0640
+#define PCI_DEVICE_ID_CMD_643		0x0643
+#define PCI_DEVICE_ID_CMD_646		0x0646
+#define PCI_DEVICE_ID_CMD_647		0x0647
+#define PCI_DEVICE_ID_CMD_648		0x0648
+#define PCI_DEVICE_ID_CMD_649		0x0649
+#define PCI_DEVICE_ID_CMD_670		0x0670
+#define PCI_DEVICE_ID_CMD_680		0x0680
+
+#define PCI_VENDOR_ID_VISION		0x1098
+#define PCI_DEVICE_ID_VISION_QD8500	0x0001
+#define PCI_DEVICE_ID_VISION_QD8580	0x0002
+
+#define PCI_VENDOR_ID_BROOKTREE		0x109e
+#define PCI_DEVICE_ID_BROOKTREE_848	0x0350
+#define PCI_DEVICE_ID_BROOKTREE_849A	0x0351
+#define PCI_DEVICE_ID_BROOKTREE_878_1	0x036e
+#define PCI_DEVICE_ID_BROOKTREE_878	0x0878
+#define PCI_DEVICE_ID_BROOKTREE_8474	0x8474
+
+#define PCI_VENDOR_ID_SIERRA		0x10a8
+#define PCI_DEVICE_ID_SIERRA_STB	0x0000
+
+#define PCI_VENDOR_ID_SGI		0x10a9
+#define PCI_DEVICE_ID_SGI_IOC3		0x0003
+
+#define PCI_VENDOR_ID_ACC		0x10aa
+#define PCI_DEVICE_ID_ACC_2056		0x0000
+
+#define PCI_VENDOR_ID_WINBOND		0x10ad
+#define PCI_DEVICE_ID_WINBOND_83769	0x0001
+#define PCI_DEVICE_ID_WINBOND_82C105	0x0105
+#define PCI_DEVICE_ID_WINBOND_83C553	0x0565
+
+#define PCI_VENDOR_ID_DATABOOK		0x10b3
+#define PCI_DEVICE_ID_DATABOOK_87144	0xb106
+
+#define PCI_VENDOR_ID_PLX		0x10b5
+#define PCI_DEVICE_ID_PLX_R685		0x1030
+#define PCI_DEVICE_ID_PLX_ROMULUS	0x106a
+#define PCI_DEVICE_ID_PLX_SPCOM800	0x1076
+#define PCI_DEVICE_ID_PLX_1077		0x1077
+#define PCI_DEVICE_ID_PLX_SPCOM200	0x1103
+#define PCI_DEVICE_ID_PLX_DJINN_ITOO	0x1151
+#define PCI_DEVICE_ID_PLX_R753		0x1152
+#define PCI_DEVICE_ID_PLX_9050		0x9050
+#define PCI_DEVICE_ID_PLX_9060		0x9060
+#define PCI_DEVICE_ID_PLX_9060ES	0x906E
+#define PCI_DEVICE_ID_PLX_9060SD	0x906D
+#define PCI_DEVICE_ID_PLX_9080		0x9080
+#define PCI_DEVICE_ID_PLX_GTEK_SERIAL2	0xa001
+
+#define PCI_VENDOR_ID_MADGE		0x10b6
+#define PCI_DEVICE_ID_MADGE_MK2		0x0002
+#define PCI_DEVICE_ID_MADGE_C155S	0x1001
+
+#define PCI_VENDOR_ID_3COM		0x10b7
+#define PCI_DEVICE_ID_3COM_3C985	0x0001
+#define PCI_DEVICE_ID_3COM_3C339	0x3390
+#define PCI_DEVICE_ID_3COM_3C590	0x5900
+#define PCI_DEVICE_ID_3COM_3C595	0x5950
+#define PCI_DEVICE_ID_3COM_3C595TX	0x5950
+#define PCI_DEVICE_ID_3COM_3C595_1	0x5951
+#define PCI_DEVICE_ID_3COM_3C595T4	0x5951
+#define PCI_DEVICE_ID_3COM_3C595_2	0x5952
+#define PCI_DEVICE_ID_3COM_3C595MII	0x5952
+#define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
+#define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
+#define PCI_DEVICE_ID_3COM_3C905TX	0x9050
+#define PCI_DEVICE_ID_3COM_3C905T4	0x9051
+#define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
+#define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
+
+#define PCI_VENDOR_ID_SMC		0x10b8
+#define PCI_DEVICE_ID_SMC_EPIC100	0x0005
+
+#define PCI_VENDOR_ID_SUNDANCE		0x13F0
+#define PCI_DEVICE_ID_SUNDANCE_ALTA	0x0201
+
+#define PCI_VENDOR_ID_AL		0x10b9
+#define PCI_DEVICE_ID_AL_M1445		0x1445
+#define PCI_DEVICE_ID_AL_M1449		0x1449
+#define PCI_DEVICE_ID_AL_M1451		0x1451
+#define PCI_DEVICE_ID_AL_M1461		0x1461
+#define PCI_DEVICE_ID_AL_M1489		0x1489
+#define PCI_DEVICE_ID_AL_M1511		0x1511
+#define PCI_DEVICE_ID_AL_M1513		0x1513
+#define PCI_DEVICE_ID_AL_M1521		0x1521
+#define PCI_DEVICE_ID_AL_M1523		0x1523
+#define PCI_DEVICE_ID_AL_M1531		0x1531
+#define PCI_DEVICE_ID_AL_M1533		0x1533
+#define PCI_DEVICE_ID_AL_M1541		0x1541
+#define PCI_DEVICE_ID_AL_M1621          0x1621
+#define PCI_DEVICE_ID_AL_M1631          0x1631
+#define PCI_DEVICE_ID_AL_M1641          0x1641
+#define PCI_DEVICE_ID_AL_M1647          0x1647
+#define PCI_DEVICE_ID_AL_M1651          0x1651
+#define PCI_DEVICE_ID_AL_M1543		0x1543
+#define PCI_DEVICE_ID_AL_M3307		0x3307
+#define PCI_DEVICE_ID_AL_M4803		0x5215
+#define PCI_DEVICE_ID_AL_M5219		0x5219
+#define PCI_DEVICE_ID_AL_M5229		0x5229
+#define PCI_DEVICE_ID_AL_M5237		0x5237
+#define PCI_DEVICE_ID_AL_M5243		0x5243
+#define PCI_DEVICE_ID_AL_M5451		0x5451
+#define PCI_DEVICE_ID_AL_M7101		0x7101
+
+#define PCI_VENDOR_ID_MITSUBISHI	0x10ba
+
+#define PCI_VENDOR_ID_SURECOM		0x10bd
+#define PCI_DEVICE_ID_SURECOM_NE34	0x0e34
+
+#define PCI_VENDOR_ID_NEOMAGIC		0x10c8
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2070 0x0001
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128V 0x0002
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZV 0x0003
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2160 0x0004
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICMEDIA_256AV       0x0005
+#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZVPLUS   0x0083
+
+#define PCI_VENDOR_ID_ASP		0x10cd
+#define PCI_DEVICE_ID_ASP_ABP940	0x1200
+#define PCI_DEVICE_ID_ASP_ABP940U	0x1300
+#define PCI_DEVICE_ID_ASP_ABP940UW	0x2300
+
+#define PCI_VENDOR_ID_MACRONIX		0x10d9
+#define PCI_DEVICE_ID_MACRONIX_MX98713	0x0512
+#define PCI_DEVICE_ID_MX987x3		0x0512
+#define PCI_DEVICE_ID_MACRONIX_MX987x5	0x0531
+#define PCI_DEVICE_ID_MX987x5		0x0531
+
+#define PCI_VENDOR_ID_TCONRAD		0x10da
+#define PCI_DEVICE_ID_TCONRAD_TOKENRING	0x0508
+
+#define PCI_VENDOR_ID_CERN		0x10dc
+#define PCI_DEVICE_ID_CERN_SPSB_PMC	0x0001
+#define PCI_DEVICE_ID_CERN_SPSB_PCI	0x0002
+#define PCI_DEVICE_ID_CERN_HIPPI_DST	0x0021
+#define PCI_DEVICE_ID_CERN_HIPPI_SRC	0x0022
+
+#define PCI_VENDOR_ID_NVIDIA			0x10de
+#define PCI_DEVICE_ID_NVIDIA_TNT		0x0020
+#define PCI_DEVICE_ID_NVIDIA_TNT2		0x0028
+#define PCI_DEVICE_ID_NVIDIA_UTNT2		0x0029
+#define PCI_DEVICE_ID_NVIDIA_VTNT2		0x002C
+#define PCI_DEVICE_ID_NVIDIA_UVTNT2		0x002D
+#define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR	0x0100
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR	0x0101
+#define PCI_DEVICE_ID_NVIDIA_QUADRO		0x0103
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX	0x0110
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2	0x0111
+#define PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR	0x0113
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS	0x0150
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2	0x0151
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA	0x0152
+#define PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO	0x0153
+
+#define PCI_VENDOR_ID_IMS		0x10e0
+#define PCI_DEVICE_ID_IMS_8849		0x8849
+#define PCI_DEVICE_ID_IMS_TT128		0x9128
+#define PCI_DEVICE_ID_IMS_TT3D		0x9135
+
+#define PCI_VENDOR_ID_TEKRAM2		0x10e1
+#define PCI_DEVICE_ID_TEKRAM2_690c	0x690c
+
+#define PCI_VENDOR_ID_TUNDRA		0x10e3
+#define PCI_DEVICE_ID_TUNDRA_CA91C042	0x0000
+
+#define PCI_VENDOR_ID_AMCC		0x10e8
+#define PCI_DEVICE_ID_AMCC_MYRINET	0x8043
+#define PCI_DEVICE_ID_AMCC_PARASTATION	0x8062
+#define PCI_DEVICE_ID_AMCC_S5933	0x807d
+#define PCI_DEVICE_ID_AMCC_S5933_HEPC3	0x809c
+
+#define PCI_VENDOR_ID_INTERG		0x10ea
+#define PCI_DEVICE_ID_INTERG_1680	0x1680
+#define PCI_DEVICE_ID_INTERG_1682	0x1682
+#define PCI_DEVICE_ID_INTERG_2000	0x2000
+#define PCI_DEVICE_ID_INTERG_2010	0x2010
+#define PCI_DEVICE_ID_INTERG_5000	0x5000
+#define PCI_DEVICE_ID_INTERG_5050	0x5050
+
+#define PCI_VENDOR_ID_REALTEK		0x10ec
+#define PCI_DEVICE_ID_REALTEK_8029	0x8029
+#define PCI_DEVICE_ID_REALTEK_8129	0x8129
+#define PCI_DEVICE_ID_REALTEK_8139	0x8139
+
+#define PCI_VENDOR_ID_XILINX		0x10ee
+#define PCI_DEVICE_ID_TURBOPAM		0x4020
+
+#define PCI_VENDOR_ID_TRUEVISION	0x10fa
+#define PCI_DEVICE_ID_TRUEVISION_T1000	0x000c
+
+#define PCI_VENDOR_ID_INIT		0x1101
+#define PCI_DEVICE_ID_INIT_320P		0x9100
+#define PCI_DEVICE_ID_INIT_360P		0x9500
+
+#define PCI_VENDOR_ID_CREATIVE		0x1102 // duplicate: ECTIVA
+#define PCI_DEVICE_ID_CREATIVE_EMU10K1	0x0002
+
+#define PCI_VENDOR_ID_ECTIVA		0x1102 // duplicate: CREATIVE
+#define PCI_DEVICE_ID_ECTIVA_EV1938	0x8938
+
+#define PCI_VENDOR_ID_TTI		0x1103
+#define PCI_DEVICE_ID_TTI_HPT343	0x0003
+#define PCI_DEVICE_ID_TTI_HPT366	0x0004
+
+#define PCI_VENDOR_ID_VIA		0x1106
+#define PCI_VENDOR_ID_VIATEC		0x1106
+#define PCI_DEVICE_ID_VIA_8363_0	0x0305
+#define PCI_DEVICE_ID_VIA_8371_0	0x0391
+#define PCI_DEVICE_ID_VIA_8501_0	0x0501
+#define PCI_DEVICE_ID_VIA_82C505	0x0505
+#define PCI_DEVICE_ID_VIA_82C561	0x0561
+#define PCI_DEVICE_ID_VIA_82C586_1	0x0571
+#define PCI_DEVICE_ID_VIA_82C576	0x0576
+#define PCI_DEVICE_ID_VIA_82C585	0x0585
+#define PCI_DEVICE_ID_VIA_82C586_0	0x0586
+#define PCI_DEVICE_ID_VIA_82C595	0x0595
+#define PCI_DEVICE_ID_VIA_82C596	0x0596
+#define PCI_DEVICE_ID_VIA_82C597_0	0x0597
+#define PCI_DEVICE_ID_VIA_82C598_0	0x0598
+#define PCI_DEVICE_ID_VIA_8601_0	0x0601
+#define PCI_DEVICE_ID_VIA_8605_0	0x0605
+#define PCI_DEVICE_ID_VIA_82C680	0x0680
+#define PCI_DEVICE_ID_VIA_82C686	0x0686
+#define PCI_DEVICE_ID_VIA_82C691	0x0691
+#define PCI_DEVICE_ID_VIA_82C693	0x0693
+#define PCI_DEVICE_ID_VIA_82C693_1	0x0698
+#define PCI_DEVICE_ID_VIA_82C926	0x0926
+#define PCI_DEVICE_ID_VIA_82C576_1	0x1571
+#define PCI_DEVICE_ID_VIA_82C595_97	0x1595
+#define PCI_DEVICE_ID_VIA_82C586_2	0x3038
+#define PCI_DEVICE_ID_VIA_82C586_3	0x3040
+#define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
+#define PCI_DEVICE_ID_VIA_6305		0x3044
+#define PCI_DEVICE_ID_VIA_82C596_3	0x3050
+#define PCI_DEVICE_ID_VIA_82C596B_3	0x3051
+#define PCI_DEVICE_ID_VIA_82C686_4	0x3057
+#define PCI_DEVICE_ID_VIA_82C686_5	0x3058
+#define PCI_DEVICE_ID_VIA_8233_5	0x3059
+#define PCI_DEVICE_ID_VIA_8233_7	0x3065
+#define PCI_DEVICE_ID_VIA_VT6102	0x3065
+#define PCI_DEVICE_ID_VIA_82C686_6	0x3068
+#define PCI_DEVICE_ID_VIA_8233_0	0x3074
+#define PCI_DEVICE_ID_VIA_VT6105	0x3106
+#define PCI_DEVICE_ID_VIA_8233C_0	0x3109
+#define PCI_DEVICE_ID_VIA_8633_0	0x3091
+#define PCI_DEVICE_ID_VIA_8367_0	0x3099
+#define PCI_DEVICE_ID_VIA_86C100A	0x6100
+#define PCI_DEVICE_ID_VIA_8231		0x8231
+#define PCI_DEVICE_ID_VIA_8231_4	0x8235
+#define PCI_DEVICE_ID_VIA_8365_1	0x8305
+#define PCI_DEVICE_ID_VIA_8371_1	0x8391
+#define PCI_DEVICE_ID_VIA_8501_1	0x8501
+#define PCI_DEVICE_ID_VIA_82C597_1	0x8597
+#define PCI_DEVICE_ID_VIA_82C598_1	0x8598
+#define PCI_DEVICE_ID_VIA_8601_1	0x8601
+#define PCI_DEVICE_ID_VIA_8505_1	0X8605
+#define PCI_DEVICE_ID_VIA_8633_1	0xB091
+#define PCI_DEVICE_ID_VIA_8367_1	0xB099
+
+#define PCI_VENDOR_ID_SIEMENS           0x110A
+#define PCI_DEVICE_ID_SIEMENS_DSCC4     0x2102
+
+#define PCI_VENDOR_ID_SMC2		0x1113
+#define PCI_DEVICE_ID_SMC2_1211TX	0x1211
+#define PCI_DEVICE_ID_SMC2_1211         0x1211
+#define PCI_DEVICE_ID_SMC2_1216         0x1216
+
+#define PCI_VENDOR_ID_VORTEX		0x1119
+#define PCI_DEVICE_ID_VORTEX_GDT60x0	0x0000
+#define PCI_DEVICE_ID_VORTEX_GDT6000B	0x0001
+#define PCI_DEVICE_ID_VORTEX_GDT6x10	0x0002
+#define PCI_DEVICE_ID_VORTEX_GDT6x20	0x0003
+#define PCI_DEVICE_ID_VORTEX_GDT6530	0x0004
+#define PCI_DEVICE_ID_VORTEX_GDT6550	0x0005
+#define PCI_DEVICE_ID_VORTEX_GDT6x17	0x0006
+#define PCI_DEVICE_ID_VORTEX_GDT6x27	0x0007
+#define PCI_DEVICE_ID_VORTEX_GDT6537	0x0008
+#define PCI_DEVICE_ID_VORTEX_GDT6557	0x0009
+#define PCI_DEVICE_ID_VORTEX_GDT6x15	0x000a
+#define PCI_DEVICE_ID_VORTEX_GDT6x25	0x000b
+#define PCI_DEVICE_ID_VORTEX_GDT6535	0x000c
+#define PCI_DEVICE_ID_VORTEX_GDT6555	0x000d
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP	0x0100
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP	0x0101
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP	0x0102
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP	0x0103
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP	0x0104
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP	0x0105
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP1	0x0110
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP1	0x0111
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP1	0x0112
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP1	0x0113
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP1	0x0114
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP1	0x0115
+#define PCI_DEVICE_ID_VORTEX_GDT6x17RP2	0x0120
+#define PCI_DEVICE_ID_VORTEX_GDT6x27RP2	0x0121
+#define PCI_DEVICE_ID_VORTEX_GDT6537RP2	0x0122
+#define PCI_DEVICE_ID_VORTEX_GDT6557RP2	0x0123
+#define PCI_DEVICE_ID_VORTEX_GDT6x11RP2	0x0124
+#define PCI_DEVICE_ID_VORTEX_GDT6x21RP2	0x0125
+
+#define PCI_VENDOR_ID_EF		0x111a
+#define PCI_DEVICE_ID_EF_ATM_FPGA	0x0000
+#define PCI_DEVICE_ID_EF_ATM_ASIC	0x0002
+
+#define PCI_VENDOR_ID_IDT		0x111d
+#define PCI_DEVICE_ID_IDT_IDT77201	0x0001
+
+#define PCI_VENDOR_ID_FORE		0x1127
+#define PCI_DEVICE_ID_FORE_PCA200PC	0x0210
+#define PCI_DEVICE_ID_FORE_PCA200E	0x0300
+
+#define PCI_VENDOR_ID_IMAGINGTECH	0x112f
+#define PCI_DEVICE_ID_IMAGINGTECH_ICPCI	0x0000
+
+#define PCI_VENDOR_ID_PHILIPS		0x1131
+#define PCI_DEVICE_ID_PHILIPS_SAA7145	0x7145
+#define PCI_DEVICE_ID_PHILIPS_SAA7146	0x7146
+#define PCI_DEVICE_ID_PHILIPS_SAA9730	0x9730
+
+#define PCI_VENDOR_ID_EICON		0x1133
+#define PCI_DEVICE_ID_EICON_DIVA20PRO	0xe001
+#define PCI_DEVICE_ID_EICON_DIVA20	0xe002
+#define PCI_DEVICE_ID_EICON_DIVA20PRO_U	0xe003
+#define PCI_DEVICE_ID_EICON_DIVA20_U	0xe004
+#define PCI_DEVICE_ID_EICON_DIVA201	0xe005
+#define PCI_DEVICE_ID_EICON_MAESTRA	0xe010
+#define PCI_DEVICE_ID_EICON_MAESTRAQ	0xe012
+#define PCI_DEVICE_ID_EICON_MAESTRAQ_U	0xe013
+#define PCI_DEVICE_ID_EICON_MAESTRAP	0xe014
+ 
+#define PCI_VENDOR_ID_CYCLONE		0x113c
+#define PCI_DEVICE_ID_CYCLONE_SDK	0x0001
+
+#define PCI_VENDOR_ID_ALLIANCE		0x1142
+#define PCI_DEVICE_ID_ALLIANCE_PROMOTIO	0x3210
+#define PCI_DEVICE_ID_ALLIANCE_PROVIDEO	0x6422
+#define PCI_DEVICE_ID_ALLIANCE_AT24	0x6424
+#define PCI_DEVICE_ID_ALLIANCE_AT3D	0x643d
+
+#define PCI_VENDOR_ID_SYSKONNECT	0x1148
+#define PCI_DEVICE_ID_SYSKONNECT_FP	0x4000
+#define PCI_DEVICE_ID_SYSKONNECT_TR	0x4200
+#define PCI_DEVICE_ID_SYSKONNECT_GE	0x4300
+
+#define PCI_VENDOR_ID_VMIC		0x114a
+#define PCI_DEVICE_ID_VMIC_VME		0x7587
+
+#define PCI_VENDOR_ID_DIGI		0x114f
+#define PCI_DEVICE_ID_DIGI_EPC		0x0002
+#define PCI_DEVICE_ID_DIGI_RIGHTSWITCH	0x0003
+#define PCI_DEVICE_ID_DIGI_XEM		0x0004
+#define PCI_DEVICE_ID_DIGI_XR		0x0005
+#define PCI_DEVICE_ID_DIGI_CX		0x0006
+#define PCI_DEVICE_ID_DIGI_XRJ		0x0009
+#define PCI_DEVICE_ID_DIGI_EPCJ		0x000a
+#define PCI_DEVICE_ID_DIGI_XR_920	0x0027
+#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_E	0x0070
+#define PCI_DEVICE_ID_DIGI_DF_M_E	0x0071
+#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_A	0x0072
+#define PCI_DEVICE_ID_DIGI_DF_M_A	0x0073
+
+#define PCI_VENDOR_ID_MUTECH		0x1159
+#define PCI_DEVICE_ID_MUTECH_MV1000	0x0001
+
+#define PCI_VENDOR_ID_XIRCOM		0x115d
+#define PCI_DEVICE_ID_XIRCOM_X3201_ETH	0x0003
+#define PCI_DEVICE_ID_XIRCOM_X3201_MDM	0x0103
+
+#define PCI_VENDOR_ID_RENDITION		0x1163
+#define PCI_DEVICE_ID_RENDITION_VERITE	0x0001
+#define PCI_DEVICE_ID_RENDITION_VERITE2100 0x2000
+
+#define PCI_VENDOR_ID_SERVERWORKS	  0x1166
+#define PCI_DEVICE_ID_SERVERWORKS_HE	  0x0008
+#define PCI_DEVICE_ID_SERVERWORKS_LE	  0x0009
+#define PCI_DEVICE_ID_SERVERWORKS_CIOB30  0x0010
+#define PCI_DEVICE_ID_SERVERWORKS_CMIC_HE 0x0011
+#define PCI_DEVICE_ID_SERVERWORKS_OSB4	  0x0200
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5	  0x0201
+#define PCI_DEVICE_ID_SERVERWORKS_OSB4IDE 0x0211
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5IDE 0x0212
+#define PCI_DEVICE_ID_SERVERWORKS_OSB4USB 0x0220
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5USB PCI_DEVICE_ID_SERVERWORKS_OSB4USB
+#define PCI_DEVICE_ID_SERVERWORKS_CSB5ISA 0x0230
+
+#define PCI_VENDOR_ID_SBE		0x1176
+#define PCI_DEVICE_ID_SBE_WANXL100	0x0301
+#define PCI_DEVICE_ID_SBE_WANXL200	0x0302
+#define PCI_DEVICE_ID_SBE_WANXL400	0x0104
+
+#define PCI_VENDOR_ID_TOSHIBA		0x1179
+#define PCI_DEVICE_ID_TOSHIBA_601	0x0601
+#define PCI_DEVICE_ID_TOSHIBA_TOPIC95	0x060a
+#define PCI_DEVICE_ID_TOSHIBA_TOPIC97	0x060f
+
+#define PCI_VENDOR_ID_RICOH		0x1180
+#define PCI_DEVICE_ID_RICOH_RL5C465	0x0465
+#define PCI_DEVICE_ID_RICOH_RL5C466	0x0466
+#define PCI_DEVICE_ID_RICOH_RL5C475	0x0475
+#define PCI_DEVICE_ID_RICOH_RL5C476	0x0476
+#define PCI_DEVICE_ID_RICOH_RL5C478	0x0478
+
+#define	PCI_VENDOR_ID_DLINK		0x1186
+#define	PCI_DEVICE_ID_DFE530TXP		0x1300
+#define PCI_DEVICE_ID_DFE530TXS		0x1002
+
+#define PCI_VENDOR_ID_ARTOP		0x1191
+#define PCI_DEVICE_ID_ARTOP_ATP8400	0x0004
+#define PCI_DEVICE_ID_ARTOP_ATP850UF	0x0005
+#define PCI_DEVICE_ID_ARTOP_ATP860	0x0006
+#define PCI_DEVICE_ID_ARTOP_ATP860R	0x0007
+#define PCI_DEVICE_ID_ARTOP_AEC7610	0x8002
+#define PCI_DEVICE_ID_ARTOP_AEC7612UW	0x8010
+#define PCI_DEVICE_ID_ARTOP_AEC7612U	0x8020
+#define PCI_DEVICE_ID_ARTOP_AEC7612S	0x8030
+#define PCI_DEVICE_ID_ARTOP_AEC7612D	0x8040
+#define PCI_DEVICE_ID_ARTOP_AEC7612SUW	0x8050
+#define PCI_DEVICE_ID_ARTOP_8060	0x8060
+
+#define PCI_VENDOR_ID_ZEITNET		0x1193
+#define PCI_DEVICE_ID_ZEITNET_1221	0x0001
+#define PCI_DEVICE_ID_ZEITNET_1225	0x0002
+
+#define PCI_VENDOR_ID_OMEGA		0x119b
+#define PCI_DEVICE_ID_OMEGA_82C092G	0x1221
+
+#define PCI_VENDOR_ID_FUJITSU_ME	0x119e
+#define PCI_DEVICE_ID_FUJITSU_FS155	0x0001
+#define PCI_DEVICE_ID_FUJITSU_FS50	0x0003
+
+#define PCI_SUBVENDOR_ID_KEYSPAN	0x11a9
+#define PCI_SUBDEVICE_ID_KEYSPAN_SX2	0x5334
+
+#define PCI_VENDOR_ID_GALILEO		0x11ab
+#define PCI_DEVICE_ID_GALILEO_GT64011	0x4146
+#define PCI_DEVICE_ID_GALILEO_GT64111	0x4146
+#define PCI_DEVICE_ID_GALILEO_GT96100	0x9652
+#define PCI_DEVICE_ID_GALILEO_GT96100A	0x9653
+
+#define PCI_VENDOR_ID_LINKSYS		0x11ad
+#define PCI_VENDOR_ID_LITEON		0x11ad
+#define PCI_DEVICE_ID_LITEON_LNE100TX	0x0002
+#define PCI_DEVICE_ID_LC82C115		0xC115
+
+#define PCI_VENDOR_ID_V3		0x11b0
+#define PCI_DEVICE_ID_V3_V960		0x0001
+#define PCI_DEVICE_ID_V3_V350		0x0001
+#define PCI_DEVICE_ID_V3_V961		0x0002
+#define PCI_DEVICE_ID_V3_V351		0x0002
+
+#define PCI_VENDOR_ID_NP		0x11bc
+#define PCI_DEVICE_ID_NP_PCI_FDDI	0x0001
+
+#define PCI_VENDOR_ID_ATT		0x11c1
+#define PCI_DEVICE_ID_ATT_L56XMF	0x0440
+#define PCI_DEVICE_ID_ATT_VENUS_MODEM	0x480
+
+#define PCI_VENDOR_ID_SPECIALIX		0x11cb
+#define PCI_DEVICE_ID_SPECIALIX_IO8	0x2000
+#define PCI_DEVICE_ID_SPECIALIX_XIO	0x4000
+#define PCI_DEVICE_ID_SPECIALIX_RIO	0x8000
+#define PCI_SUBDEVICE_ID_SPECIALIX_SPEED4 0xa004
+
+#define PCI_VENDOR_ID_AURAVISION	0x11d1
+#define PCI_DEVICE_ID_AURAVISION_VXP524	0x01f7
+
+#define PCI_VENDOR_ID_ANALOG_DEVICES	0x11d4
+#define PCI_DEVICE_ID_AD1889JS		0x1889
+
+#define PCI_VENDOR_ID_IKON		0x11d5
+#define PCI_DEVICE_ID_IKON_10115	0x0115
+#define PCI_DEVICE_ID_IKON_10117	0x0117
+
+#define PCI_VENDOR_ID_ZORAN		0x11de
+#define PCI_DEVICE_ID_ZORAN_36057	0x6057
+#define PCI_DEVICE_ID_ZORAN_36120	0x6120
+
+#define PCI_VENDOR_ID_KINETIC		0x11f4
+#define PCI_DEVICE_ID_KINETIC_2915	0x2915
+
+#define PCI_VENDOR_ID_COMPEX		0x11f6
+#define PCI_DEVICE_ID_COMPEX_ENET100VG4	0x0112
+#define PCI_DEVICE_ID_COMPEX_RL2000	0x1401
+#define PCI_DEVICE_ID_COMPEX_RL100ATX   0x2011
+
+#define PCI_VENDOR_ID_RP		0x11fe
+#define PCI_DEVICE_ID_RP32INTF		0x0001
+#define PCI_DEVICE_ID_RP8INTF		0x0002
+#define PCI_DEVICE_ID_RP16INTF		0x0003
+#define PCI_DEVICE_ID_RP4QUAD		0x0004
+#define PCI_DEVICE_ID_RP8OCTA		0x0005
+#define PCI_DEVICE_ID_RP8J		0x0006
+#define PCI_DEVICE_ID_RPP4		0x000A
+#define PCI_DEVICE_ID_RPP8		0x000B
+#define PCI_DEVICE_ID_RP8M		0x000C
+
+#define PCI_VENDOR_ID_CYCLADES		0x120e
+#define PCI_DEVICE_ID_CYCLOM_Y_Lo	0x0100
+#define PCI_DEVICE_ID_CYCLOM_Y_Hi	0x0101
+#define PCI_DEVICE_ID_CYCLOM_4Y_Lo	0x0102
+#define PCI_DEVICE_ID_CYCLOM_4Y_Hi	0x0103
+#define PCI_DEVICE_ID_CYCLOM_8Y_Lo	0x0104
+#define PCI_DEVICE_ID_CYCLOM_8Y_Hi	0x0105
+#define PCI_DEVICE_ID_CYCLOM_Z_Lo	0x0200
+#define PCI_DEVICE_ID_CYCLOM_Z_Hi	0x0201
+#define PCI_DEVICE_ID_PC300_RX_2	0x0300
+#define PCI_DEVICE_ID_PC300_RX_1	0x0301
+#define PCI_DEVICE_ID_PC300_TE_2	0x0310
+#define PCI_DEVICE_ID_PC300_TE_1	0x0311
+
+#define PCI_VENDOR_ID_ESSENTIAL		0x120f
+#define PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER	0x0001
+
+#define PCI_VENDOR_ID_O2		0x1217
+#define PCI_DEVICE_ID_O2_6729		0x6729
+#define PCI_DEVICE_ID_O2_6730		0x673a
+#define PCI_DEVICE_ID_O2_6832		0x6832
+#define PCI_DEVICE_ID_O2_6836		0x6836
+
+#define PCI_VENDOR_ID_3DFX		0x121a
+#define PCI_DEVICE_ID_3DFX_VOODOO	0x0001
+#define PCI_DEVICE_ID_3DFX_VOODOO2	0x0002
+#define PCI_DEVICE_ID_3DFX_BANSHEE	0x0003
+#define PCI_DEVICE_ID_3DFX_VOODOO3	0x0005
+
+#define PCI_VENDOR_ID_SIGMADES		0x1236
+#define PCI_DEVICE_ID_SIGMADES_6425	0x6401
+
+#define PCI_VENDOR_ID_CCUBE		0x123f
+
+#define PCI_VENDOR_ID_AVM		0x1244
+#define PCI_DEVICE_ID_AVM_B1		0x0700
+#define PCI_DEVICE_ID_AVM_C4		0x0800
+#define PCI_DEVICE_ID_AVM_A1		0x0a00
+#define PCI_DEVICE_ID_AVM_A1_V2		0x0e00
+#define PCI_DEVICE_ID_AVM_C2		0x1100
+#define PCI_DEVICE_ID_AVM_T1		0x1200
+
+#define PCI_VENDOR_ID_DIPIX		0x1246
+
+#define PCI_VENDOR_ID_STALLION		0x124d
+#define PCI_DEVICE_ID_STALLION_ECHPCI832 0x0000
+#define PCI_DEVICE_ID_STALLION_ECHPCI864 0x0002
+#define PCI_DEVICE_ID_STALLION_EIOPCI	0x0003
+
+#define PCI_VENDOR_ID_OPTIBASE		0x1255
+#define PCI_DEVICE_ID_OPTIBASE_FORGE	0x1110
+#define PCI_DEVICE_ID_OPTIBASE_FUSION	0x1210
+#define PCI_DEVICE_ID_OPTIBASE_VPLEX	0x2110
+#define PCI_DEVICE_ID_OPTIBASE_VPLEXCC	0x2120
+#define PCI_DEVICE_ID_OPTIBASE_VQUEST	0x2130
+
+#define PCI_VENDOR_ID_ESS		0x125d
+#define PCI_DEVICE_ID_ESS_ESS1968	0x1968
+#define PCI_DEVICE_ID_ESS_AUDIOPCI	0x1969
+#define PCI_DEVICE_ID_ESS_ESS1978	0x1978
+
+#define PCI_VENDOR_ID_HARRIS        	0x1260
+#define PCI_DEVICE_ID_HARRIS_PRISM2	0x3873
+
+#define PCI_VENDOR_ID_SATSAGEM		0x1267
+#define PCI_DEVICE_ID_SATSAGEM_NICCY	0x1016
+#define PCI_DEVICE_ID_SATSAGEM_PCR2101	0x5352
+#define PCI_DEVICE_ID_SATSAGEM_TELSATTURBO 0x5a4b
+
+#define PCI_VENDOR_ID_HUGHES		0x1273
+#define PCI_DEVICE_ID_HUGHES_DIRECPC	0x0002
+
+#define PCI_VENDOR_ID_ENSONIQ		0x1274
+#define PCI_DEVICE_ID_ENSONIQ_CT5880	0x5880
+#define PCI_DEVICE_ID_ENSONIQ_ES1370	0x5000
+#define PCI_DEVICE_ID_ENSONIQ_ES1371	0x1371
+
+#define PCI_VENDOR_ID_ROCKWELL		0x127A
+
+#define PCI_VENDOR_ID_DAVICOM		0x1282
+#define	PCI_DEVICE_ID_DM9009		0x9009
+#define PCI_DEVICE_ID_DM9102		0x9102
+
+#define PCI_VENDOR_ID_ITE		0x1283
+#define PCI_DEVICE_ID_ITE_IT8172G_AUDIO 0x0801
+#define PCI_DEVICE_ID_ITE_IT8172G	0x8172
+#define PCI_DEVICE_ID_ITE_8872		0x8872
+
+
+/* formerly Platform Tech */
+#define PCI_VENDOR_ID_ESS_OLD		0x1285
+#define PCI_DEVICE_ID_ESS_ESS0100	0x0100
+
+#define PCI_VENDOR_ID_ALTEON		0x12ae
+#define PCI_DEVICE_ID_ALTEON_ACENIC	0x0001
+
+#define PCI_VENDOR_ID_USR		0x12B9
+
+#define	PCI_VENDOR_ID_HOLTEK		0x12c3
+#define	PCI_DEVICE_ID_HOLTEK_HT80232	0x0058
+
+#define PCI_SUBVENDOR_ID_CONNECT_TECH			0x12c4
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_232		0x0001
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_232		0x0002
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_232		0x0003
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485		0x0004
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_4_4	0x0005
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485		0x0006
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485_2_2	0x0007
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_485		0x0008
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_2_6	0x0009
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH081101V1	0x000A
+#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH041101V1	0x000B
+
+#define PCI_VENDOR_ID_PICTUREL		0x12c5
+#define PCI_DEVICE_ID_PICTUREL_PCIVST	0x0081
+
+#define PCI_VENDOR_ID_NVIDIA_SGS	0x12d2
+#define PCI_DEVICE_ID_NVIDIA_SGS_RIVA128 0x0018
+
+#define PCI_SUBVENDOR_ID_CHASE_PCIFAST		0x12E0
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST4		0x0031
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST8		0x0021
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST16	0x0011
+#define PCI_SUBDEVICE_ID_CHASE_PCIFAST16FMC	0x0041
+#define PCI_SUBVENDOR_ID_CHASE_PCIRAS		0x124D
+#define PCI_SUBDEVICE_ID_CHASE_PCIRAS4		0xF001
+#define PCI_SUBDEVICE_ID_CHASE_PCIRAS8		0xF010
+
+#define PCI_VENDOR_ID_AUREAL		0x12eb
+#define PCI_DEVICE_ID_AUREAL_VORTEX_1	0x0001
+#define PCI_DEVICE_ID_AUREAL_VORTEX_2	0x0002
+
+#define PCI_VENDOR_ID_CBOARDS		0x1307
+#define PCI_DEVICE_ID_CBOARDS_DAS1602_16 0x0001
+
+#define PCI_VENDOR_ID_SIIG		0x131f
+#define PCI_DEVICE_ID_SIIG_1S_10x_550	0x1000
+#define PCI_DEVICE_ID_SIIG_1S_10x_650	0x1001
+#define PCI_DEVICE_ID_SIIG_1S_10x_850	0x1002
+#define PCI_DEVICE_ID_SIIG_1S1P_10x_550	0x1010
+#define PCI_DEVICE_ID_SIIG_1S1P_10x_650	0x1011
+#define PCI_DEVICE_ID_SIIG_1S1P_10x_850	0x1012
+#define PCI_DEVICE_ID_SIIG_1P_10x	0x1020
+#define PCI_DEVICE_ID_SIIG_2P_10x	0x1021
+#define PCI_DEVICE_ID_SIIG_2S_10x_550	0x1030
+#define PCI_DEVICE_ID_SIIG_2S_10x_650	0x1031
+#define PCI_DEVICE_ID_SIIG_2S_10x_850	0x1032
+#define PCI_DEVICE_ID_SIIG_2S1P_10x_550	0x1034
+#define PCI_DEVICE_ID_SIIG_2S1P_10x_650	0x1035
+#define PCI_DEVICE_ID_SIIG_2S1P_10x_850	0x1036
+#define PCI_DEVICE_ID_SIIG_4S_10x_550	0x1050
+#define PCI_DEVICE_ID_SIIG_4S_10x_650	0x1051
+#define PCI_DEVICE_ID_SIIG_4S_10x_850	0x1052
+#define PCI_DEVICE_ID_SIIG_1S_20x_550	0x2000
+#define PCI_DEVICE_ID_SIIG_1S_20x_650	0x2001
+#define PCI_DEVICE_ID_SIIG_1S_20x_850	0x2002
+#define PCI_DEVICE_ID_SIIG_1P_20x	0x2020
+#define PCI_DEVICE_ID_SIIG_2P_20x	0x2021
+#define PCI_DEVICE_ID_SIIG_2S_20x_550	0x2030
+#define PCI_DEVICE_ID_SIIG_2S_20x_650	0x2031
+#define PCI_DEVICE_ID_SIIG_2S_20x_850	0x2032
+#define PCI_DEVICE_ID_SIIG_2P1S_20x_550	0x2040
+#define PCI_DEVICE_ID_SIIG_2P1S_20x_650	0x2041
+#define PCI_DEVICE_ID_SIIG_2P1S_20x_850	0x2042
+#define PCI_DEVICE_ID_SIIG_1S1P_20x_550	0x2010
+#define PCI_DEVICE_ID_SIIG_1S1P_20x_650	0x2011
+#define PCI_DEVICE_ID_SIIG_1S1P_20x_850	0x2012
+#define PCI_DEVICE_ID_SIIG_4S_20x_550	0x2050
+#define PCI_DEVICE_ID_SIIG_4S_20x_650	0x2051
+#define PCI_DEVICE_ID_SIIG_4S_20x_850	0x2052
+#define PCI_DEVICE_ID_SIIG_2S1P_20x_550	0x2060
+#define PCI_DEVICE_ID_SIIG_2S1P_20x_650	0x2061
+#define PCI_DEVICE_ID_SIIG_2S1P_20x_850	0x2062
+
+#define PCI_VENDOR_ID_ADMTEK            0x1317
+#define PCI_DEVICE_ID_ADMTEK_0985       0x0985
+
+#define PCI_VENDOR_ID_DOMEX		0x134a
+#define PCI_DEVICE_ID_DOMEX_DMX3191D	0x0001
+
+#define PCI_VENDOR_ID_QUATECH		0x135C
+#define PCI_DEVICE_ID_QUATECH_QSC100	0x0010
+#define PCI_DEVICE_ID_QUATECH_DSC100	0x0020
+#define PCI_DEVICE_ID_QUATECH_DSC200	0x0030
+#define PCI_DEVICE_ID_QUATECH_QSC200	0x0040
+#define PCI_DEVICE_ID_QUATECH_ESC100D	0x0050
+#define PCI_DEVICE_ID_QUATECH_ESC100M	0x0060
+
+#define PCI_VENDOR_ID_SEALEVEL		0x135e
+#define PCI_DEVICE_ID_SEALEVEL_U530	0x7101
+#define PCI_DEVICE_ID_SEALEVEL_UCOMM2	0x7201
+#define PCI_DEVICE_ID_SEALEVEL_UCOMM422	0x7402
+#define PCI_DEVICE_ID_SEALEVEL_UCOMM232	0x7202
+#define PCI_DEVICE_ID_SEALEVEL_COMM4	0x7401
+#define PCI_DEVICE_ID_SEALEVEL_COMM8	0x7801
+
+#define PCI_VENDOR_ID_HYPERCOPE		0x1365
+#define PCI_DEVICE_ID_HYPERCOPE_PLX	0x9050
+#define PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO	0x0104
+#define PCI_SUBDEVICE_ID_HYPERCOPE_ERGO		0x0106
+#define PCI_SUBDEVICE_ID_HYPERCOPE_METRO	0x0107
+#define PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2	0x0108
+#define PCI_SUBDEVICE_ID_HYPERCOPE_PLEXUS	0x0109
+
+#define PCI_VENDOR_ID_KAWASAKI		0x136b
+#define PCI_DEVICE_ID_MCHIP_KL5A72002	0xff01
+
+#define PCI_VENDOR_ID_LMC		0x1376
+#define PCI_DEVICE_ID_LMC_HSSI		0x0003
+#define PCI_DEVICE_ID_LMC_DS3		0x0004
+#define PCI_DEVICE_ID_LMC_SSI		0x0005
+#define PCI_DEVICE_ID_LMC_T1		0x0006
+
+#define PCI_VENDOR_ID_NETGEAR		0x1385
+#define PCI_DEVICE_ID_NETGEAR_MA301	0x4100
+#define PCI_DEVICE_ID_NETGEAR_GA620	0x620a
+#define PCI_DEVICE_ID_NETGEAR_GA622	0x622a
+
+#define PCI_VENDOR_ID_APPLICOM		0x1389
+#define PCI_DEVICE_ID_APPLICOM_PCIGENERIC 0x0001
+#define PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN 0x0002
+#define PCI_DEVICE_ID_APPLICOM_PCI2000PFB 0x0003
+
+#define PCI_VENDOR_ID_MOXA		0x1393
+#define PCI_DEVICE_ID_MOXA_C104		0x1040
+#define PCI_DEVICE_ID_MOXA_C168		0x1680
+#define PCI_DEVICE_ID_MOXA_CP204J	0x2040
+#define PCI_DEVICE_ID_MOXA_C218		0x2180
+#define PCI_DEVICE_ID_MOXA_C320		0x3200
+
+#define PCI_VENDOR_ID_CCD		0x1397
+#define PCI_DEVICE_ID_CCD_2BD0		0x2bd0
+#define PCI_DEVICE_ID_CCD_B000		0xb000
+#define PCI_DEVICE_ID_CCD_B006		0xb006
+#define PCI_DEVICE_ID_CCD_B007		0xb007
+#define PCI_DEVICE_ID_CCD_B008		0xb008
+#define PCI_DEVICE_ID_CCD_B009		0xb009
+#define PCI_DEVICE_ID_CCD_B00A		0xb00a
+#define PCI_DEVICE_ID_CCD_B00B		0xb00b
+#define PCI_DEVICE_ID_CCD_B00C		0xb00c
+#define PCI_DEVICE_ID_CCD_B100		0xb100
+
+#define PCI_VENDOR_ID_MICROGATE		0x13c0
+#define PCI_DEVICE_ID_MICROGATE_USC	0x0010
+#define PCI_DEVICE_ID_MICROGATE_SCC	0x0020
+#define PCI_DEVICE_ID_MICROGATE_SCA	0x0030
+
+#define PCI_VENDOR_ID_3WARE		0x13C1
+#define PCI_DEVICE_ID_3WARE_1000	0x1000
+
+#define PCI_VENDOR_ID_ABOCOM		0x13D1
+#define PCI_DEVICE_ID_ABOCOM_2BD1       0x2BD1
+
+#define PCI_VENDOR_ID_CMEDIA		0x13f6
+#define PCI_DEVICE_ID_CMEDIA_CM8338A	0x0100
+#define PCI_DEVICE_ID_CMEDIA_CM8338B	0x0101
+#define PCI_DEVICE_ID_CMEDIA_CM8738	0x0111
+#define PCI_DEVICE_ID_CMEDIA_CM8738B	0x0112
+
+#define PCI_VENDOR_ID_LAVA		0x1407
+#define PCI_DEVICE_ID_LAVA_DSERIAL	0x0100 /* 2x 16550 */
+#define PCI_DEVICE_ID_LAVA_QUATRO_A	0x0101 /* 2x 16550, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_QUATRO_B	0x0102 /* 2x 16550, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_PORT_PLUS	0x0200 /* 2x 16650 */
+#define PCI_DEVICE_ID_LAVA_QUAD_A	0x0201 /* 2x 16650, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_QUAD_B	0x0202 /* 2x 16650, half of 4 port */
+#define PCI_DEVICE_ID_LAVA_SSERIAL	0x0500 /* 1x 16550 */
+#define PCI_DEVICE_ID_LAVA_PORT_650	0x0600 /* 1x 16650 */
+#define PCI_DEVICE_ID_LAVA_PARALLEL	0x8000
+#define PCI_DEVICE_ID_LAVA_DUAL_PAR_A	0x8002 /* The Lava Dual Parallel is */
+#define PCI_DEVICE_ID_LAVA_DUAL_PAR_B	0x8003 /* two PCI devices on a card */
+#define PCI_DEVICE_ID_LAVA_BOCA_IOPPAR	0x8800
+
+#define PCI_VENDOR_ID_TIMEDIA		0x1409
+#define PCI_DEVICE_ID_TIMEDIA_1889	0x7168
+
+#define PCI_VENDOR_ID_OXSEMI		0x1415
+#define PCI_DEVICE_ID_OXSEMI_12PCI840	0x8403
+#define PCI_DEVICE_ID_OXSEMI_16PCI954	0x9501
+#define PCI_DEVICE_ID_OXSEMI_16PCI952	0x950A
+#define PCI_DEVICE_ID_OXSEMI_16PCI95N	0x9511
+#define PCI_DEVICE_ID_OXSEMI_16PCI954PP	0x9513
+
+#define PCI_VENDOR_ID_AIRONET		0x14b9
+#define PCI_DEVICE_ID_AIRONET_4800_1	0x0001
+#define PCI_DEVICE_ID_AIRONET_4800	0x4500 // values switched?  see
+#define PCI_DEVICE_ID_AIRONET_4500	0x4800 // drivers/net/aironet4500_card.c
+
+#define PCI_VENDOR_ID_TITAN		0x14D2
+#define PCI_DEVICE_ID_TITAN_010L	0x8001
+#define PCI_DEVICE_ID_TITAN_100L	0x8010
+#define PCI_DEVICE_ID_TITAN_110L	0x8011
+#define PCI_DEVICE_ID_TITAN_200L	0x8020
+#define PCI_DEVICE_ID_TITAN_210L	0x8021
+#define PCI_DEVICE_ID_TITAN_400L	0x8040
+#define PCI_DEVICE_ID_TITAN_800L	0x8080
+#define PCI_DEVICE_ID_TITAN_100		0xA001
+#define PCI_DEVICE_ID_TITAN_200		0xA005
+#define PCI_DEVICE_ID_TITAN_400		0xA003
+#define PCI_DEVICE_ID_TITAN_800B	0xA004
+
+#define PCI_VENDOR_ID_PANACOM		0x14d4
+#define PCI_DEVICE_ID_PANACOM_QUADMODEM	0x0400
+#define PCI_DEVICE_ID_PANACOM_DUALMODEM	0x0402
+
+#define PCI_VENDOR_ID_BROADCOM		0x14e4
+#define PCI_DEVICE_ID_TIGON3_5700	0x1644
+#define PCI_DEVICE_ID_TIGON3_5701	0x1645
+#define PCI_DEVICE_ID_TIGON3_5702	0x1646
+#define PCI_DEVICE_ID_TIGON3_5703	0x1647
+#define PCI_DEVICE_ID_TIGON3_5704	0x1648
+#define PCI_DEVICE_ID_TIGON3_5702FE	0x164d
+#define PCI_DEVICE_ID_TIGON3_5705	0x1653
+#define PCI_DEVICE_ID_TIGON3_5705_2	0x1654
+#define PCI_DEVICE_ID_TIGON3_5705M	0x165d
+#define PCI_DEVICE_ID_TIGON3_5705M_2	0x165e
+#define PCI_DEVICE_ID_TIGON3_5782	0x1696
+#define PCI_DEVICE_ID_TIGON3_5788	0x169c
+#define PCI_DEVICE_ID_TIGON3_5702X	0x16a6
+#define PCI_DEVICE_ID_TIGON3_5703X	0x16a7
+#define PCI_DEVICE_ID_TIGON3_5704S	0x16a8
+#define PCI_DEVICE_ID_TIGON3_5702A3	0x16c6
+#define PCI_DEVICE_ID_TIGON3_5703A3	0x16c7
+#define PCI_DEVICE_ID_TIGON3_5901	0x170d
+#define PCI_DEVICE_ID_TIGON3_5901_2	0x170e
+
+#define PCI_VENDOR_ID_SYBA		0x1592
+#define PCI_DEVICE_ID_SYBA_2P_EPP	0x0782
+#define PCI_DEVICE_ID_SYBA_1P_ECP	0x0783
+
+#define PCI_VENDOR_ID_MORETON		0x15aa
+#define PCI_DEVICE_ID_RASTEL_2PORT	0x2000
+
+#define PCI_VENDOR_ID_ZOLTRIX		0x15b0
+#define PCI_DEVICE_ID_ZOLTRIX_2BD0	0x2bd0 
+
+#define PCI_VENDOR_ID_PDC		0x15e9
+#define PCI_DEVICE_ID_PDC_1841		0x1841
+
+#define PCI_VENDOR_ID_SYMPHONY		0x1c1c
+#define PCI_DEVICE_ID_SYMPHONY_101	0x0001
+
+#define PCI_VENDOR_ID_TEKRAM		0x1de1
+#define PCI_DEVICE_ID_TEKRAM_DC290	0xdc29
+
+#define PCI_VENDOR_ID_3DLABS		0x3d3d
+#define PCI_DEVICE_ID_3DLABS_300SX	0x0001
+#define PCI_DEVICE_ID_3DLABS_500TX	0x0002
+#define PCI_DEVICE_ID_3DLABS_DELTA	0x0003
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA	0x0004
+#define PCI_DEVICE_ID_3DLABS_MX		0x0006
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA2	0x0007
+#define PCI_DEVICE_ID_3DLABS_GAMMA	0x0008
+#define PCI_DEVICE_ID_3DLABS_PERMEDIA2V	0x0009
+
+#define PCI_VENDOR_ID_AVANCE		0x4005
+#define PCI_DEVICE_ID_AVANCE_ALG2064	0x2064
+#define PCI_DEVICE_ID_AVANCE_2302	0x2302
+
+#define PCI_VENDOR_ID_AKS		0x416c
+#define PCI_DEVICE_ID_AKS_ALADDINCARD	0x0100
+#define PCI_DEVICE_ID_AKS_CPC		0x0200
+
+#define PCI_VENDOR_ID_NETVIN		0x4a14
+#define PCI_DEVICE_ID_NETVIN_NV5000SC	0x5000
+
+#define PCI_VENDOR_ID_S3		0x5333
+#define PCI_DEVICE_ID_S3_PLATO_PXS	0x0551
+#define PCI_DEVICE_ID_S3_ViRGE		0x5631
+#define PCI_DEVICE_ID_S3_TRIO		0x8811
+#define PCI_DEVICE_ID_S3_AURORA64VP	0x8812
+#define PCI_DEVICE_ID_S3_TRIO64UVP	0x8814
+#define PCI_DEVICE_ID_S3_ViRGE_VX	0x883d
+#define PCI_DEVICE_ID_S3_868		0x8880
+#define PCI_DEVICE_ID_S3_928		0x88b0
+#define PCI_DEVICE_ID_S3_864_1		0x88c0
+#define PCI_DEVICE_ID_S3_864_2		0x88c1
+#define PCI_DEVICE_ID_S3_964_1		0x88d0
+#define PCI_DEVICE_ID_S3_964_2		0x88d1
+#define PCI_DEVICE_ID_S3_968		0x88f0
+#define PCI_DEVICE_ID_S3_TRIO64V2	0x8901
+#define PCI_DEVICE_ID_S3_PLATO_PXG	0x8902
+#define PCI_DEVICE_ID_S3_ViRGE_DXGX	0x8a01
+#define PCI_DEVICE_ID_S3_ViRGE_GX2	0x8a10
+#define PCI_DEVICE_ID_S3_ViRGE_MX	0x8c01
+#define PCI_DEVICE_ID_S3_ViRGE_MXP	0x8c02
+#define PCI_DEVICE_ID_S3_ViRGE_MXPMV	0x8c03
+#define PCI_DEVICE_ID_S3_SONICVIBES	0xca00
+
+#define PCI_VENDOR_ID_DCI		0x6666
+#define PCI_DEVICE_ID_DCI_PCCOM4	0x0001
+#define PCI_DEVICE_ID_DCI_PCCOM8	0x0002
+
+#define PCI_VENDOR_ID_GENROCO		0x5555
+#define PCI_DEVICE_ID_GENROCO_HFP832	0x0003
+
+#define PCI_VENDOR_ID_INTEL		0x8086
+#define PCI_DEVICE_ID_INTEL_21145	0x0039
+#define PCI_DEVICE_ID_INTEL_82375	0x0482
+#define PCI_DEVICE_ID_INTEL_82424	0x0483
+#define PCI_DEVICE_ID_INTEL_82378	0x0484
+#define PCI_DEVICE_ID_INTEL_82430	0x0486
+#define PCI_DEVICE_ID_INTEL_82434	0x04a3
+#define PCI_DEVICE_ID_INTEL_I960	0x0960
+#define PCI_DEVICE_ID_INTEL_82542       	0x1000
+#define PCI_DEVICE_ID_INTEL_82543GC_FIBER  	0x1001
+#define PCI_DEVICE_ID_INTEL_82543GC_COPPER 	0x1004
+#define PCI_DEVICE_ID_INTEL_82544EI_COPPER 	0x1008
+#define PCI_DEVICE_ID_INTEL_82544EI_FIBER 	0x1009
+#define PCI_DEVICE_ID_INTEL_82544GC_COPPER 	0x100C
+#define PCI_DEVICE_ID_INTEL_82544GC_LOM   	0x100D
+#define PCI_DEVICE_ID_INTEL_82540EM		0x100E
+#define PCI_DEVICE_ID_INTEL_82545EM_COPPER	0x100F
+#define PCI_DEVICE_ID_INTEL_82546EB_COPPER	0x1010
+#define PCI_DEVICE_ID_INTEL_82545EM_FIBER	0x1011
+#define PCI_DEVICE_ID_INTEL_82546EB_FIBER	0x1012
+#define PCI_DEVICE_ID_INTEL_82540EM_LOM		0x1015
+#define PCI_DEVICE_ID_INTEL_ID1029	0x1029
+#define PCI_DEVICE_ID_INTEL_ID1030	0x1030
+#define PCI_DEVICE_ID_INTEL_ID1031	0x1031
+#define PCI_DEVICE_ID_INTEL_ID1038	0x1038
+#define PCI_DEVICE_ID_INTEL_ID1039	0x1039
+#define PCI_DEVICE_ID_INTEL_ID103A	0x103A
+#define PCI_DEVICE_ID_INTEL_82562ET	0x1031
+#define PCI_DEVICE_ID_INTEL_82559ER	0x1209
+#define PCI_DEVICE_ID_INTEL_82092AA_0	0x1221
+#define PCI_DEVICE_ID_INTEL_82092AA_1	0x1222
+#define PCI_DEVICE_ID_INTEL_7116	0x1223
+#define PCI_DEVICE_ID_INTEL_82596	0x1226
+#define PCI_DEVICE_ID_INTEL_82865	0x1227
+#define PCI_DEVICE_ID_INTEL_82557	0x1229
+#define PCI_DEVICE_ID_INTEL_82437	0x122d
+#define PCI_DEVICE_ID_INTEL_82371FB_0	0x122e
+#define PCI_DEVICE_ID_INTEL_82371FB_1	0x1230
+#define PCI_DEVICE_ID_INTEL_82371MX	0x1234
+#define PCI_DEVICE_ID_INTEL_82437MX	0x1235
+#define PCI_DEVICE_ID_INTEL_82441	0x1237
+#define PCI_DEVICE_ID_INTEL_82380FB	0x124b
+#define PCI_DEVICE_ID_INTEL_82439	0x1250
+#define PCI_DEVICE_ID_INTEL_80960_RP	0x1960
+#define PCI_DEVICE_ID_INTEL_82801AA_0	0x2410
+#define PCI_DEVICE_ID_INTEL_82801AA_1	0x2411
+#define PCI_DEVICE_ID_INTEL_82801AA_2	0x2412
+#define PCI_DEVICE_ID_INTEL_82801AA_3	0x2413
+#define PCI_DEVICE_ID_INTEL_82801AA_5	0x2415
+#define PCI_DEVICE_ID_INTEL_82801AA_6	0x2416
+#define PCI_DEVICE_ID_INTEL_82801AA_8	0x2418
+#define PCI_DEVICE_ID_INTEL_82801AB_0	0x2420
+#define PCI_DEVICE_ID_INTEL_82801AB_1	0x2421
+#define PCI_DEVICE_ID_INTEL_82801AB_2	0x2422
+#define PCI_DEVICE_ID_INTEL_82801AB_3	0x2423
+#define PCI_DEVICE_ID_INTEL_82801AB_5	0x2425
+#define PCI_DEVICE_ID_INTEL_82801AB_6	0x2426
+#define PCI_DEVICE_ID_INTEL_82801AB_8	0x2428
+#define PCI_DEVICE_ID_INTEL_82801BA_0	0x2440
+#define PCI_DEVICE_ID_INTEL_82801BA_1	0x2442
+#define PCI_DEVICE_ID_INTEL_82801BA_2	0x2443
+#define PCI_DEVICE_ID_INTEL_82801BA_3	0x2444
+#define PCI_DEVICE_ID_INTEL_82801BA_4	0x2445
+#define PCI_DEVICE_ID_INTEL_82801BA_5	0x2446
+#define PCI_DEVICE_ID_INTEL_82801BA_6	0x2448
+#define PCI_DEVICE_ID_INTEL_82801BA_7	0x2449
+#define PCI_DEVICE_ID_INTEL_82562	0x2449
+#define PCI_DEVICE_ID_INTEL_82801BA_8	0x244a
+#define PCI_DEVICE_ID_INTEL_82801BA_9	0x244b
+#define PCI_DEVICE_ID_INTEL_82801BA_10	0x244c
+#define PCI_DEVICE_ID_INTEL_82801BA_11	0x244e
+#define PCI_DEVICE_ID_INTEL_82801CA_0	0x2480
+#define PCI_DEVICE_ID_INTEL_82801CA_2	0x2482
+#define PCI_DEVICE_ID_INTEL_82801CA_3	0x2483
+#define PCI_DEVICE_ID_INTEL_82801CA_4	0x2484
+#define PCI_DEVICE_ID_INTEL_82801CA_5	0x2485
+#define PCI_DEVICE_ID_INTEL_82801CA_6	0x2486
+#define PCI_DEVICE_ID_INTEL_82801CA_7	0x2487
+#define PCI_DEVICE_ID_INTEL_82801CA_10	0x248a
+#define PCI_DEVICE_ID_INTEL_82801CA_11	0x248b
+#define PCI_DEVICE_ID_INTEL_82801CA_12	0x248c
+#define PCI_DEVICE_ID_INTEL_80310	0x530d
+#define PCI_DEVICE_ID_INTEL_82371SB_0	0x7000
+#define PCI_DEVICE_ID_INTEL_82371SB_1	0x7010
+#define PCI_DEVICE_ID_INTEL_82371SB_2	0x7020
+#define PCI_DEVICE_ID_INTEL_82437VX	0x7030
+#define PCI_DEVICE_ID_INTEL_82439TX	0x7100
+#define PCI_DEVICE_ID_INTEL_82371AB_0	0x7110
+#define PCI_DEVICE_ID_INTEL_82371AB	0x7111
+#define PCI_DEVICE_ID_INTEL_82371AB_2	0x7112
+#define PCI_DEVICE_ID_INTEL_82371AB_3	0x7113
+#define PCI_DEVICE_ID_INTEL_82810_MC1	0x7120
+#define PCI_DEVICE_ID_INTEL_82810_IG1	0x7121
+#define PCI_DEVICE_ID_INTEL_82810_MC3	0x7122
+#define PCI_DEVICE_ID_INTEL_82810_IG3	0x7123
+#define PCI_DEVICE_ID_INTEL_82443LX_0	0x7180
+#define PCI_DEVICE_ID_INTEL_82443LX_1	0x7181
+#define PCI_DEVICE_ID_INTEL_82443BX_0	0x7190
+#define PCI_DEVICE_ID_INTEL_82443BX_1	0x7191
+#define PCI_DEVICE_ID_INTEL_82443BX_2	0x7192
+#define PCI_DEVICE_ID_INTEL_82443MX_0	0x7198
+#define PCI_DEVICE_ID_INTEL_82443MX_1	0x7199
+#define PCI_DEVICE_ID_INTEL_82443MX_2	0x719a
+#define PCI_DEVICE_ID_INTEL_82443MX_3	0x719b
+#define PCI_DEVICE_ID_INTEL_82372FB_0	0x7600
+#define PCI_DEVICE_ID_INTEL_82372FB_1	0x7601
+#define PCI_DEVICE_ID_INTEL_82372FB_2	0x7602
+#define PCI_DEVICE_ID_INTEL_82372FB_3	0x7603
+#define PCI_DEVICE_ID_INTEL_82454GX	0x84c4
+#define PCI_DEVICE_ID_INTEL_82450GX	0x84c5
+#define PCI_DEVICE_ID_INTEL_82451NX	0x84ca
+
+#define PCI_VENDOR_ID_COMPUTONE		0x8e0e
+#define PCI_DEVICE_ID_COMPUTONE_IP2EX	0x0291
+#define PCI_DEVICE_ID_COMPUTONE_PG	0x0302
+#define PCI_SUBVENDOR_ID_COMPUTONE	0x8e0e
+#define PCI_SUBDEVICE_ID_COMPUTONE_PG4	0x0001
+#define PCI_SUBDEVICE_ID_COMPUTONE_PG8	0x0002
+#define PCI_SUBDEVICE_ID_COMPUTONE_PG6	0x0003
+
+#define PCI_VENDOR_ID_KTI		0x8e2e
+#define PCI_DEVICE_ID_KTI_ET32P2	0x3000
+
+#define PCI_VENDOR_ID_ADAPTEC		0x9004
+#define PCI_DEVICE_ID_ADAPTEC_7810	0x1078
+#define PCI_DEVICE_ID_ADAPTEC_7821	0x2178
+#define PCI_DEVICE_ID_ADAPTEC_38602	0x3860
+#define PCI_DEVICE_ID_ADAPTEC_7850	0x5078
+#define PCI_DEVICE_ID_ADAPTEC_7855	0x5578
+#define PCI_DEVICE_ID_ADAPTEC_5800	0x5800
+#define PCI_DEVICE_ID_ADAPTEC_3860	0x6038
+#define PCI_DEVICE_ID_ADAPTEC_1480A	0x6075
+#define PCI_DEVICE_ID_ADAPTEC_7860	0x6078
+#define PCI_DEVICE_ID_ADAPTEC_7861	0x6178
+#define PCI_DEVICE_ID_ADAPTEC_7870	0x7078
+#define PCI_DEVICE_ID_ADAPTEC_7871	0x7178
+#define PCI_DEVICE_ID_ADAPTEC_7872	0x7278
+#define PCI_DEVICE_ID_ADAPTEC_7873	0x7378
+#define PCI_DEVICE_ID_ADAPTEC_7874	0x7478
+#define PCI_DEVICE_ID_ADAPTEC_7895	0x7895
+#define PCI_DEVICE_ID_ADAPTEC_7880	0x8078
+#define PCI_DEVICE_ID_ADAPTEC_7881	0x8178
+#define PCI_DEVICE_ID_ADAPTEC_7882	0x8278
+#define PCI_DEVICE_ID_ADAPTEC_7883	0x8378
+#define PCI_DEVICE_ID_ADAPTEC_7884	0x8478
+#define PCI_DEVICE_ID_ADAPTEC_7885	0x8578
+#define PCI_DEVICE_ID_ADAPTEC_7886	0x8678
+#define PCI_DEVICE_ID_ADAPTEC_7887	0x8778
+#define PCI_DEVICE_ID_ADAPTEC_7888	0x8878
+#define PCI_DEVICE_ID_ADAPTEC_1030	0x8b78
+
+#define PCI_VENDOR_ID_ADAPTEC2		0x9005
+#define PCI_DEVICE_ID_ADAPTEC2_2940U2	0x0010
+#define PCI_DEVICE_ID_ADAPTEC2_2930U2	0x0011
+#define PCI_DEVICE_ID_ADAPTEC2_7890B	0x0013
+#define PCI_DEVICE_ID_ADAPTEC2_7890	0x001f
+#define PCI_DEVICE_ID_ADAPTEC2_3940U2	0x0050
+#define PCI_DEVICE_ID_ADAPTEC2_3950U2D	0x0051
+#define PCI_DEVICE_ID_ADAPTEC2_7896	0x005f
+#define PCI_DEVICE_ID_ADAPTEC2_7892A	0x0080
+#define PCI_DEVICE_ID_ADAPTEC2_7892B	0x0081
+#define PCI_DEVICE_ID_ADAPTEC2_7892D	0x0083
+#define PCI_DEVICE_ID_ADAPTEC2_7892P	0x008f
+#define PCI_DEVICE_ID_ADAPTEC2_7899A	0x00c0
+#define PCI_DEVICE_ID_ADAPTEC2_7899B	0x00c1
+#define PCI_DEVICE_ID_ADAPTEC2_7899D	0x00c3
+#define PCI_DEVICE_ID_ADAPTEC2_7899P	0x00cf
+
+#define PCI_VENDOR_ID_ATRONICS		0x907f
+#define PCI_DEVICE_ID_ATRONICS_2015	0x2015
+
+#define PCI_VENDOR_ID_HOLTEK2		0x9412
+#define PCI_DEVICE_ID_HOLTEK2_6565	0x6565
+
+#define PCI_VENDOR_ID_NETMOS		0x9710
+#define PCI_DEVICE_ID_NETMOS_9735	0x9735
+#define PCI_DEVICE_ID_NETMOS_9835	0x9835
+
+#define PCI_SUBVENDOR_ID_EXSYS		0xd84d
+#define PCI_SUBDEVICE_ID_EXSYS_4014	0x4014
+
+#define PCI_VENDOR_ID_TIGERJET		0xe159
+#define PCI_DEVICE_ID_TIGERJET_300	0x0001
+#define PCI_DEVICE_ID_TIGERJET_100	0x0002
+
+#define PCI_VENDOR_ID_ARK		0xedd8
+#define PCI_DEVICE_ID_ARK_STING		0xa091
+#define PCI_DEVICE_ID_ARK_STINGARK	0xa099
+#define PCI_DEVICE_ID_ARK_2000MT	0xa0a1
+
Index: netboot/tg3.c
===================================================================
--- netboot/tg3.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/tg3.c	(.../trunk)	(revision 112)
@@ -0,0 +1,3297 @@
+/* $Id$
+ * tg3.c: Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001, 2002 Jeff Garzik (jgarzik@mandrakesoft.com)
+ * Copyright (C) 2003 Eric Biederman (ebiederman@lnxi.com)  [etherboot port]
+ */
+
+/* 11-13-2003	timlegge	Fix Issue with NetGear GA302T 
+ * 11-18-2003   ebiederm        Generalize NetGear Fix to what the code was supposed to be.
+ */
+
+#include "etherboot.h"
+#include "nic.h"
+#include "pci.h"
+#include "timer.h"
+/* #include "string.h" */
+#include "tg3.h"
+
+#define SUPPORT_COPPER_PHY  1
+#define SUPPORT_FIBER_PHY   1
+#define SUPPORT_LINK_REPORT 1
+#define SUPPORT_PARTNO_STR  1
+#define SUPPORT_PHY_STR     1
+
+struct tg3 tg3;
+
+/* Dummy defines for error handling */
+#define EBUSY  1
+#define ENODEV 2
+#define EINVAL 3
+#define ENOMEM 4
+
+
+/* These numbers seem to be hard coded in the NIC firmware somehow.
+ * You can't change the ring sizes, but you can change where you place
+ * them in the NIC onboard memory.
+ */
+#define TG3_RX_RING_SIZE		512
+#define TG3_DEF_RX_RING_PENDING		20	/* RX_RING_PENDING seems to be o.k. at 20 and 200 */
+#define TG3_RX_RCB_RING_SIZE	1024
+
+/*	(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705 ? \
+	 512 : 1024) */
+ #define TG3_TX_RING_SIZE		512
+#define TG3_DEF_TX_RING_PENDING		(TG3_TX_RING_SIZE - 1)
+
+#define TG3_RX_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_RING_SIZE)
+#define TG3_RX_RCB_RING_BYTES	(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_RCB_RING_SIZE)
+
+#define TG3_TX_RING_BYTES	(sizeof(struct tg3_tx_buffer_desc) * TG3_TX_RING_SIZE)
+#define NEXT_TX(N)		(((N) + 1) & (TG3_TX_RING_SIZE - 1))
+#define PREV_TX(N)		(((N) - 1) & (TG3_TX_RING_SIZE - 1))
+
+#define RX_PKT_BUF_SZ		(1536 + 2 + 64)
+
+
+static struct bss {
+	struct tg3_rx_buffer_desc rx_std[TG3_RX_RING_SIZE];
+	struct tg3_rx_buffer_desc rx_rcb[TG3_RX_RCB_RING_SIZE];
+	struct tg3_tx_buffer_desc tx_ring[TG3_TX_RING_SIZE];
+	struct tg3_hw_status      hw_status;
+	struct tg3_hw_stats       hw_stats;
+	unsigned char             rx_bufs[TG3_DEF_RX_RING_PENDING][RX_PKT_BUF_SZ];
+} tg3_bss;
+
+/**
+ * pci_save_state - save the PCI configuration space of a device before suspending
+ * @dev: - PCI device that we're dealing with
+ * @buffer: - buffer to hold config space context
+ *
+ * @buffer must be large enough to hold the entire PCI 2.2 config space 
+ * (>= 64 bytes).
+ */
+static int pci_save_state(struct pci_device *dev, uint32_t *buffer)
+{
+	int i;
+	for (i = 0; i < 16; i++)
+		pci_read_config_dword(dev, i * 4,&buffer[i]);
+	return 0;
+}
+
+/** 
+ * pci_restore_state - Restore the saved state of a PCI device
+ * @dev: - PCI device that we're dealing with
+ * @buffer: - saved PCI config space
+ *
+ */
+static int pci_restore_state(struct pci_device *dev, uint32_t *buffer)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		pci_write_config_dword(dev,i * 4, buffer[i]);
+	return 0;
+}
+
+static void tg3_write_indirect_reg32(uint32_t off, uint32_t val)
+{
+	pci_write_config_dword(tg3.pdev, TG3PCI_REG_BASE_ADDR, off);
+	pci_write_config_dword(tg3.pdev, TG3PCI_REG_DATA, val);
+}
+
+#define tw32(reg,val)		tg3_write_indirect_reg32((reg),(val))
+#define tw32_mailbox(reg, val)	writel(((val) & 0xffffffff), tg3.regs + (reg))
+#define tw16(reg,val)		writew(((val) & 0xffff), tg3.regs + (reg))
+#define tw8(reg,val)		writeb(((val) & 0xff), tg3.regs + (reg))
+#define tr32(reg)		readl(tg3.regs + (reg))
+#define tr16(reg)		readw(tg3.regs + (reg))
+#define tr8(reg)		readb(tg3.regs + (reg))
+
+static void tw32_carefully(uint32_t reg, uint32_t val)
+{
+	tw32(reg, val);
+	tr32(reg);
+	udelay(100);
+}
+
+static void tw32_mailbox2(uint32_t reg, uint32_t val)
+{
+	tw32_mailbox(reg, val);
+	tr32(reg);
+}
+
+static void tg3_write_mem(uint32_t off, uint32_t val)
+{
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+}
+
+static void tg3_read_mem(uint32_t off, uint32_t *val)
+{
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);
+	pci_read_config_dword(tg3.pdev, TG3PCI_MEM_WIN_DATA, val);
+
+	/* Always leave this as zero. */
+	pci_write_config_dword(tg3.pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);
+}
+
+static void tg3_disable_ints(struct tg3 *tp)
+{
+	tw32(TG3PCI_MISC_HOST_CTRL,
+	     (tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));
+	tw32_mailbox2(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);
+}
+
+static void tg3_switch_clocks(struct tg3 *tp)
+{
+	uint32_t orig_clock_ctrl, clock_ctrl;
+
+	clock_ctrl = tr32(TG3PCI_CLOCK_CTRL);
+
+	orig_clock_ctrl = clock_ctrl;
+	clock_ctrl &= (CLOCK_CTRL_FORCE_CLKRUN | CLOCK_CTRL_CLKRUN_OENABLE | 0x1f);
+	tp->pci_clock_ctrl = clock_ctrl;
+	
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) &&
+		(orig_clock_ctrl & CLOCK_CTRL_44MHZ_CORE)!=0) {
+		tw32_carefully(TG3PCI_CLOCK_CTRL, 
+			clock_ctrl | (CLOCK_CTRL_44MHZ_CORE | CLOCK_CTRL_ALTCLK));
+		tw32_carefully(TG3PCI_CLOCK_CTRL, 
+			clock_ctrl | (CLOCK_CTRL_ALTCLK));
+	}
+	tw32_carefully(TG3PCI_CLOCK_CTRL, clock_ctrl);
+}
+
+#define PHY_BUSY_LOOPS	5000
+
+static int tg3_readphy(struct tg3 *tp, int reg, uint32_t *val)
+{
+	uint32_t frame_val;
+	int loops, ret;
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL);
+
+	*val = 0xffffffff;
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (MI_COM_CMD_READ | MI_COM_START);
+	
+	tw32_carefully(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		udelay(10);
+		frame_val = tr32(MAC_MI_COM);
+
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+	}
+
+	ret = -EBUSY;
+	if (loops > 0) {
+		*val = frame_val & MI_COM_DATA_MASK;
+		ret = 0;
+	}
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	return ret;
+}
+
+static int tg3_writephy(struct tg3 *tp, int reg, uint32_t val)
+{
+	uint32_t frame_val;
+	int loops, ret;
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL);
+
+	frame_val  = ((PHY_ADDR << MI_COM_PHY_ADDR_SHIFT) &
+		      MI_COM_PHY_ADDR_MASK);
+	frame_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &
+		      MI_COM_REG_ADDR_MASK);
+	frame_val |= (val & MI_COM_DATA_MASK);
+	frame_val |= (MI_COM_CMD_WRITE | MI_COM_START);
+	
+	tw32_carefully(MAC_MI_COM, frame_val);
+
+	loops = PHY_BUSY_LOOPS;
+	while (loops-- > 0) {
+		udelay(10);
+		frame_val = tr32(MAC_MI_COM);
+		if ((frame_val & MI_COM_BUSY) == 0) {
+			udelay(5);
+			frame_val = tr32(MAC_MI_COM);
+			break;
+		}
+	}
+
+	ret = -EBUSY;
+	if (loops > 0)
+		ret = 0;
+
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	return ret;
+}
+
+static int tg3_writedsp(struct tg3 *tp, uint16_t addr, uint16_t val)
+{
+	int err;
+	err  = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, addr);
+	err |= tg3_writephy(tp, MII_TG3_DSP_RW_PORT, val);
+	return err;
+}
+
+
+static void tg3_phy_set_wirespeed(struct tg3 *tp)
+{
+	uint32_t val;
+
+	if (tp->tg3_flags2 & TG3_FLG2_NO_ETH_WIRE_SPEED)
+		return;
+
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x7007);
+	tg3_readphy(tp, MII_TG3_AUX_CTRL, &val);
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, (val | (1 << 15) | (1 << 4)));
+}
+
+static int tg3_bmcr_reset(struct tg3 *tp)
+{
+	uint32_t phy_control;
+	int limit, err;
+
+	/* OK, reset it, and poll the BMCR_RESET bit until it
+	 * clears or we time out.
+	 */
+	phy_control = BMCR_RESET;
+	err = tg3_writephy(tp, MII_BMCR, phy_control);
+	if (err != 0)
+		return -EBUSY;
+
+	limit = 5000;
+	while (limit--) {
+		err = tg3_readphy(tp, MII_BMCR, &phy_control);
+		if (err != 0)
+			return -EBUSY;
+
+		if ((phy_control & BMCR_RESET) == 0) {
+			udelay(40);
+			break;
+		}
+		udelay(10);
+	}
+	if (limit <= 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int tg3_wait_macro_done(struct tg3 *tp)
+{
+	int limit = 100;
+
+	while (limit--) {
+		uint32_t tmp32;
+
+		tg3_readphy(tp, 0x16, &tmp32);
+		if ((tmp32 & 0x1000) == 0)
+			break;
+	}
+	if (limit <= 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int tg3_phy_write_and_check_testpat(struct tg3 *tp, int *resetp)
+{
+	static const uint32_t test_pat[4][6] = {
+	{ 0x00005555, 0x00000005, 0x00002aaa, 0x0000000a, 0x00003456, 0x00000003 },
+	{ 0x00002aaa, 0x0000000a, 0x00003333, 0x00000003, 0x0000789a, 0x00000005 },
+	{ 0x00005a5a, 0x00000005, 0x00002a6a, 0x0000000a, 0x00001bcd, 0x00000003 },
+	{ 0x00002a5a, 0x0000000a, 0x000033c3, 0x00000003, 0x00002ef1, 0x00000005 }
+	};
+	int chan;
+
+	for (chan = 0; chan < 4; chan++) {
+		int i;
+
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+			(chan * 0x2000) | 0x0200);
+		tg3_writephy(tp, 0x16, 0x0002);
+
+		for (i = 0; i < 6; i++)
+			tg3_writephy(tp, MII_TG3_DSP_RW_PORT,
+				test_pat[chan][i]);
+
+		tg3_writephy(tp, 0x16, 0x0202);
+		if (tg3_wait_macro_done(tp)) {
+			*resetp = 1;
+			return -EBUSY;
+		}
+
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+			     (chan * 0x2000) | 0x0200);
+		tg3_writephy(tp, 0x16, 0x0082);
+		if (tg3_wait_macro_done(tp)) {
+			*resetp = 1;
+			return -EBUSY;
+		}
+
+		tg3_writephy(tp, 0x16, 0x0802);
+		if (tg3_wait_macro_done(tp)) {
+			*resetp = 1;
+			return -EBUSY;
+		}
+
+		for (i = 0; i < 6; i += 2) {
+			uint32_t low, high;
+
+			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low);
+			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high);
+			if (tg3_wait_macro_done(tp)) {
+				*resetp = 1;
+				return -EBUSY;
+			}
+			low &= 0x7fff;
+			high &= 0x000f;
+			if (low != test_pat[chan][i] ||
+			    high != test_pat[chan][i+1]) {
+				tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000b);
+				tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4001);
+				tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4005);
+
+				return -EBUSY;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int tg3_phy_reset_chanpat(struct tg3 *tp)
+{
+	int chan;
+
+	for (chan = 0; chan < 4; chan++) {
+		int i;
+
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS,
+			     (chan * 0x2000) | 0x0200);
+		tg3_writephy(tp, 0x16, 0x0002);
+		for (i = 0; i < 6; i++)
+			tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x000);
+		tg3_writephy(tp, 0x16, 0x0202);
+		if (tg3_wait_macro_done(tp))
+			return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int tg3_phy_reset_5703_4_5(struct tg3 *tp)
+{
+	uint32_t reg32, phy9_orig;
+	int retries, do_phy_reset, err;
+
+	retries = 10;
+	do_phy_reset = 1;
+	do {
+		if (do_phy_reset) {
+			err = tg3_bmcr_reset(tp);
+			if (err)
+				return err;
+			do_phy_reset = 0;
+		}
+		
+		/* Disable transmitter and interrupt.  */
+		tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+		reg32 |= 0x3000;
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+
+		/* Set full-duplex, 1000 mbps.  */
+		tg3_writephy(tp, MII_BMCR,
+			BMCR_FULLDPLX | TG3_BMCR_SPEED1000);
+
+		/* Set to master mode.  */
+		tg3_readphy(tp, MII_TG3_CTRL, &phy9_orig);
+		tg3_writephy(tp, MII_TG3_CTRL,
+			(MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER));
+
+		/* Enable SM_DSP_CLOCK and 6dB.  */
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+
+		/* Block the PHY control access.  */
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8005);
+		tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0800);
+
+		err = tg3_phy_write_and_check_testpat(tp, &do_phy_reset);
+		if (!err)
+			break;
+	} while (--retries);
+
+	err = tg3_phy_reset_chanpat(tp);
+	if (err)
+		return err;
+
+	tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8005);
+	tg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x0000);
+
+	tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8200);
+	tg3_writephy(tp, 0x16, 0x0000);
+
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0400);
+
+	tg3_writephy(tp, MII_TG3_CTRL, phy9_orig);
+
+	tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+	reg32 &= ~0x3000;
+	tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+
+	return err;
+}
+
+/* This will reset the tigon3 PHY if there is no valid
+ * link.
+ */
+static int tg3_phy_reset(struct tg3 *tp)
+{
+	uint32_t phy_status;
+	int err;
+
+	err  = tg3_readphy(tp, MII_BMSR, &phy_status);
+	err |= tg3_readphy(tp, MII_BMSR, &phy_status);
+	if (err != 0)
+		return -EBUSY;
+
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) {
+		err = tg3_phy_reset_5703_4_5(tp);
+		if (err)
+			return err;
+		goto out;
+	}
+	err = tg3_bmcr_reset(tp);
+	if (err)
+		return err;
+ out:
+	tg3_phy_set_wirespeed(tp);
+	return 0;
+}
+
+static void tg3_set_power_state_0(struct tg3 *tp)
+{
+	uint16_t power_control;
+	int pm = tp->pm_cap;
+
+	/* Make sure register accesses (indirect or otherwise)
+	 * will function correctly.
+	 */
+	pci_write_config_dword(tp->pdev,  TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+
+	pci_read_config_word(tp->pdev, pm + PCI_PM_CTRL, &power_control);
+
+	power_control |= PCI_PM_CTRL_PME_STATUS;
+	power_control &= ~(PCI_PM_CTRL_STATE_MASK);
+	power_control |= 0;
+	pci_write_config_word(tp->pdev, pm + PCI_PM_CTRL, power_control);
+
+	tw32_carefully(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+
+	return;
+}
+
+
+#if SUPPORT_LINK_REPORT
+static void tg3_link_report(struct tg3 *tp)
+{
+	if (!tp->carrier_ok) {
+		printf("Link is down.\n");
+	} else {
+		printf("Link is up at %d Mbps, %s duplex. %s %s %s\n",
+			(tp->link_config.active_speed == SPEED_1000 ?
+			       1000 :
+			(tp->link_config.active_speed == SPEED_100 ?
+				100 : 10)),
+			(tp->link_config.active_duplex == DUPLEX_FULL ?  
+				"full" : "half"),
+			(tp->tg3_flags & TG3_FLAG_TX_PAUSE) ? "TX" : "",
+			(tp->tg3_flags & TG3_FLAG_RX_PAUSE) ? "RX" : "",
+			(tp->tg3_flags & (TG3_FLAG_TX_PAUSE |TG3_FLAG_RX_PAUSE)) ? "flow control" : "");
+	}
+}
+#else
+#define tg3_link_report(tp)
+#endif
+
+static void tg3_setup_flow_control(struct tg3 *tp, uint32_t local_adv, uint32_t remote_adv)
+{
+	uint32_t new_tg3_flags = 0;
+
+	if (local_adv & ADVERTISE_PAUSE_CAP) {
+		if (local_adv & ADVERTISE_PAUSE_ASYM) {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+			else if (remote_adv & LPA_PAUSE_ASYM)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE);
+		} else {
+			if (remote_adv & LPA_PAUSE_CAP)
+				new_tg3_flags |=
+					(TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+		}
+	} else if (local_adv & ADVERTISE_PAUSE_ASYM) {
+		if ((remote_adv & LPA_PAUSE_CAP) &&
+		    (remote_adv & LPA_PAUSE_ASYM))
+			new_tg3_flags |= TG3_FLAG_TX_PAUSE;
+	}
+
+	tp->tg3_flags &= ~(TG3_FLAG_RX_PAUSE | TG3_FLAG_TX_PAUSE);
+	tp->tg3_flags |= new_tg3_flags;
+
+	if (new_tg3_flags & TG3_FLAG_RX_PAUSE)
+		tp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;
+
+	if (new_tg3_flags & TG3_FLAG_TX_PAUSE)
+		tp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;
+	else
+		tp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;
+}
+
+#if SUPPORT_COPPER_PHY
+static void tg3_aux_stat_to_speed_duplex(
+	struct tg3 *tp __unused, uint32_t val, uint8_t *speed, uint8_t *duplex)
+{
+	static const uint8_t map[] = {
+		[0] = (SPEED_INVALID << 2) | DUPLEX_INVALID,
+		[MII_TG3_AUX_STAT_10HALF >> 8]   = (SPEED_10 << 2) | DUPLEX_HALF,
+		[MII_TG3_AUX_STAT_10FULL >> 8]   = (SPEED_10 << 2) | DUPLEX_FULL,
+		[MII_TG3_AUX_STAT_100HALF >> 8]  = (SPEED_100 << 2) | DUPLEX_HALF,
+		[MII_TG3_AUX_STAT_100_4 >> 8] = (SPEED_INVALID << 2) | DUPLEX_INVALID,
+		[MII_TG3_AUX_STAT_100FULL >> 8]  = (SPEED_100 << 2) | DUPLEX_FULL,
+		[MII_TG3_AUX_STAT_1000HALF >> 8] = (SPEED_1000 << 2) | DUPLEX_HALF,
+		[MII_TG3_AUX_STAT_1000FULL >> 8] = (SPEED_1000 << 2) | DUPLEX_FULL,
+	};
+	uint8_t result;
+	result = map[(val & MII_TG3_AUX_STAT_SPDMASK) >> 8];
+	*speed = result >> 2;
+	*duplex = result & 3;
+}
+
+static int tg3_phy_copper_begin(struct tg3 *tp)
+{
+	uint32_t new_adv;
+
+	tp->link_config.advertising =
+		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+			ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+			ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+			ADVERTISED_Autoneg | ADVERTISED_MII);
+	
+	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY) {
+		tp->link_config.advertising &=
+			~(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full);
+	}
+	
+	new_adv = (ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+	if (tp->link_config.advertising & ADVERTISED_10baseT_Half) {
+		new_adv |= ADVERTISE_10HALF;
+	}
+	if (tp->link_config.advertising & ADVERTISED_10baseT_Full) {
+		new_adv |= ADVERTISE_10FULL;
+	}
+	if (tp->link_config.advertising & ADVERTISED_100baseT_Half) {
+		new_adv |= ADVERTISE_100HALF;
+	}
+	if (tp->link_config.advertising & ADVERTISED_100baseT_Full) {
+		new_adv |= ADVERTISE_100FULL;
+	}
+	tg3_writephy(tp, MII_ADVERTISE, new_adv);
+	
+	if (tp->link_config.advertising &
+		(ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {
+		new_adv = 0;
+		if (tp->link_config.advertising & ADVERTISED_1000baseT_Half) {
+			new_adv |= MII_TG3_CTRL_ADV_1000_HALF;
+		}
+		if (tp->link_config.advertising & ADVERTISED_1000baseT_Full) {
+			new_adv |= MII_TG3_CTRL_ADV_1000_FULL;
+		}
+		if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY) &&
+			(tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+				tp->pci_chip_rev_id == CHIPREV_ID_5701_B0)) {
+			new_adv |= (MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER);
+		}
+		tg3_writephy(tp, MII_TG3_CTRL, new_adv);
+	} else {
+		tg3_writephy(tp, MII_TG3_CTRL, 0);
+	}
+
+	tg3_writephy(tp, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+
+	return 0;
+}
+
+static int tg3_init_5401phy_dsp(struct tg3 *tp)
+{
+	int err;
+
+	/* Turn off tap power management. */
+	err  = tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c20);
+	
+	err |= tg3_writedsp(tp, 0x0012, 0x1804);
+	err |= tg3_writedsp(tp, 0x0013, 0x1204);
+	err |= tg3_writedsp(tp, 0x8006, 0x0132);
+	err |= tg3_writedsp(tp, 0x8006, 0x0232);
+	err |= tg3_writedsp(tp, 0x201f, 0x0a20);
+
+	udelay(40);
+
+	return err;
+}
+
+static int tg3_setup_copper_phy(struct tg3 *tp)
+{
+	int current_link_up;
+	uint32_t bmsr, dummy;
+	int i, err;
+
+	tw32_carefully(MAC_STATUS,
+		(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x02);
+
+	/* Some third-party PHYs need to be reset on link going
+	 * down.
+	 */
+	if (	(	(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+			(tp->pci_chip_rev_id == CHIPREV_ID_5705_A0)) &&
+		(tp->carrier_ok)) {
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		if (!(bmsr & BMSR_LSTATUS))
+			tg3_phy_reset(tp);
+	}
+
+	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401) {
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+		tg3_readphy(tp, MII_BMSR, &bmsr);
+
+		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
+			bmsr = 0;
+
+		if (!(bmsr & BMSR_LSTATUS)) {
+			err = tg3_init_5401phy_dsp(tp);
+			if (err)
+				return err;
+
+			tg3_readphy(tp, MII_BMSR, &bmsr);
+			for (i = 0; i < 1000; i++) {
+				udelay(10);
+				tg3_readphy(tp, MII_BMSR, &bmsr);
+				if (bmsr & BMSR_LSTATUS) {
+					udelay(40);
+					break;
+				}
+			}
+
+			if ((tp->phy_id & PHY_ID_REV_MASK) == PHY_REV_BCM5401_B0 &&
+			    !(bmsr & BMSR_LSTATUS) &&
+			    tp->link_config.active_speed == SPEED_1000) {
+				err = tg3_phy_reset(tp);
+				if (!err)
+					err = tg3_init_5401phy_dsp(tp);
+				if (err)
+					return err;
+			}
+		}
+	} else if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+		   tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+		/* 5701 {A0,B0} CRC bug workaround */
+		tg3_writephy(tp, 0x15, 0x0a75);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+		tg3_writephy(tp, 0x1c, 0x8d68);
+		tg3_writephy(tp, 0x1c, 0x8c68);
+	}
+
+	/* Clear pending interrupts... */
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+	tg3_readphy(tp, MII_TG3_ISTAT, &dummy);
+
+	tg3_writephy(tp, MII_TG3_IMASK, ~0);
+
+	if (tp->led_mode == led_mode_three_link)
+		tg3_writephy(tp, MII_TG3_EXT_CTRL,
+			     MII_TG3_EXT_CTRL_LNK3_LED_MODE);
+	else
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, 0);
+
+	current_link_up = 0;
+
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+	tg3_readphy(tp, MII_BMSR, &bmsr);
+
+	if (bmsr & BMSR_LSTATUS) {
+		uint32_t aux_stat, bmcr;
+
+		tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+		for (i = 0; i < 2000; i++) {
+			udelay(10);
+			tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
+			if (aux_stat)
+				break;
+		}
+
+		tg3_aux_stat_to_speed_duplex(tp, aux_stat,
+			&tp->link_config.active_speed,
+			&tp->link_config.active_duplex);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		tg3_readphy(tp, MII_BMCR, &bmcr);
+		if (bmcr & BMCR_ANENABLE) {
+			uint32_t gig_ctrl;
+			
+			current_link_up = 1;
+			
+			/* Force autoneg restart if we are exiting
+			 * low power mode.
+			 */
+			tg3_readphy(tp, MII_TG3_CTRL, &gig_ctrl);
+			if (!(gig_ctrl & (MII_TG3_CTRL_ADV_1000_HALF |
+				      MII_TG3_CTRL_ADV_1000_FULL))) {
+				current_link_up = 0;
+			}
+		} else {
+			current_link_up = 0;
+		}
+	}
+
+	if (current_link_up == 1 &&
+		(tp->link_config.active_duplex == DUPLEX_FULL)) {
+		uint32_t local_adv, remote_adv;
+
+		tg3_readphy(tp, MII_ADVERTISE, &local_adv);
+		local_adv &= (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+		tg3_readphy(tp, MII_LPA, &remote_adv);
+		remote_adv &= (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);
+
+		/* If we are not advertising full pause capability,
+		 * something is wrong.  Bring the link down and reconfigure.
+		 */
+		if (local_adv != ADVERTISE_PAUSE_CAP) {
+			current_link_up = 0;
+		} else {
+			tg3_setup_flow_control(tp, local_adv, remote_adv);
+		}
+	}
+
+	if (current_link_up == 0) {
+		uint32_t tmp;
+
+		tg3_phy_copper_begin(tp);
+
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		tg3_readphy(tp, MII_BMSR, &tmp);
+		if (tmp & BMSR_LSTATUS)
+			current_link_up = 1;
+	}
+
+	tp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;
+	if (current_link_up == 1) {
+		if (tp->link_config.active_speed == SPEED_100 ||
+		    tp->link_config.active_speed == SPEED_10)
+			tp->mac_mode |= MAC_MODE_PORT_MODE_MII;
+		else
+			tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+	} else
+		tp->mac_mode |= MAC_MODE_PORT_MODE_GMII;
+
+	tp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;
+	if (tp->link_config.active_duplex == DUPLEX_HALF)
+		tp->mac_mode |= MAC_MODE_HALF_DUPLEX;
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) {
+		if ((tp->led_mode == led_mode_link10) ||
+		    (current_link_up == 1 &&
+		     tp->link_config.active_speed == SPEED_10))
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+	} else {
+		if (current_link_up == 1)
+			tp->mac_mode |= MAC_MODE_LINK_POLARITY;
+		tw32(MAC_LED_CTRL, LED_CTRL_PHY_MODE_1);
+	}
+
+	/* ??? Without this setting Netgear GA302T PHY does not
+	 * ??? send/receive packets...
+	 * With this other PHYs cannot bring up the link
+	 */
+	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5411 &&
+		tp->pci_chip_rev_id == CHIPREV_ID_5700_ALTIMA) {
+		tp->mi_mode |= MAC_MI_MODE_AUTO_POLL;
+		tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+	}
+
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	/* Link change polled. */
+	tw32_carefully(MAC_EVENT, 0);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700 &&
+	    current_link_up == 1 &&
+	    tp->link_config.active_speed == SPEED_1000 &&
+	    ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ||
+	     (tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED))) {
+		udelay(120);
+		tw32_carefully(MAC_STATUS,
+			(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+		tg3_write_mem(
+			      NIC_SRAM_FIRMWARE_MBOX,
+			      NIC_SRAM_FIRMWARE_MBOX_MAGIC2);
+	}
+
+	if (current_link_up != tp->carrier_ok) {
+		tp->carrier_ok = current_link_up;
+		tg3_link_report(tp);
+	}
+
+	return 0;
+}
+#else
+#define tg3_setup_copper_phy(TP) (-EINVAL)
+#endif /* SUPPORT_COPPER_PHY */
+
+#if SUPPORT_FIBER_PHY
+struct tg3_fiber_aneginfo {
+	int state;
+#define ANEG_STATE_UNKNOWN		0
+#define ANEG_STATE_AN_ENABLE		1
+#define ANEG_STATE_RESTART_INIT		2
+#define ANEG_STATE_RESTART		3
+#define ANEG_STATE_DISABLE_LINK_OK	4
+#define ANEG_STATE_ABILITY_DETECT_INIT	5
+#define ANEG_STATE_ABILITY_DETECT	6
+#define ANEG_STATE_ACK_DETECT_INIT	7
+#define ANEG_STATE_ACK_DETECT		8
+#define ANEG_STATE_COMPLETE_ACK_INIT	9
+#define ANEG_STATE_COMPLETE_ACK		10
+#define ANEG_STATE_IDLE_DETECT_INIT	11
+#define ANEG_STATE_IDLE_DETECT		12
+#define ANEG_STATE_LINK_OK		13
+#define ANEG_STATE_NEXT_PAGE_WAIT_INIT	14
+#define ANEG_STATE_NEXT_PAGE_WAIT	15
+
+	uint32_t flags;
+#define MR_AN_ENABLE		0x00000001
+#define MR_RESTART_AN		0x00000002
+#define MR_AN_COMPLETE		0x00000004
+#define MR_PAGE_RX		0x00000008
+#define MR_NP_LOADED		0x00000010
+#define MR_TOGGLE_TX		0x00000020
+#define MR_LP_ADV_FULL_DUPLEX	0x00000040
+#define MR_LP_ADV_HALF_DUPLEX	0x00000080
+#define MR_LP_ADV_SYM_PAUSE	0x00000100
+#define MR_LP_ADV_ASYM_PAUSE	0x00000200
+#define MR_LP_ADV_REMOTE_FAULT1	0x00000400
+#define MR_LP_ADV_REMOTE_FAULT2	0x00000800
+#define MR_LP_ADV_NEXT_PAGE	0x00001000
+#define MR_TOGGLE_RX		0x00002000
+#define MR_NP_RX		0x00004000
+
+#define MR_LINK_OK		0x80000000
+
+	unsigned long link_time, cur_time;
+
+	uint32_t ability_match_cfg;
+	int ability_match_count;
+
+	char ability_match, idle_match, ack_match;
+
+	uint32_t txconfig, rxconfig;
+#define ANEG_CFG_NP		0x00000080
+#define ANEG_CFG_ACK		0x00000040
+#define ANEG_CFG_RF2		0x00000020
+#define ANEG_CFG_RF1		0x00000010
+#define ANEG_CFG_PS2		0x00000001
+#define ANEG_CFG_PS1		0x00008000
+#define ANEG_CFG_HD		0x00004000
+#define ANEG_CFG_FD		0x00002000
+#define ANEG_CFG_INVAL		0x00001f06
+
+};
+#define ANEG_OK		0
+#define ANEG_DONE	1
+#define ANEG_TIMER_ENAB	2
+#define ANEG_FAILED	-1
+
+#define ANEG_STATE_SETTLE_TIME	10000
+
+static int tg3_fiber_aneg_smachine(struct tg3 *tp,
+				   struct tg3_fiber_aneginfo *ap)
+{
+	unsigned long delta;
+	uint32_t rx_cfg_reg;
+	int ret;
+
+	if (ap->state == ANEG_STATE_UNKNOWN) {
+		ap->rxconfig = 0;
+		ap->link_time = 0;
+		ap->cur_time = 0;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->idle_match = 0;
+		ap->ack_match = 0;
+	}
+	ap->cur_time++;
+
+	if (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {
+		rx_cfg_reg = tr32(MAC_RX_AUTO_NEG);
+
+		if (rx_cfg_reg != ap->ability_match_cfg) {
+			ap->ability_match_cfg = rx_cfg_reg;
+			ap->ability_match = 0;
+			ap->ability_match_count = 0;
+		} else {
+			if (++ap->ability_match_count > 1) {
+				ap->ability_match = 1;
+				ap->ability_match_cfg = rx_cfg_reg;
+			}
+		}
+		if (rx_cfg_reg & ANEG_CFG_ACK)
+			ap->ack_match = 1;
+		else
+			ap->ack_match = 0;
+
+		ap->idle_match = 0;
+	} else {
+		ap->idle_match = 1;
+		ap->ability_match_cfg = 0;
+		ap->ability_match_count = 0;
+		ap->ability_match = 0;
+		ap->ack_match = 0;
+
+		rx_cfg_reg = 0;
+	}
+
+	ap->rxconfig = rx_cfg_reg;
+	ret = ANEG_OK;
+
+	switch(ap->state) {
+	case ANEG_STATE_UNKNOWN:
+		if (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))
+			ap->state = ANEG_STATE_AN_ENABLE;
+
+		/* fallthru */
+	case ANEG_STATE_AN_ENABLE:
+		ap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);
+		if (ap->flags & MR_AN_ENABLE) {
+			ap->link_time = 0;
+			ap->cur_time = 0;
+			ap->ability_match_cfg = 0;
+			ap->ability_match_count = 0;
+			ap->ability_match = 0;
+			ap->idle_match = 0;
+			ap->ack_match = 0;
+
+			ap->state = ANEG_STATE_RESTART_INIT;
+		} else {
+			ap->state = ANEG_STATE_DISABLE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_RESTART_INIT:
+		ap->link_time = ap->cur_time;
+		ap->flags &= ~(MR_NP_LOADED);
+		ap->txconfig = 0;
+		tw32(MAC_TX_AUTO_NEG, 0);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ret = ANEG_TIMER_ENAB;
+		ap->state = ANEG_STATE_RESTART;
+
+		/* fallthru */
+	case ANEG_STATE_RESTART:
+		delta = ap->cur_time - ap->link_time;
+		if (delta > ANEG_STATE_SETTLE_TIME) {
+			ap->state = ANEG_STATE_ABILITY_DETECT_INIT;
+		} else {
+			ret = ANEG_TIMER_ENAB;
+		}
+		break;
+
+	case ANEG_STATE_DISABLE_LINK_OK:
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT_INIT:
+		ap->flags &= ~(MR_TOGGLE_TX);
+		ap->txconfig = (ANEG_CFG_FD | ANEG_CFG_PS1);
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ap->state = ANEG_STATE_ABILITY_DETECT;
+		break;
+
+	case ANEG_STATE_ABILITY_DETECT:
+		if (ap->ability_match != 0 && ap->rxconfig != 0) {
+			ap->state = ANEG_STATE_ACK_DETECT_INIT;
+		}
+		break;
+
+	case ANEG_STATE_ACK_DETECT_INIT:
+		ap->txconfig |= ANEG_CFG_ACK;
+		tw32(MAC_TX_AUTO_NEG, ap->txconfig);
+		tp->mac_mode |= MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ap->state = ANEG_STATE_ACK_DETECT;
+
+		/* fallthru */
+	case ANEG_STATE_ACK_DETECT:
+		if (ap->ack_match != 0) {
+			if ((ap->rxconfig & ~ANEG_CFG_ACK) ==
+			    (ap->ability_match_cfg & ~ANEG_CFG_ACK)) {
+				ap->state = ANEG_STATE_COMPLETE_ACK_INIT;
+			} else {
+				ap->state = ANEG_STATE_AN_ENABLE;
+			}
+		} else if (ap->ability_match != 0 &&
+			   ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+		}
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK_INIT:
+		if (ap->rxconfig & ANEG_CFG_INVAL) {
+			ret = ANEG_FAILED;
+			break;
+		}
+		ap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |
+			       MR_LP_ADV_HALF_DUPLEX |
+			       MR_LP_ADV_SYM_PAUSE |
+			       MR_LP_ADV_ASYM_PAUSE |
+			       MR_LP_ADV_REMOTE_FAULT1 |
+			       MR_LP_ADV_REMOTE_FAULT2 |
+			       MR_LP_ADV_NEXT_PAGE |
+			       MR_TOGGLE_RX |
+			       MR_NP_RX);
+		if (ap->rxconfig & ANEG_CFG_FD)
+			ap->flags |= MR_LP_ADV_FULL_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_HD)
+			ap->flags |= MR_LP_ADV_HALF_DUPLEX;
+		if (ap->rxconfig & ANEG_CFG_PS1)
+			ap->flags |= MR_LP_ADV_SYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_PS2)
+			ap->flags |= MR_LP_ADV_ASYM_PAUSE;
+		if (ap->rxconfig & ANEG_CFG_RF1)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT1;
+		if (ap->rxconfig & ANEG_CFG_RF2)
+			ap->flags |= MR_LP_ADV_REMOTE_FAULT2;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_LP_ADV_NEXT_PAGE;
+
+		ap->link_time = ap->cur_time;
+
+		ap->flags ^= (MR_TOGGLE_TX);
+		if (ap->rxconfig & 0x0008)
+			ap->flags |= MR_TOGGLE_RX;
+		if (ap->rxconfig & ANEG_CFG_NP)
+			ap->flags |= MR_NP_RX;
+		ap->flags |= MR_PAGE_RX;
+
+		ap->state = ANEG_STATE_COMPLETE_ACK;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_COMPLETE_ACK:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > ANEG_STATE_SETTLE_TIME) {
+			if (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {
+				ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+			} else {
+				if ((ap->txconfig & ANEG_CFG_NP) == 0 &&
+				    !(ap->flags & MR_NP_RX)) {
+					ap->state = ANEG_STATE_IDLE_DETECT_INIT;
+				} else {
+					ret = ANEG_FAILED;
+				}
+			}
+		}
+		break;
+
+	case ANEG_STATE_IDLE_DETECT_INIT:
+		ap->link_time = ap->cur_time;
+		tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+		tw32_carefully(MAC_MODE, tp->mac_mode);
+
+		ap->state = ANEG_STATE_IDLE_DETECT;
+		ret = ANEG_TIMER_ENAB;
+		break;
+
+	case ANEG_STATE_IDLE_DETECT:
+		if (ap->ability_match != 0 &&
+		    ap->rxconfig == 0) {
+			ap->state = ANEG_STATE_AN_ENABLE;
+			break;
+		}
+		delta = ap->cur_time - ap->link_time;
+		if (delta > ANEG_STATE_SETTLE_TIME) {
+			/* XXX another gem from the Broadcom driver :( */
+			ap->state = ANEG_STATE_LINK_OK;
+		}
+		break;
+
+	case ANEG_STATE_LINK_OK:
+		ap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);
+		ret = ANEG_DONE;
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT_INIT:
+		/* ??? unimplemented */
+		break;
+
+	case ANEG_STATE_NEXT_PAGE_WAIT:
+		/* ??? unimplemented */
+		break;
+
+	default:
+		ret = ANEG_FAILED;
+		break;
+	};
+
+	return ret;
+}
+
+static int tg3_setup_fiber_phy(struct tg3 *tp)
+{
+	uint32_t orig_pause_cfg;
+	uint16_t orig_active_speed;
+	uint8_t orig_active_duplex;
+	int current_link_up;
+	int i;
+
+	orig_pause_cfg =
+		(tp->tg3_flags & (TG3_FLAG_RX_PAUSE |
+				  TG3_FLAG_TX_PAUSE));
+	orig_active_speed = tp->link_config.active_speed;
+	orig_active_duplex = tp->link_config.active_duplex;
+
+	tp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);
+	tp->mac_mode |= MAC_MODE_PORT_MODE_TBI;
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	/* Reset when initting first time or we have a link. */
+	if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) ||
+	    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+		/* Set PLL lock range. */
+		tg3_writephy(tp, 0x16, 0x8007);
+
+		/* SW reset */
+		tg3_writephy(tp, MII_BMCR, BMCR_RESET);
+
+		/* Wait for reset to complete. */
+		mdelay(5);
+
+		/* Config mode; select PMA/Ch 1 regs. */
+		tg3_writephy(tp, 0x10, 0x8411);
+
+		/* Enable auto-lock and comdet, select txclk for tx. */
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		tg3_writephy(tp, 0x18, 0x00a0);
+		tg3_writephy(tp, 0x16, 0x41ff);
+
+		/* Assert and deassert POR. */
+		tg3_writephy(tp, 0x13, 0x0400);
+		udelay(40);
+		tg3_writephy(tp, 0x13, 0x0000);
+
+		tg3_writephy(tp, 0x11, 0x0a50);
+		udelay(40);
+		tg3_writephy(tp, 0x11, 0x0a10);
+
+		/* Wait for signal to stabilize */
+		mdelay(150);
+
+		/* Deselect the channel register so we can read the PHYID
+		 * later.
+		 */
+		tg3_writephy(tp, 0x10, 0x8011);
+	}
+
+	/* Disable link change interrupt.  */
+	tw32_carefully(MAC_EVENT, 0);
+
+	current_link_up = 0;
+	if (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) {
+		if (!(tp->tg3_flags & TG3_FLAG_GOT_SERDES_FLOWCTL)) {
+			struct tg3_fiber_aneginfo aninfo;
+			int status = ANEG_FAILED;
+			unsigned int tick;
+			uint32_t tmp;
+
+			memset(&aninfo, 0, sizeof(aninfo));
+			aninfo.flags |= (MR_AN_ENABLE);
+
+			tw32(MAC_TX_AUTO_NEG, 0);
+
+			tmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;
+			tw32_carefully(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);
+
+			tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);
+
+			aninfo.state = ANEG_STATE_UNKNOWN;
+			aninfo.cur_time = 0;
+			tick = 0;
+			while (++tick < 195000) {
+				status = tg3_fiber_aneg_smachine(tp, &aninfo);
+				if (status == ANEG_DONE ||
+				    status == ANEG_FAILED)
+					break;
+
+				udelay(1);
+			}
+
+			tp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;
+			tw32_carefully(MAC_MODE, tp->mac_mode);
+
+			if (status == ANEG_DONE &&
+			    (aninfo.flags &
+			     (MR_AN_COMPLETE | MR_LINK_OK |
+			      MR_LP_ADV_FULL_DUPLEX))) {
+				uint32_t local_adv, remote_adv;
+
+				local_adv = ADVERTISE_PAUSE_CAP;
+				remote_adv = 0;
+				if (aninfo.flags & MR_LP_ADV_SYM_PAUSE)
+					remote_adv |= LPA_PAUSE_CAP;
+				if (aninfo.flags & MR_LP_ADV_ASYM_PAUSE)
+					remote_adv |= LPA_PAUSE_ASYM;
+
+				tg3_setup_flow_control(tp, local_adv, remote_adv);
+
+				tp->tg3_flags |=
+					TG3_FLAG_GOT_SERDES_FLOWCTL;
+				current_link_up = 1;
+			}
+			for (i = 0; i < 60; i++) {
+				udelay(20);
+				tw32_carefully(MAC_STATUS,
+					(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+				if ((tr32(MAC_STATUS) &
+				     (MAC_STATUS_SYNC_CHANGED |
+				      MAC_STATUS_CFG_CHANGED)) == 0)
+					break;
+			}
+			if (current_link_up == 0 &&
+			    (tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED)) {
+				current_link_up = 1;
+			}
+		} else {
+			/* Forcing 1000FD link up. */
+			current_link_up = 1;
+		}
+	}
+
+	tp->mac_mode &= ~MAC_MODE_LINK_POLARITY;
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	tp->hw_status->status =
+		(SD_STATUS_UPDATED |
+		 (tp->hw_status->status & ~SD_STATUS_LINK_CHG));
+
+	for (i = 0; i < 100; i++) {
+		udelay(20);
+		tw32_carefully(MAC_STATUS,
+			(MAC_STATUS_SYNC_CHANGED | MAC_STATUS_CFG_CHANGED));
+		if ((tr32(MAC_STATUS) &
+		     (MAC_STATUS_SYNC_CHANGED |
+		      MAC_STATUS_CFG_CHANGED)) == 0)
+			break;
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0)
+		current_link_up = 0;
+
+	if (current_link_up == 1) {
+		tp->link_config.active_speed = SPEED_1000;
+		tp->link_config.active_duplex = DUPLEX_FULL;
+	} else {
+		tp->link_config.active_speed = SPEED_INVALID;
+		tp->link_config.active_duplex = DUPLEX_INVALID;
+	}
+
+	if (current_link_up != tp->carrier_ok) {
+		tp->carrier_ok = current_link_up;
+		tg3_link_report(tp);
+	} else {
+		uint32_t now_pause_cfg =
+			tp->tg3_flags & (TG3_FLAG_RX_PAUSE |
+					 TG3_FLAG_TX_PAUSE);
+		if (orig_pause_cfg != now_pause_cfg ||
+		    orig_active_speed != tp->link_config.active_speed ||
+		    orig_active_duplex != tp->link_config.active_duplex)
+			tg3_link_report(tp);
+	}
+
+	if ((tr32(MAC_STATUS) & MAC_STATUS_PCS_SYNCED) == 0) {
+		tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_LINK_POLARITY);
+		if (tp->tg3_flags & TG3_FLAG_INIT_COMPLETE) {
+			tw32_carefully(MAC_MODE, tp->mac_mode);
+		}
+	}
+
+	return 0;
+}
+#else
+#define tg3_setup_fiber_phy(TP) (-EINVAL)
+#endif /* SUPPORT_FIBER_PHY */
+
+static int tg3_setup_phy(struct tg3 *tp)
+{
+	int err;
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		err = tg3_setup_fiber_phy(tp);
+	} else {
+		err = tg3_setup_copper_phy(tp);
+	}
+
+	if (tp->link_config.active_speed == SPEED_1000 &&
+	    tp->link_config.active_duplex == DUPLEX_HALF)
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));
+	else
+		tw32(MAC_TX_LENGTHS,
+		     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+		      (6 << TX_LENGTHS_IPG_SHIFT) |
+		      (32 << TX_LENGTHS_SLOT_TIME_SHIFT)));
+
+	return err;
+}
+
+
+#define MAX_WAIT_CNT 1000
+
+/* To stop a block, clear the enable bit and poll till it
+ * clears.  
+ */
+static int tg3_stop_block(struct tg3 *tp, unsigned long ofs, uint32_t enable_bit)
+{
+	unsigned int i;
+	uint32_t val;
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+		switch(ofs) {
+		case RCVLSC_MODE:
+		case DMAC_MODE:
+		case MBFREE_MODE:
+		case BUFMGR_MODE:
+		case MEMARB_MODE:
+			/* We can't enable/disable these bits of the
+			 * 5705, just say success.
+			 */
+			return 0;
+		default:
+			break;
+		}
+	}
+	val = tr32(ofs);
+	val &= ~enable_bit;
+	tw32(ofs, val);
+	tr32(ofs);
+
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		udelay(100);
+		val = tr32(ofs);
+		if ((val & enable_bit) == 0)
+			break;
+	}
+
+	if (i == MAX_WAIT_CNT) {
+		printf("tg3_stop_block timed out, ofs=%lx enable_bit=%x\n",
+		       ofs, enable_bit);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int tg3_abort_hw(struct tg3 *tp)
+{
+	int i, err;
+
+	tg3_disable_ints(tp);
+
+	tp->rx_mode &= ~RX_MODE_ENABLE;
+	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+
+	err  = tg3_stop_block(tp, RCVBDI_MODE,   RCVBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLPC_MODE,   RCVLPC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVLSC_MODE,   RCVLSC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDBDI_MODE,  RCVDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVDCC_MODE,   RCVDCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RCVCC_MODE,    RCVCC_MODE_ENABLE);
+
+	err |= tg3_stop_block(tp, SNDBDS_MODE,   SNDBDS_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDI_MODE,   SNDBDI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);
+	err |= tg3_stop_block(tp, RDMAC_MODE,    RDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, SNDBDC_MODE,   SNDBDC_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	tp->mac_mode &= ~MAC_MODE_TDE_ENABLE;
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+	tp->tx_mode &= ~TX_MODE_ENABLE;
+	tw32_carefully(MAC_TX_MODE, tp->tx_mode);
+
+	for (i = 0; i < MAX_WAIT_CNT; i++) {
+		udelay(100);
+		if (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))
+			break;
+	}
+	if (i >= MAX_WAIT_CNT) {
+		printf("tg3_abort_hw timed out TX_MODE_ENABLE will not clear MAC_TX_MODE=%x\n",
+			tr32(MAC_TX_MODE));
+		return -ENODEV;
+	}
+
+	err  = tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, WDMAC_MODE,  WDMAC_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE);
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+
+	err |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE);
+	err |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE);
+	if (err)
+		goto out;
+
+	memset(tp->hw_status, 0, TG3_HW_STATUS_SIZE);
+
+out:
+	return err;
+}
+
+static void tg3_chip_reset(struct tg3 *tp)
+{
+	uint32_t val;
+
+	if (!(tp->tg3_flags2 & TG3_FLG2_SUN_5704)) {
+		/* Force NVRAM to settle.
+		 * This deals with a chip bug which can result in EEPROM
+		 * corruption.
+		 */
+		if (tp->tg3_flags & TG3_FLAG_NVRAM) {
+			int i;
+	
+			tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+			for (i = 0; i < 100000; i++) {
+				if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+					break;
+				udelay(10);
+			}
+		}
+	}
+	/* In Etherboot we don't need to worry about the 5701
+	 * REG_WRITE_BUG because we do all register writes indirectly.
+	 */
+
+	/* do the reset */
+	val = GRC_MISC_CFG_CORECLK_RESET;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)
+		val |= GRC_MISC_CFG_KEEP_GPHY_POWER;
+	tw32(GRC_MISC_CFG, val);
+
+	/* Flush PCI posted writes.  The normal MMIO registers
+	 * are inaccessible at this time so this is the only
+	 * way to make this reliably.  I tried to use indirect
+	 * register read/write but this upset some 5701 variants.
+	 */
+	pci_read_config_dword(tp->pdev, PCI_COMMAND, &val);
+
+	udelay(120);
+
+	/* Re-enable indirect register accesses. */
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	/* Set MAX PCI retry to zero. */
+	val = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5704_A0 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE))
+		val |= PCISTATE_RETRY_SAME_DMA;
+	pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);
+
+	pci_restore_state(tp->pdev, tp->pci_cfg_state);
+
+	/* Make sure PCI-X relaxed ordering bit is clear. */
+	pci_read_config_dword(tp->pdev, TG3PCI_X_CAPS, &val);
+	val &= ~PCIX_CAPS_RELAXED_ORDERING;
+	pci_write_config_dword(tp->pdev, TG3PCI_X_CAPS, val);
+
+	tw32(MEMARB_MODE, MEMARB_MODE_ENABLE);
+
+	if (((tp->nic_sram_data_cfg & NIC_SRAM_DATA_CFG_MINI_PCI) != 0) &&
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) {
+		tp->pci_clock_ctrl |=
+			(CLOCK_CTRL_FORCE_CLKRUN | CLOCK_CTRL_CLKRUN_OENABLE);
+		tw32(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);
+	}
+
+	tw32(TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);
+}
+
+static void tg3_stop_fw(struct tg3 *tp)
+{
+	if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF) {
+		uint32_t val;
+		int i;
+
+		tg3_write_mem(NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_PAUSE_FW);
+		val = tr32(GRC_RX_CPU_EVENT);
+		val |= (1 << 14);
+		tw32(GRC_RX_CPU_EVENT, val);
+
+		/* Wait for RX cpu to ACK the event.  */
+		for (i = 0; i < 100; i++) {
+			if (!(tr32(GRC_RX_CPU_EVENT) & (1 << 14)))
+				break;
+			udelay(1);
+		}
+	}
+}
+
+static int tg3_restart_fw(struct tg3 *tp, uint32_t state)
+{
+	uint32_t val;
+	int i;
+	
+	tg3_write_mem(NIC_SRAM_FIRMWARE_MBOX, 
+		NIC_SRAM_FIRMWARE_MBOX_MAGIC1);
+	/* Wait for firmware initialization to complete. */
+	for (i = 0; i < 100000; i++) {
+		tg3_read_mem(NIC_SRAM_FIRMWARE_MBOX, &val);
+		if (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)
+			break;
+		udelay(10);
+	}
+	if (i >= 100000 &&
+		    !(tp->tg3_flags2 & TG3_FLG2_SUN_5704)) {
+		printf("Firmware will not restart magic=%x\n",
+			val);
+		return -ENODEV;
+	}
+	if (!(tp->tg3_flags & TG3_FLAG_ENABLE_ASF)) {
+		state = DRV_STATE_SUSPEND;
+	}
+	tg3_write_mem(NIC_SRAM_FW_DRV_STATE_MBOX, state);
+	return 0;
+}
+
+static int tg3_halt(struct tg3 *tp)
+{
+	tg3_stop_fw(tp);
+	tg3_abort_hw(tp);
+	tg3_chip_reset(tp);
+	return tg3_restart_fw(tp, DRV_STATE_UNLOAD);
+}
+
+static void __tg3_set_mac_addr(struct tg3 *tp)
+{
+	uint32_t addr_high, addr_low;
+	int i;
+
+	addr_high = ((tp->nic->node_addr[0] << 8) |
+		     tp->nic->node_addr[1]);
+	addr_low = ((tp->nic->node_addr[2] << 24) |
+		    (tp->nic->node_addr[3] << 16) |
+		    (tp->nic->node_addr[4] <<  8) |
+		    (tp->nic->node_addr[5] <<  0));
+	for (i = 0; i < 4; i++) {
+		tw32(MAC_ADDR_0_HIGH + (i * 8), addr_high);
+		tw32(MAC_ADDR_0_LOW + (i * 8), addr_low);
+	}
+
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700) &&
+		(GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) &&
+		(GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705)) {
+		for(i = 0; i < 12; i++) {
+			tw32(MAC_EXTADDR_0_HIGH + (i * 8), addr_high);
+			tw32(MAC_EXTADDR_0_LOW + (i * 8), addr_low);
+		}
+	}
+	addr_high = (tp->nic->node_addr[0] +
+		     tp->nic->node_addr[1] +
+		     tp->nic->node_addr[2] +
+		     tp->nic->node_addr[3] +
+		     tp->nic->node_addr[4] +
+		     tp->nic->node_addr[5]) &
+		TX_BACKOFF_SEED_MASK;
+	tw32(MAC_TX_BACKOFF_SEED, addr_high);
+}
+
+static void tg3_set_bdinfo(struct tg3 *tp, uint32_t bdinfo_addr,
+			   dma_addr_t mapping, uint32_t maxlen_flags,
+			   uint32_t nic_addr)
+{
+	tg3_write_mem((bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH),
+		      ((uint64_t) mapping >> 32));
+	tg3_write_mem((bdinfo_addr +
+		       TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW),
+		      ((uint64_t) mapping & 0xffffffff));
+	tg3_write_mem((bdinfo_addr +
+		       TG3_BDINFO_MAXLEN_FLAGS),
+		       maxlen_flags);
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		tg3_write_mem((bdinfo_addr + TG3_BDINFO_NIC_ADDR), nic_addr);
+	}
+}
+
+
+static void tg3_init_rings(struct tg3 *tp)
+{
+	unsigned i;
+
+	/* Zero out the tg3 variables */
+	memset(&tg3_bss, 0, sizeof(tg3_bss));
+	tp->rx_std    = &tg3_bss.rx_std[0];
+	tp->rx_rcb    = &tg3_bss.rx_rcb[0];
+	tp->tx_ring   = &tg3_bss.tx_ring[0];
+	tp->hw_status = &tg3_bss.hw_status;
+	tp->hw_stats  = &tg3_bss.hw_stats;
+	tp->mac_mode  = 0;
+
+
+	/* Initialize tx/rx rings for packet processing.
+	 *
+	 * The chip has been shut down and the driver detached from
+	 * the networking, so no interrupts or new tx packets will
+	 * end up in the driver.
+	 */
+
+	/* Initialize invariants of the rings, we only set this
+	 * stuff once.  This works because the card does not
+	 * write into the rx buffer posting rings.
+	 */
+	for (i = 0; i < TG3_RX_RING_SIZE; i++) {
+		struct tg3_rx_buffer_desc *rxd;
+
+		rxd = &tp->rx_std[i];
+		rxd->idx_len = (RX_PKT_BUF_SZ - 2 - 64)	<< RXD_LEN_SHIFT;
+		rxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);
+		rxd->opaque = (RXD_OPAQUE_RING_STD | (i << RXD_OPAQUE_INDEX_SHIFT));
+
+		/* Note where the receive buffer for the ring is placed */
+		rxd->addr_hi = 0;
+		rxd->addr_lo = virt_to_bus(
+			&tg3_bss.rx_bufs[i%TG3_DEF_RX_RING_PENDING][2]);
+	}
+}
+
+#define TG3_WRITE_SETTINGS(TABLE) \
+do { \
+	const uint32_t *_table, *_end; \
+	_table = TABLE; \
+	_end = _table + sizeof(TABLE)/sizeof(TABLE[0]);  \
+	for(; _table < _end; _table += 2) { \
+		tw32(_table[0], _table[1]); \
+	} \
+} while(0)
+
+
+/* initialize/reset the tg3 */
+static int tg3_setup_hw(struct tg3 *tp)
+{
+	uint32_t val, rdmac_mode;
+	int i, err, limit;
+
+	/* Simply don't support setups with extremly buggy firmware in etherboot */
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {
+		printf("Error 5701_A0 firmware bug detected\n");
+		return -EINVAL;
+	}
+
+	tg3_disable_ints(tp);
+
+	/* Originally this was all in tg3_init_hw */
+
+	/* Force the chip into D0. */
+	tg3_set_power_state_0(tp);
+
+	tg3_switch_clocks(tp);
+
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+
+	/* Originally this was all in tg3_reset_hw */
+
+	tg3_stop_fw(tp);
+
+	/* No need to call tg3_abort_hw here, it is called before tg3_setup_hw. */
+
+	tg3_chip_reset(tp);
+
+	tw32(GRC_MODE, tp->grc_mode);  /* Redundant? */
+
+	err = tg3_restart_fw(tp, DRV_STATE_START);
+	if (err)
+		return err;
+
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->mac_mode = MAC_MODE_PORT_MODE_TBI;
+	}
+	tw32_carefully(MAC_MODE, tp->mac_mode);
+
+
+	/* This works around an issue with Athlon chipsets on
+	 * B3 tigon3 silicon.  This bit has no effect on any
+	 * other revision.
+	 */
+	tp->pci_clock_ctrl |= CLOCK_CTRL_DELAY_PCI_GRANT;
+	tw32_carefully(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5704_A0 &&
+	    (tp->tg3_flags & TG3_FLAG_PCIX_MODE)) {
+		val = tr32(TG3PCI_PCISTATE);
+		val |= PCISTATE_RETRY_SAME_DMA;
+		tw32(TG3PCI_PCISTATE, val);
+	}
+
+	/* Descriptor ring init may make accesses to the
+	 * NIC SRAM area to setup the TX descriptors, so we
+	 * can only do this after the hardware has been
+	 * successfully reset.
+	 */
+	tg3_init_rings(tp);
+
+	/* Clear statistics/status block in chip */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		for (i = NIC_SRAM_STATS_BLK;
+		     i < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;
+		     i += sizeof(uint32_t)) {
+			tg3_write_mem(i, 0);
+			udelay(40);
+		}
+	}
+
+	/* This value is determined during the probe time DMA
+	 * engine test, tg3_setup_dma.
+	 */
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	tp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |
+			  GRC_MODE_4X_NIC_SEND_RINGS |
+			  GRC_MODE_NO_TX_PHDR_CSUM |
+			  GRC_MODE_NO_RX_PHDR_CSUM);
+	tp->grc_mode |= GRC_MODE_HOST_SENDBDS;
+	tp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;
+	tp->grc_mode |= GRC_MODE_NO_RX_PHDR_CSUM;
+
+	tw32(GRC_MODE,
+		tp->grc_mode | 
+		(GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP));
+
+	/* Setup the timer prescalar register.  Clock is always 66Mhz. */
+	tw32(GRC_MISC_CFG,
+	     (65 << GRC_MISC_CFG_PRESCALAR_SHIFT));
+
+	/* Initialize MBUF/DESC pool. */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		tw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE);
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)
+			tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE64);
+		else
+			tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE96);
+		tw32(BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE);
+		tw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);
+	}
+	if (!(tp->tg3_flags & TG3_FLAG_JUMBO_ENABLE)) {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water);
+	} else {
+		tw32(BUFMGR_MB_RDMA_LOW_WATER,
+		     tp->bufmgr_config.mbuf_read_dma_low_water_jumbo);
+		tw32(BUFMGR_MB_MACRX_LOW_WATER,
+		     tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);
+		tw32(BUFMGR_MB_HIGH_WATER,
+		     tp->bufmgr_config.mbuf_high_water_jumbo);
+	}
+	tw32(BUFMGR_DMA_LOW_WATER,
+	     tp->bufmgr_config.dma_low_water);
+	tw32(BUFMGR_DMA_HIGH_WATER,
+	     tp->bufmgr_config.dma_high_water);
+
+	tw32(BUFMGR_MODE, BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printf("tg3_setup_hw cannot enable BUFMGR\n");
+		return -ENODEV;
+	}
+
+	tw32(FTQ_RESET, 0xffffffff);
+	tw32(FTQ_RESET, 0x00000000);
+	for (i = 0; i < 2000; i++) {
+		if (tr32(FTQ_RESET) == 0x00000000)
+			break;
+		udelay(10);
+	}
+	if (i >= 2000) {
+		printf("tg3_setup_hw cannot reset FTQ\n");
+		return -ENODEV;
+	}
+
+	/* Initialize TG3_BDINFO's at:
+	 *  RCVDBDI_STD_BD:	standard eth size rx ring
+	 *  RCVDBDI_JUMBO_BD:	jumbo frame rx ring
+	 *  RCVDBDI_MINI_BD:	small frame rx ring (??? does not work)
+	 *
+	 * like so:
+	 *  TG3_BDINFO_HOST_ADDR:	high/low parts of DMA address of ring
+	 *  TG3_BDINFO_MAXLEN_FLAGS:	(rx max buffer size << 16) |
+	 *                              ring attribute flags
+	 *  TG3_BDINFO_NIC_ADDR:	location of descriptors in nic SRAM
+	 *
+	 * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.
+	 * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.
+	 *
+	 * ??? No space allocated for mini receive ring? :(
+	 *
+	 * The size of each ring is fixed in the firmware, but the location is
+	 * configurable.
+	 */
+	{
+		static const uint32_t table_all[] = {
+			/* Setup replenish thresholds. */
+			RCVBDI_STD_THRESH, TG3_DEF_RX_RING_PENDING / 8,
+
+			/* Etherboot lives below 4GB */
+			RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+			RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR, NIC_SRAM_RX_BUFFER_DESC,
+		};
+		static const uint32_t table_not_5705[] = {
+			/* Buffer maximum length */
+			RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS, RX_STD_MAX_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT,
+			
+			/* Disable the mini frame rx ring */
+			RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,	BDINFO_FLAGS_DISABLED,
+			
+			/* Disable the jumbo frame rx ring */
+			RCVBDI_JUMBO_THRESH, 0,
+			RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED,
+			
+			
+		};
+		TG3_WRITE_SETTINGS(table_all);
+		tw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW, 
+			virt_to_bus(tp->rx_std));
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+			tw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS,
+				RX_STD_MAX_SIZE_5705 << BDINFO_FLAGS_MAXLEN_SHIFT);
+		} else {
+			TG3_WRITE_SETTINGS(table_not_5705);
+		}
+	}
+
+	
+	/* There is only one send ring on 5705, no need to explicitly
+	 * disable the others.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		/* Clear out send RCB ring in SRAM. */
+		for (i = NIC_SRAM_SEND_RCB; i < NIC_SRAM_RCV_RET_RCB; i += TG3_BDINFO_SIZE)
+			tg3_write_mem(i + TG3_BDINFO_MAXLEN_FLAGS, BDINFO_FLAGS_DISABLED);
+	}
+
+	tp->tx_prod = 0;
+	tw32_mailbox(MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+	tw32_mailbox2(MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	tg3_set_bdinfo(tp,
+		NIC_SRAM_SEND_RCB,
+		virt_to_bus(tp->tx_ring),
+		(TG3_TX_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),
+		NIC_SRAM_TX_BUFFER_DESC);
+
+	/* There is only one receive return ring on 5705, no need to explicitly
+	 * disable the others.
+	 */
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		for (i = NIC_SRAM_RCV_RET_RCB; i < NIC_SRAM_STATS_BLK; i += TG3_BDINFO_SIZE) {
+			tg3_write_mem(i + TG3_BDINFO_MAXLEN_FLAGS,
+				BDINFO_FLAGS_DISABLED);
+		}
+	}
+
+	tp->rx_rcb_ptr = 0;
+	tw32_mailbox2(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, 0);
+
+	tg3_set_bdinfo(tp,
+		NIC_SRAM_RCV_RET_RCB,
+		virt_to_bus(tp->rx_rcb),
+		(TG3_RX_RCB_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),
+		0);
+
+	tp->rx_std_ptr = TG3_DEF_RX_RING_PENDING;
+	tw32_mailbox2(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW,
+		     tp->rx_std_ptr);
+
+	tw32_mailbox2(MAILBOX_RCV_JUMBO_PROD_IDX + TG3_64BIT_REG_LOW, 0);
+
+	/* Initialize MAC address and backoff seed. */
+	__tg3_set_mac_addr(tp);
+
+	/* Calculate RDMAC_MODE setting early, we need it to determine
+	 * the RCVLPC_STATE_ENABLE mask.
+	 */
+	rdmac_mode = (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |
+		RDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |
+		RDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |
+		RDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |
+		RDMAC_MODE_LNGREAD_ENAB);
+	if (tp->tg3_flags & TG3_FLAG_SPLIT_MODE)
+		rdmac_mode |= RDMAC_MODE_SPLIT_ENABLE;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+		if (tp->pci_chip_rev_id != CHIPREV_ID_5705_A0) {
+			if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&
+				!(tp->tg3_flags2 & TG3_FLG2_IS_5788)) {
+				rdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;
+			}
+		}
+	}
+
+	/* Setup host coalescing engine. */
+	tw32(HOSTCC_MODE, 0);
+	for (i = 0; i < 2000; i++) {
+		if (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))
+			break;
+		udelay(10);
+	}
+
+	tp->mac_mode = MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |
+		MAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE | MAC_MODE_FHDE_ENABLE;
+	tw32_carefully(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);
+
+	tp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_AUTO_SEEPROM;
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700)
+		tp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |
+				       GRC_LCLCTRL_GPIO_OUTPUT1);
+	tw32_carefully(GRC_LOCAL_CTRL, tp->grc_local_ctrl);
+
+	tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0);
+	tr32(MAILBOX_INTERRUPT_0);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+		tw32_carefully(DMAC_MODE, DMAC_MODE_ENABLE);
+	}
+
+	val = (	WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |
+		WDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |
+		WDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |
+		WDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |
+		WDMAC_MODE_LNGREAD_ENAB);
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) &&
+		((tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) != 0) &&
+		!(tp->tg3_flags2 & TG3_FLG2_IS_5788)) {
+		val |= WDMAC_MODE_RX_ACCEL;
+	}
+	tw32_carefully(WDMAC_MODE, val);
+
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) != 0) {
+		val = tr32(TG3PCI_X_CAPS);
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+			val &= PCIX_CAPS_BURST_MASK;
+			val |= (PCIX_CAPS_MAX_BURST_CPIOB << PCIX_CAPS_BURST_SHIFT);
+		} else if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) {
+			val &= ~(PCIX_CAPS_SPLIT_MASK | PCIX_CAPS_BURST_MASK);
+			val |= (PCIX_CAPS_MAX_BURST_CPIOB << PCIX_CAPS_BURST_SHIFT);
+			if (tp->tg3_flags & TG3_FLAG_SPLIT_MODE)
+				val |= (tp->split_mode_max_reqs <<
+					PCIX_CAPS_SPLIT_SHIFT);
+		}
+		tw32(TG3PCI_X_CAPS, val);
+	}
+
+	tw32_carefully(RDMAC_MODE, rdmac_mode);
+	{
+		static const uint32_t table_all[] = {
+			/* MTU + ethernet header + FCS + optional VLAN tag */
+			MAC_RX_MTU_SIZE, ETH_MAX_MTU + ETH_HLEN + 8,
+			
+			/* The slot time is changed by tg3_setup_phy if we
+			 * run at gigabit with half duplex.
+			 */
+			MAC_TX_LENGTHS,	
+			(2 << TX_LENGTHS_IPG_CRS_SHIFT) |
+			(6 << TX_LENGTHS_IPG_SHIFT) |
+			(32 << TX_LENGTHS_SLOT_TIME_SHIFT),
+			
+			/* Receive rules. */
+			MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS,
+			RCVLPC_CONFIG, 0x0181,
+			
+			/* Receive/send statistics. */
+			RCVLPC_STATS_ENABLE, 0xffffff,
+			RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE,
+			SNDDATAI_STATSENAB, 0xffffff,
+			SNDDATAI_STATSCTRL, (SNDDATAI_SCTRL_ENABLE |SNDDATAI_SCTRL_FASTUPD),
+			
+			/* Host coalescing engine */
+			HOSTCC_RXCOL_TICKS, 0,
+			HOSTCC_TXCOL_TICKS, LOW_TXCOL_TICKS,
+			HOSTCC_RXMAX_FRAMES, 1,
+			HOSTCC_TXMAX_FRAMES, LOW_RXMAX_FRAMES,
+			HOSTCC_RXCOAL_MAXF_INT, 1,
+			HOSTCC_TXCOAL_MAXF_INT, 0,
+			
+			/* Status/statistics block address. */
+			/* Etherboot lives below 4GB, so HIGH == 0 */
+			HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+
+			/* No need to enable 32byte coalesce mode. */
+			HOSTCC_MODE, HOSTCC_MODE_ENABLE | 0,
+			
+			RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE,
+			RCVLPC_MODE, RCVLPC_MODE_ENABLE,
+			
+			RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE,
+
+			SNDDATAC_MODE, SNDDATAC_MODE_ENABLE,
+			SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE,
+			RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB,
+			RCVDBDI_MODE, RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ,
+			SNDDATAI_MODE, SNDDATAI_MODE_ENABLE,
+			SNDBDI_MODE, SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE,
+			SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE,
+			
+			/* Accept all multicast frames. */
+			MAC_HASH_REG_0, 0xffffffff,
+			MAC_HASH_REG_1, 0xffffffff,
+			MAC_HASH_REG_2, 0xffffffff,
+			MAC_HASH_REG_3, 0xffffffff,
+		};
+		static const uint32_t table_not_5705[] = {
+			/* Host coalescing engine */
+			HOSTCC_RXCOAL_TICK_INT, 0,
+			HOSTCC_TXCOAL_TICK_INT, 0,
+
+			/* Status/statistics block address. */
+			/* Etherboot lives below 4GB, so HIGH == 0 */
+			HOSTCC_STAT_COAL_TICKS, DEFAULT_STAT_COAL_TICKS,
+			HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH, 0,
+			HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK,
+			HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK,
+
+			RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE,
+
+			MBFREE_MODE, MBFREE_MODE_ENABLE,
+		};
+		TG3_WRITE_SETTINGS(table_all);
+		tw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+			virt_to_bus(tp->hw_stats));
+		tw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,
+			virt_to_bus(tp->hw_status));
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5705) {
+			TG3_WRITE_SETTINGS(table_not_5705);
+		}
+	}
+
+	tp->tx_mode = TX_MODE_ENABLE;
+	tw32_carefully(MAC_TX_MODE, tp->tx_mode);
+
+	tp->rx_mode = RX_MODE_ENABLE;
+	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+
+	tp->mi_mode = MAC_MI_MODE_BASE;
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	tw32(MAC_LED_CTRL, 0);
+	tw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tw32_carefully(MAC_RX_MODE, RX_MODE_RESET);
+	}
+	tp->rx_mode |= RX_MODE_KEEP_VLAN_TAG; /* drop tagged vlan packets */
+	tw32_carefully(MAC_RX_MODE, tp->rx_mode);
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5703_A1)
+		tw32(MAC_SERDES_CFG, 0x616000);
+
+	/* Prevent chip from dropping frames when flow control
+	 * is enabled.
+	 */
+	tw32(MAC_LOW_WMARK_MAX_RX_FRAME, 2);
+	tr32(MAC_LOW_WMARK_MAX_RX_FRAME);
+
+	err = tg3_setup_phy(tp);
+
+	/* Ignore CRC stats */
+
+	/* Initialize receive rules. */
+	tw32(MAC_RCV_RULE_0,  0xc2000000 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_RULE_1,  0x86000004 & RCV_RULE_DISABLE_MASK);
+	tw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)
+		limit = 8;
+	else
+		limit = 16;
+	if (tp->tg3_flags & TG3_FLAG_ENABLE_ASF)
+		limit -= 4;
+	switch (limit) {
+	case 16:	tw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);
+	case 15:	tw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);
+	case 14:	tw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);
+	case 13:	tw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);
+	case 12:	tw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);
+	case 11:	tw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);
+	case 10:	tw32(MAC_RCV_RULE_9,  0);  tw32(MAC_RCV_VALUE_9,  0);
+	case 9:		tw32(MAC_RCV_RULE_8,  0);  tw32(MAC_RCV_VALUE_8,  0);
+	case 8:		tw32(MAC_RCV_RULE_7,  0);  tw32(MAC_RCV_VALUE_7,  0);
+	case 7:		tw32(MAC_RCV_RULE_6,  0);  tw32(MAC_RCV_VALUE_6,  0);
+	case 6:		tw32(MAC_RCV_RULE_5,  0);  tw32(MAC_RCV_VALUE_5,  0);
+	case 5:		tw32(MAC_RCV_RULE_4,  0);  tw32(MAC_RCV_VALUE_4,  0);
+	case 4:		/* tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0); */
+	case 3:		/* tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0); */
+	case 2:
+	case 1:
+	default:
+		break;
+	};
+
+	return err;
+}
+
+
+
+/* Chips other than 5700/5701 use the NVRAM for fetching info. */
+static void tg3_nvram_init(struct tg3 *tp)
+{
+	tw32(GRC_EEPROM_ADDR,
+	     (EEPROM_ADDR_FSM_RESET |
+	      (EEPROM_DEFAULT_CLOCK_PERIOD <<
+	       EEPROM_ADDR_CLKPERD_SHIFT)));
+
+	mdelay(1);
+
+	/* Enable seeprom accesses. */
+	tw32_carefully(GRC_LOCAL_CTRL,
+		tr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5700 &&
+	    GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5701) {
+		uint32_t nvcfg1 = tr32(NVRAM_CFG1);
+
+		tp->tg3_flags |= TG3_FLAG_NVRAM;
+		if (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {
+			if (nvcfg1 & NVRAM_CFG1_BUFFERED_MODE)
+				tp->tg3_flags |= TG3_FLAG_NVRAM_BUFFERED;
+		} else {
+			nvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;
+			tw32(NVRAM_CFG1, nvcfg1);
+		}
+
+	} else {
+		tp->tg3_flags &= ~(TG3_FLAG_NVRAM | TG3_FLAG_NVRAM_BUFFERED);
+	}
+}
+
+
+static int tg3_nvram_read_using_eeprom(
+	struct tg3 *tp __unused, uint32_t offset, uint32_t *val)
+{
+	uint32_t tmp;
+	int i;
+
+	if (offset > EEPROM_ADDR_ADDR_MASK ||
+		(offset % 4) != 0) {
+		return -EINVAL;
+	}
+
+	tmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |
+					EEPROM_ADDR_DEVID_MASK |
+					EEPROM_ADDR_READ);
+	tw32(GRC_EEPROM_ADDR,
+	     tmp |
+	     (0 << EEPROM_ADDR_DEVID_SHIFT) |
+	     ((offset << EEPROM_ADDR_ADDR_SHIFT) &
+	      EEPROM_ADDR_ADDR_MASK) |
+	     EEPROM_ADDR_READ | EEPROM_ADDR_START);
+
+	for (i = 0; i < 10000; i++) {
+		tmp = tr32(GRC_EEPROM_ADDR);
+
+		if (tmp & EEPROM_ADDR_COMPLETE)
+			break;
+		udelay(100);
+	}
+	if (!(tmp & EEPROM_ADDR_COMPLETE)) {
+		return -EBUSY;
+	}
+
+	*val = tr32(GRC_EEPROM_DATA);
+	return 0;
+}
+
+static int tg3_nvram_read(struct tg3 *tp, uint32_t offset, uint32_t *val)
+{
+	int i, saw_done_clear;
+
+	if (!(tp->tg3_flags & TG3_FLAG_NVRAM))
+		return tg3_nvram_read_using_eeprom(tp, offset, val);
+
+	if (tp->tg3_flags & TG3_FLAG_NVRAM_BUFFERED)
+		offset = ((offset / NVRAM_BUFFERED_PAGE_SIZE) <<
+			  NVRAM_BUFFERED_PAGE_POS) +
+			(offset % NVRAM_BUFFERED_PAGE_SIZE);
+
+	if (offset > NVRAM_ADDR_MSK)
+		return -EINVAL;
+
+	tw32(NVRAM_SWARB, SWARB_REQ_SET1);
+	for (i = 0; i < 1000; i++) {
+		if (tr32(NVRAM_SWARB) & SWARB_GNT1)
+			break;
+		udelay(20);
+	}
+
+	tw32(NVRAM_ADDR, offset);
+	tw32(NVRAM_CMD,
+	     NVRAM_CMD_RD | NVRAM_CMD_GO |
+	     NVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);
+
+	/* Wait for done bit to clear then set again. */
+	saw_done_clear = 0;
+	for (i = 0; i < 1000; i++) {
+		udelay(10);
+		if (!saw_done_clear &&
+		    !(tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			saw_done_clear = 1;
+		else if (saw_done_clear &&
+			 (tr32(NVRAM_CMD) & NVRAM_CMD_DONE))
+			break;
+	}
+	if (i >= 1000) {
+		tw32(NVRAM_SWARB, SWARB_REQ_CLR1);
+		return -EBUSY;
+	}
+
+	*val = bswap_32(tr32(NVRAM_RDDATA));
+	tw32(NVRAM_SWARB, 0x20);
+
+	return 0;
+}
+
+struct subsys_tbl_ent {
+	uint16_t subsys_vendor, subsys_devid;
+	uint32_t phy_id;
+};
+
+static struct subsys_tbl_ent subsys_id_to_phy_id[] = {
+	/* Broadcom boards. */
+	{ 0x14e4, 0x1644, PHY_ID_BCM5401 }, /* BCM95700A6 */
+	{ 0x14e4, 0x0001, PHY_ID_BCM5701 }, /* BCM95701A5 */
+	{ 0x14e4, 0x0002, PHY_ID_BCM8002 }, /* BCM95700T6 */
+	{ 0x14e4, 0x0003, PHY_ID_SERDES  }, /* BCM95700A9 */
+	{ 0x14e4, 0x0005, PHY_ID_BCM5701 }, /* BCM95701T1 */
+	{ 0x14e4, 0x0006, PHY_ID_BCM5701 }, /* BCM95701T8 */
+	{ 0x14e4, 0x0007, PHY_ID_SERDES  }, /* BCM95701A7 */
+	{ 0x14e4, 0x0008, PHY_ID_BCM5701 }, /* BCM95701A10 */
+	{ 0x14e4, 0x8008, PHY_ID_BCM5701 }, /* BCM95701A12 */
+	{ 0x14e4, 0x0009, PHY_ID_BCM5701 }, /* BCM95703Ax1 */
+	{ 0x14e4, 0x8009, PHY_ID_BCM5701 }, /* BCM95703Ax2 */
+
+	/* 3com boards. */
+	{ PCI_VENDOR_ID_3COM, 0x1000, PHY_ID_BCM5401 }, /* 3C996T */
+	{ PCI_VENDOR_ID_3COM, 0x1006, PHY_ID_BCM5701 }, /* 3C996BT */
+	/* { PCI_VENDOR_ID_3COM, 0x1002, PHY_ID_XXX },     3C996CT */
+	/* { PCI_VENDOR_ID_3COM, 0x1003, PHY_ID_XXX },     3C997T */
+	{ PCI_VENDOR_ID_3COM, 0x1004, PHY_ID_SERDES  }, /* 3C996SX */
+	/* { PCI_VENDOR_ID_3COM, 0x1005, PHY_ID_XXX },     3C997SZ */
+	{ PCI_VENDOR_ID_3COM, 0x1007, PHY_ID_BCM5701 }, /* 3C1000T */
+	{ PCI_VENDOR_ID_3COM, 0x1008, PHY_ID_BCM5701 }, /* 3C940BR01 */
+
+	/* DELL boards. */
+	{ PCI_VENDOR_ID_DELL, 0x00d1, PHY_ID_BCM5401 }, /* VIPER */
+	{ PCI_VENDOR_ID_DELL, 0x0106, PHY_ID_BCM5401 }, /* JAGUAR */
+	{ PCI_VENDOR_ID_DELL, 0x0109, PHY_ID_BCM5411 }, /* MERLOT */
+	{ PCI_VENDOR_ID_DELL, 0x010a, PHY_ID_BCM5411 }, /* SLIM_MERLOT */
+
+	/* Compaq boards. */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007c, PHY_ID_BCM5701 }, /* BANSHEE */
+	{ PCI_VENDOR_ID_COMPAQ, 0x009a, PHY_ID_BCM5701 }, /* BANSHEE_2 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x007d, PHY_ID_SERDES  }, /* CHANGELING */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0085, PHY_ID_BCM5701 }, /* NC7780 */
+	{ PCI_VENDOR_ID_COMPAQ, 0x0099, PHY_ID_BCM5701 }  /* NC7780_2 */
+};
+
+static int tg3_phy_probe(struct tg3 *tp)
+{
+	uint32_t eeprom_phy_id, hw_phy_id_1, hw_phy_id_2;
+	uint32_t hw_phy_id, hw_phy_id_masked;
+	enum phy_led_mode eeprom_led_mode;
+	uint32_t val;
+	unsigned i;
+	int eeprom_signature_found, err;
+
+	tp->phy_id = PHY_ID_INVALID;
+
+	for (i = 0; i < sizeof(subsys_id_to_phy_id)/sizeof(subsys_id_to_phy_id[0]); i++) {
+		if ((subsys_id_to_phy_id[i].subsys_vendor == tp->subsystem_vendor) &&
+			(subsys_id_to_phy_id[i].subsys_devid == tp->subsystem_device)) {
+			tp->phy_id = subsys_id_to_phy_id[i].phy_id;
+			break;
+		}
+	}
+
+	eeprom_phy_id = PHY_ID_INVALID;
+	eeprom_led_mode = led_mode_auto;
+	eeprom_signature_found = 0;
+	tg3_read_mem(NIC_SRAM_DATA_SIG, &val);
+	if (val == NIC_SRAM_DATA_SIG_MAGIC) {
+		uint32_t nic_cfg;
+
+		tg3_read_mem(NIC_SRAM_DATA_CFG, &nic_cfg);
+		tp->nic_sram_data_cfg = nic_cfg;
+
+		eeprom_signature_found = 1;
+
+		if ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==
+		    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER) {
+			eeprom_phy_id = PHY_ID_SERDES;
+		} else {
+			uint32_t nic_phy_id;
+
+			tg3_read_mem(NIC_SRAM_DATA_PHY_ID, &nic_phy_id);
+			if (nic_phy_id != 0) {
+				uint32_t id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;
+				uint32_t id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;
+
+				eeprom_phy_id  = (id1 >> 16) << 10;
+				eeprom_phy_id |= (id2 & 0xfc00) << 16;
+				eeprom_phy_id |= (id2 & 0x03ff) <<  0;
+			}
+		}
+
+		switch (nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK) {
+		case NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD:
+			eeprom_led_mode = led_mode_three_link;
+			break;
+
+		case NIC_SRAM_DATA_CFG_LED_LINK_SPD:
+			eeprom_led_mode = led_mode_link10;
+			break;
+
+		default:
+			eeprom_led_mode = led_mode_auto;
+			break;
+		};
+		if (((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705)) &&
+			(nic_cfg & NIC_SRAM_DATA_CFG_EEPROM_WP)) {
+			tp->tg3_flags |= TG3_FLAG_EEPROM_WRITE_PROT;
+		}
+
+		if (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE)
+			tp->tg3_flags |= TG3_FLAG_ENABLE_ASF;
+		if (nic_cfg & NIC_SRAM_DATA_CFG_FIBER_WOL)
+			tp->tg3_flags |= TG3_FLAG_SERDES_WOL_CAP;
+	}
+
+	/* Now read the physical PHY_ID from the chip and verify
+	 * that it is sane.  If it doesn't look good, we fall back
+	 * to either the hard-coded table based PHY_ID and failing
+	 * that the value found in the eeprom area.
+	 */
+	err  = tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);
+	err |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);
+
+	hw_phy_id  = (hw_phy_id_1 & 0xffff) << 10;
+	hw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;
+	hw_phy_id |= (hw_phy_id_2 & 0x03ff) <<  0;
+
+	hw_phy_id_masked = hw_phy_id & PHY_ID_MASK;
+
+	if (!err && KNOWN_PHY_ID(hw_phy_id_masked)) {
+		tp->phy_id = hw_phy_id;
+	} else {
+		/* phy_id currently holds the value found in the
+		 * subsys_id_to_phy_id[] table or PHY_ID_INVALID
+		 * if a match was not found there.
+		 */
+		if (tp->phy_id == PHY_ID_INVALID) {
+			if (!eeprom_signature_found ||
+			    !KNOWN_PHY_ID(eeprom_phy_id & PHY_ID_MASK))
+				return -ENODEV;
+			tp->phy_id = eeprom_phy_id;
+		}
+	}
+
+	err = tg3_phy_reset(tp);
+	if (err)
+		return err;
+
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0 ||
+	    tp->pci_chip_rev_id == CHIPREV_ID_5701_B0) {
+		uint32_t mii_tg3_ctrl;
+		
+		/* These chips, when reset, only advertise 10Mb
+		 * capabilities.  Fix that.
+		 */
+		err  = tg3_writephy(tp, MII_ADVERTISE,
+				    (ADVERTISE_CSMA |
+				     ADVERTISE_PAUSE_CAP |
+				     ADVERTISE_10HALF |
+				     ADVERTISE_10FULL |
+				     ADVERTISE_100HALF |
+				     ADVERTISE_100FULL));
+		mii_tg3_ctrl = (MII_TG3_CTRL_ADV_1000_HALF |
+				MII_TG3_CTRL_ADV_1000_FULL |
+				MII_TG3_CTRL_AS_MASTER |
+				MII_TG3_CTRL_ENABLE_AS_MASTER);
+		if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+			mii_tg3_ctrl = 0;
+
+		err |= tg3_writephy(tp, MII_TG3_CTRL, mii_tg3_ctrl);
+		err |= tg3_writephy(tp, MII_BMCR,
+				    (BMCR_ANRESTART | BMCR_ANENABLE));
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) {
+		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0c00);
+		tg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x201f);
+		tg3_writedsp(tp, MII_TG3_DSP_RW_PORT, 0x2aaa);
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704) {
+		tg3_writephy(tp, 0x1c, 0x8d68);
+		tg3_writephy(tp, 0x1c, 0x8d68);
+	}
+
+	/* Enable Ethernet@WireSpeed */
+	tg3_phy_set_wirespeed(tp);
+
+	if (!err && ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401)) {
+		err = tg3_init_5401phy_dsp(tp);
+	}
+
+	/* Determine the PHY led mode. 
+	 * Be careful if this gets set wrong it can result in an inability to 
+	 * establish a link.
+	 */
+	if (tp->phy_id == PHY_ID_SERDES) {
+		tp->led_mode = led_mode_three_link;
+	}
+	else if (tp->subsystem_vendor == PCI_VENDOR_ID_DELL) {
+		tp->led_mode = led_mode_link10;
+	} else {
+		tp->led_mode = led_mode_three_link;
+		if (eeprom_signature_found &&
+		    eeprom_led_mode != led_mode_auto)
+			tp->led_mode = eeprom_led_mode;
+	}
+
+	if (tp->phy_id == PHY_ID_SERDES)
+		tp->link_config.advertising =
+			(ADVERTISED_1000baseT_Half |
+			 ADVERTISED_1000baseT_Full |
+			 ADVERTISED_Autoneg |
+			 ADVERTISED_FIBRE);
+	if (tp->tg3_flags & TG3_FLAG_10_100_ONLY)
+		tp->link_config.advertising &=
+			~(ADVERTISED_1000baseT_Half |
+			  ADVERTISED_1000baseT_Full);
+
+	return err;
+}
+
+#if SUPPORT_PARTNO_STR
+static void tg3_read_partno(struct tg3 *tp)
+{
+	unsigned char vpd_data[256];
+	int i;
+
+	for (i = 0; i < 256; i += 4) {
+		uint32_t tmp;
+
+		if (tg3_nvram_read(tp, 0x100 + i, &tmp))
+			goto out_not_found;
+
+		vpd_data[i + 0] = ((tmp >>  0) & 0xff);
+		vpd_data[i + 1] = ((tmp >>  8) & 0xff);
+		vpd_data[i + 2] = ((tmp >> 16) & 0xff);
+		vpd_data[i + 3] = ((tmp >> 24) & 0xff);
+	}
+
+	/* Now parse and find the part number. */
+	for (i = 0; i < 256; ) {
+		unsigned char val = vpd_data[i];
+		int block_end;
+
+		if (val == 0x82 || val == 0x91) {
+			i = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+			continue;
+		}
+
+		if (val != 0x90)
+			goto out_not_found;
+
+		block_end = (i + 3 +
+			     (vpd_data[i + 1] +
+			      (vpd_data[i + 2] << 8)));
+		i += 3;
+		while (i < block_end) {
+			if (vpd_data[i + 0] == 'P' &&
+			    vpd_data[i + 1] == 'N') {
+				int partno_len = vpd_data[i + 2];
+
+				if (partno_len > 24)
+					goto out_not_found;
+
+				memcpy(tp->board_part_number,
+				       &vpd_data[i + 3],
+				       partno_len);
+
+				/* Success. */
+				return;
+			}
+		}
+
+		/* Part number not found. */
+		goto out_not_found;
+	}
+
+out_not_found:
+	memcpy(tp->board_part_number, "none", sizeof("none"));
+}
+#else
+#define tg3_read_partno(TP) ((TP)->board_part_number[0] = '\0')
+#endif
+
+static int tg3_get_invariants(struct tg3 *tp)
+{
+	uint32_t misc_ctrl_reg;
+	uint32_t pci_state_reg, grc_misc_cfg;
+	uint16_t pci_cmd;
+	uint8_t  pci_latency;
+	int err;
+
+	/* Read the subsystem vendor and device ids */
+	pci_read_config_word(tp->pdev, PCI_SUBSYSTEM_VENDOR_ID, &tp->subsystem_vendor);
+	pci_read_config_word(tp->pdev, PCI_SUBSYSTEM_ID, &tp->subsystem_device);
+
+	/* The sun_5704 code needs infrastructure etherboot does have
+	 * ignore it for now.
+	 */
+
+	/* If we have an AMD 762 or Intel ICH/ICH0 chipset, write
+	 * reordering to the mailbox registers done by the host
+	 * controller can cause major troubles.  We read back from
+	 * every mailbox register write to force the writes to be
+	 * posted to the chip in order.
+	 *
+	 * TG3_FLAG_MBOX_WRITE_REORDER has been forced on.
+	 */
+
+	/* Force memory write invalidate off.  If we leave it on,
+	 * then on 5700_BX chips we have to enable a workaround.
+	 * The workaround is to set the TG3PCI_DMA_RW_CTRL boundry
+	 * to match the cacheline size.  The Broadcom driver have this
+	 * workaround but turns MWI off all the times so never uses
+	 * it.  This seems to suggest that the workaround is insufficient.
+	 */
+	pci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);
+	pci_cmd &= ~PCI_COMMAND_INVALIDATE;
+	/* Also, force SERR#/PERR# in PCI command. */
+	pci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+	pci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);
+
+	/* It is absolutely critical that TG3PCI_MISC_HOST_CTRL
+	 * has the register indirect write enable bit set before
+	 * we try to access any of the MMIO registers.  It is also
+	 * critical that the PCI-X hw workaround situation is decided
+	 * before that as well.
+	 */
+	pci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL, &misc_ctrl_reg);
+
+	tp->pci_chip_rev_id = (misc_ctrl_reg >> MISC_HOST_CTRL_CHIPREV_SHIFT);
+
+	/* Initialize misc host control in PCI block. */
+	tp->misc_host_ctrl |= (misc_ctrl_reg &
+			       MISC_HOST_CTRL_CHIPREV);
+	pci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,
+			       tp->misc_host_ctrl);
+
+	pci_read_config_byte(tp->pdev, PCI_LATENCY_TIMER, &pci_latency);
+	if (pci_latency < 64) {
+		pci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER, 64);
+	}
+
+	pci_read_config_dword(tp->pdev, TG3PCI_PCISTATE, &pci_state_reg);
+
+	/* If this is a 5700 BX chipset, and we are in PCI-X
+	 * mode, enable register write workaround.
+	 *
+	 * The workaround is to use indirect register accesses
+	 * for all chip writes not to mailbox registers.
+	 *
+	 * In etherboot to simplify things we just always use this work around.
+	 */
+	if ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0) {
+		tp->tg3_flags |= TG3_FLAG_PCIX_MODE;
+	}
+	/* Back to back register writes can cause problems on the 5701,
+	 * the workaround is to read back all reg writes except those to
+	 * mailbox regs.
+	 * In etherboot we always use indirect register accesses so
+	 * we don't see this.
+	 */
+
+	if ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_HIGH_SPEED;
+	if ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)
+		tp->tg3_flags |= TG3_FLAG_PCI_32BIT;
+
+	/* Chip-specific fixup from Broadcom driver */
+	if ((tp->pci_chip_rev_id == CHIPREV_ID_5704_A0) &&
+	    (!(pci_state_reg & PCISTATE_RETRY_SAME_DMA))) {
+		pci_state_reg |= PCISTATE_RETRY_SAME_DMA;
+		pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, pci_state_reg);
+	}
+
+	/* Force the chip into D0. */
+	tg3_set_power_state_0(tp);
+
+	/* Etherboot does not ask the tg3 to do checksums */
+	/* Etherboot does not ask the tg3 to do jumbo frames */
+	/* Ehterboot does not ask the tg3 to use WakeOnLan. */
+
+	/* A few boards don't want Ethernet@WireSpeed phy feature */
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5700) ||
+		((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
+			(tp->pci_chip_rev_id != CHIPREV_ID_5705_A0) &&
+			(tp->pci_chip_rev_id != CHIPREV_ID_5705_A1))) {
+		tp->tg3_flags2 |= TG3_FLG2_NO_ETH_WIRE_SPEED;
+	}
+
+	/* Avoid tagged irq status etherboot does not use irqs */
+
+	/* Only 5701 and later support tagged irq status mode.
+	 * Also, 5788 chips cannot use tagged irq status.
+	 *
+	 * However, since etherboot does not use irqs avoid tagged irqs
+	 * status  because the interrupt condition is more difficult to
+	 * fully clear in that mode.
+	 */
+	
+	/* Since some 5700_AX && 5700_BX have problems with 32BYTE
+	 * coalesce_mode, and the rest work fine anything set.
+	 * Don't enable HOST_CC_MODE_32BYTE in etherboot.
+	 */
+
+	/* Initialize MAC MI mode, polling disabled. */
+	tw32_carefully(MAC_MI_MODE, tp->mi_mode);
+
+	/* Initialize data/descriptor byte/word swapping. */
+	tw32(GRC_MODE, tp->grc_mode);
+
+	tg3_switch_clocks(tp);
+
+	/* Clear this out for sanity. */
+	tw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);
+
+	/* Etherboot does not need to check if the PCIX_TARGET_HWBUG
+	 * is needed.  It always uses it.
+	 */
+	
+	udelay(50);
+	tg3_nvram_init(tp);
+
+	/* The TX descriptors will reside in main memory.
+	 */
+
+	/* See which board we are using.
+	 */
+	grc_misc_cfg = tr32(GRC_MISC_CFG);
+	grc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704 &&
+	    grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5704CIOBE) {
+		tp->tg3_flags |= TG3_FLAG_SPLIT_MODE;
+		tp->split_mode_max_reqs = SPLIT_MODE_5704_MAX_REQ;
+	}
+
+	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705 &&
+	    (grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788 ||
+	     grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788M))
+		tp->tg3_flags2 |= TG3_FLG2_IS_5788;
+
+	/* these are limited to 10/100 only */
+	if (((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) &&
+		    ((grc_misc_cfg == 0x8000) || (grc_misc_cfg == 0x4000))) ||
+		((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
+			(tp->pdev->vendor == PCI_VENDOR_ID_BROADCOM) &&
+			((tp->pdev->dev_id == PCI_DEVICE_ID_TIGON3_5901) ||
+				(tp->pdev->dev_id == PCI_DEVICE_ID_TIGON3_5901_2)))) {
+		tp->tg3_flags |= TG3_FLAG_10_100_ONLY;
+	}
+
+	err = tg3_phy_probe(tp);
+	if (err) {
+		printf("phy probe failed, err %d\n", err);
+	}
+
+	tg3_read_partno(tp);
+
+
+	/* 5700 BX chips need to have their TX producer index mailboxes
+	 * written twice to workaround a bug.
+	 * In etherboot we do this unconditionally to simplify things.
+	 */
+
+	/* 5700 chips can get confused if TX buffers straddle the
+	 * 4GB address boundary in some cases.
+	 * 
+	 * In etherboot we can ignore the problem as etherboot lives below 4GB.
+	 */
+
+	/* In etherboot wake-on-lan is unconditionally disabled */
+	return err;
+}
+
+static int  tg3_get_device_address(struct tg3 *tp)
+{
+	struct nic *nic = tp->nic;
+	uint32_t hi, lo, mac_offset;
+
+	if (PCI_FUNC(tp->pdev->devfn) == 0)
+		mac_offset = 0x7c;
+	else
+		mac_offset = 0xcc;
+
+	/* First try to get it from MAC address mailbox. */
+	tg3_read_mem(NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);
+	if ((hi >> 16) == 0x484b) {
+		nic->node_addr[0] = (hi >>  8) & 0xff;
+		nic->node_addr[1] = (hi >>  0) & 0xff;
+
+		tg3_read_mem(NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);
+		nic->node_addr[2] = (lo >> 24) & 0xff;
+		nic->node_addr[3] = (lo >> 16) & 0xff;
+		nic->node_addr[4] = (lo >>  8) & 0xff;
+		nic->node_addr[5] = (lo >>  0) & 0xff;
+	}
+	/* Next, try NVRAM. */
+	else if (!tg3_nvram_read(tp, mac_offset + 0, &hi) &&
+		 !tg3_nvram_read(tp, mac_offset + 4, &lo)) {
+		nic->node_addr[0] = ((hi >> 16) & 0xff);
+		nic->node_addr[1] = ((hi >> 24) & 0xff);
+		nic->node_addr[2] = ((lo >>  0) & 0xff);
+		nic->node_addr[3] = ((lo >>  8) & 0xff);
+		nic->node_addr[4] = ((lo >> 16) & 0xff);
+		nic->node_addr[5] = ((lo >> 24) & 0xff);
+	}
+	/* Finally just fetch it out of the MAC control regs. */
+	else {
+		hi = tr32(MAC_ADDR_0_HIGH);
+		lo = tr32(MAC_ADDR_0_LOW);
+
+		nic->node_addr[5] = lo & 0xff;
+		nic->node_addr[4] = (lo >> 8) & 0xff;
+		nic->node_addr[3] = (lo >> 16) & 0xff;
+		nic->node_addr[2] = (lo >> 24) & 0xff;
+		nic->node_addr[1] = hi & 0xff;
+		nic->node_addr[0] = (hi >> 8) & 0xff;
+	}
+
+	return 0;
+}
+
+
+static int tg3_setup_dma(struct tg3 *tp)
+{
+	tw32(TG3PCI_CLOCK_CTRL, 0);
+
+	if ((tp->tg3_flags & TG3_FLAG_PCIX_MODE) == 0) {
+		tp->dma_rwctrl =
+			(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+			(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+			(0x7 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+			(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+			(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
+			tp->dma_rwctrl &= ~(DMA_RWCTRL_MIN_DMA << DMA_RWCTRL_MIN_DMA_SHIFT);
+		}
+	} else {
+		if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)
+			tp->dma_rwctrl =
+				(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+				(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+				(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+				(0x7 << DMA_RWCTRL_READ_WATER_SHIFT) |
+				(0x00 << DMA_RWCTRL_MIN_DMA_SHIFT);
+		else
+			tp->dma_rwctrl =
+				(0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |
+				(0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT) |
+				(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |
+				(0x3 << DMA_RWCTRL_READ_WATER_SHIFT) |
+				(0x0f << DMA_RWCTRL_MIN_DMA_SHIFT);
+
+		/* Wheee, some more chip bugs... */
+		if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+			(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)) {
+			uint32_t ccval = tr32(TG3PCI_CLOCK_CTRL) & 0x1f;
+
+			if ((ccval == 0x6) || (ccval == 0x7)) {
+				tp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;
+			}
+		}
+	}
+
+	if ((GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5703) ||
+		(GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5704)) {
+		tp->dma_rwctrl &= ~(DMA_RWCTRL_MIN_DMA << DMA_RWCTRL_MIN_DMA_SHIFT);
+	}
+
+	tp->dma_rwctrl |= DMA_RWCTRL_ASSERT_ALL_BE;
+
+	tw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);
+
+	return 0;
+}
+
+static void tg3_init_link_config(struct tg3 *tp)
+{
+	tp->link_config.advertising =
+		(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+		 ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+		 ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full |
+		 ADVERTISED_Autoneg | ADVERTISED_MII);
+	tp->carrier_ok = 0;
+	tp->link_config.active_speed = SPEED_INVALID;
+	tp->link_config.active_duplex = DUPLEX_INVALID;
+}
+
+
+#if SUPPORT_PHY_STR
+static const char * tg3_phy_string(struct tg3 *tp)
+{
+	switch (tp->phy_id & PHY_ID_MASK) {
+	case PHY_ID_BCM5400:	return "5400";
+	case PHY_ID_BCM5401:	return "5401";
+	case PHY_ID_BCM5411:	return "5411";
+	case PHY_ID_BCM5701:	return "5701";
+	case PHY_ID_BCM5703:	return "5703";
+	case PHY_ID_BCM5704:	return "5704";
+	case PHY_ID_BCM8002:	return "8002";
+	case PHY_ID_SERDES:	return "serdes";
+	default:		return "unknown";
+	};
+}
+#else
+#define tg3_phy_string(TP) "?"
+#endif
+
+
+static void tg3_poll_link(struct tg3 *tp)
+{
+	uint32_t mac_stat;
+
+	mac_stat = tr32(MAC_STATUS);
+	if (tp->phy_id == PHY_ID_SERDES) {
+		if (tp->carrier_ok?
+			(mac_stat & MAC_STATUS_LNKSTATE_CHANGED):
+			(mac_stat & MAC_STATUS_PCS_SYNCED)) {
+			tw32_carefully(MAC_MODE, tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK);
+			tw32_carefully(MAC_MODE, tp->mac_mode);
+
+			tg3_setup_phy(tp);
+		}
+	}
+	else {
+		if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED) {
+			tg3_setup_phy(tp);
+		}
+	}
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static void tg3_ack_irqs(struct tg3 *tp)
+{
+	if (tp->hw_status->status & SD_STATUS_UPDATED) {
+		/*
+		 * writing any value to intr-mbox-0 clears PCI INTA# and
+		 * chip-internal interrupt pending events.
+		 * writing non-zero to intr-mbox-0 additional tells the
+		 * NIC to stop sending us irqs, engaging "in-intr-handler"
+		 * event coalescing.
+		 */
+		tw32_mailbox(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 
+			0x00000001);
+		/*
+		 * Flush PCI write.  This also guarantees that our
+		 * status block has been flushed to host memory.
+		 */
+		tr32(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW);
+		tp->hw_status->status &= ~SD_STATUS_UPDATED;
+	}
+}
+
+static int tg3_poll(struct nic *nic)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+
+	struct tg3 *tp = &tg3;
+	int result;
+
+	result = 0;
+	tg3_ack_irqs(tp);
+	if (tp->hw_status->idx[0].rx_producer != tp->rx_rcb_ptr) {
+		struct tg3_rx_buffer_desc *desc;
+		unsigned int len;
+		desc = &tp->rx_rcb[tp->rx_rcb_ptr];
+		if ((desc->opaque & RXD_OPAQUE_RING_MASK) == RXD_OPAQUE_RING_STD) {
+			len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) - 4; /* omit crc */
+			
+			nic->packetlen = len;
+			memcpy(nic->packet, bus_to_virt(desc->addr_lo), len);
+			result = 1;
+		}
+		tp->rx_rcb_ptr = (tp->rx_rcb_ptr + 1) % TG3_RX_RCB_RING_SIZE;
+		
+		/* ACK the status ring */
+		tw32_mailbox2(MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW, tp->rx_rcb_ptr);
+
+		/* Refill RX ring. */
+		if (result) {
+			tp->rx_std_ptr = (tp->rx_std_ptr + 1) % TG3_RX_RING_SIZE;
+			tw32_mailbox2(MAILBOX_RCV_STD_PROD_IDX + TG3_64BIT_REG_LOW, tp->rx_std_ptr);
+		}
+	}
+	tg3_poll_link(tp);
+	return result;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void tg3_set_txd(struct tg3 *tp, int entry,
+	dma_addr_t mapping, int len, uint32_t flags,
+	uint32_t mss_and_is_end)
+{
+	struct tg3_tx_buffer_desc *txd =  &tp->tx_ring[entry];
+	int is_end = (mss_and_is_end & 0x1);
+	if (is_end) {
+		flags |= TXD_FLAG_END;
+	}
+
+	txd->addr_hi   = 0;
+	txd->addr_lo   = mapping & 0xffffffff;
+	txd->len_flags = (len << TXD_LEN_SHIFT) | flags;
+	txd->vlan_tag  = 0 << TXD_VLAN_TAG_SHIFT;
+}
+
+static void tg3_transmit(struct nic *nic, const char *dst_addr,
+	unsigned int type, unsigned int size, const char *packet)
+{
+	static struct eth_frame {
+		uint8_t  dst_addr[ETH_ALEN];
+		uint8_t  src_addr[ETH_ALEN];
+		uint16_t type;
+		uint8_t  data [ETH_FRAME_LEN - ETH_HLEN];
+	} frame[2];
+	static int frame_idx;
+	
+	/* send the packet to destination */
+	struct tg3_tx_buffer_desc *txd;
+	struct tg3 *tp;
+	uint32_t entry;
+	int i;
+
+	/* Wait until there is a free packet frame */
+	tp = &tg3;
+	i = 0;
+	entry = tp->tx_prod;
+	while((tp->hw_status->idx[0].tx_consumer != entry) &&
+		(tp->hw_status->idx[0].tx_consumer != PREV_TX(entry))) {
+		mdelay(10);	/* give the nick a chance */
+		poll_interruptions();
+		if (++i > 500) { /* timeout 5s for transmit */
+			printf("transmit timed out\n");
+			tg3_halt(tp);
+			tg3_setup_hw(tp);
+			return;
+		}
+	}
+	if (i != 0) {
+		printf("#");
+	}
+	
+	/* Copy the packet to the our local buffer */
+	memcpy(&frame[frame_idx].dst_addr, dst_addr, ETH_ALEN);
+	memcpy(&frame[frame_idx].src_addr, nic->node_addr, ETH_ALEN);
+	frame[frame_idx].type = htons(type);
+	memset(&frame[frame_idx].data, 0, sizeof(frame[frame_idx].data));
+	memcpy(&frame[frame_idx].data, packet, size);
+
+	/* Setup the ring buffer entry to transmit */
+	txd            = &tp->tx_ring[entry];
+	txd->addr_hi   = 0; /* Etherboot runs under 4GB */
+	txd->addr_lo   = virt_to_bus(&frame[frame_idx]);
+	txd->len_flags = ((size + ETH_HLEN) << TXD_LEN_SHIFT) | TXD_FLAG_END;
+	txd->vlan_tag  = 0 << TXD_VLAN_TAG_SHIFT;
+
+	/* Advance to the next entry */
+	entry = NEXT_TX(entry);
+	frame_idx ^= 1;
+
+	/* Packets are ready, update Tx producer idx local and on card */
+	tw32_mailbox((MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW), entry);
+	tw32_mailbox2((MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW), entry);
+	tp->tx_prod = entry;
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void tg3_disable(struct dev *dev __unused)
+{
+	struct tg3 *tp = &tg3;
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished. 
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 */
+	tg3_halt(tp);
+	tp->tg3_flags &= ~(TG3_FLAG_INIT_COMPLETE|TG3_FLAG_GOT_SERDES_FLOWCTL);
+	tp->carrier_ok = 0;
+	iounmap((void *)tp->regs);
+}
+
+
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+You should omit the last argument struct pci_device * for a non-PCI NIC
+***************************************************************************/
+static int tg3_probe(struct dev *dev, struct pci_device *pdev)
+{
+	struct nic *nic = (struct nic *)dev;
+	struct tg3 *tp = &tg3;
+	unsigned long tg3reg_base, tg3reg_len;
+	int i, err, pm_cap;
+
+	if (pdev == 0)
+		return 0;
+
+	memset(tp, 0, sizeof(*tp));
+
+	adjust_pci_device(pdev);
+
+	/* Find power-management capability. */
+	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+	if (pm_cap == 0) {
+		printf("Cannot find PowerManagement capability, aborting.\n");
+		return 0;
+	}
+	tg3reg_base = pci_bar_start(pdev, PCI_BASE_ADDRESS_0);
+	if (tg3reg_base == -1UL) {
+		printf("Unuseable bar\n");
+		return 0;
+	}
+	tg3reg_len  = pci_bar_size(pdev,  PCI_BASE_ADDRESS_0);
+
+	tp->pdev       = pdev;
+	tp->nic        = nic;
+	tp->pm_cap     = pm_cap;
+	tp->rx_mode    = 0;
+	tp->tx_mode    = 0;
+	tp->mi_mode    = MAC_MI_MODE_BASE;
+	tp->tg3_flags  = 0 & ~TG3_FLAG_INIT_COMPLETE; 
+	
+	/* The word/byte swap controls here control register access byte
+	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE
+	 * setting below.
+	 */
+	tp->misc_host_ctrl =
+		MISC_HOST_CTRL_MASK_PCI_INT |
+		MISC_HOST_CTRL_WORD_SWAP |
+		MISC_HOST_CTRL_INDIR_ACCESS |
+		MISC_HOST_CTRL_PCISTATE_RW;
+
+	/* The NONFRM (non-frame) byte/word swap controls take effect
+	 * on descriptor entries, anything which isn't packet data.
+	 *
+	 * The StrongARM chips on the board (one for tx, one for rx)
+	 * are running in big-endian mode.
+	 */
+	tp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |
+			GRC_MODE_WSWAP_NONFRM_DATA);
+#if __BYTE_ORDER == __BIG_ENDIAN
+	tp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;
+#endif
+	tp->regs = (unsigned long) ioremap(tg3reg_base, tg3reg_len);
+	if (tp->regs == 0UL) {
+		printf("Cannot map device registers, aborting\n");
+		return 0;
+	}
+
+	tg3_init_link_config(tp);
+
+	err = tg3_get_invariants(tp);
+	if (err) {
+		printf("Problem fetching invariants of chip, aborting.\n");
+		goto err_out_iounmap;
+	}
+
+	err = tg3_get_device_address(tp);
+	if (err) {
+		printf("Could not obtain valid ethernet address, aborting.\n");
+		goto err_out_iounmap;
+	}
+	printf("Ethernet addr: %!\n", nic->node_addr);
+
+	tg3_setup_dma(tp);
+
+	/* Now that we have fully setup the chip, save away a snapshot
+	 * of the PCI config space.  We need to restore this after
+	 * GRC_MISC_CFG core clock resets and some resume events.
+	 */
+	pci_save_state(tp->pdev, tp->pci_cfg_state);
+
+	printf("Tigon3 [partno(%s) rev %hx PHY(%s)] (PCI%s:%s:%s)\n",
+		tp->board_part_number,
+		tp->pci_chip_rev_id,
+		tg3_phy_string(tp),
+		((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "X" : ""),
+		((tp->tg3_flags & TG3_FLAG_PCI_HIGH_SPEED) ?
+			((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "133MHz" : "66MHz") :
+			((tp->tg3_flags & TG3_FLAG_PCIX_MODE) ? "100MHz" : "33MHz")),
+		((tp->tg3_flags & TG3_FLAG_PCI_32BIT) ? "32-bit" : "64-bit"));
+
+
+	err = tg3_setup_hw(tp); 
+	if (err) {
+		goto err_out_disable;
+	} 
+	tp->tg3_flags |= TG3_FLAG_INIT_COMPLETE;
+
+	/* Wait for a reasonable time for the link to come up */
+	tg3_poll_link(tp);
+	for(i = 0; !tp->carrier_ok && (i < VALID_LINK_TIMEOUT*100); i++) {
+		mdelay(1);
+		tg3_poll_link(tp);
+	}
+	if (!tp->carrier_ok){
+		printf("Valid link not established\n");
+		goto err_out_disable;
+	}
+
+	dev->disable  = tg3_disable;
+	nic->poll     = tg3_poll;
+	nic->transmit = tg3_transmit;
+	return 1;
+
+ err_out_iounmap:
+	iounmap((void *)tp->regs);
+	return 0;
+ err_out_disable:
+	tg3_disable(dev);
+	return 0;
+}
+
+static struct pci_id tg3_nics[] = {
+PCI_ROM(0x14e4, 0x1644, "tg3-5700",        "Broadcom Tigon 3 5700"),
+PCI_ROM(0x14e4, 0x1645, "tg3-5701",        "Broadcom Tigon 3 5701"),
+PCI_ROM(0x14e4, 0x1646, "tg3-5702",        "Broadcom Tigon 3 5702"),
+PCI_ROM(0x14e4, 0x1647, "tg3-5703",        "Broadcom Tigon 3 5703"),
+PCI_ROM(0x14e4, 0x1648, "tg3-5704",        "Broadcom Tigon 3 5704"),
+PCI_ROM(0x14e4, 0x164d, "tg3-5702FE",      "Broadcom Tigon 3 5702FE"),
+PCI_ROM(0x14e4, 0x1653, "tg3-5705",        "Broadcom Tigon 3 5705"),
+PCI_ROM(0x14e4, 0x1654, "tg3-5705_2",      "Broadcom Tigon 3 5705_2"),
+PCI_ROM(0x14e4, 0x165d, "tg3-5705M",       "Broadcom Tigon 3 5705M"),
+PCI_ROM(0x14e4, 0x165e, "tg3-5705M_2",     "Broadcom Tigon 3 5705M_2"),
+PCI_ROM(0x14e4, 0x1696, "tg3-5782",        "Broadcom Tigon 3 5782"),
+PCI_ROM(0x14e4, 0x169c, "tg3-5788",        "Broadcom Tigon 3 5788"),
+PCI_ROM(0x14e4, 0x16a6, "tg3-5702X",       "Broadcom Tigon 3 5702X"),
+PCI_ROM(0x14e4, 0x16a7, "tg3-5703X",       "Broadcom Tigon 3 5703X"),
+PCI_ROM(0x14e4, 0x16a8, "tg3-5704S",       "Broadcom Tigon 3 5704S"),
+PCI_ROM(0x14e4, 0x16c6, "tg3-5702A3",      "Broadcom Tigon 3 5702A3"),
+PCI_ROM(0x14e4, 0x16c7, "tg3-5703A3",      "Broadcom Tigon 3 5703A3"),
+PCI_ROM(0x14e4, 0x170d, "tg3-5901",        "Broadcom Tigon 3 5901"),
+PCI_ROM(0x14e4, 0x170e, "tg3-5901_2",      "Broadcom Tigon 3 5901_2"),
+PCI_ROM(0x1148, 0x4400, "tg3-9DXX",        "Syskonnect 9DXX"),
+PCI_ROM(0x1148, 0x4500, "tg3-9MXX",        "Syskonnect 9MXX"),
+PCI_ROM(0x173b, 0x03e8, "tg3-ac1000",      "Altima AC1000"),
+PCI_ROM(0x173b, 0x03e9, "tg3-ac1001",      "Altima AC1001"),
+PCI_ROM(0x173b, 0x03ea, "tg3-ac9100",      "Altima AC9100"),
+PCI_ROM(0x173b, 0x03eb, "tg3-ac1003",      "Altima AC1003"),
+};
+
+struct pci_driver tg3_driver = {
+	.type	  = NIC_DRIVER,
+	.name	  = "TG3",
+	.probe	  = tg3_probe,
+	.ids	  = tg3_nics,
+	.id_count = sizeof(tg3_nics)/sizeof(tg3_nics[0]),
+	.class    = 0,
+};
Index: netboot/skel.c
===================================================================
--- netboot/skel.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/skel.c	(.../trunk)	(revision 112)
@@ -0,0 +1,129 @@
+/**************************************************************************
+Etherboot -  BOOTP/TFTP Bootstrap Program
+Skeleton NIC driver for Etherboot
+***************************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+/* to get the ISA support functions, if this is an ISA NIC */
+#include "isa.h"
+
+/* NIC specific static variables go here */
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int skel_poll(struct nic *nic)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	return (0);	/* initially as this is called to flush the input */
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void skel_transmit(
+	struct nic *nic,
+	const char *d,			/* Destination */
+	unsigned int t,			/* Type */
+	unsigned int s,			/* size */
+	const char *p)			/* Packet */
+{
+	/* send the packet to destination */
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void skel_disable(struct dev *dev)
+{
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished. 
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 */
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+
+#define board_found 1
+#define valid_link 0
+static int skel_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *)dev;
+	if (board_found && valid_link)
+	{
+		/* point to NIC specific routines */
+		dev->disable  = skel_disable;
+		nic->poll     = skel_poll;
+		nic->transmit = skel_transmit;
+		return 1;
+	}
+	/* else */
+	return 0;
+}
+
+static struct pci_id skel_nics[] = {
+PCI_ROM(0x0000, 0x0000, "skel-pci", "Skeleton PCI Adaptor"),
+};
+
+static struct pci_driver skel_driver __pci_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "SKELETON/PCI",
+	.probe    = skel_probe,
+	.ids      = skel_nics,
+	.id_count = sizeof(skel_nics)/sizeof(skel_nics[0]),
+	.class    = 0,
+};
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+static int skel_isa_probe(struct dev *dev, unsigned short *probe_addrs)
+{
+	struct nic *nic = (struct nic *)dev;
+	/* if probe_addrs is 0, then routine can use a hardwired default */
+	if (board_found && valid_link)
+	{
+		/* point to NIC specific routines */
+		dev->disable  = skel_disable;
+		nic->poll     = skel_poll;
+		nic->transmit = skel_transmit;
+
+		/* Report the ISA pnp id of the board */
+		dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+		dev->devid.vendor_id = htons(0x1234);
+		return 1;
+	}
+	/* else */
+	return 0;
+}
+
+ISA_ROM("skel-isa", "Skeleton ISA driver")
+static struct isa_driver skel_isa_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "SKELETON/ISA",
+	.probe   = skel_isa_probe,
+	.ioaddrs = 0,
+};
+
Index: netboot/little_bswap.h
===================================================================
--- netboot/little_bswap.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/little_bswap.h	(.../trunk)	(revision 112)
@@ -0,0 +1,17 @@
+#ifndef ETHERBOOT_LITTLE_BSWAP_H
+#define ETHERBOOT_LITTLE_BSWAP_H
+
+#define ntohl(x)	__bswap_32(x)
+#define htonl(x) 	__bswap_32(x)
+#define ntohs(x) 	__bswap_16(x)
+#define htons(x) 	__bswap_16(x)
+#define cpu_to_le32(x)	(x)
+#define cpu_to_le16(x)	(x)
+#define cpu_to_be32(x)	__bswap_32(x)
+#define cpu_to_be16(x)	__bswap_16(x)
+#define le32_to_cpu(x)	(x)
+#define le16_to_cpu(x)	(x)
+#define be32_to_cpu(x)	__bswap_32(x)
+#define be16_to_cpu(x)	__bswap_16(x)
+
+#endif /* ETHERBOOT_LITTLE_BSWAP_H */
Index: netboot/sundance.c
===================================================================
--- netboot/sundance.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/sundance.c	(.../trunk)	(revision 112)
@@ -0,0 +1,882 @@
+/**************************************************************************
+*
+*    sundance.c -- Etherboot device driver for the Sundance ST201 "Alta".
+*    Written 2002-2002 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*               sundance.c: A Linux device driver for the Sundance ST201 "Alta"
+*               Written 1999-2002 by Donald Becker
+*
+*               tulip.c: Tulip and Clone Etherboot Driver
+*               By Marty Conner
+*               Copyright (C) 2001 Entity Cyber, Inc.
+*
+*    $Revision$
+*    $Author$
+*    $Date 2003/04/13 $
+*
+*    REVISION HISTORY:
+*    ================
+*    v1.1	01-01-2003	timlegge	Initial implementation
+*    v1.7	04-10-2003	timlegge	Transfers Linux Kernel (30 sec)
+*    v1.8	04-13-2003	timlegge	Fix multiple transmission bug
+*    v1.9	08-19-2003	timlegge	Support Multicast
+*    
+***************************************************************************/
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+#include "timer.h"
+
+#define drv_version "v1.9"
+#define drv_date "08-19-2003"
+
+/* #define EDEBUG */
+/* Set the mtu */
+static int mtu = 1514;
+
+/* Maximum events (Rx packets, etc.) to handle at each interrupt. */
+static int max_interrupt_work = 20;
+
+/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).
+   The sundance uses a 64 element hash table based on the Ethernet CRC.  */
+static int multicast_filter_limit = 32;
+
+/* Set the copy breakpoint for the copy-only-tiny-frames scheme.
+   Setting to > 1518 effectively disables this feature.
+   This chip can receive into any byte alignment buffers, so word-oriented
+   archs do not need a copy-align of the IP header. */
+static int rx_copybreak = 0;
+
+/* Used to pass the media type, etc.
+   Both 'options[]' and 'full_duplex[]' should exist for driver
+   interoperability.
+   The media type is usually passed in 'options[]'.
+    The default is autonegotation for speed and duplex.
+	This should rarely be overridden.
+    Use option values 0x10/0x20 for 10Mbps, 0x100,0x200 for 100Mbps.
+    Use option values 0x10 and 0x100 for forcing half duplex fixed speed.
+    Use option values 0x20 and 0x200 for forcing full duplex operation.
+*/
+#define MAX_UNITS 8
+static int options[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+static int full_duplex[MAX_UNITS] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
+
+/* Operational parameters that are set at compile time. */
+
+/* Ring sizes are a power of two only for compile efficiency.
+   The compiler will convert <unsigned>'%'<2^N> into a bit mask.
+   There must be at least five Tx entries for the tx_full hysteresis, and
+   more than 31 requires modifying the Tx status handling error recovery.
+   Leave a inactive gap in the Tx ring for better cache behavior.
+   Making the Tx ring too large decreases the effectiveness of channel
+   bonding and packet priority.
+   Large receive rings waste memory and impact buffer accounting.
+   The driver need to protect against interrupt latency and the kernel
+   not reserving enough available memory.
+*/
+#define TX_RING_SIZE	2
+#define TX_QUEUE_LEN	10	/* Limit ring entries actually used.  */
+#define RX_RING_SIZE	4
+
+
+/* Operational parameters that usually are not changed. */
+/* Time in jiffies before concluding the transmitter is hung. */
+#define HZ 100
+#define TX_TIME_OUT	  (6*HZ)
+
+/* Allocation size of Rx buffers with normal sized Ethernet frames.
+   Do not change this value without good reason.  This is not a limit,
+   but a way to keep a consistent allocation size among drivers.
+ */
+#define PKT_BUF_SZ	1536
+
+/* Set iff a MII transceiver on any interface requires mdio preamble.
+   This only set with older tranceivers, so the extra
+   code size of a per-interface flag is not worthwhile. */
+static int mii_preamble_required = 0;
+
+/* Offsets to the device registers.
+   Unlike software-only systems, device drivers interact with complex hardware.
+   It's not useful to define symbolic names for every register bit in the
+   device.  The name can only partially document the semantics and make
+   the driver longer and more difficult to read.
+   In general, only the important configuration values or bits changed
+   multiple times should be defined symbolically.
+*/
+enum alta_offsets {
+	DMACtrl = 0x00, TxListPtr = 0x04, TxDMACtrl = 0x08, TxDescPoll =
+	    0x0a,
+	RxDMAStatus = 0x0c, RxListPtr = 0x10, RxDMACtrl =
+	    0x14, RxDescPoll = 0x16,
+	LEDCtrl = 0x1a, ASICCtrl = 0x30,
+	EEData = 0x34, EECtrl = 0x36, TxThreshold = 0x3c,
+	FlashAddr = 0x40, FlashData = 0x44, WakeEvent = 0x45, TxStatus =
+	    0x46,
+	DownCounter = 0x48, IntrClear = 0x4a, IntrEnable =
+	    0x4c, IntrStatus = 0x4e,
+	MACCtrl0 = 0x50, MACCtrl1 = 0x52, StationAddr = 0x54,
+	MaxFrameSize = 0x5A, RxMode = 0x5c, MIICtrl = 0x5e,
+	MulticastFilter0 = 0x60, MulticastFilter1 = 0x64,
+	RxOctetsLow = 0x68, RxOctetsHigh = 0x6a, TxOctetsLow =
+	    0x6c, TxOctetsHigh = 0x6e,
+	TxFramesOK = 0x70, RxFramesOK = 0x72, StatsCarrierError = 0x74,
+	StatsLateColl = 0x75, StatsMultiColl = 0x76, StatsOneColl = 0x77,
+	StatsTxDefer = 0x78, RxMissed = 0x79, StatsTxXSDefer =
+	    0x7a, StatsTxAbort = 0x7b,
+	StatsBcastTx = 0x7c, StatsBcastRx = 0x7d, StatsMcastTx =
+	    0x7e, StatsMcastRx = 0x7f,
+	/* Aliased and bogus values! */
+	RxStatus = 0x0c,
+};
+
+/* Bits in the interrupt status/mask registers. */
+enum intr_status_bits {
+	IntrSummary = 0x0001, IntrPCIErr = 0x0002, IntrMACCtrl = 0x0008,
+	IntrTxDone = 0x0004, IntrRxDone = 0x0010, IntrRxStart = 0x0020,
+	IntrDrvRqst = 0x0040,
+	StatsMax = 0x0080, LinkChange = 0x0100,
+	IntrTxDMADone = 0x0200, IntrRxDMADone = 0x0400,
+};
+
+/* Bits in the RxMode register. */
+enum rx_mode_bits {
+	AcceptAllIPMulti = 0x20, AcceptMultiHash = 0x10, AcceptAll = 0x08,
+	AcceptBroadcast = 0x04, AcceptMulticast = 0x02, AcceptMyPhys =
+	    0x01,
+};
+/* Bits in MACCtrl. */
+enum mac_ctrl0_bits {
+	EnbFullDuplex = 0x20, EnbRcvLargeFrame = 0x40,
+	EnbFlowCtrl = 0x100, EnbPassRxCRC = 0x200,
+};
+enum mac_ctrl1_bits {
+	StatsEnable = 0x0020, StatsDisable = 0x0040, StatsEnabled = 0x0080,
+	TxEnable = 0x0100, TxDisable = 0x0200, TxEnabled = 0x0400,
+	RxEnable = 0x0800, RxDisable = 0x1000, RxEnabled = 0x2000,
+};
+
+/* The Rx and Tx buffer descriptors.
+   Using only 32 bit fields simplifies software endian correction.
+   This structure must be aligned, and should avoid spanning cache lines.
+*/
+struct netdev_desc {
+	u32 next_desc;
+	u32 status;
+	u32 addr;
+	u32 length;
+};
+
+/* Bits in netdev_desc.status */
+enum desc_status_bits {
+	DescOwn = 0x8000, DescEndPacket = 0x4000, DescEndRing = 0x2000,
+	DescTxDMADone = 0x10000,
+	LastFrag = 0x80000000, DescIntrOnTx = 0x8000, DescIntrOnDMADone =
+	    0x80000000,
+};
+
+
+/* Define the TX Descriptor */
+static struct netdev_desc tx_ring[TX_RING_SIZE]
+    __attribute__ ((aligned(8)));
+
+/* Create a static buffer of size PKT_BUF_SZ for each
+TX Descriptor.  All descriptors point to a
+part of this buffer */
+static unsigned char txb[PKT_BUF_SZ * TX_RING_SIZE]
+    __attribute__ ((aligned(8)));
+
+
+/* Define the RX Descriptor */
+static struct netdev_desc rx_ring[RX_RING_SIZE]
+    __attribute__ ((aligned(8)));
+
+/* Create a static buffer of size PKT_BUF_SZ for each
+RX Descriptor   All descriptors point to a
+part of this buffer */
+static unsigned char rxb[RX_RING_SIZE * PKT_BUF_SZ]
+    __attribute__ ((aligned(8)));
+
+
+static u32 BASE;
+#define EEPROM_SIZE	128
+
+enum pci_id_flags_bits {
+	PCI_USES_IO = 1, PCI_USES_MEM = 2, PCI_USES_MASTER = 4,
+	PCI_ADDR0 = 0 << 4, PCI_ADDR1 = 1 << 4, PCI_ADDR2 =
+	    2 << 4, PCI_ADDR3 = 3 << 4,
+};
+
+enum chip_capability_flags { CanHaveMII = 1, KendinPktDropBug = 2, };
+#define PCI_IOTYPE (PCI_USES_MASTER | PCI_USES_IO  | PCI_ADDR0)
+
+struct pci_id_info {
+	char *name;
+	struct match_info {
+		u32 pci, pci_mask, subsystem, subsystem_mask;
+		u32 revision, revision_mask;	/* Only 8 bits. */
+	} id;
+	enum pci_id_flags_bits pci_flags;
+	int io_size;		/* Needed for I/O region check or ioremap(). */
+	int drv_flags;		/* Driver use, intended as capability flags. */
+};
+
+struct sundance_private {
+	unsigned short vendor_id;	/* PCI Vendor code */
+	unsigned short dev_id;	/* PCI Device code */
+	unsigned char ethr[ETH_HLEN];	/* Buffer for ethernet header */
+	const char *nic_name;
+	unsigned int if_port;
+	/* Frequently used values */
+	int msg_level;
+	int chip_id, drv_flags;
+
+	int max_interrupt_word;
+
+	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indicies */
+	unsigned rx_buf_sz;	/* Based on mtu + Slack */
+	int rx_copybreak;
+
+	struct netdev_desc *rx_head_desc;
+	unsigned int cur_tx, dirty_tx;
+	unsigned int tx_full:1;
+	unsigned int mtu;
+
+	/* These values keep track of the tranceiver/media in use */
+	unsigned int full_duplex:1;	/* Full Duplex Requested */
+	unsigned int duplex_lock:1;
+	unsigned int medialock:1;	/* Do not sense media */
+	unsigned int default_port:4;
+
+	unsigned int an_enable:1;
+	unsigned int speed;
+
+	/* Multicast and receive mode */
+	u16 mcast_filter[4];
+	int multicast_filter_limit;
+
+	/* MII tranceiver section */
+	int mii_cnt;		/* MII device addresses */
+	int link_status;
+	u16 advertizing;	/* NWay media advertizing */
+	unsigned char phys[2];
+	int budget;
+
+	int saved_if_port;
+} sdx;
+
+static struct sundance_private *sdc;
+
+/* Station Address location within the EEPROM */
+#define EEPROM_SA_OFFSET	0x10
+
+
+
+static int eeprom_read(long ioaddr, int location);
+static int mdio_read(struct nic *nic, int phy_id, unsigned int location);
+static void mdio_write(struct nic *nic, int phy_id, unsigned int location,
+		       int value);
+static void set_rx_mode(struct nic *nic);
+static void refill_rx(struct nic *nic);
+
+static void check_duplex(struct nic *nic)
+{
+	int mii_reg5 = mdio_read(nic, sdc->phys[0], 5);
+	int negotiated = mii_reg5 & sdc->advertizing;
+	int duplex;
+
+	if (sdc->duplex_lock || mii_reg5 == 0xffff)
+		return;
+	duplex = (negotiated & 0x0100) || (negotiated & 0x01C0) == 0x0040;
+	if (sdc->full_duplex != duplex) {
+		sdc->full_duplex = duplex;
+		printf("%s: Setting %s-duplex based on MII #%d "
+		       "negociated capability %hX\n", sdc->nic_name,
+		       duplex ? "full" : "half", sdc->phys[0], negotiated);
+		outw(duplex ? 0x20 : 0, BASE + MACCtrl0);
+
+	}
+}
+
+
+/**************************************************************************
+ *  init_ring - setup the tx and rx descriptors
+ *************************************************************************/
+static void init_ring(struct nic *nic __unused)
+{
+	int i;
+
+	sdc->cur_rx = 0;
+	sdc->rx_buf_sz = (PKT_BUF_SZ);
+	sdc->rx_head_desc = &rx_ring[0];
+
+	/* Initialize all the Rx descriptors */
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		rx_ring[i].next_desc = virt_to_le32desc(&rx_ring[i + 1]);
+		rx_ring[i].status = 0;
+		rx_ring[i].length = 0;
+		rx_ring[i].addr = 0;
+	}
+
+	/* Mark the last entry as wrapping the ring */
+	rx_ring[i - 1].next_desc = virt_to_le32desc(&rx_ring[0]);
+
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		rx_ring[i].addr = virt_to_le32desc(&rxb[i * PKT_BUF_SZ]);
+		rx_ring[i].length = cpu_to_le32(sdc->rx_buf_sz | LastFrag);
+	}
+	sdc->dirty_rx = (unsigned int) (i - RX_RING_SIZE);
+
+	/* We only use one transmit buffer, but two 
+	 * descriptors so transmit engines have somewhere 
+	 * to point should they feel the need */
+	tx_ring[0].status = 0x00000000;
+	tx_ring[0].addr = virt_to_bus(&txb[0]);
+	tx_ring[0].next_desc = 0; /* virt_to_bus(&tx_ring[1]); */
+
+	/* This descriptor is never used */
+	tx_ring[1].status = 0x00000000;
+	tx_ring[1].addr = 0; /*virt_to_bus(&txb[0]); */
+	tx_ring[1].next_desc = 0; 
+
+	/* Mark the last entry as wrapping the ring, 
+	 * though this should never happen */
+	tx_ring[1].length = cpu_to_le32(LastFrag | PKT_BUF_SZ);
+}
+
+/**************************************************************************
+ *  RESET - Reset Adapter
+ * ***********************************************************************/
+static void sundance_reset(struct nic *nic)
+{
+	int i;
+
+	init_ring(nic);
+
+	/* FIXME: find out where the linux driver sets duplex_lock */
+	sdc->full_duplex = sdc->duplex_lock;
+
+	/* The Tx List Pointer is written as packets are queued */
+	outl(virt_to_le32desc(&rx_ring[0]), BASE + RxListPtr);
+
+	/* Write the MAC address to the StationAddress */
+	for (i = 0; i < 6; i++)
+		outb(nic->node_addr[i], BASE + StationAddr + i);
+
+	/* Get the link status */
+	sdc->link_status = inb(BASE + MIICtrl) & 0xE0;
+	/* Write the status to the MACCtrl0 register */
+	outw((sdc->full_duplex || (sdc->link_status & 0x20)) ? 0x120 : 0,
+	     BASE + MACCtrl0);
+	outw(sdc->mtu + 14, BASE + MaxFrameSize);
+	if (sdc->mtu > 2047)/* this will never happen with default options */
+		outl(inl(BASE + ASICCtrl) | 0x0c, BASE + ASICCtrl);
+
+	set_rx_mode(nic);
+	outw(0, BASE + DownCounter);
+	/* Set the chip to poll every N*30nsec */
+	outb(100, BASE + RxDescPoll);
+/*	outb(127, BASE + TxDescPoll); */
+
+/* FIXME: Linux Driver has a bug fix for kendin nic */
+
+/* FIXME: Do we really need stats enabled?*/
+	outw(StatsEnable | RxEnable | TxEnable, BASE + MACCtrl1);
+
+	/* Construct a perfect filter frame with the mac address as first match
+	 * and broadcast for all others */
+	for (i = 0; i < 192; i++)
+		txb[i] = 0xFF;
+
+	txb[0] = nic->node_addr[0];
+	txb[1] = nic->node_addr[1];
+	txb[2] = nic->node_addr[2];
+	txb[3] = nic->node_addr[3];
+	txb[4] = nic->node_addr[4];
+	txb[5] = nic->node_addr[5];
+
+	check_duplex(nic);
+#ifdef EDEBUG
+	printf("%s: Done sundance_reset, status: Rx %hX Tx %hX "
+	       "MAC Control %hX, %hX %hX\n",
+	       sdc->nic_name, (int) inl(BASE + RxStatus),
+	       (int) inw(BASE + TxStatus), (int) inl(BASE + MACCtrl0),
+	       (int) inw(BASE + MACCtrl1), (int) inw(BASE + MACCtrl0));
+#endif
+}
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int sundance_poll(struct nic *nic)
+{
+
+	/* FIXME: The entire POLL procedure needs to be cleand up */
+
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	int entry = sdc->cur_rx % RX_RING_SIZE;
+	int boguscnt = 32;
+	int received = 0;
+	struct netdev_desc *desc = &(rx_ring[entry]);
+	u32 frame_status = le32_to_cpu(desc->status);
+	int pkt_len = 0;
+
+	if (--boguscnt < 0) {
+		goto not_done;
+	}
+	if (!(frame_status & DescOwn))
+		return 0;
+	pkt_len = frame_status & 0x1fff;
+	if (frame_status & 0x001f4000) {
+#ifdef EDEBUG
+		/* FIXME: Do we really care about this */
+		printf("There was an error\n");
+#endif
+	} else {
+		if (pkt_len < rx_copybreak) {
+			/* FIXME: What should happen Will this ever occur */
+			printf("Problem");
+		} else {
+			nic->packetlen = pkt_len;
+			memcpy(nic->packet, rxb +
+			       (sdc->cur_rx * PKT_BUF_SZ), nic->packetlen);
+
+		}
+	}
+	entry = (entry + 1) % RX_RING_SIZE;
+	received++;
+	sdc->cur_rx = entry;
+	refill_rx(nic);
+	sdc->budget -= received;
+	return 1;
+
+
+      not_done:
+	sdc->cur_rx = entry;
+	refill_rx(nic);
+	if (!received)
+		received = 1;
+	sdc->budget -= received;
+	if (sdc->budget <= 0)
+		sdc->budget = 32;
+#ifdef EDEBUG
+	printf("Not Done\n");
+#endif
+	return 0;
+
+}
+static void refill_rx(struct nic *nic __unused)
+{
+	int entry;
+	int cnt = 0;
+
+	/* Refill the Rx ring buffers. */
+	for (;
+	     (sdc->cur_rx - sdc->dirty_rx + RX_RING_SIZE) % RX_RING_SIZE >
+	     0; sdc->dirty_rx = (sdc->dirty_rx + 1) % RX_RING_SIZE) {
+		entry = sdc->dirty_rx % RX_RING_SIZE;
+		/* Perhaps we need not reset this field. */
+		rx_ring[entry].length =
+		    cpu_to_le32(sdc->rx_buf_sz | LastFrag);
+		rx_ring[entry].status = 0;
+		cnt++;
+	}
+	return;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void sundance_transmit(struct nic *nic, const char *d,	/* Destination */
+			      unsigned int t,	/* Type */
+			      unsigned int s,	/* size */
+			      const char *p)
+{				/* Packet */
+	u16 nstype;
+	u32 to;
+	/* Disable the Tx */
+	outw(TxDisable, BASE + MACCtrl1);
+
+	memcpy(txb, d, ETH_ALEN);
+	memcpy(txb + ETH_ALEN, nic->node_addr, ETH_ALEN);
+	nstype = htons((u16) t);
+	memcpy(txb + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+	memcpy(txb + ETH_HLEN, p, s);
+
+	s += ETH_HLEN;
+	s &= 0x0FFF;
+	while (s < ETH_ZLEN)
+		txb[s++] = '\0';
+
+	/* Setup the transmit descriptor */
+	tx_ring[0].length = cpu_to_le32(s | LastFrag);
+	tx_ring[0].status = cpu_to_le32(0x00000001);
+
+	/* Point to transmit descriptor */
+	outl(virt_to_le32desc(&tx_ring[0]), BASE + TxListPtr);
+
+	/* Enable Tx */
+	outw(TxEnable, BASE + MACCtrl1);
+	outw(0, BASE + TxStatus);
+	to = currticks() + TX_TIME_OUT;
+	while(!(tx_ring[0].status & 0x00010000) &&  (currticks() < to))
+		; /* wait */ 
+
+	if (currticks() >= to) {
+		printf("TX Time Out");
+	}
+	/* Disable Tx */
+	outw(TxDisable, BASE + MACCtrl1);
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void sundance_disable(struct dev *dev)
+{
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished.
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 */
+	sundance_reset((struct nic *) dev); 
+	outw(0x0000, BASE + IntrEnable);
+	/* Stop the Chipchips Tx and Rx Status */
+	outw(TxDisable | RxDisable | StatsDisable, BASE + MACCtrl1);
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
+static int sundance_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+	int card_idx = 1;
+	u8 ee_data[EEPROM_SIZE];
+	int i, option = card_idx < MAX_UNITS ? options[card_idx] : 0;
+
+	if (pci->ioaddr == 0)
+		return 0;
+
+	/* BASE is used throughout to address the card */
+	BASE = pci->ioaddr;
+	printf("\n");
+	printf("sundance.c: %s, %s Written by Timothy Legge (tlegge@rogers.com)\n", drv_version, drv_date);
+	printf("%s: Probing for Vendor=%hX   Device=%hX, %s\n",
+	       pci->name, pci->vendor, pci->dev_id);
+
+	/* Get the MAC Address by reading the EEPROM */
+	for (i = 0; i < 3; i++) {
+		((u16 *) ee_data)[i] =
+		    le16_to_cpu(eeprom_read(BASE, i + EEPROM_SA_OFFSET));
+	}
+	/* Update the nic structure with the MAC Address */
+	for (i = 0; i < ETH_ALEN; i++) {
+		nic->node_addr[i] = ee_data[i];
+	}
+	/* Print out some hardware info */
+	printf("%s: %! at ioaddr %hX\n", pci->name, nic->node_addr, BASE);
+
+	/* I really must find out what this does */
+	adjust_pci_device(pci);
+
+	/* point to private storage */
+	sdc = &sdx;
+
+	sdc->chip_id = 0;	/* Undefined */
+	sdc->drv_flags = 0;	/* Undefined */
+	sdc->rx_copybreak = rx_copybreak;
+	sdc->max_interrupt_word = max_interrupt_work;
+	sdc->multicast_filter_limit = multicast_filter_limit;
+	sdc->vendor_id = pci->vendor;
+	sdc->dev_id = pci->dev_id;
+	sdc->nic_name = pci->name;
+	sdc->mtu = mtu;
+
+	if (card_idx < MAX_UNITS && full_duplex[card_idx] > 0) {
+		sdc->full_duplex = 1;
+#ifdef EDEBUG
+		printf("sdc->full_duplex = 1\n");
+#endif
+	}
+	if (sdc->full_duplex) {
+		sdc->medialock = 1;
+#ifdef EDEBUG
+		printf("sdc->media_lock = 1\n");
+#endif
+	}
+
+	if (1) {
+		int phy, phy_idx = 0;
+		sdc->phys[0] = 1;	/* Default Setting */
+		mii_preamble_required++;
+		for (phy = 1; phy < 32 && phy_idx < 4; phy++) {
+			int mii_status = mdio_read(nic, phy, 1);
+			if (mii_status != 0xffff && mii_status != 0x0000) {
+				sdc->phys[phy_idx++] = phy;
+				sdc->advertizing = mdio_read(nic, phy, 4);
+				if ((mii_status & 0x0040) == 0)
+					mii_preamble_required++;
+#ifdef EDEBUG
+				printf
+				    ("%s: MII PHY found at address %d, status "
+				     "%hX advertizing %hX\n",
+				     sdc->nic_name, phy, mii_status,
+				     sdc->advertizing);
+#endif
+			}
+		}
+		mii_preamble_required--;
+		sdc->mii_cnt = phy_idx;
+		if (phy_idx == 0)
+			printf("%s: No MII transceiver found!\n",
+			       sdc->nic_name);
+	}
+
+	/* Allow forcing the media type */
+	if (option > 0) {
+#ifdef EDEBUG
+		printf("Trying to force the media type\n");
+#endif
+		if (option & 0x220)
+			sdc->full_duplex = 1;
+		sdc->default_port = option & 0x3ff;
+		if (sdc->default_port & 0x330) {
+			sdc->medialock = 1;
+#ifdef EDEBUG
+			printf("Forcing %dMbs %s-duplex operation.\n",
+			       (option & 0x300 ? 100 : 10),
+			       (sdc->full_duplex ? "full" : "half"));
+#endif
+			if (sdc->mii_cnt)
+				mdio_write(nic, sdc->phys[0],
+					0, ((option & 0x300) ? 0x2000 : 0)
+					|	/* 100mbps */
+					(sdc->full_duplex ? 0x0100 : 0));	/* Full Duplex? */
+		}
+	}
+
+	/* Reset the chip to erase previous misconfiguration */
+#ifdef EDEBUG
+	printf("ASIC Control is %hX\n", (int) inl(BASE + ASICCtrl));
+#endif
+	outl(0x007f0000 | inl(BASE + ASICCtrl), BASE + ASICCtrl);
+#ifdef EDEBUG
+	printf("ASIC Control is now %hX\n", (int) inl(BASE + ASICCtrl));
+#endif
+
+	sundance_reset(nic);
+
+	/* point to NIC specific routines */
+	dev->disable = sundance_disable;
+	nic->poll = sundance_poll;
+	nic->transmit = sundance_transmit;
+
+	return 1;
+}
+
+
+/* Read the EEPROM and MII Management Data I/O (MDIO) interfaces. */
+static int eeprom_read(long ioaddr, int location)
+{
+	int boguscnt = 2000;	/* Typical 190 ticks */
+	outw(0x0200 | (location & 0xff), ioaddr + EECtrl);
+	do {
+		if (!(inw(ioaddr + EECtrl) & 0x8000)) {
+			return inw(ioaddr + EEData);
+		}
+	}
+	while (--boguscnt > 0);
+	return 0;
+}
+
+/*  MII transceiver control section.
+	Read and write the MII registers using software-generated serial
+	MDIO protocol.  See the MII specifications or DP83840A data sheet
+	for details.
+
+	The maximum data clock rate is 2.5 Mhz.
+	The timing is decoupled from the processor clock by flushing the write
+	from the CPU write buffer with a following read, and using PCI
+	transaction time. */
+
+#define mdio_in(mdio_addr) inb(mdio_addr)
+#define mdio_out(value, mdio_addr) outb(value, mdio_addr)
+#define mdio_delay(mdio_addr) inb(mdio_addr)
+
+enum mii_reg_bits {
+	MDIO_ShiftClk = 0x0001, MDIO_Data = 0x0002, MDIO_EnbOutput =
+	    0x0004,
+};
+#define MDIO_EnbIn  (0)
+#define MDIO_WRITE0 (MDIO_EnbOutput)
+#define MDIO_WRITE1 (MDIO_Data | MDIO_EnbOutput)
+
+/* Generate the preamble required for initial synchronization and
+   a few older transceivers. */
+static void mdio_sync(long mdio_addr)
+{
+	int bits = 32;
+
+	/* Establish sync by sending at least 32 logic ones. */
+	while (--bits >= 0) {
+		mdio_out(MDIO_WRITE1, mdio_addr);
+		mdio_delay(mdio_addr);
+		mdio_out(MDIO_WRITE1 | MDIO_ShiftClk, mdio_addr);
+		mdio_delay(mdio_addr);
+	}
+}
+
+static int
+mdio_read(struct nic *nic __unused, int phy_id, unsigned int location)
+{
+	long mdio_addr = BASE + MIICtrl;
+	int mii_cmd = (0xf6 << 10) | (phy_id << 5) | location;
+	int i, retval = 0;
+
+	if (mii_preamble_required)
+		mdio_sync(mdio_addr);
+
+	/* Shift the read command bits out. */
+	for (i = 15; i >= 0; i--) {
+		int dataval =
+		    (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;
+
+		mdio_out(dataval, mdio_addr);
+		mdio_delay(mdio_addr);
+		mdio_out(dataval | MDIO_ShiftClk, mdio_addr);
+		mdio_delay(mdio_addr);
+	}
+	/* Read the two transition, 16 data, and wire-idle bits. */
+	for (i = 19; i > 0; i--) {
+		mdio_out(MDIO_EnbIn, mdio_addr);
+		mdio_delay(mdio_addr);
+		retval = (retval << 1) | ((mdio_in(mdio_addr) & MDIO_Data)
+					  ? 1 : 0);
+		mdio_out(MDIO_EnbIn | MDIO_ShiftClk, mdio_addr);
+		mdio_delay(mdio_addr);
+	}
+	return (retval >> 1) & 0xffff;
+}
+
+static void
+mdio_write(struct nic *nic __unused, int phy_id,
+	   unsigned int location, int value)
+{
+	long mdio_addr = BASE + MIICtrl;
+	int mii_cmd =
+	    (0x5002 << 16) | (phy_id << 23) | (location << 18) | value;
+	int i;
+
+	if (mii_preamble_required)
+		mdio_sync(mdio_addr);
+
+	/* Shift the command bits out. */
+	for (i = 31; i >= 0; i--) {
+		int dataval =
+		    (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;
+		mdio_out(dataval, mdio_addr);
+		mdio_delay(mdio_addr);
+		mdio_out(dataval | MDIO_ShiftClk, mdio_addr);
+		mdio_delay(mdio_addr);
+	}
+	/* Clear out extra bits. */
+	for (i = 2; i > 0; i--) {
+		mdio_out(MDIO_EnbIn, mdio_addr);
+		mdio_delay(mdio_addr);
+		mdio_out(MDIO_EnbIn | MDIO_ShiftClk, mdio_addr);
+		mdio_delay(mdio_addr);
+	}
+	return;
+}
+
+/* The little-endian AUTODIN II ethernet CRC calculations.
+   A big-endian version is also available.
+   This is slow but compact code.  Do not use this routine for bulk data,
+   use a table-based routine instead.
+   This is common code and should be moved to net/core/crc.c.
+   Chips may use the upper or lower CRC bits, and may reverse and/or invert
+   them.  Select the endian-ness that results in minimal calculations.
+*/
+static unsigned const ethernet_polynomial_le = 0xedb88320U;
+static inline unsigned ether_crc_le(int length, unsigned char *data)
+{
+	unsigned int crc = ~0;	/* Initial value. */
+	while (--length >= 0) {
+		unsigned char current_octet = *data++;
+		int bit;
+		for (bit = 8; --bit >= 0; current_octet >>= 1) {
+			if ((crc ^ current_octet) & 1) {
+				crc >>= 1;
+				crc ^= ethernet_polynomial_le;
+			} else
+				crc >>= 1;
+		}
+	}
+	return crc;
+}
+
+static void set_rx_mode(struct nic *nic __unused)
+{
+	int i;
+	u16 mc_filter[4];	/* Multicast hash filter */
+	u32 rx_mode;
+
+	memset(mc_filter, 0xff, sizeof(mc_filter));
+	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+	
+	for(i = 0; i < 4; i++) 
+		outw(mc_filter[i], BASE + MulticastFilter0 + i*2);	
+	outb(rx_mode, BASE + RxMode);
+	return;
+}
+
+static struct pci_id sundance_nics[] = {
+PCI_ROM(0x13f0, 0x0201, "sundance",  "ST201 Sundance 'Alta' based Adaptor"),
+PCI_ROM(0x1186, 0x1002, "dfe530txs", "D-Link DFE530TXS (Sundance ST201 Alta)"),
+};
+
+struct pci_driver sundance_driver = {
+	.type = NIC_DRIVER,
+	.name = "SUNDANCE/PCI",
+	.probe = sundance_probe,
+	.ids = sundance_nics,
+	.id_count = sizeof(sundance_nics) / sizeof(sundance_nics[0]),
+	.class = 0,
+};
Index: netboot/pci_io.c
===================================================================
--- netboot/pci_io.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/pci_io.c	(.../trunk)	(revision 112)
@@ -0,0 +1,432 @@
+/*
+** Support for NE2000 PCI clones added David Monro June 1997
+** Generalised to other NICs by Ken Yap July 1997
+**
+** Most of this is taken from:
+**
+** /usr/src/linux/drivers/pci/pci.c
+** /usr/src/linux/include/linux/pci.h
+** /usr/src/linux/arch/i386/bios32.c
+** /usr/src/linux/include/linux/bios32.h
+** /usr/src/linux/drivers/net/ne.c
+*/
+
+#include "grub.h"
+#include "types.h"
+#include "io.h"
+#include "pci.h"
+
+#define PCBIOS
+
+unsigned long virt_offset = 0;
+
+#ifdef	CONFIG_PCI_DIRECT
+#define  PCIBIOS_SUCCESSFUL                0x00
+
+
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+
+#define CONFIG_CMD(bus, device_fn, where)   (0x80000000 | (bus << 16) | (device_fn << 8) | (where & ~3))
+
+int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn,
+			       unsigned int where, uint8_t *value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    *value = inb(0xCFC + (where&3));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_read_config_word (unsigned int bus,
+    unsigned int device_fn, unsigned int where, uint16_t *value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    *value = inw(0xCFC + (where&2));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_read_config_dword (unsigned int bus, unsigned int device_fn,
+				 unsigned int where, uint32_t *value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    *value = inl(0xCFC);
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn,
+				 unsigned int where, uint8_t value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    outb(value, 0xCFC + (where&3));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_write_config_word (unsigned int bus, unsigned int device_fn,
+				 unsigned int where, uint16_t value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    outw(value, 0xCFC + (where&2));
+    return PCIBIOS_SUCCESSFUL;
+}
+
+int pcibios_write_config_dword (unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t value)
+{
+    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
+    outl(value, 0xCFC);
+    return PCIBIOS_SUCCESSFUL;
+}
+
+#undef CONFIG_CMD
+
+#else	 /* CONFIG_PCI_DIRECT  not defined */
+
+#define KERN_CODE_SEG 0X8
+/* Stuff for asm */
+#define save_flags(x) \
+__asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
+
+#define cli() __asm__ __volatile__ ("cli": : :"memory")
+
+#define restore_flags(x) \
+__asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
+
+
+
+static struct {
+	unsigned long address;
+	unsigned short segment;
+} bios32_indirect = { 0, KERN_CODE_SEG };
+
+static long pcibios_entry = 0;
+static struct {
+	unsigned long address;
+	unsigned short segment;
+} pci_indirect = { 0, KERN_CODE_SEG };
+
+static unsigned long bios32_service(unsigned long service)
+{
+	unsigned char return_code;	/* %al */
+	unsigned long address;		/* %ebx */
+	unsigned long length;		/* %ecx */
+	unsigned long entry;		/* %edx */
+	unsigned long flags;
+
+	save_flags(flags);
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%edi)"
+#else
+		"lcall *(%%edi)"
+#endif
+		: "=a" (return_code),
+		  "=b" (address),
+		  "=c" (length),
+		  "=d" (entry)
+		: "0" (service),
+		  "1" (0),
+		  "D" (&bios32_indirect));
+	restore_flags(flags);
+
+	switch (return_code) {
+		case 0:
+			return address + entry;
+		case 0x80:	/* Not present */
+			printf("bios32_service(%d) : not present\n", service);
+			return 0;
+		default: /* Shouldn't happen */
+			printf("bios32_service(%d) : returned %#X, mail drew@colorado.edu\n",
+				service, return_code);
+			return 0;
+	}
+}
+
+int pcibios_read_config_byte(unsigned int bus,
+        unsigned int device_fn, unsigned int where, uint8_t *value)
+{
+        unsigned long ret;
+        unsigned long bx = (bus << 8) | device_fn;
+        unsigned long flags;
+
+        save_flags(flags);
+        __asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+                "jc 1f\n\t"
+                "xor %%ah, %%ah\n"
+                "1:"
+                : "=c" (*value),
+                  "=a" (ret)
+                : "1" (PCIBIOS_READ_CONFIG_BYTE),
+                  "b" (bx),
+                  "D" ((long) where),
+                  "S" (&pci_indirect));
+        restore_flags(flags);
+        return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_read_config_word(unsigned int bus,
+        unsigned int device_fn, unsigned int where, uint16_t *value)
+{
+        unsigned long ret;
+        unsigned long bx = (bus << 8) | device_fn;
+        unsigned long flags;
+
+        save_flags(flags);
+        __asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+                "jc 1f\n\t"
+                "xor %%ah, %%ah\n"
+                "1:"
+                : "=c" (*value),
+                  "=a" (ret)
+                : "1" (PCIBIOS_READ_CONFIG_WORD),
+                  "b" (bx),
+                  "D" ((long) where),
+                  "S" (&pci_indirect));
+        restore_flags(flags);
+        return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_read_config_dword(unsigned int bus,
+        unsigned int device_fn, unsigned int where, uint32_t *value)
+{
+        unsigned long ret;
+        unsigned long bx = (bus << 8) | device_fn;
+        unsigned long flags;
+
+        save_flags(flags);
+        __asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+                "jc 1f\n\t"
+                "xor %%ah, %%ah\n"
+                "1:"
+                : "=c" (*value),
+                  "=a" (ret)
+                : "1" (PCIBIOS_READ_CONFIG_DWORD),
+                  "b" (bx),
+                  "D" ((long) where),
+                  "S" (&pci_indirect));
+        restore_flags(flags);
+        return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_write_config_byte (unsigned int bus,
+	unsigned int device_fn, unsigned int where, uint8_t value)
+{
+	unsigned long ret;
+	unsigned long bx = (bus << 8) | device_fn;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+		"jc 1f\n\t"
+		"xor %%ah, %%ah\n"
+		"1:"
+		: "=a" (ret)
+		: "0" (PCIBIOS_WRITE_CONFIG_BYTE),
+		  "c" (value),
+		  "b" (bx),
+		  "D" ((long) where),
+		  "S" (&pci_indirect));
+	restore_flags(flags);
+	return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_write_config_word (unsigned int bus,
+	unsigned int device_fn, unsigned int where, uint16_t value)
+{
+	unsigned long ret;
+	unsigned long bx = (bus << 8) | device_fn;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+		"jc 1f\n\t"
+		"xor %%ah, %%ah\n"
+		"1:"
+		: "=a" (ret)
+		: "0" (PCIBIOS_WRITE_CONFIG_WORD),
+		  "c" (value),
+		  "b" (bx),
+		  "D" ((long) where),
+		  "S" (&pci_indirect));
+	restore_flags(flags);
+	return (int) (ret & 0xff00) >> 8;
+}
+
+int pcibios_write_config_dword (unsigned int bus,
+	unsigned int device_fn, unsigned int where, uint32_t value)
+{
+	unsigned long ret;
+	unsigned long bx = (bus << 8) | device_fn;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+		"lcall (%%esi)\n\t"
+#else
+		"lcall *(%%esi)\n\t"
+#endif
+		"jc 1f\n\t"
+		"xor %%ah, %%ah\n"
+		"1:"
+		: "=a" (ret)
+		: "0" (PCIBIOS_WRITE_CONFIG_DWORD),
+		  "c" (value),
+		  "b" (bx),
+		  "D" ((long) where),
+		  "S" (&pci_indirect));
+	restore_flags(flags);
+	return (int) (ret & 0xff00) >> 8;
+}
+
+static void check_pcibios(void)
+{
+	unsigned long signature;
+	unsigned char present_status;
+	unsigned char major_revision;
+	unsigned char minor_revision;
+	unsigned long flags;
+	int pack;
+
+	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
+		pci_indirect.address = pcibios_entry;
+
+		save_flags(flags);
+		__asm__(
+#ifdef ABSOLUTE_WITHOUT_ASTERISK
+			"lcall (%%edi)\n\t"
+#else
+			"lcall *(%%edi)\n\t"
+#endif
+			"jc 1f\n\t"
+			"xor %%ah, %%ah\n"
+			"1:\tshl $8, %%eax\n\t"
+			"movw %%bx, %%ax"
+			: "=d" (signature),
+			  "=a" (pack)
+			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
+			  "D" (&pci_indirect)
+			: "bx", "cx");
+		restore_flags(flags);
+
+		present_status = (pack >> 16) & 0xff;
+		major_revision = (pack >> 8) & 0xff;
+		minor_revision = pack & 0xff;
+		if (present_status || (signature != PCI_SIGNATURE)) {
+			printf("ERROR: BIOS32 says PCI BIOS, but no PCI "
+				"BIOS????\n");
+			pcibios_entry = 0;
+		}
+#if	DEBUG
+		if (pcibios_entry) {
+			printf ("pcibios_init : PCI BIOS revision %hhX.%hhX"
+				" entry at %#X\n", major_revision,
+				minor_revision, pcibios_entry);
+		}
+#endif
+	}
+}
+
+static void pcibios_init(void)
+{
+	union bios32 *check;
+	unsigned char sum;
+	int i, length;
+	unsigned long bios32_entry = 0;
+
+	EnterFunction("pcibios_init");
+	/*
+	 * Follow the standard procedure for locating the BIOS32 Service
+	 * directory by scanning the permissible address range from
+	 * 0xe0000 through 0xfffff for a valid BIOS32 structure.
+	 *
+	 */
+
+	for (check = (union bios32 *) 0xe0000; check <= (union bios32 *) 0xffff0; ++check) {
+		if (check->fields.signature != BIOS32_SIGNATURE)
+			continue;
+		length = check->fields.length * 16;
+		if (!length)
+			continue;
+		sum = 0;
+		for (i = 0; i < length ; ++i)
+			sum += check->chars[i];
+		if (sum != 0)
+			continue;
+		if (check->fields.revision != 0) {
+			printf("pcibios_init : unsupported revision %d at %#X, mail drew@colorado.edu\n",
+				check->fields.revision, check);
+			continue;
+		}
+#if	DEBUG
+		printf("pcibios_init : BIOS32 Service Directory "
+			"structure at %#X\n", check);
+#endif
+		if (!bios32_entry) {
+			if (check->fields.entry >= 0x100000) {
+				printf("pcibios_init: entry in high "
+					"memory, giving up\n");
+				return;
+			} else {
+				bios32_entry = check->fields.entry;
+#if	DEBUG
+				printf("pcibios_init : BIOS32 Service Directory"
+					" entry at %#X\n", bios32_entry);
+#endif
+				bios32_indirect.address = bios32_entry;
+			}
+		}
+	}
+	if (bios32_entry)
+		check_pcibios();
+	LeaveFunction("pcibios_init");
+}
+
+#endif	/* CONFIG_PCI_DIRECT not defined*/
+
+unsigned long pcibios_bus_base(unsigned int bus __unused)
+{
+	/* architecturally this must be 0 */
+	return 0;
+}
+
+void find_pci(int type, struct pci_device *dev)
+{
+	EnterFunction("find_pci");
+#ifndef	CONFIG_PCI_DIRECT
+	if (!pcibios_entry) {
+		pcibios_init();
+	}
+	if (!pcibios_entry) {
+		printf("pci_init: no BIOS32 detected\n");
+		return;
+	}
+#endif
+	LeaveFunction("find_pci");
+	return scan_pci_bus(type, dev);
+}
Index: netboot/tg3.h
===================================================================
--- netboot/tg3.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/tg3.h	(.../trunk)	(revision 112)
@@ -0,0 +1,2203 @@
+/* $Id$
+ * tg3.h: Definitions for Broadcom Tigon3 ethernet driver.
+ *
+ * Copyright (C) 2001, 2002 David S. Miller (davem@redhat.com)
+ * Copyright (C) 2001 Jeff Garzik (jgarzik@mandrakesoft.com)
+ */
+
+#ifndef _T3_H
+#define _T3_H
+
+#include "stdint.h"
+
+typedef unsigned long dma_addr_t;
+
+/* From mii.h */
+
+/* Indicates what features are advertised by the interface. */
+#define ADVERTISED_10baseT_Half		(1 << 0)
+#define ADVERTISED_10baseT_Full		(1 << 1)
+#define ADVERTISED_100baseT_Half	(1 << 2)
+#define ADVERTISED_100baseT_Full	(1 << 3)
+#define ADVERTISED_1000baseT_Half	(1 << 4)
+#define ADVERTISED_1000baseT_Full	(1 << 5)
+#define ADVERTISED_Autoneg		(1 << 6)
+#define ADVERTISED_TP			(1 << 7)
+#define ADVERTISED_AUI			(1 << 8)
+#define ADVERTISED_MII			(1 << 9)
+#define ADVERTISED_FIBRE		(1 << 10)
+#define ADVERTISED_BNC			(1 << 11)
+
+/* The following are all involved in forcing a particular link
+ * mode for the device for setting things.  When getting the
+ * devices settings, these indicate the current mode and whether
+ * it was foced up into this mode or autonegotiated.
+ */
+
+/* The forced speed, 10Mb, 100Mb, gigabit. */
+#define SPEED_10		0
+#define SPEED_100		1
+#define SPEED_1000		2
+#define SPEED_INVALID           3
+
+
+/* Duplex, half or full. */
+#define DUPLEX_HALF		0x00
+#define DUPLEX_FULL		0x01
+#define DUPLEX_INVALID          0x02
+
+/* Which connector port. */
+#define PORT_TP			0x00
+#define PORT_AUI		0x01
+#define PORT_MII		0x02
+#define PORT_FIBRE		0x03
+#define PORT_BNC		0x04
+
+/* Which tranceiver to use. */
+#define XCVR_INTERNAL		0x00
+#define XCVR_EXTERNAL		0x01
+#define XCVR_DUMMY1		0x02
+#define XCVR_DUMMY2		0x03
+#define XCVR_DUMMY3		0x04
+
+/* Enable or disable autonegotiation.  If this is set to enable,
+ * the forced link modes above are completely ignored.
+ */
+#define AUTONEG_DISABLE		0x00
+#define AUTONEG_ENABLE		0x01
+
+/* Wake-On-Lan options. */
+#define WAKE_PHY		(1 << 0)
+#define WAKE_UCAST		(1 << 1)
+#define WAKE_MCAST		(1 << 2)
+#define WAKE_BCAST		(1 << 3)
+#define WAKE_ARP		(1 << 4)
+#define WAKE_MAGIC		(1 << 5)
+#define WAKE_MAGICSECURE	(1 << 6) /* only meaningful if WAKE_MAGIC */
+
+/* Generic MII registers. */
+
+#define MII_BMCR            0x00        /* Basic mode control register */
+#define MII_BMSR            0x01        /* Basic mode status register  */
+#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+#define MII_ADVERTISE       0x04        /* Advertisement control reg   */
+#define MII_LPA             0x05        /* Link partner ability reg    */
+#define MII_EXPANSION       0x06        /* Expansion register          */
+#define MII_DCOUNTER        0x12        /* Disconnect counter          */
+#define MII_FCSCOUNTER      0x13        /* False carrier counter       */
+#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER     0x15        /* Receive error counter       */
+#define MII_SREVISION       0x16        /* Silicon revision            */
+#define MII_RESV1           0x17        /* Reserved...                 */
+#define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
+#define MII_PHYADDR         0x19        /* PHY address                 */
+#define MII_RESV2           0x1a        /* Reserved...                 */
+#define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
+#define MII_NCONFIG         0x1c        /* Network interface config    */
+
+/* Basic mode control register. */
+#define BMCR_RESV               0x007f  /* Unused...                   */
+#define BMCR_CTST               0x0080  /* Collision test              */
+#define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
+#define BMCR_RESET              0x8000  /* Reset the DP83840           */
+
+/* Basic mode status register. */
+#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+#define BMSR_JCD                0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS            0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT             0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV               0x07c0  /* Unused...                   */
+#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register. */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_RESV          0x1c00  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
+			ADVERTISE_CSMA)
+#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                       ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register. */
+#define LPA_SLCT                0x001f  /* Same as advertise selector  */
+#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
+#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
+#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
+#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
+#define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
+#define LPA_RESV                0x1c00  /* Unused...                   */
+#define LPA_RFAULT              0x2000  /* Link partner faulted        */
+#define LPA_LPACK               0x4000  /* Link partner acked us       */
+#define LPA_NPAGE               0x8000  /* Next page bit               */
+
+#define LPA_DUPLEX		(LPA_10FULL | LPA_100FULL)
+#define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+/* Expansion register for auto-negotiation. */
+#define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
+#define EXPANSION_LCWP          0x0002  /* Got new RX page code word   */
+#define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
+#define EXPANSION_NPCAPABLE     0x0008  /* Link partner supports npage */
+#define EXPANSION_MFAULTS       0x0010  /* Multiple faults detected    */
+#define EXPANSION_RESV          0xffe0  /* Unused...                   */
+
+/* N-way test register. */
+#define NWAYTEST_RESV1          0x00ff  /* Unused...                   */
+#define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
+#define NWAYTEST_RESV2          0xfe00  /* Unused...                   */
+
+
+/* From tg3.h */
+
+#define TG3_64BIT_REG_HIGH		0x00UL
+#define TG3_64BIT_REG_LOW		0x04UL
+
+/* Descriptor block info. */
+#define TG3_BDINFO_HOST_ADDR		0x0UL /* 64-bit */
+#define TG3_BDINFO_MAXLEN_FLAGS		0x8UL /* 32-bit */
+#define  BDINFO_FLAGS_USE_EXT_RECV	 0x00000001 /* ext rx_buffer_desc */
+#define  BDINFO_FLAGS_DISABLED		 0x00000002
+#define  BDINFO_FLAGS_MAXLEN_MASK	 0xffff0000
+#define  BDINFO_FLAGS_MAXLEN_SHIFT	 16
+#define TG3_BDINFO_NIC_ADDR		0xcUL /* 32-bit */
+#define TG3_BDINFO_SIZE			0x10UL
+
+#define RX_COPY_THRESHOLD  		256
+
+#define RX_STD_MAX_SIZE			1536
+#define RX_STD_MAX_SIZE_5705		512
+#define RX_JUMBO_MAX_SIZE		0xdeadbeef /* XXX */
+
+/* First 256 bytes are a mirror of PCI config space. */
+#define TG3PCI_VENDOR			0x00000000
+#define  TG3PCI_VENDOR_BROADCOM		 0x14e4
+#define TG3PCI_DEVICE			0x00000002
+#define  TG3PCI_DEVICE_TIGON3_1		 0x1644 /* BCM5700 */
+#define  TG3PCI_DEVICE_TIGON3_2		 0x1645 /* BCM5701 */
+#define  TG3PCI_DEVICE_TIGON3_3		 0x1646 /* BCM5702 */
+#define  TG3PCI_DEVICE_TIGON3_4		 0x1647 /* BCM5703 */
+#define TG3PCI_COMMAND			0x00000004
+#define TG3PCI_STATUS			0x00000006
+#define TG3PCI_CCREVID			0x00000008
+#define TG3PCI_CACHELINESZ		0x0000000c
+#define TG3PCI_LATTIMER			0x0000000d
+#define TG3PCI_HEADERTYPE		0x0000000e
+#define TG3PCI_BIST			0x0000000f
+#define TG3PCI_BASE0_LOW		0x00000010
+#define TG3PCI_BASE0_HIGH		0x00000014
+/* 0x18 --> 0x2c unused */
+#define TG3PCI_SUBSYSVENID		0x0000002c
+#define TG3PCI_SUBSYSID			0x0000002e
+#define TG3PCI_ROMADDR			0x00000030
+#define TG3PCI_CAPLIST			0x00000034
+/* 0x35 --> 0x3c unused */
+#define TG3PCI_IRQ_LINE			0x0000003c
+#define TG3PCI_IRQ_PIN			0x0000003d
+#define TG3PCI_MIN_GNT			0x0000003e
+#define TG3PCI_MAX_LAT			0x0000003f
+#define TG3PCI_X_CAPS			0x00000040
+#define  PCIX_CAPS_RELAXED_ORDERING	 0x00020000
+#define  PCIX_CAPS_SPLIT_MASK		 0x00700000
+#define  PCIX_CAPS_SPLIT_SHIFT		 20
+#define  PCIX_CAPS_BURST_MASK		 0x000c0000
+#define  PCIX_CAPS_BURST_SHIFT		 18
+#define  PCIX_CAPS_MAX_BURST_CPIOB	 2
+#define TG3PCI_PM_CAP_PTR		0x00000041
+#define TG3PCI_X_COMMAND		0x00000042
+#define TG3PCI_X_STATUS			0x00000044
+#define TG3PCI_PM_CAP_ID		0x00000048
+#define TG3PCI_VPD_CAP_PTR		0x00000049
+#define TG3PCI_PM_CAPS			0x0000004a
+#define TG3PCI_PM_CTRL_STAT		0x0000004c
+#define TG3PCI_BR_SUPP_EXT		0x0000004e
+#define TG3PCI_PM_DATA			0x0000004f
+#define TG3PCI_VPD_CAP_ID		0x00000050
+#define TG3PCI_MSI_CAP_PTR		0x00000051
+#define TG3PCI_VPD_ADDR_FLAG		0x00000052
+#define  VPD_ADDR_FLAG_WRITE		0x00008000
+#define TG3PCI_VPD_DATA			0x00000054
+#define TG3PCI_MSI_CAP_ID		0x00000058
+#define TG3PCI_NXT_CAP_PTR		0x00000059
+#define TG3PCI_MSI_CTRL			0x0000005a
+#define TG3PCI_MSI_ADDR_LOW		0x0000005c
+#define TG3PCI_MSI_ADDR_HIGH		0x00000060
+#define TG3PCI_MSI_DATA			0x00000064
+/* 0x66 --> 0x68 unused */
+#define TG3PCI_MISC_HOST_CTRL		0x00000068
+#define  MISC_HOST_CTRL_CLEAR_INT	 0x00000001
+#define  MISC_HOST_CTRL_MASK_PCI_INT	 0x00000002
+#define  MISC_HOST_CTRL_BYTE_SWAP	 0x00000004
+#define  MISC_HOST_CTRL_WORD_SWAP	 0x00000008
+#define  MISC_HOST_CTRL_PCISTATE_RW	 0x00000010
+#define  MISC_HOST_CTRL_CLKREG_RW	 0x00000020
+#define  MISC_HOST_CTRL_REGWORD_SWAP	 0x00000040
+#define  MISC_HOST_CTRL_INDIR_ACCESS	 0x00000080
+#define  MISC_HOST_CTRL_IRQ_MASK_MODE	 0x00000100
+#define  MISC_HOST_CTRL_TAGGED_STATUS	 0x00000200
+#define  MISC_HOST_CTRL_CHIPREV		 0xffff0000
+#define  MISC_HOST_CTRL_CHIPREV_SHIFT	 16
+#define  GET_CHIP_REV_ID(MISC_HOST_CTRL) \
+	 (((MISC_HOST_CTRL) & MISC_HOST_CTRL_CHIPREV) >> \
+	  MISC_HOST_CTRL_CHIPREV_SHIFT)
+#define  CHIPREV_ID_5700_A0		 0x7000
+#define  CHIPREV_ID_5700_A1		 0x7001
+#define  CHIPREV_ID_5700_B0		 0x7100
+#define  CHIPREV_ID_5700_B1		 0x7101
+#define  CHIPREV_ID_5700_B3		 0x7102
+#define  CHIPREV_ID_5700_ALTIMA		 0x7104
+#define  CHIPREV_ID_5700_C0		 0x7200
+#define  CHIPREV_ID_5701_A0		 0x0000
+#define  CHIPREV_ID_5701_B0		 0x0100
+#define  CHIPREV_ID_5701_B2		 0x0102
+#define  CHIPREV_ID_5701_B5		 0x0105
+#define  CHIPREV_ID_5703_A0		 0x1000
+#define  CHIPREV_ID_5703_A1		 0x1001
+#define  CHIPREV_ID_5703_A2		 0x1002
+#define  CHIPREV_ID_5703_A3		 0x1003
+#define  CHIPREV_ID_5704_A0		 0x2000
+#define  CHIPREV_ID_5704_A1		 0x2001
+#define  CHIPREV_ID_5704_A2		 0x2002
+#define  CHIPREV_ID_5705_A0		 0x3000
+#define  CHIPREV_ID_5705_A1		 0x3001
+#define	 CHIPREV_ID_5705_A2              0x3002
+#define  CHIPREV_ID_5705_A3              0x3003
+#define  GET_ASIC_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 12)
+#define   ASIC_REV_5700			 0x07
+#define   ASIC_REV_5701			 0x00
+#define   ASIC_REV_5703			 0x01
+#define   ASIC_REV_5704			 0x02
+#define   ASIC_REV_5705			 0x03
+#define  GET_CHIP_REV(CHIP_REV_ID)	((CHIP_REV_ID) >> 8)
+#define   CHIPREV_5700_AX		 0x70
+#define   CHIPREV_5700_BX		 0x71
+#define   CHIPREV_5700_CX		 0x72
+#define   CHIPREV_5701_AX		 0x00
+#define  GET_METAL_REV(CHIP_REV_ID)	((CHIP_REV_ID) & 0xff)
+#define   METAL_REV_A0			 0x00
+#define   METAL_REV_A1			 0x01
+#define   METAL_REV_B0			 0x00
+#define   METAL_REV_B1			 0x01
+#define   METAL_REV_B2			 0x02
+#define TG3PCI_DMA_RW_CTRL		0x0000006c
+#define  DMA_RWCTRL_MIN_DMA		 0x000000ff
+#define  DMA_RWCTRL_MIN_DMA_SHIFT	 0
+#define  DMA_RWCTRL_READ_BNDRY_MASK	 0x00000700
+#define  DMA_RWCTRL_READ_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_READ_BNDRY_16	 0x00000100
+#define  DMA_RWCTRL_READ_BNDRY_32	 0x00000200
+#define  DMA_RWCTRL_READ_BNDRY_64	 0x00000300
+#define  DMA_RWCTRL_READ_BNDRY_128	 0x00000400
+#define  DMA_RWCTRL_READ_BNDRY_256	 0x00000500
+#define  DMA_RWCTRL_READ_BNDRY_512	 0x00000600
+#define  DMA_RWCTRL_READ_BNDRY_1024	 0x00000700
+#define  DMA_RWCTRL_WRITE_BNDRY_MASK	 0x00003800
+#define  DMA_RWCTRL_WRITE_BNDRY_DISAB	 0x00000000
+#define  DMA_RWCTRL_WRITE_BNDRY_16	 0x00000800
+#define  DMA_RWCTRL_WRITE_BNDRY_32	 0x00001000
+#define  DMA_RWCTRL_WRITE_BNDRY_64	 0x00001800
+#define  DMA_RWCTRL_WRITE_BNDRY_128	 0x00002000
+#define  DMA_RWCTRL_WRITE_BNDRY_256	 0x00002800
+#define  DMA_RWCTRL_WRITE_BNDRY_512	 0x00003000
+#define  DMA_RWCTRL_WRITE_BNDRY_1024	 0x00003800
+#define  DMA_RWCTRL_ONE_DMA		 0x00004000
+#define  DMA_RWCTRL_READ_WATER		 0x00070000
+#define  DMA_RWCTRL_READ_WATER_SHIFT	 16
+#define  DMA_RWCTRL_WRITE_WATER		 0x00380000
+#define  DMA_RWCTRL_WRITE_WATER_SHIFT	 19
+#define  DMA_RWCTRL_USE_MEM_READ_MULT	 0x00400000
+#define  DMA_RWCTRL_ASSERT_ALL_BE	 0x00800000
+#define  DMA_RWCTRL_PCI_READ_CMD	 0x0f000000
+#define  DMA_RWCTRL_PCI_READ_CMD_SHIFT	 24
+#define  DMA_RWCTRL_PCI_WRITE_CMD	 0xf0000000
+#define  DMA_RWCTRL_PCI_WRITE_CMD_SHIFT	 28
+#define TG3PCI_PCISTATE			0x00000070
+#define  PCISTATE_FORCE_RESET		 0x00000001
+#define  PCISTATE_INT_NOT_ACTIVE	 0x00000002
+#define  PCISTATE_CONV_PCI_MODE		 0x00000004
+#define  PCISTATE_BUS_SPEED_HIGH	 0x00000008
+#define  PCISTATE_BUS_32BIT		 0x00000010
+#define  PCISTATE_ROM_ENABLE		 0x00000020
+#define  PCISTATE_ROM_RETRY_ENABLE	 0x00000040
+#define  PCISTATE_FLAT_VIEW		 0x00000100
+#define  PCISTATE_RETRY_SAME_DMA	 0x00002000
+#define TG3PCI_CLOCK_CTRL		0x00000074
+#define  CLOCK_CTRL_CORECLK_DISABLE	 0x00000200
+#define  CLOCK_CTRL_RXCLK_DISABLE	 0x00000400
+#define  CLOCK_CTRL_TXCLK_DISABLE	 0x00000800
+#define  CLOCK_CTRL_ALTCLK		 0x00001000
+#define  CLOCK_CTRL_PWRDOWN_PLL133	 0x00008000
+#define  CLOCK_CTRL_44MHZ_CORE		 0x00040000
+#define  CLOCK_CTRL_625_CORE		 0x00100000
+#define  CLOCK_CTRL_FORCE_CLKRUN	 0x00200000
+#define  CLOCK_CTRL_CLKRUN_OENABLE	 0x00400000
+#define  CLOCK_CTRL_DELAY_PCI_GRANT	 0x80000000
+#define TG3PCI_REG_BASE_ADDR		0x00000078
+#define TG3PCI_MEM_WIN_BASE_ADDR	0x0000007c
+#define TG3PCI_REG_DATA			0x00000080
+#define TG3PCI_MEM_WIN_DATA		0x00000084
+#define TG3PCI_MODE_CTRL		0x00000088
+#define TG3PCI_MISC_CFG			0x0000008c
+#define TG3PCI_MISC_LOCAL_CTRL		0x00000090
+/* 0x94 --> 0x98 unused */
+#define TG3PCI_STD_RING_PROD_IDX	0x00000098 /* 64-bit */
+#define TG3PCI_RCV_RET_RING_CON_IDX	0x000000a0 /* 64-bit */
+#define TG3PCI_SND_PROD_IDX		0x000000a8 /* 64-bit */
+/* 0xb0 --> 0x100 unused */
+
+/* 0x100 --> 0x200 unused */
+
+/* Mailbox registers */
+#define MAILBOX_INTERRUPT_0		0x00000200 /* 64-bit */
+#define MAILBOX_INTERRUPT_1		0x00000208 /* 64-bit */
+#define MAILBOX_INTERRUPT_2		0x00000210 /* 64-bit */
+#define MAILBOX_INTERRUPT_3		0x00000218 /* 64-bit */
+#define MAILBOX_GENERAL_0		0x00000220 /* 64-bit */
+#define MAILBOX_GENERAL_1		0x00000228 /* 64-bit */
+#define MAILBOX_GENERAL_2		0x00000230 /* 64-bit */
+#define MAILBOX_GENERAL_3		0x00000238 /* 64-bit */
+#define MAILBOX_GENERAL_4		0x00000240 /* 64-bit */
+#define MAILBOX_GENERAL_5		0x00000248 /* 64-bit */
+#define MAILBOX_GENERAL_6		0x00000250 /* 64-bit */
+#define MAILBOX_GENERAL_7		0x00000258 /* 64-bit */
+#define MAILBOX_RELOAD_STAT		0x00000260 /* 64-bit */
+#define MAILBOX_RCV_STD_PROD_IDX	0x00000268 /* 64-bit */
+#define MAILBOX_RCV_JUMBO_PROD_IDX	0x00000270 /* 64-bit */
+#define MAILBOX_RCV_MINI_PROD_IDX	0x00000278 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_0	0x00000280 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_1	0x00000288 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_2	0x00000290 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_3	0x00000298 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_4	0x000002a0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_5	0x000002a8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_6	0x000002b0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_7	0x000002b8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_8	0x000002c0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_9	0x000002c8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_10	0x000002d0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_11	0x000002d8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_12	0x000002e0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_13	0x000002e8 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_14	0x000002f0 /* 64-bit */
+#define MAILBOX_RCVRET_CON_IDX_15	0x000002f8 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_0	0x00000300 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_1	0x00000308 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_2	0x00000310 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_3	0x00000318 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_4	0x00000320 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_5	0x00000328 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_6	0x00000330 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_7	0x00000338 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_8	0x00000340 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_9	0x00000348 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_10	0x00000350 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_11	0x00000358 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_12	0x00000360 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_13	0x00000368 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_14	0x00000370 /* 64-bit */
+#define MAILBOX_SNDHOST_PROD_IDX_15	0x00000378 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_0	0x00000380 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_1	0x00000388 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_2	0x00000390 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_3	0x00000398 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_4	0x000003a0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_5	0x000003a8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_6	0x000003b0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_7	0x000003b8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_8	0x000003c0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_9	0x000003c8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_10	0x000003d0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_11	0x000003d8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_12	0x000003e0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_13	0x000003e8 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_14	0x000003f0 /* 64-bit */
+#define MAILBOX_SNDNIC_PROD_IDX_15	0x000003f8 /* 64-bit */
+
+/* MAC control registers */
+#define MAC_MODE			0x00000400
+#define  MAC_MODE_RESET			 0x00000001
+#define  MAC_MODE_HALF_DUPLEX		 0x00000002
+#define  MAC_MODE_PORT_MODE_MASK	 0x0000000c
+#define  MAC_MODE_PORT_MODE_TBI		 0x0000000c
+#define  MAC_MODE_PORT_MODE_GMII	 0x00000008
+#define  MAC_MODE_PORT_MODE_MII		 0x00000004
+#define  MAC_MODE_PORT_MODE_NONE	 0x00000000
+#define  MAC_MODE_PORT_INT_LPBACK	 0x00000010
+#define  MAC_MODE_TAGGED_MAC_CTRL	 0x00000080
+#define  MAC_MODE_TX_BURSTING		 0x00000100
+#define  MAC_MODE_MAX_DEFER		 0x00000200
+#define  MAC_MODE_LINK_POLARITY		 0x00000400
+#define  MAC_MODE_RXSTAT_ENABLE		 0x00000800
+#define  MAC_MODE_RXSTAT_CLEAR		 0x00001000
+#define  MAC_MODE_RXSTAT_FLUSH		 0x00002000
+#define  MAC_MODE_TXSTAT_ENABLE		 0x00004000
+#define  MAC_MODE_TXSTAT_CLEAR		 0x00008000
+#define  MAC_MODE_TXSTAT_FLUSH		 0x00010000
+#define  MAC_MODE_SEND_CONFIGS		 0x00020000
+#define  MAC_MODE_MAGIC_PKT_ENABLE	 0x00040000
+#define  MAC_MODE_ACPI_ENABLE		 0x00080000
+#define  MAC_MODE_MIP_ENABLE		 0x00100000
+#define  MAC_MODE_TDE_ENABLE		 0x00200000
+#define  MAC_MODE_RDE_ENABLE		 0x00400000
+#define  MAC_MODE_FHDE_ENABLE		 0x00800000
+#define MAC_STATUS			0x00000404
+#define  MAC_STATUS_PCS_SYNCED		 0x00000001
+#define  MAC_STATUS_SIGNAL_DET		 0x00000002
+#define  MAC_STATUS_RCVD_CFG		 0x00000004
+#define  MAC_STATUS_CFG_CHANGED		 0x00000008
+#define  MAC_STATUS_SYNC_CHANGED	 0x00000010
+#define  MAC_STATUS_PORT_DEC_ERR	 0x00000400
+#define  MAC_STATUS_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_STATUS_MI_COMPLETION	 0x00400000
+#define  MAC_STATUS_MI_INTERRUPT	 0x00800000
+#define  MAC_STATUS_AP_ERROR		 0x01000000
+#define  MAC_STATUS_ODI_ERROR		 0x02000000
+#define  MAC_STATUS_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_STATUS_TXSTAT_OVERRUN	 0x08000000
+#define MAC_EVENT			0x00000408
+#define  MAC_EVENT_PORT_DECODE_ERR	 0x00000400
+#define  MAC_EVENT_LNKSTATE_CHANGED	 0x00001000
+#define  MAC_EVENT_MI_COMPLETION	 0x00400000
+#define  MAC_EVENT_MI_INTERRUPT		 0x00800000
+#define  MAC_EVENT_AP_ERROR		 0x01000000
+#define  MAC_EVENT_ODI_ERROR		 0x02000000
+#define  MAC_EVENT_RXSTAT_OVERRUN	 0x04000000
+#define  MAC_EVENT_TXSTAT_OVERRUN	 0x08000000
+#define MAC_LED_CTRL			0x0000040c
+#define  LED_CTRL_LNKLED_OVERRIDE	 0x00000001
+#define  LED_CTRL_1000MBPS_ON		 0x00000002
+#define  LED_CTRL_100MBPS_ON		 0x00000004
+#define  LED_CTRL_10MBPS_ON		 0x00000008
+#define  LED_CTRL_TRAFFIC_OVERRIDE	 0x00000010
+#define  LED_CTRL_TRAFFIC_BLINK		 0x00000020
+#define  LED_CTRL_TRAFFIC_LED		 0x00000040
+#define  LED_CTRL_1000MBPS_STATUS	 0x00000080
+#define  LED_CTRL_100MBPS_STATUS	 0x00000100
+#define  LED_CTRL_10MBPS_STATUS		 0x00000200
+#define  LED_CTRL_TRAFFIC_STATUS	 0x00000400
+#define  LED_CTRL_MAC_MODE		 0x00000000
+#define  LED_CTRL_PHY_MODE_1		 0x00000800
+#define  LED_CTRL_PHY_MODE_2		 0x00001000
+#define  LED_CTRL_BLINK_RATE_MASK	 0x7ff80000
+#define  LED_CTRL_BLINK_RATE_SHIFT	 19
+#define  LED_CTRL_BLINK_PER_OVERRIDE	 0x00080000
+#define  LED_CTRL_BLINK_RATE_OVERRIDE	 0x80000000
+#define MAC_ADDR_0_HIGH			0x00000410 /* upper 2 bytes */
+#define MAC_ADDR_0_LOW			0x00000414 /* lower 4 bytes */
+#define MAC_ADDR_1_HIGH			0x00000418 /* upper 2 bytes */
+#define MAC_ADDR_1_LOW			0x0000041c /* lower 4 bytes */
+#define MAC_ADDR_2_HIGH			0x00000420 /* upper 2 bytes */
+#define MAC_ADDR_2_LOW			0x00000424 /* lower 4 bytes */
+#define MAC_ADDR_3_HIGH			0x00000428 /* upper 2 bytes */
+#define MAC_ADDR_3_LOW			0x0000042c /* lower 4 bytes */
+#define MAC_ACPI_MBUF_PTR		0x00000430
+#define MAC_ACPI_LEN_OFFSET		0x00000434
+#define  ACPI_LENOFF_LEN_MASK		 0x0000ffff
+#define  ACPI_LENOFF_LEN_SHIFT		 0
+#define  ACPI_LENOFF_OFF_MASK		 0x0fff0000
+#define  ACPI_LENOFF_OFF_SHIFT		 16
+#define MAC_TX_BACKOFF_SEED		0x00000438
+#define  TX_BACKOFF_SEED_MASK		 0x000003ff
+#define MAC_RX_MTU_SIZE			0x0000043c
+#define  RX_MTU_SIZE_MASK		 0x0000ffff
+#define MAC_PCS_TEST			0x00000440
+#define  PCS_TEST_PATTERN_MASK		 0x000fffff
+#define  PCS_TEST_PATTERN_SHIFT		 0
+#define  PCS_TEST_ENABLE		 0x00100000
+#define MAC_TX_AUTO_NEG			0x00000444
+#define  TX_AUTO_NEG_MASK		 0x0000ffff
+#define  TX_AUTO_NEG_SHIFT		 0
+#define MAC_RX_AUTO_NEG			0x00000448
+#define  RX_AUTO_NEG_MASK		 0x0000ffff
+#define  RX_AUTO_NEG_SHIFT		 0
+#define MAC_MI_COM			0x0000044c
+#define  MI_COM_CMD_MASK		 0x0c000000
+#define  MI_COM_CMD_WRITE		 0x04000000
+#define  MI_COM_CMD_READ		 0x08000000
+#define  MI_COM_READ_FAILED		 0x10000000
+#define  MI_COM_START			 0x20000000
+#define  MI_COM_BUSY			 0x20000000
+#define  MI_COM_PHY_ADDR_MASK		 0x03e00000
+#define  MI_COM_PHY_ADDR_SHIFT		 21
+#define  MI_COM_REG_ADDR_MASK		 0x001f0000
+#define  MI_COM_REG_ADDR_SHIFT		 16
+#define  MI_COM_DATA_MASK		 0x0000ffff
+#define MAC_MI_STAT			0x00000450
+#define  MAC_MI_STAT_LNKSTAT_ATTN_ENAB	 0x00000001
+#define MAC_MI_MODE			0x00000454
+#define  MAC_MI_MODE_CLK_10MHZ		 0x00000001
+#define  MAC_MI_MODE_SHORT_PREAMBLE	 0x00000002
+#define  MAC_MI_MODE_AUTO_POLL		 0x00000010
+#define  MAC_MI_MODE_CORE_CLK_62MHZ	 0x00008000
+#define  MAC_MI_MODE_BASE		 0x000c0000 /* XXX magic values XXX */
+#define MAC_AUTO_POLL_STATUS		0x00000458
+#define  MAC_AUTO_POLL_ERROR		 0x00000001
+#define MAC_TX_MODE			0x0000045c
+#define  TX_MODE_RESET			 0x00000001
+#define  TX_MODE_ENABLE			 0x00000002
+#define  TX_MODE_FLOW_CTRL_ENABLE	 0x00000010
+#define  TX_MODE_BIG_BCKOFF_ENABLE	 0x00000020
+#define  TX_MODE_LONG_PAUSE_ENABLE	 0x00000040
+#define MAC_TX_STATUS			0x00000460
+#define  TX_STATUS_XOFFED		 0x00000001
+#define  TX_STATUS_SENT_XOFF		 0x00000002
+#define  TX_STATUS_SENT_XON		 0x00000004
+#define  TX_STATUS_LINK_UP		 0x00000008
+#define  TX_STATUS_ODI_UNDERRUN		 0x00000010
+#define  TX_STATUS_ODI_OVERRUN		 0x00000020
+#define MAC_TX_LENGTHS			0x00000464
+#define  TX_LENGTHS_SLOT_TIME_MASK	 0x000000ff
+#define  TX_LENGTHS_SLOT_TIME_SHIFT	 0
+#define  TX_LENGTHS_IPG_MASK		 0x00000f00
+#define  TX_LENGTHS_IPG_SHIFT		 8
+#define  TX_LENGTHS_IPG_CRS_MASK	 0x00003000
+#define  TX_LENGTHS_IPG_CRS_SHIFT	 12
+#define MAC_RX_MODE			0x00000468
+#define  RX_MODE_RESET			 0x00000001
+#define  RX_MODE_ENABLE			 0x00000002
+#define  RX_MODE_FLOW_CTRL_ENABLE	 0x00000004
+#define  RX_MODE_KEEP_MAC_CTRL		 0x00000008
+#define  RX_MODE_KEEP_PAUSE		 0x00000010
+#define  RX_MODE_ACCEPT_OVERSIZED	 0x00000020
+#define  RX_MODE_ACCEPT_RUNTS		 0x00000040
+#define  RX_MODE_LEN_CHECK		 0x00000080
+#define  RX_MODE_PROMISC		 0x00000100
+#define  RX_MODE_NO_CRC_CHECK		 0x00000200
+#define  RX_MODE_KEEP_VLAN_TAG		 0x00000400
+#define MAC_RX_STATUS			0x0000046c
+#define  RX_STATUS_REMOTE_TX_XOFFED	 0x00000001
+#define  RX_STATUS_XOFF_RCVD		 0x00000002
+#define  RX_STATUS_XON_RCVD		 0x00000004
+#define MAC_HASH_REG_0			0x00000470
+#define MAC_HASH_REG_1			0x00000474
+#define MAC_HASH_REG_2			0x00000478
+#define MAC_HASH_REG_3			0x0000047c
+#define MAC_RCV_RULE_0			0x00000480
+#define MAC_RCV_VALUE_0			0x00000484
+#define MAC_RCV_RULE_1			0x00000488
+#define MAC_RCV_VALUE_1			0x0000048c
+#define MAC_RCV_RULE_2			0x00000490
+#define MAC_RCV_VALUE_2			0x00000494
+#define MAC_RCV_RULE_3			0x00000498
+#define MAC_RCV_VALUE_3			0x0000049c
+#define MAC_RCV_RULE_4			0x000004a0
+#define MAC_RCV_VALUE_4			0x000004a4
+#define MAC_RCV_RULE_5			0x000004a8
+#define MAC_RCV_VALUE_5			0x000004ac
+#define MAC_RCV_RULE_6			0x000004b0
+#define MAC_RCV_VALUE_6			0x000004b4
+#define MAC_RCV_RULE_7			0x000004b8
+#define MAC_RCV_VALUE_7			0x000004bc
+#define MAC_RCV_RULE_8			0x000004c0
+#define MAC_RCV_VALUE_8			0x000004c4
+#define MAC_RCV_RULE_9			0x000004c8
+#define MAC_RCV_VALUE_9			0x000004cc
+#define MAC_RCV_RULE_10			0x000004d0
+#define MAC_RCV_VALUE_10		0x000004d4
+#define MAC_RCV_RULE_11			0x000004d8
+#define MAC_RCV_VALUE_11		0x000004dc
+#define MAC_RCV_RULE_12			0x000004e0
+#define MAC_RCV_VALUE_12		0x000004e4
+#define MAC_RCV_RULE_13			0x000004e8
+#define MAC_RCV_VALUE_13		0x000004ec
+#define MAC_RCV_RULE_14			0x000004f0
+#define MAC_RCV_VALUE_14		0x000004f4
+#define MAC_RCV_RULE_15			0x000004f8
+#define MAC_RCV_VALUE_15		0x000004fc
+#define  RCV_RULE_DISABLE_MASK		 0x7fffffff
+#define MAC_RCV_RULE_CFG		0x00000500
+#define  RCV_RULE_CFG_DEFAULT_CLASS	0x00000008
+#define MAC_LOW_WMARK_MAX_RX_FRAME	0x00000504
+/* 0x508 --> 0x520 unused */
+#define MAC_HASHREGU_0			0x00000520
+#define MAC_HASHREGU_1			0x00000524
+#define MAC_HASHREGU_2			0x00000528
+#define MAC_HASHREGU_3			0x0000052c
+#define MAC_EXTADDR_0_HIGH		0x00000530
+#define MAC_EXTADDR_0_LOW		0x00000534
+#define MAC_EXTADDR_1_HIGH		0x00000538
+#define MAC_EXTADDR_1_LOW		0x0000053c
+#define MAC_EXTADDR_2_HIGH		0x00000540
+#define MAC_EXTADDR_2_LOW		0x00000544
+#define MAC_EXTADDR_3_HIGH		0x00000548
+#define MAC_EXTADDR_3_LOW		0x0000054c
+#define MAC_EXTADDR_4_HIGH		0x00000550
+#define MAC_EXTADDR_4_LOW		0x00000554
+#define MAC_EXTADDR_5_HIGH		0x00000558
+#define MAC_EXTADDR_5_LOW		0x0000055c
+#define MAC_EXTADDR_6_HIGH		0x00000560
+#define MAC_EXTADDR_6_LOW		0x00000564
+#define MAC_EXTADDR_7_HIGH		0x00000568
+#define MAC_EXTADDR_7_LOW		0x0000056c
+#define MAC_EXTADDR_8_HIGH		0x00000570
+#define MAC_EXTADDR_8_LOW		0x00000574
+#define MAC_EXTADDR_9_HIGH		0x00000578
+#define MAC_EXTADDR_9_LOW		0x0000057c
+#define MAC_EXTADDR_10_HIGH		0x00000580
+#define MAC_EXTADDR_10_LOW		0x00000584
+#define MAC_EXTADDR_11_HIGH		0x00000588
+#define MAC_EXTADDR_11_LOW		0x0000058c
+#define MAC_SERDES_CFG			0x00000590
+#define MAC_SERDES_STAT			0x00000594
+/* 0x598 --> 0x600 unused */
+#define MAC_TX_MAC_STATE_BASE		0x00000600 /* 16 bytes */
+#define MAC_RX_MAC_STATE_BASE		0x00000610 /* 20 bytes */
+/* 0x624 --> 0x800 unused */
+#define MAC_TX_STATS_OCTETS		0x00000800
+#define MAC_TX_STATS_RESV1		0x00000804
+#define MAC_TX_STATS_COLLISIONS		0x00000808
+#define MAC_TX_STATS_XON_SENT		0x0000080c
+#define MAC_TX_STATS_XOFF_SENT		0x00000810
+#define MAC_TX_STATS_RESV2		0x00000814
+#define MAC_TX_STATS_MAC_ERRORS		0x00000818
+#define MAC_TX_STATS_SINGLE_COLLISIONS	0x0000081c
+#define MAC_TX_STATS_MULT_COLLISIONS	0x00000820
+#define MAC_TX_STATS_DEFERRED		0x00000824
+#define MAC_TX_STATS_RESV3		0x00000828
+#define MAC_TX_STATS_EXCESSIVE_COL	0x0000082c
+#define MAC_TX_STATS_LATE_COL		0x00000830
+#define MAC_TX_STATS_RESV4_1		0x00000834
+#define MAC_TX_STATS_RESV4_2		0x00000838
+#define MAC_TX_STATS_RESV4_3		0x0000083c
+#define MAC_TX_STATS_RESV4_4		0x00000840
+#define MAC_TX_STATS_RESV4_5		0x00000844
+#define MAC_TX_STATS_RESV4_6		0x00000848
+#define MAC_TX_STATS_RESV4_7		0x0000084c
+#define MAC_TX_STATS_RESV4_8		0x00000850
+#define MAC_TX_STATS_RESV4_9		0x00000854
+#define MAC_TX_STATS_RESV4_10		0x00000858
+#define MAC_TX_STATS_RESV4_11		0x0000085c
+#define MAC_TX_STATS_RESV4_12		0x00000860
+#define MAC_TX_STATS_RESV4_13		0x00000864
+#define MAC_TX_STATS_RESV4_14		0x00000868
+#define MAC_TX_STATS_UCAST		0x0000086c
+#define MAC_TX_STATS_MCAST		0x00000870
+#define MAC_TX_STATS_BCAST		0x00000874
+#define MAC_TX_STATS_RESV5_1		0x00000878
+#define MAC_TX_STATS_RESV5_2		0x0000087c
+#define MAC_RX_STATS_OCTETS		0x00000880
+#define MAC_RX_STATS_RESV1		0x00000884
+#define MAC_RX_STATS_FRAGMENTS		0x00000888
+#define MAC_RX_STATS_UCAST		0x0000088c
+#define MAC_RX_STATS_MCAST		0x00000890
+#define MAC_RX_STATS_BCAST		0x00000894
+#define MAC_RX_STATS_FCS_ERRORS		0x00000898
+#define MAC_RX_STATS_ALIGN_ERRORS	0x0000089c
+#define MAC_RX_STATS_XON_PAUSE_RECVD	0x000008a0
+#define MAC_RX_STATS_XOFF_PAUSE_RECVD	0x000008a4
+#define MAC_RX_STATS_MAC_CTRL_RECVD	0x000008a8
+#define MAC_RX_STATS_XOFF_ENTERED	0x000008ac
+#define MAC_RX_STATS_FRAME_TOO_LONG	0x000008b0
+#define MAC_RX_STATS_JABBERS		0x000008b4
+#define MAC_RX_STATS_UNDERSIZE		0x000008b8
+/* 0x8bc --> 0xc00 unused */
+
+/* Send data initiator control registers */
+#define SNDDATAI_MODE			0x00000c00
+#define  SNDDATAI_MODE_RESET		 0x00000001
+#define  SNDDATAI_MODE_ENABLE		 0x00000002
+#define  SNDDATAI_MODE_STAT_OFLOW_ENAB	 0x00000004
+#define SNDDATAI_STATUS			0x00000c04
+#define  SNDDATAI_STATUS_STAT_OFLOW	 0x00000004
+#define SNDDATAI_STATSCTRL		0x00000c08
+#define  SNDDATAI_SCTRL_ENABLE		 0x00000001
+#define  SNDDATAI_SCTRL_FASTUPD		 0x00000002
+#define  SNDDATAI_SCTRL_CLEAR		 0x00000004
+#define  SNDDATAI_SCTRL_FLUSH		 0x00000008
+#define  SNDDATAI_SCTRL_FORCE_ZERO	 0x00000010
+#define SNDDATAI_STATSENAB		0x00000c0c
+#define SNDDATAI_STATSINCMASK		0x00000c10
+/* 0xc14 --> 0xc80 unused */
+#define SNDDATAI_COS_CNT_0		0x00000c80
+#define SNDDATAI_COS_CNT_1		0x00000c84
+#define SNDDATAI_COS_CNT_2		0x00000c88
+#define SNDDATAI_COS_CNT_3		0x00000c8c
+#define SNDDATAI_COS_CNT_4		0x00000c90
+#define SNDDATAI_COS_CNT_5		0x00000c94
+#define SNDDATAI_COS_CNT_6		0x00000c98
+#define SNDDATAI_COS_CNT_7		0x00000c9c
+#define SNDDATAI_COS_CNT_8		0x00000ca0
+#define SNDDATAI_COS_CNT_9		0x00000ca4
+#define SNDDATAI_COS_CNT_10		0x00000ca8
+#define SNDDATAI_COS_CNT_11		0x00000cac
+#define SNDDATAI_COS_CNT_12		0x00000cb0
+#define SNDDATAI_COS_CNT_13		0x00000cb4
+#define SNDDATAI_COS_CNT_14		0x00000cb8
+#define SNDDATAI_COS_CNT_15		0x00000cbc
+#define SNDDATAI_DMA_RDQ_FULL_CNT	0x00000cc0
+#define SNDDATAI_DMA_PRIO_RDQ_FULL_CNT	0x00000cc4
+#define SNDDATAI_SDCQ_FULL_CNT		0x00000cc8
+#define SNDDATAI_NICRNG_SSND_PIDX_CNT	0x00000ccc
+#define SNDDATAI_STATS_UPDATED_CNT	0x00000cd0
+#define SNDDATAI_INTERRUPTS_CNT		0x00000cd4
+#define SNDDATAI_AVOID_INTERRUPTS_CNT	0x00000cd8
+#define SNDDATAI_SND_THRESH_HIT_CNT	0x00000cdc
+/* 0xce0 --> 0x1000 unused */
+
+/* Send data completion control registers */
+#define SNDDATAC_MODE			0x00001000
+#define  SNDDATAC_MODE_RESET		 0x00000001
+#define  SNDDATAC_MODE_ENABLE		 0x00000002
+/* 0x1004 --> 0x1400 unused */
+
+/* Send BD ring selector */
+#define SNDBDS_MODE			0x00001400
+#define  SNDBDS_MODE_RESET		 0x00000001
+#define  SNDBDS_MODE_ENABLE		 0x00000002
+#define  SNDBDS_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDS_STATUS			0x00001404
+#define  SNDBDS_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDS_HWDIAG			0x00001408
+/* 0x140c --> 0x1440 */
+#define SNDBDS_SEL_CON_IDX_0		0x00001440
+#define SNDBDS_SEL_CON_IDX_1		0x00001444
+#define SNDBDS_SEL_CON_IDX_2		0x00001448
+#define SNDBDS_SEL_CON_IDX_3		0x0000144c
+#define SNDBDS_SEL_CON_IDX_4		0x00001450
+#define SNDBDS_SEL_CON_IDX_5		0x00001454
+#define SNDBDS_SEL_CON_IDX_6		0x00001458
+#define SNDBDS_SEL_CON_IDX_7		0x0000145c
+#define SNDBDS_SEL_CON_IDX_8		0x00001460
+#define SNDBDS_SEL_CON_IDX_9		0x00001464
+#define SNDBDS_SEL_CON_IDX_10		0x00001468
+#define SNDBDS_SEL_CON_IDX_11		0x0000146c
+#define SNDBDS_SEL_CON_IDX_12		0x00001470
+#define SNDBDS_SEL_CON_IDX_13		0x00001474
+#define SNDBDS_SEL_CON_IDX_14		0x00001478
+#define SNDBDS_SEL_CON_IDX_15		0x0000147c
+/* 0x1480 --> 0x1800 unused */
+
+/* Send BD initiator control registers */
+#define SNDBDI_MODE			0x00001800
+#define  SNDBDI_MODE_RESET		 0x00000001
+#define  SNDBDI_MODE_ENABLE		 0x00000002
+#define  SNDBDI_MODE_ATTN_ENABLE	 0x00000004
+#define SNDBDI_STATUS			0x00001804
+#define  SNDBDI_STATUS_ERROR_ATTN	 0x00000004
+#define SNDBDI_IN_PROD_IDX_0		0x00001808
+#define SNDBDI_IN_PROD_IDX_1		0x0000180c
+#define SNDBDI_IN_PROD_IDX_2		0x00001810
+#define SNDBDI_IN_PROD_IDX_3		0x00001814
+#define SNDBDI_IN_PROD_IDX_4		0x00001818
+#define SNDBDI_IN_PROD_IDX_5		0x0000181c
+#define SNDBDI_IN_PROD_IDX_6		0x00001820
+#define SNDBDI_IN_PROD_IDX_7		0x00001824
+#define SNDBDI_IN_PROD_IDX_8		0x00001828
+#define SNDBDI_IN_PROD_IDX_9		0x0000182c
+#define SNDBDI_IN_PROD_IDX_10		0x00001830
+#define SNDBDI_IN_PROD_IDX_11		0x00001834
+#define SNDBDI_IN_PROD_IDX_12		0x00001838
+#define SNDBDI_IN_PROD_IDX_13		0x0000183c
+#define SNDBDI_IN_PROD_IDX_14		0x00001840
+#define SNDBDI_IN_PROD_IDX_15		0x00001844
+/* 0x1848 --> 0x1c00 unused */
+
+/* Send BD completion control registers */
+#define SNDBDC_MODE			0x00001c00
+#define SNDBDC_MODE_RESET		 0x00000001
+#define SNDBDC_MODE_ENABLE		 0x00000002
+#define SNDBDC_MODE_ATTN_ENABLE		 0x00000004
+/* 0x1c04 --> 0x2000 unused */
+
+/* Receive list placement control registers */
+#define RCVLPC_MODE			0x00002000
+#define  RCVLPC_MODE_RESET		 0x00000001
+#define  RCVLPC_MODE_ENABLE		 0x00000002
+#define  RCVLPC_MODE_CLASS0_ATTN_ENAB	 0x00000004
+#define  RCVLPC_MODE_MAPOOR_AATTN_ENAB	 0x00000008
+#define  RCVLPC_MODE_STAT_OFLOW_ENAB	 0x00000010
+#define RCVLPC_STATUS			0x00002004
+#define  RCVLPC_STATUS_CLASS0		 0x00000004
+#define  RCVLPC_STATUS_MAPOOR		 0x00000008
+#define  RCVLPC_STATUS_STAT_OFLOW	 0x00000010
+#define RCVLPC_LOCK			0x00002008
+#define  RCVLPC_LOCK_REQ_MASK		 0x0000ffff
+#define  RCVLPC_LOCK_REQ_SHIFT		 0
+#define  RCVLPC_LOCK_GRANT_MASK		 0xffff0000
+#define  RCVLPC_LOCK_GRANT_SHIFT	 16
+#define RCVLPC_NON_EMPTY_BITS		0x0000200c
+#define  RCVLPC_NON_EMPTY_BITS_MASK	 0x0000ffff
+#define RCVLPC_CONFIG			0x00002010
+#define RCVLPC_STATSCTRL		0x00002014
+#define  RCVLPC_STATSCTRL_ENABLE	 0x00000001
+#define  RCVLPC_STATSCTRL_FASTUPD	 0x00000002
+#define RCVLPC_STATS_ENABLE		0x00002018
+#define  RCVLPC_STATSENAB_LNGBRST_RFIX	 0x00400000
+#define RCVLPC_STATS_INCMASK		0x0000201c
+/* 0x2020 --> 0x2100 unused */
+#define RCVLPC_SELLST_BASE		0x00002100 /* 16 16-byte entries */
+#define  SELLST_TAIL			0x00000004
+#define  SELLST_CONT			0x00000008
+#define  SELLST_UNUSED			0x0000000c
+#define RCVLPC_COS_CNTL_BASE		0x00002200 /* 16 4-byte entries */
+#define RCVLPC_DROP_FILTER_CNT		0x00002240
+#define RCVLPC_DMA_WQ_FULL_CNT		0x00002244
+#define RCVLPC_DMA_HIPRIO_WQ_FULL_CNT	0x00002248
+#define RCVLPC_NO_RCV_BD_CNT		0x0000224c
+#define RCVLPC_IN_DISCARDS_CNT		0x00002250
+#define RCVLPC_IN_ERRORS_CNT		0x00002254
+#define RCVLPC_RCV_THRESH_HIT_CNT	0x00002258
+/* 0x225c --> 0x2400 unused */
+
+/* Receive Data and Receive BD Initiator Control */
+#define RCVDBDI_MODE			0x00002400
+#define  RCVDBDI_MODE_RESET		 0x00000001
+#define  RCVDBDI_MODE_ENABLE		 0x00000002
+#define  RCVDBDI_MODE_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_MODE_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_MODE_INV_RING_SZ	 0x00000010
+#define RCVDBDI_STATUS			0x00002404
+#define  RCVDBDI_STATUS_JUMBOBD_NEEDED	 0x00000004
+#define  RCVDBDI_STATUS_FRM_TOO_BIG	 0x00000008
+#define  RCVDBDI_STATUS_INV_RING_SZ	 0x00000010
+#define RCVDBDI_SPLIT_FRAME_MINSZ	0x00002408
+/* 0x240c --> 0x2440 unused */
+#define RCVDBDI_JUMBO_BD		0x00002440 /* TG3_BDINFO_... */
+#define RCVDBDI_STD_BD			0x00002450 /* TG3_BDINFO_... */
+#define RCVDBDI_MINI_BD			0x00002460 /* TG3_BDINFO_... */
+#define RCVDBDI_JUMBO_CON_IDX		0x00002470
+#define RCVDBDI_STD_CON_IDX		0x00002474
+#define RCVDBDI_MINI_CON_IDX		0x00002478
+/* 0x247c --> 0x2480 unused */
+#define RCVDBDI_BD_PROD_IDX_0		0x00002480
+#define RCVDBDI_BD_PROD_IDX_1		0x00002484
+#define RCVDBDI_BD_PROD_IDX_2		0x00002488
+#define RCVDBDI_BD_PROD_IDX_3		0x0000248c
+#define RCVDBDI_BD_PROD_IDX_4		0x00002490
+#define RCVDBDI_BD_PROD_IDX_5		0x00002494
+#define RCVDBDI_BD_PROD_IDX_6		0x00002498
+#define RCVDBDI_BD_PROD_IDX_7		0x0000249c
+#define RCVDBDI_BD_PROD_IDX_8		0x000024a0
+#define RCVDBDI_BD_PROD_IDX_9		0x000024a4
+#define RCVDBDI_BD_PROD_IDX_10		0x000024a8
+#define RCVDBDI_BD_PROD_IDX_11		0x000024ac
+#define RCVDBDI_BD_PROD_IDX_12		0x000024b0
+#define RCVDBDI_BD_PROD_IDX_13		0x000024b4
+#define RCVDBDI_BD_PROD_IDX_14		0x000024b8
+#define RCVDBDI_BD_PROD_IDX_15		0x000024bc
+#define RCVDBDI_HWDIAG			0x000024c0
+/* 0x24c4 --> 0x2800 unused */
+
+/* Receive Data Completion Control */
+#define RCVDCC_MODE			0x00002800
+#define  RCVDCC_MODE_RESET		 0x00000001
+#define  RCVDCC_MODE_ENABLE		 0x00000002
+#define  RCVDCC_MODE_ATTN_ENABLE	 0x00000004
+/* 0x2804 --> 0x2c00 unused */
+
+/* Receive BD Initiator Control Registers */
+#define RCVBDI_MODE			0x00002c00
+#define  RCVBDI_MODE_RESET		 0x00000001
+#define  RCVBDI_MODE_ENABLE		 0x00000002
+#define  RCVBDI_MODE_RCB_ATTN_ENAB	 0x00000004
+#define RCVBDI_STATUS			0x00002c04
+#define  RCVBDI_STATUS_RCB_ATTN		 0x00000004
+#define RCVBDI_JUMBO_PROD_IDX		0x00002c08
+#define RCVBDI_STD_PROD_IDX		0x00002c0c
+#define RCVBDI_MINI_PROD_IDX		0x00002c10
+#define RCVBDI_MINI_THRESH		0x00002c14
+#define RCVBDI_STD_THRESH		0x00002c18
+#define RCVBDI_JUMBO_THRESH		0x00002c1c
+/* 0x2c20 --> 0x3000 unused */
+
+/* Receive BD Completion Control Registers */
+#define RCVCC_MODE			0x00003000
+#define  RCVCC_MODE_RESET		 0x00000001
+#define  RCVCC_MODE_ENABLE		 0x00000002
+#define  RCVCC_MODE_ATTN_ENABLE		 0x00000004
+#define RCVCC_STATUS			0x00003004
+#define  RCVCC_STATUS_ERROR_ATTN	 0x00000004
+#define RCVCC_JUMP_PROD_IDX		0x00003008
+#define RCVCC_STD_PROD_IDX		0x0000300c
+#define RCVCC_MINI_PROD_IDX		0x00003010
+/* 0x3014 --> 0x3400 unused */
+
+/* Receive list selector control registers */
+#define RCVLSC_MODE			0x00003400
+#define  RCVLSC_MODE_RESET		 0x00000001
+#define  RCVLSC_MODE_ENABLE		 0x00000002
+#define  RCVLSC_MODE_ATTN_ENABLE	 0x00000004
+#define RCVLSC_STATUS			0x00003404
+#define  RCVLSC_STATUS_ERROR_ATTN	 0x00000004
+/* 0x3408 --> 0x3800 unused */
+
+/* Mbuf cluster free registers */
+#define MBFREE_MODE			0x00003800
+#define  MBFREE_MODE_RESET		 0x00000001
+#define  MBFREE_MODE_ENABLE		 0x00000002
+#define MBFREE_STATUS			0x00003804
+/* 0x3808 --> 0x3c00 unused */
+
+/* Host coalescing control registers */
+#define HOSTCC_MODE			0x00003c00
+#define  HOSTCC_MODE_RESET		 0x00000001
+#define  HOSTCC_MODE_ENABLE		 0x00000002
+#define  HOSTCC_MODE_ATTN		 0x00000004
+#define  HOSTCC_MODE_NOW		 0x00000008
+#define  HOSTCC_MODE_FULL_STATUS	 0x00000000
+#define  HOSTCC_MODE_64BYTE		 0x00000080
+#define  HOSTCC_MODE_32BYTE		 0x00000100
+#define  HOSTCC_MODE_CLRTICK_RXBD	 0x00000200
+#define  HOSTCC_MODE_CLRTICK_TXBD	 0x00000400
+#define  HOSTCC_MODE_NOINT_ON_NOW	 0x00000800
+#define  HOSTCC_MODE_NOINT_ON_FORCE	 0x00001000
+#define HOSTCC_STATUS			0x00003c04
+#define  HOSTCC_STATUS_ERROR_ATTN	 0x00000004
+#define HOSTCC_RXCOL_TICKS		0x00003c08
+#define  LOW_RXCOL_TICKS		 0x00000032
+#define  DEFAULT_RXCOL_TICKS		 0x00000048
+#define  HIGH_RXCOL_TICKS		 0x00000096
+#define HOSTCC_TXCOL_TICKS		0x00003c0c
+#define  LOW_TXCOL_TICKS		 0x00000096
+#define  DEFAULT_TXCOL_TICKS		 0x0000012c
+#define  HIGH_TXCOL_TICKS		 0x00000145
+#define HOSTCC_RXMAX_FRAMES		0x00003c10
+#define  LOW_RXMAX_FRAMES		 0x00000005
+#define  DEFAULT_RXMAX_FRAMES		 0x00000008
+#define  HIGH_RXMAX_FRAMES		 0x00000012
+#define HOSTCC_TXMAX_FRAMES		0x00003c14
+#define  LOW_TXMAX_FRAMES		 0x00000035
+#define  DEFAULT_TXMAX_FRAMES		 0x0000004b
+#define  HIGH_TXMAX_FRAMES		 0x00000052
+#define HOSTCC_RXCOAL_TICK_INT		0x00003c18
+#define  DEFAULT_RXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_TXCOAL_TICK_INT		0x00003c1c
+#define  DEFAULT_TXCOAL_TICK_INT	 0x00000019
+#define HOSTCC_RXCOAL_MAXF_INT		0x00003c20
+#define  DEFAULT_RXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_TXCOAL_MAXF_INT		0x00003c24
+#define  DEFAULT_TXCOAL_MAXF_INT	 0x00000005
+#define HOSTCC_STAT_COAL_TICKS		0x00003c28
+#define  DEFAULT_STAT_COAL_TICKS	 0x000f4240
+/* 0x3c2c --> 0x3c30 unused */
+#define HOSTCC_STATS_BLK_HOST_ADDR	0x00003c30 /* 64-bit */
+#define HOSTCC_STATUS_BLK_HOST_ADDR	0x00003c38 /* 64-bit */
+#define HOSTCC_STATS_BLK_NIC_ADDR	0x00003c40
+#define HOSTCC_STATUS_BLK_NIC_ADDR	0x00003c44
+#define HOSTCC_FLOW_ATTN		0x00003c48
+/* 0x3c4c --> 0x3c50 unused */
+#define HOSTCC_JUMBO_CON_IDX		0x00003c50
+#define HOSTCC_STD_CON_IDX		0x00003c54
+#define HOSTCC_MINI_CON_IDX		0x00003c58
+/* 0x3c5c --> 0x3c80 unused */
+#define HOSTCC_RET_PROD_IDX_0		0x00003c80
+#define HOSTCC_RET_PROD_IDX_1		0x00003c84
+#define HOSTCC_RET_PROD_IDX_2		0x00003c88
+#define HOSTCC_RET_PROD_IDX_3		0x00003c8c
+#define HOSTCC_RET_PROD_IDX_4		0x00003c90
+#define HOSTCC_RET_PROD_IDX_5		0x00003c94
+#define HOSTCC_RET_PROD_IDX_6		0x00003c98
+#define HOSTCC_RET_PROD_IDX_7		0x00003c9c
+#define HOSTCC_RET_PROD_IDX_8		0x00003ca0
+#define HOSTCC_RET_PROD_IDX_9		0x00003ca4
+#define HOSTCC_RET_PROD_IDX_10		0x00003ca8
+#define HOSTCC_RET_PROD_IDX_11		0x00003cac
+#define HOSTCC_RET_PROD_IDX_12		0x00003cb0
+#define HOSTCC_RET_PROD_IDX_13		0x00003cb4
+#define HOSTCC_RET_PROD_IDX_14		0x00003cb8
+#define HOSTCC_RET_PROD_IDX_15		0x00003cbc
+#define HOSTCC_SND_CON_IDX_0		0x00003cc0
+#define HOSTCC_SND_CON_IDX_1		0x00003cc4
+#define HOSTCC_SND_CON_IDX_2		0x00003cc8
+#define HOSTCC_SND_CON_IDX_3		0x00003ccc
+#define HOSTCC_SND_CON_IDX_4		0x00003cd0
+#define HOSTCC_SND_CON_IDX_5		0x00003cd4
+#define HOSTCC_SND_CON_IDX_6		0x00003cd8
+#define HOSTCC_SND_CON_IDX_7		0x00003cdc
+#define HOSTCC_SND_CON_IDX_8		0x00003ce0
+#define HOSTCC_SND_CON_IDX_9		0x00003ce4
+#define HOSTCC_SND_CON_IDX_10		0x00003ce8
+#define HOSTCC_SND_CON_IDX_11		0x00003cec
+#define HOSTCC_SND_CON_IDX_12		0x00003cf0
+#define HOSTCC_SND_CON_IDX_13		0x00003cf4
+#define HOSTCC_SND_CON_IDX_14		0x00003cf8
+#define HOSTCC_SND_CON_IDX_15		0x00003cfc
+/* 0x3d00 --> 0x4000 unused */
+
+/* Memory arbiter control registers */
+#define MEMARB_MODE			0x00004000
+#define  MEMARB_MODE_RESET		 0x00000001
+#define  MEMARB_MODE_ENABLE		 0x00000002
+#define MEMARB_STATUS			0x00004004
+#define MEMARB_TRAP_ADDR_LOW		0x00004008
+#define MEMARB_TRAP_ADDR_HIGH		0x0000400c
+/* 0x4010 --> 0x4400 unused */
+
+/* Buffer manager control registers */
+#define BUFMGR_MODE			0x00004400
+#define  BUFMGR_MODE_RESET		 0x00000001
+#define  BUFMGR_MODE_ENABLE		 0x00000002
+#define  BUFMGR_MODE_ATTN_ENABLE	 0x00000004
+#define  BUFMGR_MODE_BM_TEST		 0x00000008
+#define  BUFMGR_MODE_MBLOW_ATTN_ENAB	 0x00000010
+#define BUFMGR_STATUS			0x00004404
+#define  BUFMGR_STATUS_ERROR		 0x00000004
+#define  BUFMGR_STATUS_MBLOW		 0x00000010
+#define BUFMGR_MB_POOL_ADDR		0x00004408
+#define BUFMGR_MB_POOL_SIZE		0x0000440c
+#define BUFMGR_MB_RDMA_LOW_WATER	0x00004410
+#define  DEFAULT_MB_RDMA_LOW_WATER	 0x00000050
+#define  DEFAULT_MB_RDMA_LOW_WATER_5705	 0x00000000
+#define  DEFAULT_MB_RDMA_LOW_WATER_JUMBO 0x00000130
+#define BUFMGR_MB_MACRX_LOW_WATER	0x00004414
+#define  DEFAULT_MB_MACRX_LOW_WATER	  0x00000020
+#define  DEFAULT_MB_MACRX_LOW_WATER_5705  0x00000010
+#define  DEFAULT_MB_MACRX_LOW_WATER_JUMBO 0x00000098
+#define BUFMGR_MB_HIGH_WATER		0x00004418
+#define  DEFAULT_MB_HIGH_WATER		 0x00000060
+#define  DEFAULT_MB_HIGH_WATER_5705	 0x00000060
+#define  DEFAULT_MB_HIGH_WATER_JUMBO	 0x0000017c
+#define BUFMGR_RX_MB_ALLOC_REQ		0x0000441c
+#define  BUFMGR_MB_ALLOC_BIT		 0x10000000
+#define BUFMGR_RX_MB_ALLOC_RESP		0x00004420
+#define BUFMGR_TX_MB_ALLOC_REQ		0x00004424
+#define BUFMGR_TX_MB_ALLOC_RESP		0x00004428
+#define BUFMGR_DMA_DESC_POOL_ADDR	0x0000442c
+#define BUFMGR_DMA_DESC_POOL_SIZE	0x00004430
+#define BUFMGR_DMA_LOW_WATER		0x00004434
+#define  DEFAULT_DMA_LOW_WATER		 0x00000005
+#define BUFMGR_DMA_HIGH_WATER		0x00004438
+#define  DEFAULT_DMA_HIGH_WATER		 0x0000000a
+#define BUFMGR_RX_DMA_ALLOC_REQ		0x0000443c
+#define BUFMGR_RX_DMA_ALLOC_RESP	0x00004440
+#define BUFMGR_TX_DMA_ALLOC_REQ		0x00004444
+#define BUFMGR_TX_DMA_ALLOC_RESP	0x00004448
+#define BUFMGR_HWDIAG_0			0x0000444c
+#define BUFMGR_HWDIAG_1			0x00004450
+#define BUFMGR_HWDIAG_2			0x00004454
+/* 0x4458 --> 0x4800 unused */
+
+/* Read DMA control registers */
+#define RDMAC_MODE			0x00004800
+#define  RDMAC_MODE_RESET		 0x00000001
+#define  RDMAC_MODE_ENABLE		 0x00000002
+#define  RDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  RDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  RDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  RDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  RDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  RDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  RDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  RDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define  RDMAC_MODE_SPLIT_ENABLE	 0x00000800
+#define  RDMAC_MODE_SPLIT_RESET		 0x00001000
+#define  RDMAC_MODE_FIFO_SIZE_128	 0x00020000
+#define  RDMAC_MODE_FIFO_LONG_BURST	 0x00030000
+#define RDMAC_STATUS			0x00004804
+#define  RDMAC_STATUS_TGTABORT		 0x00000004
+#define  RDMAC_STATUS_MSTABORT		 0x00000008
+#define  RDMAC_STATUS_PARITYERR		 0x00000010
+#define  RDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  RDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  RDMAC_STATUS_FIFOURUN		 0x00000080
+#define  RDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  RDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4808 --> 0x4c00 unused */
+
+/* Write DMA control registers */
+#define WDMAC_MODE			0x00004c00
+#define  WDMAC_MODE_RESET		 0x00000001
+#define  WDMAC_MODE_ENABLE		 0x00000002
+#define  WDMAC_MODE_TGTABORT_ENAB	 0x00000004
+#define  WDMAC_MODE_MSTABORT_ENAB	 0x00000008
+#define  WDMAC_MODE_PARITYERR_ENAB	 0x00000010
+#define  WDMAC_MODE_ADDROFLOW_ENAB	 0x00000020
+#define  WDMAC_MODE_FIFOOFLOW_ENAB	 0x00000040
+#define  WDMAC_MODE_FIFOURUN_ENAB	 0x00000080
+#define  WDMAC_MODE_FIFOOREAD_ENAB	 0x00000100
+#define  WDMAC_MODE_LNGREAD_ENAB	 0x00000200
+#define  WDMAC_MODE_RX_ACCEL	 	 0x00000400
+#define WDMAC_STATUS			0x00004c04
+#define  WDMAC_STATUS_TGTABORT		 0x00000004
+#define  WDMAC_STATUS_MSTABORT		 0x00000008
+#define  WDMAC_STATUS_PARITYERR		 0x00000010
+#define  WDMAC_STATUS_ADDROFLOW		 0x00000020
+#define  WDMAC_STATUS_FIFOOFLOW		 0x00000040
+#define  WDMAC_STATUS_FIFOURUN		 0x00000080
+#define  WDMAC_STATUS_FIFOOREAD		 0x00000100
+#define  WDMAC_STATUS_LNGREAD		 0x00000200
+/* 0x4c08 --> 0x5000 unused */
+
+/* Per-cpu register offsets (arm9) */
+#define CPU_MODE			0x00000000
+#define  CPU_MODE_RESET			 0x00000001
+#define  CPU_MODE_HALT			 0x00000400
+#define CPU_STATE			0x00000004
+#define CPU_EVTMASK			0x00000008
+/* 0xc --> 0x1c reserved */
+#define CPU_PC				0x0000001c
+#define CPU_INSN			0x00000020
+#define CPU_SPAD_UFLOW			0x00000024
+#define CPU_WDOG_CLEAR			0x00000028
+#define CPU_WDOG_VECTOR			0x0000002c
+#define CPU_WDOG_PC			0x00000030
+#define CPU_HW_BP			0x00000034
+/* 0x38 --> 0x44 unused */
+#define CPU_WDOG_SAVED_STATE		0x00000044
+#define CPU_LAST_BRANCH_ADDR		0x00000048
+#define CPU_SPAD_UFLOW_SET		0x0000004c
+/* 0x50 --> 0x200 unused */
+#define CPU_R0				0x00000200
+#define CPU_R1				0x00000204
+#define CPU_R2				0x00000208
+#define CPU_R3				0x0000020c
+#define CPU_R4				0x00000210
+#define CPU_R5				0x00000214
+#define CPU_R6				0x00000218
+#define CPU_R7				0x0000021c
+#define CPU_R8				0x00000220
+#define CPU_R9				0x00000224
+#define CPU_R10				0x00000228
+#define CPU_R11				0x0000022c
+#define CPU_R12				0x00000230
+#define CPU_R13				0x00000234
+#define CPU_R14				0x00000238
+#define CPU_R15				0x0000023c
+#define CPU_R16				0x00000240
+#define CPU_R17				0x00000244
+#define CPU_R18				0x00000248
+#define CPU_R19				0x0000024c
+#define CPU_R20				0x00000250
+#define CPU_R21				0x00000254
+#define CPU_R22				0x00000258
+#define CPU_R23				0x0000025c
+#define CPU_R24				0x00000260
+#define CPU_R25				0x00000264
+#define CPU_R26				0x00000268
+#define CPU_R27				0x0000026c
+#define CPU_R28				0x00000270
+#define CPU_R29				0x00000274
+#define CPU_R30				0x00000278
+#define CPU_R31				0x0000027c
+/* 0x280 --> 0x400 unused */
+
+#define RX_CPU_BASE			0x00005000
+#define TX_CPU_BASE			0x00005400
+
+/* Mailboxes */
+#define GRCMBOX_INTERRUPT_0		0x00005800 /* 64-bit */
+#define GRCMBOX_INTERRUPT_1		0x00005808 /* 64-bit */
+#define GRCMBOX_INTERRUPT_2		0x00005810 /* 64-bit */
+#define GRCMBOX_INTERRUPT_3		0x00005818 /* 64-bit */
+#define GRCMBOX_GENERAL_0		0x00005820 /* 64-bit */
+#define GRCMBOX_GENERAL_1		0x00005828 /* 64-bit */
+#define GRCMBOX_GENERAL_2		0x00005830 /* 64-bit */
+#define GRCMBOX_GENERAL_3		0x00005838 /* 64-bit */
+#define GRCMBOX_GENERAL_4		0x00005840 /* 64-bit */
+#define GRCMBOX_GENERAL_5		0x00005848 /* 64-bit */
+#define GRCMBOX_GENERAL_6		0x00005850 /* 64-bit */
+#define GRCMBOX_GENERAL_7		0x00005858 /* 64-bit */
+#define GRCMBOX_RELOAD_STAT		0x00005860 /* 64-bit */
+#define GRCMBOX_RCVSTD_PROD_IDX		0x00005868 /* 64-bit */
+#define GRCMBOX_RCVJUMBO_PROD_IDX	0x00005870 /* 64-bit */
+#define GRCMBOX_RCVMINI_PROD_IDX	0x00005878 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_0	0x00005880 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_1	0x00005888 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_2	0x00005890 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_3	0x00005898 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_4	0x000058a0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_5	0x000058a8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_6	0x000058b0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_7	0x000058b8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_8	0x000058c0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_9	0x000058c8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_10	0x000058d0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_11	0x000058d8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_12	0x000058e0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_13	0x000058e8 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_14	0x000058f0 /* 64-bit */
+#define GRCMBOX_RCVRET_CON_IDX_15	0x000058f8 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_0	0x00005900 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_1	0x00005908 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_2	0x00005910 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_3	0x00005918 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_4	0x00005920 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_5	0x00005928 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_6	0x00005930 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_7	0x00005938 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_8	0x00005940 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_9	0x00005948 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_10	0x00005950 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_11	0x00005958 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_12	0x00005960 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_13	0x00005968 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_14	0x00005970 /* 64-bit */
+#define GRCMBOX_SNDHOST_PROD_IDX_15	0x00005978 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_0	0x00005980 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_1	0x00005988 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_2	0x00005990 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_3	0x00005998 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_4	0x000059a0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_5	0x000059a8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_6	0x000059b0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_7	0x000059b8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_8	0x000059c0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_9	0x000059c8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_10	0x000059d0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_11	0x000059d8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_12	0x000059e0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_13	0x000059e8 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_14	0x000059f0 /* 64-bit */
+#define GRCMBOX_SNDNIC_PROD_IDX_15	0x000059f8 /* 64-bit */
+#define GRCMBOX_HIGH_PRIO_EV_VECTOR	0x00005a00
+#define GRCMBOX_HIGH_PRIO_EV_MASK	0x00005a04
+#define GRCMBOX_LOW_PRIO_EV_VEC		0x00005a08
+#define GRCMBOX_LOW_PRIO_EV_MASK	0x00005a0c
+/* 0x5a10 --> 0x5c00 */
+
+/* Flow Through queues */
+#define FTQ_RESET			0x00005c00
+/* 0x5c04 --> 0x5c10 unused */
+#define FTQ_DMA_NORM_READ_CTL		0x00005c10
+#define FTQ_DMA_NORM_READ_FULL_CNT	0x00005c14
+#define FTQ_DMA_NORM_READ_FIFO_ENQDEQ	0x00005c18
+#define FTQ_DMA_NORM_READ_WRITE_PEEK	0x00005c1c
+#define FTQ_DMA_HIGH_READ_CTL		0x00005c20
+#define FTQ_DMA_HIGH_READ_FULL_CNT	0x00005c24
+#define FTQ_DMA_HIGH_READ_FIFO_ENQDEQ	0x00005c28
+#define FTQ_DMA_HIGH_READ_WRITE_PEEK	0x00005c2c
+#define FTQ_DMA_COMP_DISC_CTL		0x00005c30
+#define FTQ_DMA_COMP_DISC_FULL_CNT	0x00005c34
+#define FTQ_DMA_COMP_DISC_FIFO_ENQDEQ	0x00005c38
+#define FTQ_DMA_COMP_DISC_WRITE_PEEK	0x00005c3c
+#define FTQ_SEND_BD_COMP_CTL		0x00005c40
+#define FTQ_SEND_BD_COMP_FULL_CNT	0x00005c44
+#define FTQ_SEND_BD_COMP_FIFO_ENQDEQ	0x00005c48
+#define FTQ_SEND_BD_COMP_WRITE_PEEK	0x00005c4c
+#define FTQ_SEND_DATA_INIT_CTL		0x00005c50
+#define FTQ_SEND_DATA_INIT_FULL_CNT	0x00005c54
+#define FTQ_SEND_DATA_INIT_FIFO_ENQDEQ	0x00005c58
+#define FTQ_SEND_DATA_INIT_WRITE_PEEK	0x00005c5c
+#define FTQ_DMA_NORM_WRITE_CTL		0x00005c60
+#define FTQ_DMA_NORM_WRITE_FULL_CNT	0x00005c64
+#define FTQ_DMA_NORM_WRITE_FIFO_ENQDEQ	0x00005c68
+#define FTQ_DMA_NORM_WRITE_WRITE_PEEK	0x00005c6c
+#define FTQ_DMA_HIGH_WRITE_CTL		0x00005c70
+#define FTQ_DMA_HIGH_WRITE_FULL_CNT	0x00005c74
+#define FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ	0x00005c78
+#define FTQ_DMA_HIGH_WRITE_WRITE_PEEK	0x00005c7c
+#define FTQ_SWTYPE1_CTL			0x00005c80
+#define FTQ_SWTYPE1_FULL_CNT		0x00005c84
+#define FTQ_SWTYPE1_FIFO_ENQDEQ		0x00005c88
+#define FTQ_SWTYPE1_WRITE_PEEK		0x00005c8c
+#define FTQ_SEND_DATA_COMP_CTL		0x00005c90
+#define FTQ_SEND_DATA_COMP_FULL_CNT	0x00005c94
+#define FTQ_SEND_DATA_COMP_FIFO_ENQDEQ	0x00005c98
+#define FTQ_SEND_DATA_COMP_WRITE_PEEK	0x00005c9c
+#define FTQ_HOST_COAL_CTL		0x00005ca0
+#define FTQ_HOST_COAL_FULL_CNT		0x00005ca4
+#define FTQ_HOST_COAL_FIFO_ENQDEQ	0x00005ca8
+#define FTQ_HOST_COAL_WRITE_PEEK	0x00005cac
+#define FTQ_MAC_TX_CTL			0x00005cb0
+#define FTQ_MAC_TX_FULL_CNT		0x00005cb4
+#define FTQ_MAC_TX_FIFO_ENQDEQ		0x00005cb8
+#define FTQ_MAC_TX_WRITE_PEEK		0x00005cbc
+#define FTQ_MB_FREE_CTL			0x00005cc0
+#define FTQ_MB_FREE_FULL_CNT		0x00005cc4
+#define FTQ_MB_FREE_FIFO_ENQDEQ		0x00005cc8
+#define FTQ_MB_FREE_WRITE_PEEK		0x00005ccc
+#define FTQ_RCVBD_COMP_CTL		0x00005cd0
+#define FTQ_RCVBD_COMP_FULL_CNT		0x00005cd4
+#define FTQ_RCVBD_COMP_FIFO_ENQDEQ	0x00005cd8
+#define FTQ_RCVBD_COMP_WRITE_PEEK	0x00005cdc
+#define FTQ_RCVLST_PLMT_CTL		0x00005ce0
+#define FTQ_RCVLST_PLMT_FULL_CNT	0x00005ce4
+#define FTQ_RCVLST_PLMT_FIFO_ENQDEQ	0x00005ce8
+#define FTQ_RCVLST_PLMT_WRITE_PEEK	0x00005cec
+#define FTQ_RCVDATA_INI_CTL		0x00005cf0
+#define FTQ_RCVDATA_INI_FULL_CNT	0x00005cf4
+#define FTQ_RCVDATA_INI_FIFO_ENQDEQ	0x00005cf8
+#define FTQ_RCVDATA_INI_WRITE_PEEK	0x00005cfc
+#define FTQ_RCVDATA_COMP_CTL		0x00005d00
+#define FTQ_RCVDATA_COMP_FULL_CNT	0x00005d04
+#define FTQ_RCVDATA_COMP_FIFO_ENQDEQ	0x00005d08
+#define FTQ_RCVDATA_COMP_WRITE_PEEK	0x00005d0c
+#define FTQ_SWTYPE2_CTL			0x00005d10
+#define FTQ_SWTYPE2_FULL_CNT		0x00005d14
+#define FTQ_SWTYPE2_FIFO_ENQDEQ		0x00005d18
+#define FTQ_SWTYPE2_WRITE_PEEK		0x00005d1c
+/* 0x5d20 --> 0x6000 unused */
+
+/* Message signaled interrupt registers */
+#define MSGINT_MODE			0x00006000
+#define  MSGINT_MODE_RESET		 0x00000001
+#define  MSGINT_MODE_ENABLE		 0x00000002
+#define MSGINT_STATUS			0x00006004
+#define MSGINT_FIFO			0x00006008
+/* 0x600c --> 0x6400 unused */
+
+/* DMA completion registers */
+#define DMAC_MODE			0x00006400
+#define  DMAC_MODE_RESET		 0x00000001
+#define  DMAC_MODE_ENABLE		 0x00000002
+/* 0x6404 --> 0x6800 unused */
+
+/* GRC registers */
+#define GRC_MODE			0x00006800
+#define  GRC_MODE_UPD_ON_COAL		0x00000001
+#define  GRC_MODE_BSWAP_NONFRM_DATA	0x00000002
+#define  GRC_MODE_WSWAP_NONFRM_DATA	0x00000004
+#define  GRC_MODE_BSWAP_DATA		0x00000010
+#define  GRC_MODE_WSWAP_DATA		0x00000020
+#define  GRC_MODE_SPLITHDR		0x00000100
+#define  GRC_MODE_NOFRM_CRACKING	0x00000200
+#define  GRC_MODE_INCL_CRC		0x00000400
+#define  GRC_MODE_ALLOW_BAD_FRMS	0x00000800
+#define  GRC_MODE_NOIRQ_ON_SENDS	0x00002000
+#define  GRC_MODE_NOIRQ_ON_RCV		0x00004000
+#define  GRC_MODE_FORCE_PCI32BIT	0x00008000
+#define  GRC_MODE_HOST_STACKUP		0x00010000
+#define  GRC_MODE_HOST_SENDBDS		0x00020000
+#define  GRC_MODE_NO_TX_PHDR_CSUM	0x00100000
+#define  GRC_MODE_NO_RX_PHDR_CSUM	0x00800000
+#define  GRC_MODE_IRQ_ON_TX_CPU_ATTN	0x01000000
+#define  GRC_MODE_IRQ_ON_RX_CPU_ATTN	0x02000000
+#define  GRC_MODE_IRQ_ON_MAC_ATTN	0x04000000
+#define  GRC_MODE_IRQ_ON_DMA_ATTN	0x08000000
+#define  GRC_MODE_IRQ_ON_FLOW_ATTN	0x10000000
+#define  GRC_MODE_4X_NIC_SEND_RINGS	0x20000000
+#define  GRC_MODE_MCAST_FRM_ENABLE	0x40000000
+#define GRC_MISC_CFG			0x00006804
+#define  GRC_MISC_CFG_CORECLK_RESET	0x00000001
+#define  GRC_MISC_CFG_PRESCALAR_MASK	0x000000fe
+#define  GRC_MISC_CFG_PRESCALAR_SHIFT	1
+#define  GRC_MISC_CFG_BOARD_ID_MASK	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5700	0x0001e000
+#define  GRC_MISC_CFG_BOARD_ID_5701	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5702FE	0x00004000
+#define  GRC_MISC_CFG_BOARD_ID_5703	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5703S	0x00002000
+#define  GRC_MISC_CFG_BOARD_ID_5704	0x00000000
+#define  GRC_MISC_CFG_BOARD_ID_5704CIOBE 0x00004000
+#define  GRC_MISC_CFG_BOARD_ID_5704_A2	0x00008000
+#define  GRC_MISC_CFG_BOARD_ID_5788	0x00010000
+#define  GRC_MISC_CFG_BOARD_ID_5788M	0x00018000
+#define  GRC_MISC_CFG_BOARD_ID_AC91002A1 0x00018000
+#define  GRC_MISC_CFG_KEEP_GPHY_POWER	0x04000000
+#define GRC_LOCAL_CTRL			0x00006808
+#define  GRC_LCLCTRL_INT_ACTIVE		0x00000001
+#define  GRC_LCLCTRL_CLEARINT		0x00000002
+#define  GRC_LCLCTRL_SETINT		0x00000004
+#define  GRC_LCLCTRL_INT_ON_ATTN	0x00000008
+#define  GRC_LCLCTRL_GPIO_INPUT0	0x00000100
+#define  GRC_LCLCTRL_GPIO_INPUT1	0x00000200
+#define  GRC_LCLCTRL_GPIO_INPUT2	0x00000400
+#define  GRC_LCLCTRL_GPIO_OE0		0x00000800
+#define  GRC_LCLCTRL_GPIO_OE1		0x00001000
+#define  GRC_LCLCTRL_GPIO_OE2		0x00002000
+#define  GRC_LCLCTRL_GPIO_OUTPUT0	0x00004000
+#define  GRC_LCLCTRL_GPIO_OUTPUT1	0x00008000
+#define  GRC_LCLCTRL_GPIO_OUTPUT2	0x00010000
+#define  GRC_LCLCTRL_EXTMEM_ENABLE	0x00020000
+#define  GRC_LCLCTRL_MEMSZ_MASK		0x001c0000
+#define  GRC_LCLCTRL_MEMSZ_256K		0x00000000
+#define  GRC_LCLCTRL_MEMSZ_512K		0x00040000
+#define  GRC_LCLCTRL_MEMSZ_1M		0x00080000
+#define  GRC_LCLCTRL_MEMSZ_2M		0x000c0000
+#define  GRC_LCLCTRL_MEMSZ_4M		0x00100000
+#define  GRC_LCLCTRL_MEMSZ_8M		0x00140000
+#define  GRC_LCLCTRL_MEMSZ_16M		0x00180000
+#define  GRC_LCLCTRL_BANK_SELECT	0x00200000
+#define  GRC_LCLCTRL_SSRAM_TYPE		0x00400000
+#define  GRC_LCLCTRL_AUTO_SEEPROM	0x01000000
+#define GRC_TIMER			0x0000680c
+#define GRC_RX_CPU_EVENT		0x00006810
+#define GRC_RX_TIMER_REF		0x00006814
+#define GRC_RX_CPU_SEM			0x00006818
+#define GRC_REMOTE_RX_CPU_ATTN		0x0000681c
+#define GRC_TX_CPU_EVENT		0x00006820
+#define GRC_TX_TIMER_REF		0x00006824
+#define GRC_TX_CPU_SEM			0x00006828
+#define GRC_REMOTE_TX_CPU_ATTN		0x0000682c
+#define GRC_MEM_POWER_UP		0x00006830 /* 64-bit */
+#define GRC_EEPROM_ADDR			0x00006838
+#define  EEPROM_ADDR_WRITE		0x00000000
+#define  EEPROM_ADDR_READ		0x80000000
+#define  EEPROM_ADDR_COMPLETE		0x40000000
+#define  EEPROM_ADDR_FSM_RESET		0x20000000
+#define  EEPROM_ADDR_DEVID_MASK		0x1c000000
+#define  EEPROM_ADDR_DEVID_SHIFT	26
+#define  EEPROM_ADDR_START		0x02000000
+#define  EEPROM_ADDR_CLKPERD_SHIFT	16
+#define  EEPROM_ADDR_ADDR_MASK		0x0000ffff
+#define  EEPROM_ADDR_ADDR_SHIFT		0
+#define  EEPROM_DEFAULT_CLOCK_PERIOD	0x60
+#define  EEPROM_CHIP_SIZE		(64 * 1024)
+#define GRC_EEPROM_DATA			0x0000683c
+#define GRC_EEPROM_CTRL			0x00006840
+#define GRC_MDI_CTRL			0x00006844
+#define GRC_SEEPROM_DELAY		0x00006848
+/* 0x684c --> 0x6c00 unused */
+
+/* 0x6c00 --> 0x7000 unused */
+
+/* NVRAM Control registers */
+#define NVRAM_CMD			0x00007000
+#define  NVRAM_CMD_RESET		 0x00000001
+#define  NVRAM_CMD_DONE			 0x00000008
+#define  NVRAM_CMD_GO			 0x00000010
+#define  NVRAM_CMD_WR			 0x00000020
+#define  NVRAM_CMD_RD			 0x00000000
+#define  NVRAM_CMD_ERASE		 0x00000040
+#define  NVRAM_CMD_FIRST		 0x00000080
+#define  NVRAM_CMD_LAST			 0x00000100
+#define NVRAM_STAT			0x00007004
+#define NVRAM_WRDATA			0x00007008
+#define NVRAM_ADDR			0x0000700c
+#define  NVRAM_ADDR_MSK			0x00ffffff
+#define NVRAM_RDDATA			0x00007010
+#define NVRAM_CFG1			0x00007014
+#define  NVRAM_CFG1_FLASHIF_ENAB	 0x00000001
+#define  NVRAM_CFG1_BUFFERED_MODE	 0x00000002
+#define  NVRAM_CFG1_PASS_THRU		 0x00000004
+#define  NVRAM_CFG1_BIT_BANG		 0x00000008
+#define  NVRAM_CFG1_COMPAT_BYPASS	 0x80000000
+#define NVRAM_CFG2			0x00007018
+#define NVRAM_CFG3			0x0000701c
+#define NVRAM_SWARB			0x00007020
+#define  SWARB_REQ_SET0			 0x00000001
+#define  SWARB_REQ_SET1			 0x00000002
+#define  SWARB_REQ_SET2			 0x00000004
+#define  SWARB_REQ_SET3			 0x00000008
+#define  SWARB_REQ_CLR0			 0x00000010
+#define  SWARB_REQ_CLR1			 0x00000020
+#define  SWARB_REQ_CLR2			 0x00000040
+#define  SWARB_REQ_CLR3			 0x00000080
+#define  SWARB_GNT0			 0x00000100
+#define  SWARB_GNT1			 0x00000200
+#define  SWARB_GNT2			 0x00000400
+#define  SWARB_GNT3			 0x00000800
+#define  SWARB_REQ0			 0x00001000
+#define  SWARB_REQ1			 0x00002000
+#define  SWARB_REQ2			 0x00004000
+#define  SWARB_REQ3			 0x00008000
+#define    NVRAM_BUFFERED_PAGE_SIZE	   264
+#define    NVRAM_BUFFERED_PAGE_POS	   9
+/* 0x7024 --> 0x7400 unused */
+
+/* 0x7400 --> 0x8000 unused */
+
+/* 32K Window into NIC internal memory */
+#define NIC_SRAM_WIN_BASE		0x00008000
+
+/* Offsets into first 32k of NIC internal memory. */
+#define NIC_SRAM_PAGE_ZERO		0x00000000
+#define NIC_SRAM_SEND_RCB		0x00000100 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_RCV_RET_RCB		0x00000200 /* 16 * TG3_BDINFO_... */
+#define NIC_SRAM_STATS_BLK		0x00000300
+#define NIC_SRAM_STATUS_BLK		0x00000b00
+
+#define NIC_SRAM_FIRMWARE_MBOX		0x00000b50
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC1	 0x4B657654
+#define  NIC_SRAM_FIRMWARE_MBOX_MAGIC2	 0x4861764b /* !dma on linkchg */
+
+#define NIC_SRAM_DATA_SIG		0x00000b54
+#define  NIC_SRAM_DATA_SIG_MAGIC	 0x4b657654 /* ascii for 'KevT' */
+
+#define NIC_SRAM_DATA_CFG			0x00000b58
+#define  NIC_SRAM_DATA_CFG_LED_MODE_MASK	 0x0000000c
+#define  NIC_SRAM_DATA_CFG_LED_MODE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_LED_TRIPLE_SPD	 0x00000004
+#define  NIC_SRAM_DATA_CFG_LED_OPEN_DRAIN	 0x00000004
+#define  NIC_SRAM_DATA_CFG_LED_LINK_SPD		 0x00000008
+#define  NIC_SRAM_DATA_CFG_LED_OUTPUT		 0x00000008
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_MASK	 0x00000030
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_UNKNOWN	 0x00000000
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_COPPER	 0x00000010
+#define  NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER	 0x00000020
+#define  NIC_SRAM_DATA_CFG_WOL_ENABLE		 0x00000040
+#define  NIC_SRAM_DATA_CFG_ASF_ENABLE		 0x00000080
+#define  NIC_SRAM_DATA_CFG_EEPROM_WP		 0x00000100
+#define  NIC_SRAM_DATA_CFG_MINI_PCI		 0x00001000
+#define  NIC_SRAM_DATA_CFG_FIBER_WOL		 0x00004000
+
+#define NIC_SRAM_DATA_PHY_ID		0x00000b74
+#define  NIC_SRAM_DATA_PHY_ID1_MASK	 0xffff0000
+#define  NIC_SRAM_DATA_PHY_ID2_MASK	 0x0000ffff
+
+#define NIC_SRAM_FW_CMD_MBOX		0x00000b78
+#define  FWCMD_NICDRV_ALIVE		 0x00000001
+#define  FWCMD_NICDRV_PAUSE_FW		 0x00000002
+#define  FWCMD_NICDRV_IPV4ADDR_CHG	 0x00000003
+#define  FWCMD_NICDRV_IPV6ADDR_CHG	 0x00000004
+#define  FWCMD_NICDRV_FIX_DMAR		 0x00000005
+#define  FWCMD_NICDRV_FIX_DMAW		 0x00000006
+#define NIC_SRAM_FW_CMD_LEN_MBOX	0x00000b7c
+#define NIC_SRAM_FW_CMD_DATA_MBOX	0x00000b80
+#define NIC_SRAM_FW_ASF_STATUS_MBOX	0x00000c00
+#define NIC_SRAM_FW_DRV_STATE_MBOX	0x00000c04
+#define  DRV_STATE_START		 0x00000001
+#define  DRV_STATE_UNLOAD		 0x00000002
+#define  DRV_STATE_WOL			 0x00000003
+#define  DRV_STATE_SUSPEND		 0x00000004
+
+#define NIC_SRAM_FW_RESET_TYPE_MBOX	0x00000c08
+
+#define NIC_SRAM_MAC_ADDR_HIGH_MBOX	0x00000c14
+#define NIC_SRAM_MAC_ADDR_LOW_MBOX	0x00000c18
+
+#define NIC_SRAM_RX_MINI_BUFFER_DESC	0x00001000
+
+#define NIC_SRAM_DMA_DESC_POOL_BASE	0x00002000
+#define  NIC_SRAM_DMA_DESC_POOL_SIZE	 0x00002000
+#define NIC_SRAM_TX_BUFFER_DESC		0x00004000 /* 512 entries */
+#define NIC_SRAM_RX_BUFFER_DESC		0x00006000 /* 256 entries */
+#define NIC_SRAM_RX_JUMBO_BUFFER_DESC	0x00007000 /* 256 entries */
+#define NIC_SRAM_MBUF_POOL_BASE		0x00008000
+#define  NIC_SRAM_MBUF_POOL_SIZE96	 0x00018000
+#define  NIC_SRAM_MBUF_POOL_SIZE64	 0x00010000
+#define  NIC_SRAM_MBUF_POOL_BASE5705	0x00010000
+#define  NIC_SRAM_MBUF_POOL_SIZE5705	0x0000e000
+
+/* Currently this is fixed. */
+#define PHY_ADDR		0x01
+
+/* Tigon3 specific PHY MII registers. */
+#define  TG3_BMCR_SPEED1000		0x0040
+
+#define MII_TG3_CTRL			0x09 /* 1000-baseT control register */
+#define  MII_TG3_CTRL_ADV_1000_HALF	0x0100
+#define  MII_TG3_CTRL_ADV_1000_FULL	0x0200
+#define  MII_TG3_CTRL_AS_MASTER		0x0800
+#define  MII_TG3_CTRL_ENABLE_AS_MASTER	0x1000
+
+#define MII_TG3_EXT_CTRL		0x10 /* Extended control register */
+#define  MII_TG3_EXT_CTRL_LNK3_LED_MODE	0x0002
+#define  MII_TG3_EXT_CTRL_TBI		0x8000
+
+#define MII_TG3_EXT_STAT		0x11 /* Extended status register */
+#define  MII_TG3_EXT_STAT_LPASS		0x0100
+
+#define MII_TG3_DSP_RW_PORT		0x15 /* DSP coefficient read/write port */
+
+#define MII_TG3_DSP_ADDRESS		0x17 /* DSP address register */
+
+#define MII_TG3_AUX_CTRL		0x18 /* auxilliary control register */
+
+#define MII_TG3_AUX_STAT		0x19 /* auxilliary status register */
+#define MII_TG3_AUX_STAT_LPASS		0x0004
+#define MII_TG3_AUX_STAT_SPDMASK	0x0700
+#define MII_TG3_AUX_STAT_10HALF		0x0100
+#define MII_TG3_AUX_STAT_10FULL		0x0200
+#define MII_TG3_AUX_STAT_100HALF	0x0300
+#define MII_TG3_AUX_STAT_100_4		0x0400
+#define MII_TG3_AUX_STAT_100FULL	0x0500
+#define MII_TG3_AUX_STAT_1000HALF	0x0600
+#define MII_TG3_AUX_STAT_1000FULL	0x0700
+
+#define MII_TG3_ISTAT			0x1a /* IRQ status register */
+#define MII_TG3_IMASK			0x1b /* IRQ mask register */
+
+/* ISTAT/IMASK event bits */
+#define MII_TG3_INT_LINKCHG		0x0002
+#define MII_TG3_INT_SPEEDCHG		0x0004
+#define MII_TG3_INT_DUPLEXCHG		0x0008
+#define MII_TG3_INT_ANEG_PAGE_RX	0x0400
+
+/* XXX Add this to mii.h */
+#ifndef ADVERTISE_PAUSE
+#define ADVERTISE_PAUSE_CAP		0x0400
+#endif
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM		0x0800
+#endif
+#ifndef LPA_PAUSE
+#define LPA_PAUSE_CAP			0x0400
+#endif
+#ifndef LPA_PAUSE_ASYM
+#define LPA_PAUSE_ASYM			0x0800
+#endif
+
+/* There are two ways to manage the TX descriptors on the tigon3.
+ * Either the descriptors are in host DMA'able memory, or they
+ * exist only in the cards on-chip SRAM.  All 16 send bds are under
+ * the same mode, they may not be configured individually.
+ *
+ * The mode we use is controlled by TG3_FLAG_HOST_TXDS in tp->tg3_flags.
+ *
+ * To use host memory TX descriptors:
+ *	1) Set GRC_MODE_HOST_SENDBDS in GRC_MODE register.
+ *	   Make sure GRC_MODE_4X_NIC_SEND_RINGS is clear.
+ *	2) Allocate DMA'able memory.
+ *	3) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to DMA address of memory
+ *	      obtained in step 2
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC.
+ *	   c) Set len field of TG3_BDINFO_MAXLEN_FLAGS to number
+ *            of TX descriptors.  Leave flags field clear.
+ *	4) Access TX descriptors via host memory.  The chip
+ *	   will refetch into local SRAM as needed when producer
+ *	   index mailboxes are updated.
+ *
+ * To use on-chip TX descriptors:
+ *	1) Set GRC_MODE_4X_NIC_SEND_RINGS in GRC_MODE register.
+ *	   Make sure GRC_MODE_HOST_SENDBDS is clear.
+ *	2) In NIC_SRAM_SEND_RCB (of desired index) of on-chip SRAM:
+ *	   a) Set TG3_BDINFO_HOST_ADDR to zero.
+ *	   b) Set TG3_BDINFO_NIC_ADDR to NIC_SRAM_TX_BUFFER_DESC
+ *	   c) TG3_BDINFO_MAXLEN_FLAGS is don't care.
+ *	3) Access TX descriptors directly in on-chip SRAM
+ *	   using normal {read,write}l().  (and not using
+ *         pointer dereferencing of ioremap()'d memory like
+ *	   the broken Broadcom driver does)
+ *
+ * Note that BDINFO_FLAGS_DISABLED should be set in the flags field of
+ * TG3_BDINFO_MAXLEN_FLAGS of all unused SEND_RCB indices.
+ */
+struct tg3_tx_buffer_desc {
+	uint32_t			addr_hi;
+	uint32_t			addr_lo;
+
+	uint32_t			len_flags;
+#define TXD_FLAG_TCPUDP_CSUM		0x0001
+#define TXD_FLAG_IP_CSUM		0x0002
+#define TXD_FLAG_END			0x0004
+#define TXD_FLAG_IP_FRAG		0x0008
+#define TXD_FLAG_IP_FRAG_END		0x0010
+#define TXD_FLAG_VLAN			0x0040
+#define TXD_FLAG_COAL_NOW		0x0080
+#define TXD_FLAG_CPU_PRE_DMA		0x0100
+#define TXD_FLAG_CPU_POST_DMA		0x0200
+#define TXD_FLAG_ADD_SRC_ADDR		0x1000
+#define TXD_FLAG_CHOOSE_SRC_ADDR	0x6000
+#define TXD_FLAG_NO_CRC			0x8000
+#define TXD_LEN_SHIFT			16
+
+	uint32_t			vlan_tag;
+#define TXD_VLAN_TAG_SHIFT		0
+#define TXD_MSS_SHIFT			16
+};
+
+#define TXD_ADDR			0x00UL /* 64-bit */
+#define TXD_LEN_FLAGS			0x08UL /* 32-bit (upper 16-bits are len) */
+#define TXD_VLAN_TAG			0x0cUL /* 32-bit (upper 16-bits are tag) */
+#define TXD_SIZE			0x10UL
+
+struct tg3_rx_buffer_desc {
+	uint32_t			addr_hi;
+	uint32_t			addr_lo;
+
+	uint32_t			idx_len;
+#define RXD_IDX_MASK	0xffff0000
+#define RXD_IDX_SHIFT	16
+#define RXD_LEN_MASK	0x0000ffff
+#define RXD_LEN_SHIFT	0
+
+	uint32_t			type_flags;
+#define RXD_TYPE_SHIFT	16
+#define RXD_FLAGS_SHIFT	0
+
+#define RXD_FLAG_END			0x0004
+#define RXD_FLAG_MINI			0x0800
+#define RXD_FLAG_JUMBO			0x0020
+#define RXD_FLAG_VLAN			0x0040
+#define RXD_FLAG_ERROR			0x0400
+#define RXD_FLAG_IP_CSUM		0x1000
+#define RXD_FLAG_TCPUDP_CSUM		0x2000
+#define RXD_FLAG_IS_TCP			0x4000
+
+	uint32_t			ip_tcp_csum;
+#define RXD_IPCSUM_MASK		0xffff0000
+#define RXD_IPCSUM_SHIFT	16
+#define RXD_TCPCSUM_MASK	0x0000ffff
+#define RXD_TCPCSUM_SHIFT	0
+
+	uint32_t			err_vlan;
+
+#define RXD_VLAN_MASK			0x0000ffff
+
+#define RXD_ERR_BAD_CRC			0x00010000
+#define RXD_ERR_COLLISION		0x00020000
+#define RXD_ERR_LINK_LOST		0x00040000
+#define RXD_ERR_PHY_DECODE		0x00080000
+#define RXD_ERR_ODD_NIBBLE_RCVD_MII	0x00100000
+#define RXD_ERR_MAC_ABRT		0x00200000
+#define RXD_ERR_TOO_SMALL		0x00400000
+#define RXD_ERR_NO_RESOURCES		0x00800000
+#define RXD_ERR_HUGE_FRAME		0x01000000
+#define RXD_ERR_MASK			0xffff0000
+
+	uint32_t			reserved;
+	uint32_t			opaque;
+#define RXD_OPAQUE_INDEX_MASK		0x0000ffff
+#define RXD_OPAQUE_INDEX_SHIFT		0
+#define RXD_OPAQUE_RING_STD		0x00010000
+#define RXD_OPAQUE_RING_JUMBO		0x00020000
+#define RXD_OPAQUE_RING_MINI		0x00040000
+#define RXD_OPAQUE_RING_MASK		0x00070000
+};
+
+struct tg3_ext_rx_buffer_desc {
+	struct {
+		uint32_t		addr_hi;
+		uint32_t		addr_lo;
+	}				addrlist[3];
+	uint32_t			len2_len1;
+	uint32_t			resv_len3;
+	struct tg3_rx_buffer_desc	std;
+};
+
+/* We only use this when testing out the DMA engine
+ * at probe time.  This is the internal format of buffer
+ * descriptors used by the chip at NIC_SRAM_DMA_DESCS.
+ */
+struct tg3_internal_buffer_desc {
+	uint32_t			addr_hi;
+	uint32_t			addr_lo;
+	uint32_t			nic_mbuf;
+	/* XXX FIX THIS */
+#if __BYTE_ORDER == __BIG_ENDIAN
+	uint16_t			cqid_sqid;
+	uint16_t			len;
+#else
+	uint16_t			len;
+	uint16_t			cqid_sqid;
+#endif
+	uint32_t			flags;
+	uint32_t			__cookie1;
+	uint32_t			__cookie2;
+	uint32_t			__cookie3;
+};
+
+#define TG3_HW_STATUS_SIZE		0x50
+struct tg3_hw_status {
+	uint32_t			status;
+#define SD_STATUS_UPDATED		0x00000001
+#define SD_STATUS_LINK_CHG		0x00000002
+#define SD_STATUS_ERROR			0x00000004
+
+	uint32_t			status_tag;
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	uint16_t			rx_consumer;
+	uint16_t			rx_jumbo_consumer;
+#else
+	uint16_t			rx_jumbo_consumer;
+	uint16_t			rx_consumer;
+#endif
+
+#if __BYTE_ORDER ==  __BIG_ENDIAN
+	uint16_t			reserved;
+	uint16_t			rx_mini_consumer;
+#else
+	uint16_t			rx_mini_consumer;
+	uint16_t			reserved;
+#endif
+	struct {
+#if __BYTE_ORDER ==  __BIG_ENDIAN
+		uint16_t		tx_consumer;
+		uint16_t		rx_producer;
+#else
+		uint16_t		rx_producer;
+		uint16_t		tx_consumer;
+#endif
+	}				idx[16];
+};
+
+typedef struct {
+	uint32_t high, low;
+} tg3_stat64_t;
+
+struct tg3_hw_stats {
+	uint8_t				__reserved0[0x400-0x300];
+
+	/* Statistics maintained by Receive MAC. */
+	tg3_stat64_t			rx_octets;
+	uint64_t			__reserved1;
+	tg3_stat64_t			rx_fragments;
+	tg3_stat64_t			rx_ucast_packets;
+	tg3_stat64_t			rx_mcast_packets;
+	tg3_stat64_t			rx_bcast_packets;
+	tg3_stat64_t			rx_fcs_errors;
+	tg3_stat64_t			rx_align_errors;
+	tg3_stat64_t			rx_xon_pause_rcvd;
+	tg3_stat64_t			rx_xoff_pause_rcvd;
+	tg3_stat64_t			rx_mac_ctrl_rcvd;
+	tg3_stat64_t			rx_xoff_entered;
+	tg3_stat64_t			rx_frame_too_long_errors;
+	tg3_stat64_t			rx_jabbers;
+	tg3_stat64_t			rx_undersize_packets;
+	tg3_stat64_t			rx_in_length_errors;
+	tg3_stat64_t			rx_out_length_errors;
+	tg3_stat64_t			rx_64_or_less_octet_packets;
+	tg3_stat64_t			rx_65_to_127_octet_packets;
+	tg3_stat64_t			rx_128_to_255_octet_packets;
+	tg3_stat64_t			rx_256_to_511_octet_packets;
+	tg3_stat64_t			rx_512_to_1023_octet_packets;
+	tg3_stat64_t			rx_1024_to_1522_octet_packets;
+	tg3_stat64_t			rx_1523_to_2047_octet_packets;
+	tg3_stat64_t			rx_2048_to_4095_octet_packets;
+	tg3_stat64_t			rx_4096_to_8191_octet_packets;
+	tg3_stat64_t			rx_8192_to_9022_octet_packets;
+
+	uint64_t			__unused0[37];
+
+	/* Statistics maintained by Transmit MAC. */
+	tg3_stat64_t			tx_octets;
+	uint64_t			__reserved2;
+	tg3_stat64_t			tx_collisions;
+	tg3_stat64_t			tx_xon_sent;
+	tg3_stat64_t			tx_xoff_sent;
+	tg3_stat64_t			tx_flow_control;
+	tg3_stat64_t			tx_mac_errors;
+	tg3_stat64_t			tx_single_collisions;
+	tg3_stat64_t			tx_mult_collisions;
+	tg3_stat64_t			tx_deferred;
+	uint64_t			__reserved3;
+	tg3_stat64_t			tx_excessive_collisions;
+	tg3_stat64_t			tx_late_collisions;
+	tg3_stat64_t			tx_collide_2times;
+	tg3_stat64_t			tx_collide_3times;
+	tg3_stat64_t			tx_collide_4times;
+	tg3_stat64_t			tx_collide_5times;
+	tg3_stat64_t			tx_collide_6times;
+	tg3_stat64_t			tx_collide_7times;
+	tg3_stat64_t			tx_collide_8times;
+	tg3_stat64_t			tx_collide_9times;
+	tg3_stat64_t			tx_collide_10times;
+	tg3_stat64_t			tx_collide_11times;
+	tg3_stat64_t			tx_collide_12times;
+	tg3_stat64_t			tx_collide_13times;
+	tg3_stat64_t			tx_collide_14times;
+	tg3_stat64_t			tx_collide_15times;
+	tg3_stat64_t			tx_ucast_packets;
+	tg3_stat64_t			tx_mcast_packets;
+	tg3_stat64_t			tx_bcast_packets;
+	tg3_stat64_t			tx_carrier_sense_errors;
+	tg3_stat64_t			tx_discards;
+	tg3_stat64_t			tx_errors;
+
+	uint64_t			__unused1[31];
+
+	/* Statistics maintained by Receive List Placement. */
+	tg3_stat64_t			COS_rx_packets[16];
+	tg3_stat64_t			COS_rx_filter_dropped;
+	tg3_stat64_t			dma_writeq_full;
+	tg3_stat64_t			dma_write_prioq_full;
+	tg3_stat64_t			rxbds_empty;
+	tg3_stat64_t			rx_discards;
+	tg3_stat64_t			rx_errors;
+	tg3_stat64_t			rx_threshold_hit;
+
+	uint64_t			__unused2[9];
+
+	/* Statistics maintained by Send Data Initiator. */
+	tg3_stat64_t			COS_out_packets[16];
+	tg3_stat64_t			dma_readq_full;
+	tg3_stat64_t			dma_read_prioq_full;
+	tg3_stat64_t			tx_comp_queue_full;
+
+	/* Statistics maintained by Host Coalescing. */
+	tg3_stat64_t			ring_set_send_prod_index;
+	tg3_stat64_t			ring_status_update;
+	tg3_stat64_t			nic_irqs;
+	tg3_stat64_t			nic_avoided_irqs;
+	tg3_stat64_t			nic_tx_threshold_hit;
+
+	uint8_t				__reserved4[0xb00-0x9c0];
+};
+
+enum phy_led_mode {
+	led_mode_auto,
+	led_mode_three_link,
+	led_mode_link10
+};
+
+#if 0
+/* 'mapping' is superfluous as the chip does not write into
+ * the tx/rx post rings so we could just fetch it from there.
+ * But the cache behavior is better how we are doing it now.
+ */
+struct ring_info {
+	struct sk_buff			*skb;
+	DECLARE_PCI_UNMAP_ADDR(mapping)
+};
+
+struct tx_ring_info {
+	struct sk_buff			*skb;
+	DECLARE_PCI_UNMAP_ADDR(mapping)
+	uint32_t			prev_vlan_tag;
+};
+#endif
+
+struct tg3_config_info {
+	uint32_t			flags;
+};
+
+struct tg3_link_config {
+	/* Describes what we're trying to get. */
+	uint32_t			advertising;
+#if 0
+	uint16_t			speed;
+	uint8_t				duplex;
+	uint8_t				autoneg;
+#define SPEED_INVALID		0xffff
+#define DUPLEX_INVALID		0xff
+#define AUTONEG_INVALID		0xff
+#endif
+
+	/* Describes what we actually have. */
+	uint8_t				active_speed;
+	uint8_t				active_duplex;
+
+	/* When we go in and out of low power mode we need
+	 * to swap with this state.
+	 */
+#if 0
+	int				phy_is_low_power;
+	uint16_t			orig_speed;
+	uint8_t				orig_duplex;
+	uint8_t				orig_autoneg;
+#endif
+};
+
+struct tg3_bufmgr_config {
+	uint32_t		mbuf_read_dma_low_water;
+	uint32_t		mbuf_mac_rx_low_water;
+	uint32_t		mbuf_high_water;
+
+	uint32_t		mbuf_read_dma_low_water_jumbo;
+	uint32_t		mbuf_mac_rx_low_water_jumbo;
+	uint32_t		mbuf_high_water_jumbo;
+
+	uint32_t		dma_low_water;
+	uint32_t		dma_high_water;
+};
+
+struct tg3 {
+#if 0
+	/* SMP locking strategy:
+	 *
+	 * lock: Held during all operations except TX packet
+	 *       processing.
+	 *
+	 * tx_lock: Held during tg3_start_xmit{,_4gbug} and tg3_tx
+	 *
+	 * If you want to shut up all asynchronous processing you must
+	 * acquire both locks, 'lock' taken before 'tx_lock'.  IRQs must
+	 * be disabled to take 'lock' but only softirq disabling is
+	 * necessary for acquisition of 'tx_lock'.
+	 */
+	spinlock_t			lock;
+	spinlock_t			tx_lock;
+#endif
+
+	uint32_t			tx_prod;
+#if 0
+	uint32_t			tx_cons;
+#endif
+	uint32_t			rx_rcb_ptr;
+	uint32_t			rx_std_ptr;
+#if 0
+	uint32_t			rx_jumbo_ptr;
+	spinlock_t			indirect_lock;
+
+	struct net_device_stats		net_stats;
+	struct net_device_stats		net_stats_prev;
+#endif
+	unsigned long			phy_crc_errors;
+
+#if 0
+	uint32_t			rx_offset;
+#endif
+	uint32_t			tg3_flags;
+#if 0
+#define TG3_FLAG_HOST_TXDS		0x00000001
+#endif
+#define TG3_FLAG_TXD_MBOX_HWBUG		0x00000002
+#define TG3_FLAG_RX_CHECKSUMS		0x00000004
+#define TG3_FLAG_USE_LINKCHG_REG	0x00000008
+#define TG3_FLAG_USE_MI_INTERRUPT	0x00000010
+#define TG3_FLAG_ENABLE_ASF		0x00000020
+#define TG3_FLAG_5701_REG_WRITE_BUG	0x00000040
+#define TG3_FLAG_POLL_SERDES		0x00000080
+#define TG3_FLAG_MBOX_WRITE_REORDER	0x00000100
+#define TG3_FLAG_PCIX_TARGET_HWBUG	0x00000200
+#define TG3_FLAG_WOL_SPEED_100MB	0x00000400
+#define TG3_FLAG_WOL_ENABLE		0x00000800
+#define TG3_FLAG_EEPROM_WRITE_PROT	0x00001000
+#define TG3_FLAG_NVRAM			0x00002000
+#define TG3_FLAG_NVRAM_BUFFERED		0x00004000
+#define TG3_FLAG_RX_PAUSE		0x00008000
+#define TG3_FLAG_TX_PAUSE		0x00010000
+#define TG3_FLAG_PCIX_MODE		0x00020000
+#define TG3_FLAG_PCI_HIGH_SPEED		0x00040000
+#define TG3_FLAG_PCI_32BIT		0x00080000
+#define TG3_FLAG_NO_TX_PSEUDO_CSUM	0x00100000
+#define TG3_FLAG_NO_RX_PSEUDO_CSUM	0x00200000
+#define TG3_FLAG_SERDES_WOL_CAP		0x00400000
+#define TG3_FLAG_JUMBO_ENABLE		0x00800000
+#define TG3_FLAG_10_100_ONLY		0x01000000
+#define TG3_FLAG_PAUSE_AUTONEG		0x02000000
+#define TG3_FLAG_PAUSE_RX		0x04000000
+#define TG3_FLAG_PAUSE_TX		0x08000000
+#define TG3_FLAG_BROKEN_CHECKSUMS	0x10000000
+#define TG3_FLAG_GOT_SERDES_FLOWCTL	0x20000000
+#define TG3_FLAG_SPLIT_MODE		0x40000000
+#define TG3_FLAG_INIT_COMPLETE		0x80000000
+
+	uint32_t			tg3_flags2;
+#define TG3_FLG2_RESTART_TIMER		0x00000001
+#define TG3_FLG2_SUN_5704		0x00000002
+#define TG3_FLG2_NO_ETH_WIRE_SPEED	0x00000004
+#define TG3_FLG2_IS_5788		0x00000008
+#define TG3_FLG2_MAX_RXPEND_64		0x00000010
+#define TG3_FLG2_TSO_CAPABLE		0x00000020
+
+
+
+	uint32_t			split_mode_max_reqs;
+#define SPLIT_MODE_5704_MAX_REQ		3
+
+#if 0
+	struct timer_list		timer;
+	uint16_t			timer_counter;
+	uint16_t			timer_multiplier;
+	uint32_t			timer_offset;
+	uint16_t			asf_counter;
+	uint16_t			asf_multiplier;
+#endif
+
+	struct tg3_link_config		link_config;
+	struct tg3_bufmgr_config	bufmgr_config;
+
+#if 0
+	uint32_t			rx_pending;
+	uint32_t			rx_jumbo_pending;
+	uint32_t			tx_pending;
+#endif
+
+	/* cache h/w values, often passed straight to h/w */
+	uint32_t			rx_mode;
+	uint32_t			tx_mode;
+	uint32_t			mac_mode;
+	uint32_t			mi_mode;
+	uint32_t			misc_host_ctrl;
+	uint32_t			grc_mode;
+	uint32_t			grc_local_ctrl;
+	uint32_t			dma_rwctrl;
+#if 0
+	uint32_t			coalesce_mode;
+#endif
+
+	/* PCI block */
+	uint16_t			pci_chip_rev_id;
+#if 0
+	uint8_t				pci_cacheline_sz;
+	uint8_t				pci_lat_timer;
+	uint8_t				pci_hdr_type;
+	uint8_t				pci_bist;
+#endif
+	uint32_t			pci_cfg_state[64 / sizeof(uint32_t)];
+
+	int				pm_cap;
+
+	/* PHY info */
+	uint32_t			phy_id;
+#define PHY_ID_MASK			0xfffffff0
+#define PHY_ID_BCM5400			0x60008040
+#define PHY_ID_BCM5401			0x60008050
+#define PHY_ID_BCM5411			0x60008070
+#define PHY_ID_BCM5701			0x60008110
+#define PHY_ID_BCM5703			0x60008160
+#define PHY_ID_BCM5704			0x60008190
+#define PHY_ID_BCM5705			0x600081a0
+#define PHY_ID_BCM8002			0x60010140
+#define PHY_ID_SERDES			0xfeedbee0
+#define PHY_ID_INVALID			0xffffffff
+#define PHY_ID_REV_MASK			0x0000000f
+#define PHY_REV_BCM5401_B0		0x1
+#define PHY_REV_BCM5401_B2		0x3
+#define PHY_REV_BCM5401_C0		0x6
+#define PHY_REV_BCM5411_X0		0x1 /* Found on Netgear GA302T */
+
+	enum phy_led_mode		led_mode;
+
+	char				board_part_number[24];
+	uint32_t			nic_sram_data_cfg;
+	uint32_t			pci_clock_ctrl;
+#if 0
+	struct pci_device		*pdev_peer;
+#endif
+
+	/* This macro assumes the passed PHY ID is already masked
+	 * with PHY_ID_MASK.
+	 */
+#define KNOWN_PHY_ID(X)		\
+	((X) == PHY_ID_BCM5400 || (X) == PHY_ID_BCM5401 || \
+	 (X) == PHY_ID_BCM5411 || (X) == PHY_ID_BCM5701 || \
+	 (X) == PHY_ID_BCM5703 || (X) == PHY_ID_BCM5704 || \
+	 (X) == PHY_ID_BCM5705 || \
+	 (X) == PHY_ID_BCM8002 || (X) == PHY_ID_SERDES)
+
+	unsigned long			regs;
+	struct pci_device		*pdev;
+	struct nic			*nic;
+#if 0
+	struct net_device		*dev;
+#endif
+#if TG3_VLAN_TAG_USED
+	struct vlan_group		*vlgrp;
+#endif
+
+	struct tg3_rx_buffer_desc	*rx_std;
+#if 0
+	struct ring_info		*rx_std_buffers;
+	dma_addr_t			rx_std_mapping;
+	struct tg3_rx_buffer_desc	*rx_jumbo;
+	struct ring_info		*rx_jumbo_buffers;
+	dma_addr_t			rx_jumbo_mapping;
+#endif
+
+	struct tg3_rx_buffer_desc	*rx_rcb;
+#if 0
+	dma_addr_t			rx_rcb_mapping;
+#endif
+
+	/* TX descs are only used if TG3_FLAG_HOST_TXDS is set. */
+	struct tg3_tx_buffer_desc	*tx_ring;
+#if 0
+	struct tx_ring_info		*tx_buffers;
+	dma_addr_t			tx_desc_mapping;
+#endif
+
+	struct tg3_hw_status		*hw_status;
+#if 0
+	dma_addr_t			status_mapping;
+#endif
+#if 0
+	uint32_t			msg_enable;
+#endif
+
+	struct tg3_hw_stats		*hw_stats;
+#if 0
+	dma_addr_t			stats_mapping;
+#endif
+
+	int				carrier_ok;
+	uint16_t			subsystem_vendor;
+	uint16_t			subsystem_device;
+};
+
+#endif /* !(_T3_H) */
Index: netboot/grub.h
===================================================================
--- netboot/grub.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/grub.h	(.../trunk)	(revision 112)
@@ -0,0 +1,165 @@
+#ifndef GRUB_H
+#define GRUB_H
+
+#include "osdep.h"
+#include "byteswap.h"
+#include "in.h"
+#include "ip.h"
+#include "udp.h"
+#include "if_ether.h"
+#include "latch.h"
+#include "io.h"
+#include "nic.h"
+#include <shared.h>
+
+#define K_ESC		'\033'
+#define K_EOF		'\04'  /* Ctrl-D */
+#define K_INTR		'\03'  /* Ctrl-C */
+
+#ifndef	MAX_RPC_RETRIES
+#define MAX_RPC_RETRIES		20
+#endif
+
+/* Link configuration time in tenths of a second */
+#ifndef VALID_LINK_TIMEOUT
+#define VALID_LINK_TIMEOUT	100 /* 10.0 seconds */
+#endif
+
+/* Inter-packet retry in ticks */
+#ifndef TIMEOUT
+#define TIMEOUT			(10*TICKS_PER_SEC)
+#endif
+
+#ifndef	NULL
+#define NULL	((void *)0)
+#endif
+
+
+#define ARP_CLIENT	0
+#define ARP_SERVER	1
+#define ARP_GATEWAY	2
+#define MAX_ARP		ARP_GATEWAY+1
+
+#define IGMP_SERVER	0
+#define MAX_IGMP	IGMP_SERVER+1
+
+#define	RARP_REQUEST	3
+#define	RARP_REPLY	4
+
+
+#define MULTICAST_MASK    0xF0000000
+#define MULTICAST_NETWORK 0xE0000000
+
+struct arptable_t {
+	in_addr ipaddr;
+	uint8_t node[6];
+};
+
+struct igmptable_t {
+	in_addr group;
+	unsigned long time;
+};
+
+#define	KERNEL_BUF	(BOOTP_DATA_ADDR->bootp_reply.bp_file)
+
+#define	FLOPPY_BOOT_LOCATION	0x7c00
+/* Must match offsets in loader.S */
+#define ROM_SEGMENT		0x1fa
+#define ROM_LENGTH		0x1fc
+
+#define	ROM_INFO_LOCATION	(FLOPPY_BOOT_LOCATION+ROM_SEGMENT)
+/* at end of floppy boot block */
+
+
+
+/* Define a type for passing info to a loaded program */
+struct ebinfo {
+	uint8_t  major, minor;	/* Version */
+	uint16_t flags;		/* Bit flags */
+};
+
+/***************************************************************************
+External prototypes
+***************************************************************************/
+extern void rx_qdrain P((void));
+extern int tftp P((const char *name, int (*)(unsigned char *, unsigned int, unsigned int, int)));
+extern int ip_transmit P((int len, const void *buf));
+extern void build_ip_hdr P((unsigned long destip, int ttl, int protocol, 
+	int option_len, int len, const void *buf));
+extern void build_udp_hdr P((unsigned long destip, 
+	unsigned int srcsock, unsigned int destsock, int ttl,
+	int len, const void *buf));
+extern int udp_transmit P((unsigned long destip, unsigned int srcsock,
+	unsigned int destsock, int len, const void *buf));
+typedef int (*reply_t)(int ival, void *ptr, unsigned short ptype, struct iphdr *ip, struct udphdr *udp);
+extern int await_reply P((reply_t reply,	int ival, void *ptr, long timeout));
+extern int decode_rfc1533 P((unsigned char *, unsigned int, unsigned int, int));
+void store_ip_in_var(in_addr client_ip);
+extern void join_group(int slot, unsigned long group);
+extern void leave_group(int slot);
+#define RAND_MAX 2147483647L
+extern uint16_t ipchksum P((const void *ip, unsigned long len));
+extern uint16_t add_ipchksums P((unsigned long offset, uint16_t sum, uint16_t new));
+extern int32_t random P((void));
+extern long rfc2131_sleep_interval P((long base, int exp));
+extern long rfc1112_sleep_interval P((long base, int exp));
+#ifndef DOWNLOAD_PROTO_TFTP
+#define	tftp(fname, load_block) 0
+#endif
+extern void cleanup P((void));
+
+/* misc.c */
+extern void twiddle P((void));
+extern void sleep P((int secs));
+extern void interruptible_sleep P((int secs));
+extern void poll_interruptions P((void));
+extern int strcasecmp P((const char *a, const char *b));
+extern char *substr P((const char *a, const char *b));
+extern unsigned long strtoul P((const char *p, const char **, int base));
+extern void printf P((const char *, ...));
+extern int sprintf P((char *, const char *, ...));
+extern int inet_aton P((char *p, in_addr *i));
+#ifdef PCBIOS
+extern void gateA20_set P((void));
+#ifdef	RELOCATE
+#define gateA20_unset()
+#else
+extern void gateA20_unset P((void));
+#endif
+#else
+#define gateA20_set()
+#define gateA20_unset()
+#endif
+extern void putchar P((int));
+extern int getchar P((void));
+extern int iskey P((void));
+
+extern void grub_printf(const char *, ...);
+extern char config_file[128];
+extern void etherboot_printf(const char *,  ...);
+extern int etherboot_sprintf(char *, const char *, ...);
+extern int getdec(char **s);
+extern void cleanup_net(void);
+extern void print_network_configuration (void);
+extern int ifconfig (char *, char *, char *, char *);
+extern struct arptable_t arptable[MAX_ARP];
+
+#define EnterFunction(func)
+#define LeaveFunction(func)
+#undef printf
+#undef sprintf
+#define printf etherboot_printf
+#define sprintf etherboot_sprintf
+
+/*
+ * Some codes from etherboot use a level in DEBUG. Define it to be
+ * zero means no debug info output, that will make them silence in
+ * compiling. Up it as you want.
+ */
+#ifndef DEBUG
+#  define DEBUG 0
+#endif
+
+/*#define RPC_DEBUG*/
+
+#endif /* GRUB_H */
Index: netboot/if_arp.h
===================================================================
--- netboot/if_arp.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/if_arp.h	(.../trunk)	(revision 112)
@@ -0,0 +1,29 @@
+#ifndef	_IF_ARP_H
+#define	_IF_ARP_H
+
+#include "types.h"
+
+#define ARP_REQUEST	1
+#define ARP_REPLY	2
+
+#ifndef	MAX_ARP_RETRIES
+#define MAX_ARP_RETRIES		20
+#endif
+
+/*
+ * A pity sipaddr and tipaddr are not longword aligned or we could use
+ * in_addr. No, I don't want to use #pragma packed.
+ */
+struct arprequest {
+	uint16_t hwtype;
+	uint16_t protocol;
+	uint8_t  hwlen;
+	uint8_t  protolen;
+	uint16_t opcode;
+	uint8_t  shwaddr[6];
+	uint8_t  sipaddr[4];
+	uint8_t  thwaddr[6];
+	uint8_t  tipaddr[4];
+};
+
+#endif	/* _IF_ARP_H */
Index: netboot/3c595.c
===================================================================
--- netboot/3c595.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/3c595.c	(.../trunk)	(revision 112)
@@ -20,6 +20,7 @@
 *
 *  Copyright (c) 1994 Herb Peyerl <hpeyerl@novatel.ca>
 *
+* timlegge	08-24-2003	Add Multicast Support
 */
 
 /* #define EDEBUG */
@@ -30,7 +31,7 @@
 #include "3c595.h"
 #include "timer.h"
 
-static unsigned short	eth_nic_base, eth_asic_base;
+static unsigned short	eth_nic_base;
 static unsigned short	vx_connector, vx_connectors;
 
 static struct connector_entry {
@@ -57,14 +58,12 @@
 static void vxgetlink(void);
 static void vxsetlink(void);
 
-#define	udelay(n)	waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
 /**************************************************************************
 ETH_RESET - Reset adapter
 ***************************************************************************/
 static void t595_reset(struct nic *nic)
 {
-	int i, j;
+	int i;
 
 	/***********************************************************
 			Reset 3Com 595 card
@@ -133,7 +132,7 @@
 	outw(ACK_INTR | 0xff, BASE + VX_COMMAND);
 
 	outw(SET_RX_FILTER | FIL_INDIVIDUAL |
-	    FIL_BRDCST, BASE + VX_COMMAND);
+	    FIL_BRDCST|FIL_MULTICAST, BASE + VX_COMMAND);
 
 	vxsetlink();
 /*{
@@ -228,7 +227,6 @@
 static int t595_poll(struct nic *nic)
 {
 	/* common variables */
-	unsigned short type = 0;	/* used by EDEBUG */
 	/* variables for 3C595 */
 	short status, cst;
 	register short rx_fifo;
@@ -300,12 +298,15 @@
 	outw(RX_DISCARD_TOP_PACK, BASE + VX_COMMAND);
 	while (inw(BASE + VX_STATUS) & S_COMMAND_IN_PROGRESS);
 #ifdef EDEBUG
+{
+	unsigned short type = 0;	/* used by EDEBUG */
 	type = (nic->packet[12]<<8) | nic->packet[13];
 	if(nic->packet[0]+nic->packet[1]+nic->packet[2]+nic->packet[3]+nic->packet[4]+
 	    nic->packet[5] == 0xFF*ETH_ALEN)
 		printf(",t=%hX,b]",type);
 	else
 		printf(",t=%hX]",type);
+}
 #endif
 	return 1;
 }
@@ -382,9 +383,8 @@
 static void            
 vxsetlink(void)
 {       
-    int i, j, k;
+    int i, j;
     char *reason, *warning;
-    static short prev_flags;
     static char prev_conn = -1;
 
     if (prev_conn == -1) {
@@ -438,24 +438,28 @@
     GO_WINDOW(1); 
 }
 
-static void t595_disable(struct nic *nic)
+static void t595_disable(struct dev *dev)
 {
-    outw(STOP_TRANSCEIVER, BASE + VX_COMMAND);
-    udelay(8000);
-    GO_WINDOW(4);
-    outw(0, BASE + VX_W4_MEDIA_TYPE);
-    GO_WINDOW(1);
+	struct nic *nic = (struct nic *)dev;
+	t595_reset(nic);
+
+	outw(STOP_TRANSCEIVER, BASE + VX_COMMAND);
+	udelay(8000);
+	GO_WINDOW(4);
+	outw(0, BASE + VX_W4_MEDIA_TYPE);
+	GO_WINDOW(1);
 }
 
 /**************************************************************************
 ETH_PROBE - Look for an adapter
 ***************************************************************************/
-struct nic *t595_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *pci)
+static int t595_probe(struct dev *dev, struct pci_device *pci)
 {
+	struct nic *nic = (struct nic *)dev;
 	int i;
 	unsigned short *p;
 
-	if (probeaddrs == 0 || probeaddrs[0] == 0)
+	if (pci->ioaddr == 0)
 		return 0;
 /*	eth_nic_base = probeaddrs[0] & ~3; */
 	eth_nic_base = pci->ioaddr;
@@ -487,14 +491,39 @@
 	printf("Ethernet address: %!\n", nic->node_addr);
 
 	t595_reset(nic);
-	nic->reset = t595_reset;
-	nic->poll = t595_poll;
+	dev->disable  = t595_disable;
+	nic->poll     = t595_poll;
 	nic->transmit = t595_transmit;
-	nic->disable = t595_disable;
 	return nic;
 
 }
 
+static struct pci_id t595_nics[] = {
+PCI_ROM(0x10b7, 0x5900, "3c590",           "3Com590"),		/* Vortex 10Mbps */
+PCI_ROM(0x10b7, 0x5950, "3c595",           "3Com595"),		/* Vortex 100baseTx */
+PCI_ROM(0x10b7, 0x5951, "3c595-1",         "3Com595"),		/* Vortex 100baseT4 */
+PCI_ROM(0x10b7, 0x5952, "3c595-2",         "3Com595"),		/* Vortex 100base-MII */
+PCI_ROM(0x10b7, 0x9000, "3c900-tpo",       "3Com900-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9001, "3c900-t4",        "3Com900-Combo"),	/* 10/100 T4 */
+PCI_ROM(0x10b7, 0x9004, "3c900b-tpo",      "3Com900B-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9005, "3c900b-combo",    "3Com900B-Combo"),	/* 10 Base Combo */
+PCI_ROM(0x10b7, 0x9006, "3c900b-tpb2",     "3Com900B-2/T"),	/* 10 Base TP and Base2 */
+PCI_ROM(0x10b7, 0x900a, "3c900b-fl",       "3Com900B-FL"),	/* 10 Base F */
+PCI_ROM(0x10b7, 0x9800, "3c980-cyclone-1", "3Com980-Cyclone"),	/* Cyclone */
+PCI_ROM(0x10b7, 0x9805, "3c9805-1",        "3Com9805"),		/* Dual Port Server Cyclone */
+PCI_ROM(0x10b7, 0x7646, "3csoho100-tx-1",  "3CSOHO100-TX"),	/* Hurricane */
+PCI_ROM(0x10b7, 0x4500, "3c450-1",         "3Com450 HomePNA Tornado"),
+};
+
+struct pci_driver t595_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "3C595",
+	.probe    = t595_probe,
+	.ids      = t595_nics,
+	.id_count = sizeof(t595_nics)/sizeof(t595_nics[0]),
+	.class    = 0,
+};
+
 /*
  * Local variables:
  *  c-basic-offset: 8
Index: netboot/types.h
===================================================================
--- netboot/types.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/types.h	(.../trunk)	(revision 112)
@@ -0,0 +1,44 @@
+#ifndef _TYPES_H
+#define _TYPES_H
+
+/* I'm architecture independed :-) */
+
+/* 
+ * It's architecture depended headers for common integer types
+ */
+#include "stdint.h"
+
+/* 
+ * Here are some RPC types define from linux /usr/include/rpc/types.h
+ */
+typedef int bool_t;
+typedef int enum_t;
+typedef uint32_t rpcprog_t;
+typedef uint32_t rpcvers_t;
+typedef uint32_t rpcproc_t;
+typedef uint32_t rpcprot_t;
+typedef uint32_t rpcport_t;
+
+/* For bool_t */
+typedef enum {
+ 	FALSE = 0,
+ 	TRUE = 1
+} boolean_t;
+
+
+
+/* Some BSD or RPC style types */
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+typedef long long quad_t;
+typedef unsigned long long u_quad_t;
+typedef struct {
+	int __val[2];
+}fsid_t;			/* Type of file system IDs, from bits/types.h */
+
+typedef int daddr_t;		/* The type of a disk address, from bits/types.h */
+typedef char * caddr_t;
+
+#endif /* _TYPES_H */
Index: netboot/stdint.h
===================================================================
--- netboot/stdint.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/stdint.h	(.../trunk)	(revision 112)
@@ -0,0 +1,18 @@
+#ifndef STDINT_H
+#define STDINT_H
+/* 
+ * I'm architecture depended. Check me before port GRUB
+ */
+typedef unsigned           size_t;
+
+typedef unsigned char      uint8_t;
+typedef unsigned short     uint16_t;
+typedef unsigned long      uint32_t;
+typedef unsigned long long uint64_t;
+
+typedef signed char        int8_t;
+typedef signed short       int16_t;
+typedef signed long        int32_t;
+typedef signed long long   int64_t;
+
+#endif /* STDINT_H */
Index: netboot/io.h
===================================================================
--- netboot/io.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/io.h	(.../trunk)	(revision 112)
@@ -0,0 +1,246 @@
+#ifndef	IO_H
+#define IO_H
+
+
+/* Amount of relocation etherboot is experiencing */
+extern unsigned long virt_offset;
+
+/* Don't require identity mapped physical memory,
+ * osloader.c is the only valid user at the moment.
+ */
+static inline unsigned long virt_to_phys(volatile const void *virt_addr)
+{
+	return ((unsigned long)virt_addr) + virt_offset;
+}
+
+static inline void *phys_to_virt(unsigned long phys_addr)
+{
+	return (void *)(phys_addr - virt_offset);
+}
+
+/* virt_to_bus converts an addresss inside of etherboot [_start, _end]
+ * into a memory access cards can use.
+ */
+#define virt_to_bus virt_to_phys
+
+
+/* bus_to_virt reverses virt_to_bus, the address must be output
+ * from virt_to_bus to be valid.  This function does not work on
+ * all bus addresses.
+ */
+#define bus_to_virt phys_to_virt
+
+/* ioremap converts a random 32bit bus address into something
+ * etherboot can access.
+ */
+static inline void *ioremap(unsigned long bus_addr, unsigned long length __unused)
+{
+	return bus_to_virt(bus_addr);
+}
+
+/* iounmap cleans up anything ioremap had to setup */
+static inline void iounmap(void *virt_addr __unused)
+{
+	return;
+}
+
+/*
+ * This file contains the definitions for the x86 IO instructions
+ * inb/inw/inl/outb/outw/outl and the "string versions" of the same
+ * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
+ * versions of the single-IO instructions (inb_p/inw_p/..).
+ *
+ * This file is not meant to be obfuscating: it's just complicated
+ * to (a) handle it all in a way that makes gcc able to optimize it
+ * as well as possible and (b) trying to avoid writing the same thing
+ * over and over again with slight variations and possibly making a
+ * mistake somewhere.
+ */
+
+/*
+ * Thanks to James van Artsdalen for a better timing-fix than
+ * the two short jumps: using outb's to a nonexistent port seems
+ * to guarantee better timings even on fast machines.
+ *
+ * On the other hand, I'd like to be sure of a non-existent port:
+ * I feel a bit unsafe about using 0x80 (should be safe, though)
+ *
+ *		Linus
+ */
+
+#ifdef	SLOW_IO_BY_JUMPING
+#define __SLOW_DOWN_IO __asm__ __volatile__("jmp 1f\n1:\tjmp 1f\n1:")
+#else
+#define __SLOW_DOWN_IO __asm__ __volatile__("outb %al,$0x80")
+#endif
+
+#ifdef	REALLY_SLOW_IO
+#define SLOW_DOWN_IO { __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; }
+#else
+#define SLOW_DOWN_IO __SLOW_DOWN_IO
+#endif
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the x86 architecture, we just read/write the
+ * memory location directly.
+ */
+#define readb(addr) (*(volatile unsigned char *) (addr))
+#define readw(addr) (*(volatile unsigned short *) (addr))
+#define readl(addr) (*(volatile unsigned int *) (addr))
+
+#define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
+
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+
+/*
+ * Force strict CPU ordering.
+ * And yes, this is required on UP too when we're talking
+ * to devices.
+ *
+ * For now, "wmb()" doesn't actually do anything, as all
+ * Intel CPU's follow what Intel calls a *Processor Order*,
+ * in which all writes are seen in the program order even
+ * outside the CPU.
+ *
+ * I expect future Intel CPU's to have a weaker ordering,
+ * but I'd also expect them to finally get their act together
+ * and add some real memory barriers if so.
+ *
+ * Some non intel clones support out of order store. wmb() ceases to be a
+ * nop for these.
+ */
+ 
+#define mb() 	__asm__ __volatile__ ("lock; addl $0,0(%%esp)": : :"memory")
+#define rmb()	mb()
+#define wmb()	mb();
+
+
+/*
+ * Talk about misusing macros..
+ */
+
+#define __OUT1(s,x) \
+extern void __out##s(unsigned x value, unsigned short port); \
+extern inline void __out##s(unsigned x value, unsigned short port) {
+
+#define __OUT2(s,s1,s2) \
+__asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
+
+#define __OUT(s,s1,x) \
+__OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); } \
+__OUT1(s##c,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); } \
+__OUT1(s##_p,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); SLOW_DOWN_IO; } \
+__OUT1(s##c_p,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); SLOW_DOWN_IO; }
+
+#define __IN1(s,x) \
+extern unsigned x __in##s(unsigned short port); \
+extern inline unsigned x __in##s(unsigned short port) { unsigned x _v;
+
+#define __IN2(s,s1,s2) \
+__asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
+
+#define __IN(s,s1,x,i...) \
+__IN1(s,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); return _v; } \
+__IN1(s##c,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); return _v; } \
+__IN1(s##_p,x) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); SLOW_DOWN_IO; return _v; } \
+__IN1(s##c_p,x) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); SLOW_DOWN_IO; return _v; }
+
+#define __INS(s) \
+extern void ins##s(unsigned short port, void * addr, unsigned long count); \
+extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("cld ; rep ; ins" #s \
+: "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+#define __OUTS(s) \
+extern void outs##s(unsigned short port, const void * addr, unsigned long  count); \
+extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("cld ; rep ; outs" #s \
+: "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+__IN(b,"", char)
+__IN(w,"",short)
+__IN(l,"", long)
+
+__OUT(b,"b",char)
+__OUT(w,"w",short)
+__OUT(l,,int)
+
+__INS(b)
+__INS(w)
+__INS(l)
+
+__OUTS(b)
+__OUTS(w)
+__OUTS(l)
+
+/*
+ * Note that due to the way __builtin_constant_p() works, you
+ *  - can't use it inside a inline function (it will never be true)
+ *  - you don't have to worry about side effects within the __builtin..
+ */
+#define outb(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outbc((val),(port)) : \
+	__outb((val),(port)))
+
+#define inb(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inbc(port) : \
+	__inb(port))
+
+#define outb_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outbc_p((val),(port)) : \
+	__outb_p((val),(port)))
+
+#define inb_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inbc_p(port) : \
+	__inb_p(port))
+
+#define outw(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outwc((val),(port)) : \
+	__outw((val),(port)))
+
+#define inw(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inwc(port) : \
+	__inw(port))
+
+#define outw_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outwc_p((val),(port)) : \
+	__outw_p((val),(port)))
+
+#define inw_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inwc_p(port) : \
+	__inw_p(port))
+
+#define outl(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outlc((val),(port)) : \
+	__outl((val),(port)))
+
+#define inl(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inlc(port) : \
+	__inl(port))
+
+#define outl_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outlc_p((val),(port)) : \
+	__outl_p((val),(port)))
+
+#define inl_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inlc_p(port) : \
+	__inl_p(port))
+
+#endif /* ETHERBOOT_IO_H */
Index: netboot/i386_endian.h
===================================================================
--- netboot/i386_endian.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/i386_endian.h	(.../trunk)	(revision 112)
@@ -0,0 +1,6 @@
+#ifndef ETHERBOOT_BITS_ENDIAN_H
+#define ETHERBOOT_BITS_ENDIAN_H
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#endif /* ETHERBOOT_BITS_ENDIAN_H */
Index: netboot/segoff.h
===================================================================
--- netboot/segoff.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/segoff.h	(.../trunk)	(revision 112)
@@ -0,0 +1,43 @@
+/*
+ * Segment:offset types and macros
+ *
+ * Initially written by Michael Brown (mcb30).
+ */
+
+#ifndef SEGOFF_H
+#define SEGOFF_H
+
+#include <stdint.h>
+#include <io.h>
+
+/* Segment:offset structure.  Note that the order within the structure
+ * is offset:segment.
+ */
+typedef struct {
+	uint16_t offset;
+	uint16_t segment;
+} segoff_t;
+
+/* For PXE stuff */
+typedef segoff_t SEGOFF16_t;
+
+/* Macros for converting from virtual to segment:offset addresses,
+ * when we don't actually care which of the many isomorphic results we
+ * get.
+ */
+#ifdef DEBUG_SEGMENT
+uint16_t SEGMENT ( const void * const ptr ) {
+	uint32_t phys = virt_to_phys ( ptr );
+	if ( phys > 0xfffff ) {
+		printf ( "FATAL ERROR: segment address out of range\n" );
+	}
+	return phys >> 4;
+}
+#else
+#define SEGMENT(x) ( virt_to_phys ( x ) >> 4 )
+#endif
+#define OFFSET(x) ( virt_to_phys ( x ) & 0xf )
+#define SEGOFF(x) { OFFSET(x), SEGMENT(x) }
+#define VIRTUAL(x,y) ( phys_to_virt ( ( ( x ) << 4 ) + ( y ) ) )
+
+#endif /* SEGOFF_H */
Index: netboot/via-rhine.c
===================================================================
--- netboot/via-rhine.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/via-rhine.c	(.../trunk)	(revision 112)
@@ -18,7 +18,7 @@
 
 */
 
-static const char *version = "rhine.c v1.0.0 2000-01-07\n";
+static const char *version = "rhine.c v1.0.1 2003-02-06\n";
 
 /* A few user-configurable values. */
 
@@ -46,7 +46,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 /* define all ioaddr */
 
@@ -103,6 +102,11 @@
 #define byCFGD				ioaddr + 0x7b
 #define wTallyCntMPA			ioaddr + 0x7c
 #define wTallyCntCRC			ioaddr + 0x7d
+#define bySTICKHW			ioaddr + 0x83
+#define byWOLcrClr			ioaddr + 0xA4
+#define byWOLcgClr			ioaddr + 0xA7
+#define byPwrcsrClr			ioaddr + 0xAC
+
 /*---------------------  Exioaddr Definitions -------------------------*/
 
 /*
@@ -617,9 +621,6 @@
 
 */
 
-#define PCI_VENDOR_ID_FET		0x1106
-#define PCI_DEVICE_ID_FET_3043		0x3043
-
 /* The rest of these values should never change. */
 #define NUM_TX_DESC	2	/* Number of Tx descriptor registers. */
 
@@ -652,23 +653,19 @@
 }
 rhine;
 
-static struct nic *rhine_probe1 (struct nic *dev, int ioaddr,
+static void rhine_probe1 (struct nic *nic, int ioaddr,
 				 int chip_id, int options);
 static int QueryAuto (int);
 static int ReadMII (int byMIIIndex, int);
 static void WriteMII (char, char, char, int);
 static void MIIDelay (void);
 static void rhine_init_ring (struct nic *dev);
-static void rhine_disable (struct nic *nic);
+static void rhine_disable (struct dev *dev);
 static void rhine_reset (struct nic *nic);
 static int rhine_poll (struct nic *nic);
 static void rhine_transmit (struct nic *nic, const char *d, unsigned int t,
 			    unsigned int s, const char *p);
 
-/* Linux support functions */
-#define virt_to_bus(x) ((unsigned long)x)
-#define bus_to_virt(x) ((void *)x)
-
 /* Initialize the Rx and Tx rings, along with various 'dev' bits. */
 static void
 rhine_init_ring (struct nic *nic)
@@ -854,26 +851,38 @@
     }
 }
 
-struct nic *
-rhine_probe (struct nic *nic, unsigned short *probeaddrs,
-	       struct pci_device *pci)
+static int
+rhine_probe (struct dev *dev, struct pci_device *pci)
 {
+    struct nic *nic = (struct nic *)dev;
     if (!pci->ioaddr)
-	return NULL;
-    nic = rhine_probe1 (nic, pci->ioaddr, 0, -1);
+	return 0;
+    rhine_probe1 (nic, pci->ioaddr, pci->dev_id, -1);
 
-    if (nic)
-	adjust_pci_device(pci);
-    nic->poll = rhine_poll;
-    nic->transmit = rhine_transmit;
-    nic->reset = rhine_reset;
-    nic->disable = rhine_disable;
+    adjust_pci_device(pci);
     rhine_reset (nic);
 
-    return nic;
+    dev->disable  = rhine_disable;
+    nic->poll     = rhine_poll;
+    nic->transmit = rhine_transmit;
+
+    return 1;
 }
 
-static struct nic *
+static void set_rx_mode(struct nic *nic __unused) {
+    	struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
+	unsigned char rx_mode;
+    	int ioaddr = tp->ioaddr;
+
+	/* ! IFF_PROMISC */
+	outl(0xffffffff, byMAR0);
+	outl(0xffffffff, byMAR4);
+	rx_mode = 0x0C;
+
+	outb(0x60 /* thresh */ | rx_mode, byRCR );
+}
+
+static void
 rhine_probe1 (struct nic *nic, int ioaddr, int chip_id, int options)
 {
     struct rhine_private *tp;
@@ -885,6 +894,29 @@
 
     if (rhine_debug > 0 && did_version++ == 0)
 	printf (version);
+
+    /* D-Link provided reset code (with comment additions) */
+    if((chip_id != 0x3043) && (chip_id != 0x6100)) {
+	unsigned char byOrgValue;
+	
+	if(rhine_debug > 0)
+		printf("Enabling Sticky Bit Workaround for Chip_id: 0x%hX\n"
+				, chip_id);
+	/* clear sticky bit before reset & read ethernet address */
+	byOrgValue = inb(bySTICKHW);
+	byOrgValue = byOrgValue & 0xFC;
+	outb(byOrgValue, bySTICKHW);
+
+	/* (bits written are cleared?) */
+	/* disable force PME-enable */
+	outb(0x80, byWOLcgClr);
+	/* disable power-event config bit */
+	outb(0xFF, byWOLcrClr);
+	/* clear power status (undocumented in vt6102 docs?) */
+	outb(0xFF, byPwrcsrClr);
+	
+    }
+
     /* Perhaps this should be read from the EEPROM? */
     for (i = 0; i < ETH_ALEN; i++)
 	nic->node_addr[i] = inb (byPAR0 + i);
@@ -920,6 +952,7 @@
 	}
 #endif
 
+    
     /* query MII to know LineSpeed,duplex mode */
     byMIIvalue = inb (ioaddr + 0x6d);
     LineSpeed = byMIIvalue & MIISR_SPEED;
@@ -971,15 +1004,19 @@
 	if (tp->default_port)
 	    tp->medialock = 1;
     }
-    return nic;
+    return;
 }
 
-static void
-rhine_disable (struct nic *nic)
+static void 
+rhine_disable (struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
     struct rhine_private *tp = (struct rhine_private *) nic->priv_data;
     int ioaddr = tp->ioaddr;
 
+    /* merge reset and disable */
+    rhine_reset(nic);
+
     printf ("rhine disable\n");
     /* Switch to loopback mode to avoid hardware races. */
     writeb(0x60 | 0x01, byTCR);
@@ -1002,17 +1039,10 @@
     int rx_bufs_tmp, rx_bufs_tmp1;
     int tx_bufs_tmp, tx_bufs_tmp1;
 
-#ifdef	USE_LOWMEM_BUFFER
-#define buf1 (0x10000 - (RX_RING_SIZE * PKT_BUF_SZ + 32))
-#define buf2 (buf1 - (RX_RING_SIZE * PKT_BUF_SZ + 32))
-#define desc1 (buf2 - (TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32))
-#define desc2 (desc1 - (TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32))
-#else
     static char buf1[RX_RING_SIZE * PKT_BUF_SZ + 32];
     static char buf2[RX_RING_SIZE * PKT_BUF_SZ + 32];
     static char desc1[TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32];
     static char desc2[TX_RING_SIZE * sizeof (struct rhine_tx_desc) + 32];
-#endif
 
     /* printf ("rhine_reset\n"); */
     /* Soft reset the chip. */
@@ -1069,6 +1099,9 @@
     outl (virt_to_bus (tp->rx_ring), dwCurrentRxDescAddr);
     outl (virt_to_bus (tp->tx_ring), dwCurrentTxDescAddr);
 
+    /* Setup Multicast */	
+    set_rx_mode(nic);
+
     /* close IMR */
     outw (0x0000, byIMR0);
 
@@ -1152,7 +1185,7 @@
     while (s < ETH_ZLEN)
 	*((char *) tp->tx_buffs[entry] + ETH_HLEN + (s++)) = 0;
 
-    tp->tx_ring[entry].tx_ctrl.bits.tx_buf_size = ETH_HLEN + s;
+    tp->tx_ring[entry].tx_ctrl.bits.tx_buf_size = s;
 
     tp->tx_ring[entry].tx_status.bits.own_bit = 1;
 
@@ -1170,6 +1203,9 @@
     /*printf("td4=[%X]",inl(dwCurrentTDSE3)); */
 
     outb (CR1bak, byCR1);
+    /* Wait until transmit is finished */
+    while (tp->tx_ring[entry].tx_status.bits.own_bit != 0)
+	;
     tp->cur_tx++;
 
     /*outw(IMRShadow,byIMR0); */
@@ -1177,4 +1213,21 @@
     /*tp->tx_skbuff[entry] = 0; */
 }
 
+static struct pci_id rhine_nics[] = {
+PCI_ROM(0x1106, 0x3065, "dlink-530tx",     "VIA 6102"),
+PCI_ROM(0x1106, 0x3106, "via-rhine-6105",  "VIA 6105"),
+PCI_ROM(0x1106, 0x3043, "dlink-530tx-old", "VIA 3043"),		/* Rhine-I 86c100a */
+PCI_ROM(0x1106, 0x3053, "via6105m",        "VIA 6105M"),	
+PCI_ROM(0x1106, 0x6100, "via-rhine-old",   "VIA 86C100A"),	/* Rhine-II */
+};
+
+struct pci_driver rhine_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "VIA 86C100",
+	.probe    = rhine_probe,
+	.ids      = rhine_nics,
+	.id_count = sizeof(rhine_nics)/sizeof(rhine_nics[0]),
+	.class    = 0,
+};
+
 /* EOF via-rhine.c */
Index: netboot/rpc.c
===================================================================
--- netboot/rpc.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/rpc.c	(.../trunk)	(revision 112)
@@ -0,0 +1,371 @@
+#include "grub.h"
+#include "types.h"
+#include "nic.h"
+#include "rpc.h"
+
+#define START_OPORT 700		/* mountd usually insists on secure ports */
+#define OPORT_SWEEP 200		/* make sure we don't leave secure range */
+
+static unsigned long rpc_id;
+static int oport = START_OPORT;
+
+static int await_rpc(int ival, void *ptr,
+	unsigned short ptype, struct iphdr *ip, struct udphdr *udp)
+{
+	struct rpc_pkg *rpc;
+	if (!udp) 
+		return 0;
+	if (arptable[ARP_CLIENT].ipaddr.s_addr != ip->dest.s_addr)
+		return 0;
+	if (ntohs(udp->dest) != ival)
+		return 0;
+	if (nic.packetlen < ETH_HLEN + sizeof(struct iphdr) + sizeof(struct udphdr) + 8)
+		return 0;
+	rpc = (struct rpc_pkg *)&nic.packet[ETH_HLEN];
+	if (*(unsigned long *)ptr != ntohl(rpc->rbody.xid))
+		return 0;
+	if (MSG_REPLY != ntohl(rpc->rbody.mtype))
+		return 0;
+	return 1;
+}
+
+/**************************************************************************
+RPC_ADD_CREDENTIALS - Add RPC authentication/verifier entries
+**************************************************************************/
+long *add_auth_unix(struct opaque_auth *_auth)
+{
+	int hl;
+	long *p;
+
+	/* Here's the executive summary on authentication requirements of the
+	 * various NFS server implementations:  Linux accepts both AUTH_NONE
+	 * and AUTH_UNIX authentication (also accepts an empty hostname field
+	 * in the AUTH_UNIX scheme).  *BSD refuses AUTH_NONE, but accepts
+	 * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX
+	 * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have
+	 * it (if the BOOTP/DHCP reply didn't give one, just use an empty
+	 * hostname).  */
+
+	hl = RNDUP(hostnamelen);
+
+	/* Provide an AUTH_UNIX credential.  */
+	_auth[0].flavor = htonl(AUTH_UNIX);		/* AUTH_UNIX */
+	_auth[0].length = htonl(hl+20);		/* auth length */
+	p = _auth[0].data;
+	*p++ = htonl(0);		/* stamp */
+	*p++ = htonl(hostnamelen);	/* hostname string */
+	if (hostnamelen != hl) {
+		*(p + (hl / BYTES_PER_XDR_UNIT - 1)) = 0; /* add zero padding */
+	}
+	memcpy(p, hostname, hostnamelen);
+	p += hl / BYTES_PER_XDR_UNIT;
+	*p++ = 0;			/* uid */
+	*p++ = 0;			/* gid */
+	*p++ = 0;			/* auxiliary gid list */
+
+	/* Provide an AUTH_NONE verifier.  */
+	_auth = (struct opaque_auth *)p;
+	_auth->flavor = 0;			/* AUTH_NONE */
+	_auth->length = 0;			/* auth length */
+
+	return _auth->data;
+}
+
+long *add_auth_none(struct opaque_auth *_auth)
+{
+#ifdef RPC_DEBUG
+	grub_printf("add_auth_none(auth:%d)\n", _auth);
+#endif /* RPC_DEBUG */
+	_auth[0].flavor = htonl(AUTH_NULL); /* cred */
+	_auth[0].length = htonl(0);
+	_auth[1].flavor = htonl(AUTH_NULL); /* verf */
+	_auth[1].length = htonl(0);
+#ifdef RPC_DEBUG
+	grub_printf("add_auth_none OK, returned %d\n", _auth[1].data);
+#endif /* RPC_DEBUG */
+	return _auth[1].data;
+}
+
+AUTH *__authnone_create(AUTH *_auth)
+{
+	_auth->add_auth = &add_auth_none;
+	return _auth;
+}
+/**
+ * auth_destroy
+ * 
+ * Anything is static, do nothing here
+ **/
+void auth_destroy(AUTH *_auth)
+{
+	return;
+}
+
+static int32_t *xdr_inline(XDR *xdrs, int len)
+{
+	int32_t *retval;
+
+	if (((char *)xdrs->x_private + xdrs->x_handy) <
+	    ((char *)xdrs->x_base + len ))
+		return NULL;
+	retval = (int32_t *)xdrs->x_base;
+	xdrs->x_base = (char *)xdrs->x_base + len;
+	xdrs->x_handy -= len;
+
+	return retval;
+}
+
+/** 
+ * clntudp_call
+ * 
+ * Call the remote procedure _procnum_ in remote program _prognum_ of version
+ * _versnum_, which UDP address is _sin_addr_ and port is _sin_port_.
+ **/
+static int 
+clntudp_call(CLIENT *clnt, u_long procnum, xdrproc_t inproc, char *in,
+	     xdrproc_t outproc, char *out, struct timeval tout)
+{
+	struct rpc_pkg buf, *reply;
+
+
+
+	unsigned long xid;
+	int retries;
+	long timeout, tout_ticks;
+       	struct XDR xdrs;
+	/* Must be static */
+	static int tokens = 0;
+
+#ifdef RPC_DEBUG
+	grub_printf("clntudp_call(procnum: %d)\n buf at %d\n", procnum, &buf);
+#endif /* RPC_DEBUG */
+	
+	tout_ticks = tout.tv_sec * TICKS_PER_SEC
+		+ tout.tv_usec * TICKS_PER_SEC / 1000;
+	rx_qdrain();
+	
+	xid = rpc_id++;
+	buf.cbody.xid = htonl(xid);
+	buf.cbody.mtype = htonl(MSG_CALL);
+	buf.cbody.rpcvers = htonl(2);	/* use RPC version 2 */
+	buf.cbody.prog = htonl(clnt->prognum);
+	buf.cbody.vers = htonl(clnt->versnum);
+	buf.cbody.proc = htonl(procnum);
+
+	/*
+	 * We use _x_base_ to store the heap top and _x_private_ for
+	 * the heap end. _x_handy is the max size of the heap.
+	 */
+	xdrs.x_base = xdrs.x_private 
+		= (caddr_t)clnt->cl_auth->add_auth(buf.cbody.auth);
+	xdrs.x_handy = (char *)&buf + sizeof(buf) - (char *)xdrs.x_base;
+#ifdef RPC_DEBUG
+	grub_printf("x_base at %d, x_private at %d, x_handy is %d\n",
+		    xdrs.x_base, xdrs.x_private, xdrs.x_handy);
+	grub_printf("Encoding...");
+#endif
+	/* Encoding... */
+	xdrs.x_op = XDR_ENCODE;
+	if (!inproc(&xdrs, in)){
+		/* Unable to encode */
+		return RPC_CANTENCODEARGS;
+	}
+#ifdef RPC_DEBUG
+	grub_printf("OK.\n");
+	grub_printf("x_base at %d, x_private at %d, x_handy is %d\n",
+		    xdrs.x_base, xdrs.x_private, xdrs.x_handy);
+#endif
+	/*
+	 * Try to implement something similar to a window protocol in
+	 * terms of response to losses. On successful receive, increment
+	 * the number of tokens by 1 (cap at 256). On failure, halve it.
+	 * When the number of tokens is >= 2, use a very short timeout.
+	 */
+	for (retries = 0; retries < MAX_RPC_RETRIES; retries++) {
+		if (tokens >= 2)
+			timeout = TICKS_PER_SEC/2;
+		else
+			timeout = rfc2131_sleep_interval(tout_ticks, retries);
+		udp_transmit(arptable[clnt->server].ipaddr.s_addr, clnt->sport,
+			     clnt->port, (char *)xdrs.x_base - (char *)&buf, &buf);
+		if (await_reply(await_rpc, clnt->sport, &xid, timeout)) {
+			if (tokens < 256)
+				tokens++;
+			reply = (struct rpc_pkg *)&nic.packet[ETH_HLEN];
+			if (reply->rbody.stat || reply->rbody.verifier 
+			    || reply->rbody.astatus) {
+				if (reply->rbody.stat) {
+					/* MSG_DENIED */
+					/* TODO: specify the error */
+					return RPC_AUTHERROR;
+				}
+				if (reply->rbody.astatus) {
+					/* RPC couldn't decode parameters */
+					return RPC_CANTDECODEARGS;
+				}
+			}
+			xdrs.x_base = xdrs.x_private = (char *)reply->rbody.data;
+			xdrs.x_handy = nic.packetlen - ((char *)xdrs.x_base - (char *)reply);
+#ifdef RPC_DEBUG
+			grub_printf("x_base at %d, x_private at %d, x_handy is %d\n",
+				    xdrs.x_base, xdrs.x_private, xdrs.x_handy);
+			grub_printf("Decoding...");
+#endif
+			xdrs.x_op = XDR_DECODE;
+			if (!outproc(&xdrs, out))
+				return RPC_CANTDECODERES;
+#ifdef RPC_DEBUG
+			grub_printf("OK.\n");
+			grub_printf("x_base at %d, x_private at %d, x_handy is %d\n",
+				    xdrs.x_base, xdrs.x_private, xdrs.x_handy);
+#endif
+			return RPC_SUCCESS;
+		}
+	        else
+			tokens >>= 1;
+	}
+	return RPC_CANTRECV;
+}
+
+/**
+ * xdr_mapping
+ *
+ * An XDR proc wirten by hand.
+ **/
+static bool_t xdr_mapping (XDR *xdrs, mappping *objp)
+{
+	register int32_t *buf;
+
+	if (xdrs->x_op == XDR_ENCODE) {
+		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
+		/* It may never happened in GRUB :-) */
+		if (buf == NULL)
+			return FALSE;
+		IXDR_PUT_U_LONG(buf, objp->prog);
+		IXDR_PUT_U_LONG(buf, objp->vers);
+		IXDR_PUT_U_LONG(buf, objp->prot);
+		IXDR_PUT_U_LONG(buf, objp->port);
+		return TRUE;
+	} else if (xdrs->x_op == XDR_DECODE) {
+		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
+		/* It may never happened in GRUB :-) */
+		if (buf == NULL)
+			return FALSE;
+		objp->prog = IXDR_GET_U_LONG(buf);
+		objp->vers = IXDR_GET_U_LONG(buf);
+		objp->prot = IXDR_GET_U_LONG(buf);
+		objp->port = IXDR_GET_U_LONG(buf);
+		return TRUE;
+	}
+	return TRUE;
+}
+
+bool_t xdr_u_int (XDR *xdrs, u_int *objp)
+{
+	register int32_t *buf;
+
+	if (xdrs->x_op == XDR_ENCODE) {
+		buf = XDR_INLINE (xdrs, BYTES_PER_XDR_UNIT);
+		/* It may never happened in GRUB :-) */
+		if (buf == NULL)
+			return FALSE;
+		IXDR_PUT_U_LONG(buf, *objp);
+		return TRUE;
+	} else if (xdrs->x_op == XDR_DECODE) {
+		buf = XDR_INLINE (xdrs, BYTES_PER_XDR_UNIT);
+		/* It may never happened in GRUB :-) */
+		if (buf == NULL)
+			return FALSE;
+		*objp = IXDR_GET_U_LONG(buf);
+		return TRUE;
+	}
+	return TRUE;
+}
+
+/**
+ * __pmapudp_getport
+ *
+ * Get RPC program _prognum_ of version _versnum_ port through
+ * portmap. The portmap server is specified by _pmapsrv_.
+ **/
+static
+u_short __pmapudp_getport(int pmapsrv, u_long prognum,
+			  u_long versnum)
+{
+	u_int retval;
+	CLIENT clnt_s, *clnt;
+	AUTH auth_s, *_auth;
+	struct mapping map;
+	struct timeval tout = { 25, 0 };
+
+#ifdef RPC_DEBUG
+	grub_printf("__pmapudp_getport(pmapsrv:%d, prognum:%d, versnum:%d)\n", 
+	       pmapsrv, prognum, versnum);
+#endif /* RPC_DEBUG */
+
+	/* 
+	 * Initialize the RPC parameter, which will be handled by
+	 * xdr_mapping
+	 */
+	map.prog = prognum;
+	map.vers = versnum;
+	map.prot = IPPROTO_UDP;
+	map.port = 0;
+	/* We use AUTH_NONE */
+	_auth = __authnone_create(&auth_s);
+	if (_auth == NULL)
+		return 0;
+	clnt = __clntudp_create
+		(&clnt_s, _auth, pmapsrv, PMAP_PORT, PMAP_PROG, PMAP_VERS);
+	if (clnt == NULL)
+		return 0;
+	if (clnt_call (clnt, PMAPROC_GETPORT, (xdrproc_t)xdr_mapping,
+		       (caddr_t)&map, (xdrproc_t)xdr_u_int, (caddr_t)&retval,
+		       tout) != RPC_SUCCESS) {
+		return -1;
+	}
+	return retval;
+}
+
+/**
+ * __clntudp_create
+ *
+ * Config the _clnt_ to the RPC server specified by _server_ and
+ * _port_. The RPC program is _prognum_ with version _versnum_. If
+ * _port_ == 0, use portmap to get it.
+ **/
+CLIENT *__clntudp_create(CLIENT *clnt, AUTH *_auth, int server, u_short port,
+			 u_long prognum, u_long versnum)
+{
+	unsigned long t;
+	int sport;
+#ifdef RPC_DEBUG
+	grub_printf("__clntudp_create(server:%d, port:%d, prognum:%d, versnum:%d)\n",
+	       server, port, prognum, versnum);
+#endif /* RPC_DEBUG */
+	sport = oport++;
+	if (oport > START_OPORT + OPORT_SWEEP){
+		oport = START_OPORT;
+	}
+	if (port == 0)
+		port = __pmapudp_getport(server, prognum, versnum);
+	if (port == 0){
+		/* If dynamic, we must free the clnt here */
+		return NULL;
+	}
+	/* Initial the CLIENT structure. */
+	clnt->cl_auth = _auth;
+	clnt->server = server;
+	clnt->sport = sport;
+	clnt->prognum = prognum;
+	clnt->versnum = versnum;
+	clnt->port = port;
+
+	t = currticks();
+	rpc_id = t ^ (t << 8) ^ (t << 16);
+#ifdef RPC_DEBUG
+	grub_printf("__clntudp_create OK. Port is %d, rpc_id is %d.\n",
+		    port, rpc_id);
+#endif /* RPC_DEBUG */
+	return clnt;
+}
Index: netboot/e1000.c
===================================================================
--- netboot/e1000.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/e1000.c	(.../trunk)	(revision 112)
@@ -0,0 +1,3307 @@
+/**************************************************************************
+Etherboot -  BOOTP/TFTP Bootstrap Program
+Inter Pro 1000 for Etherboot
+Drivers are port from Intel's Linux driver e1000-4.3.15
+
+***************************************************************************/
+/*******************************************************************************
+
+  
+  Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  Linux NICS <linux.nics@intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+/*
+ *  Copyright (C) Archway Digital Solutions.
+ *
+ *  written by Chrsitopher Li <cli at arcyway dot com> or <chrisl at gnuchina dot org>
+ *  2/9/2002
+ *
+ *  Copyright (C) Linux Networx.
+ *  Massive upgrade to work with the new intel gigabit NICs.
+ *  <ebiederman at lnxi dot com>
+ *
+ *  Support for 82541ei & 82547ei chips from Intel's Linux driver 5.1.13 added by
+ *  Georg Baum <gbaum@users.sf.net>, sponsored by PetaMem GmbH and linkLINE Communications, Inc.
+ */
+
+/* to get some global routines like printf */
+#include "etherboot.h"
+/* to get the interface to the body of the program */
+#include "nic.h"
+/* to get the PCI support functions, if this is a PCI NIC */
+#include "pci.h"
+#include "timer.h"
+
+typedef unsigned char *dma_addr_t;
+
+#define DEBUG 0
+
+
+/* The following defines should not be needed normally,
+ * but may be helpful for debugging purposes. */
+
+/* Define this if you want to program the transmission control register
+ * the way the Linux driver does it. */
+#undef LINUX_DRIVER_TCTL
+
+/* Define this to behave more like the Linux driver. */
+#undef LINUX_DRIVER
+
+/* Define this (and implement the needed functions) if you want to differ
+ * between port an memory mapped io. */
+#undef PORT_IO_AND_MEMORY_IO_DIFFER
+
+#include "e1000_hw.h"
+
+/* NIC specific static variables go here */
+static struct e1000_hw hw;
+static char tx_pool[128 + 16];
+static char rx_pool[128 + 16];
+static char packet[2096];
+
+static struct e1000_tx_desc *tx_base;
+static struct e1000_rx_desc *rx_base;
+
+static int tx_tail;
+static int rx_tail, rx_last;
+
+/* Function forward declarations */
+static int e1000_setup_link(struct e1000_hw *hw);
+static int e1000_setup_fiber_link(struct e1000_hw *hw);
+static int e1000_setup_copper_link(struct e1000_hw *hw);
+static int e1000_phy_setup_autoneg(struct e1000_hw *hw);
+static void e1000_config_collision_dist(struct e1000_hw *hw);
+static int e1000_config_mac_to_phy(struct e1000_hw *hw);
+static int e1000_config_fc_after_link_up(struct e1000_hw *hw);
+static int e1000_check_for_link(struct e1000_hw *hw);
+static int e1000_wait_autoneg(struct e1000_hw *hw);
+static void e1000_get_speed_and_duplex(struct e1000_hw *hw, uint16_t *speed, uint16_t *duplex);
+static int e1000_read_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t *phy_data);
+static int e1000_write_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t phy_data);
+static void e1000_phy_hw_reset(struct e1000_hw *hw);
+static int e1000_phy_reset(struct e1000_hw *hw);
+static int e1000_detect_gig_phy(struct e1000_hw *hw);
+
+/* Printing macros... */
+
+#define E1000_ERR(args...) printf("e1000: " args)
+
+#if DEBUG >= 3
+#define E1000_DBG(args...) printf("e1000: " args)
+#else
+#define E1000_DBG(args...)
+#endif
+
+#define MSGOUT(S, A, B)     printk(S "\n", A, B)
+#if DEBUG >= 2
+#define DEBUGFUNC(F)        DEBUGOUT(F "\n");
+#else
+#define DEBUGFUNC(F)
+#endif
+#if DEBUG >= 1
+#define DEBUGOUT(S) printf(S)
+#define DEBUGOUT1(S,A) printf(S,A)
+#define DEBUGOUT2(S,A,B) printf(S,A,B)
+#define DEBUGOUT3(S,A,B,C) printf(S,A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G) printf(S,A,B,C,D,E,F,G)
+#else
+#define DEBUGOUT(S)
+#define DEBUGOUT1(S,A)
+#define DEBUGOUT2(S,A,B)
+#define DEBUGOUT3(S,A,B,C)
+#define DEBUGOUT7(S,A,B,C,D,E,F,G)
+#endif
+
+#define E1000_WRITE_REG(a, reg, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        (writel((value), ((a)->hw_addr + E1000_##reg))) : \
+        (writel((value), ((a)->hw_addr + E1000_82542_##reg))))
+
+#define E1000_READ_REG(a, reg) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg) : \
+        readl((a)->hw_addr + E1000_82542_##reg))
+
+#define E1000_WRITE_REG_ARRAY(a, reg, offset, value) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        writel((value), ((a)->hw_addr + E1000_##reg + ((offset) << 2))) : \
+        writel((value), ((a)->hw_addr + E1000_82542_##reg + ((offset) << 2))))
+
+#define E1000_READ_REG_ARRAY(a, reg, offset) ( \
+    ((a)->mac_type >= e1000_82543) ? \
+        readl((a)->hw_addr + E1000_##reg + ((offset) << 2)) : \
+        readl((a)->hw_addr + E1000_82542_##reg + ((offset) << 2)))
+
+#define E1000_WRITE_FLUSH(a) {uint32_t x; x = E1000_READ_REG(a, STATUS);}
+
+static inline void e1000_pci_set_mwi(struct e1000_hw *hw)
+{
+	pci_write_config_word(hw->pdev, PCI_COMMAND, hw->pci_cmd_word);
+}
+
+static inline void e1000_pci_clear_mwi(struct e1000_hw *hw)
+{
+	pci_write_config_word(hw->pdev, PCI_COMMAND,
+			      hw->pci_cmd_word & ~PCI_COMMAND_INVALIDATE);
+}
+
+/******************************************************************************
+ * Raises the EEPROM's clock input.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * eecd - EECD's current value
+ *****************************************************************************/
+static void
+e1000_raise_ee_clk(struct e1000_hw *hw,
+                   uint32_t *eecd)
+{
+	/* Raise the clock input to the EEPROM (by setting the SK bit), and then
+	 * wait <delay> microseconds.
+	 */
+	*eecd = *eecd | E1000_EECD_SK;
+	E1000_WRITE_REG(hw, EECD, *eecd);
+	E1000_WRITE_FLUSH(hw);
+	udelay(hw->eeprom.delay_usec);
+}
+
+/******************************************************************************
+ * Lowers the EEPROM's clock input.
+ *
+ * hw - Struct containing variables accessed by shared code 
+ * eecd - EECD's current value
+ *****************************************************************************/
+static void
+e1000_lower_ee_clk(struct e1000_hw *hw,
+                   uint32_t *eecd)
+{
+	/* Lower the clock input to the EEPROM (by clearing the SK bit), and then 
+	 * wait 50 microseconds. 
+	 */
+	*eecd = *eecd & ~E1000_EECD_SK;
+	E1000_WRITE_REG(hw, EECD, *eecd);
+	E1000_WRITE_FLUSH(hw);
+	udelay(hw->eeprom.delay_usec);
+}
+
+/******************************************************************************
+ * Shift data bits out to the EEPROM.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * data - data to send to the EEPROM
+ * count - number of bits to shift out
+ *****************************************************************************/
+static void
+e1000_shift_out_ee_bits(struct e1000_hw *hw,
+                        uint16_t data,
+                        uint16_t count)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd;
+	uint32_t mask;
+	
+	/* We need to shift "count" bits out to the EEPROM. So, value in the
+	 * "data" parameter will be shifted out to the EEPROM one bit at a time.
+	 * In order to do this, "data" must be broken down into bits. 
+	 */
+	mask = 0x01 << (count - 1);
+	eecd = E1000_READ_REG(hw, EECD);
+	if (eeprom->type == e1000_eeprom_microwire) {
+		eecd &= ~E1000_EECD_DO;
+	} else if (eeprom->type == e1000_eeprom_spi) {
+		eecd |= E1000_EECD_DO;
+	}
+	do {
+		/* A "1" is shifted out to the EEPROM by setting bit "DI" to a "1",
+		 * and then raising and then lowering the clock (the SK bit controls
+		 * the clock input to the EEPROM).  A "0" is shifted out to the EEPROM
+		 * by setting "DI" to "0" and then raising and then lowering the clock.
+		 */
+		eecd &= ~E1000_EECD_DI;
+		
+		if(data & mask)
+			eecd |= E1000_EECD_DI;
+		
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		
+		udelay(eeprom->delay_usec);
+		
+		e1000_raise_ee_clk(hw, &eecd);
+		e1000_lower_ee_clk(hw, &eecd);
+		
+		mask = mask >> 1;
+		
+	} while(mask);
+
+	/* We leave the "DI" bit set to "0" when we leave this routine. */
+	eecd &= ~E1000_EECD_DI;
+	E1000_WRITE_REG(hw, EECD, eecd);
+}
+
+/******************************************************************************
+ * Shift data bits in from the EEPROM
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static uint16_t
+e1000_shift_in_ee_bits(struct e1000_hw *hw, uint16_t count)
+{
+	uint32_t eecd;
+	uint32_t i;
+	uint16_t data;
+	
+	/* In order to read a register from the EEPROM, we need to shift 'count' 
+	 * bits in from the EEPROM. Bits are "shifted in" by raising the clock
+	 * input to the EEPROM (setting the SK bit), and then reading the value of
+	 * the "DO" bit.  During this "shifting in" process the "DI" bit should
+	 * always be clear.
+	 */
+	
+	eecd = E1000_READ_REG(hw, EECD);
+	
+	eecd &= ~(E1000_EECD_DO | E1000_EECD_DI);
+	data = 0;
+	
+	for(i = 0; i < count; i++) {
+		data = data << 1;
+		e1000_raise_ee_clk(hw, &eecd);
+		
+		eecd = E1000_READ_REG(hw, EECD);
+		
+		eecd &= ~(E1000_EECD_DI);
+		if(eecd & E1000_EECD_DO)
+			data |= 1;
+		
+		e1000_lower_ee_clk(hw, &eecd);
+	}
+	
+	return data;
+}
+
+/******************************************************************************
+ * Prepares EEPROM for access
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This 
+ * function should be called before issuing a command to the EEPROM.
+ *****************************************************************************/
+static int32_t
+e1000_acquire_eeprom(struct e1000_hw *hw)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd, i=0;
+
+	eecd = E1000_READ_REG(hw, EECD);
+
+	/* Request EEPROM Access */
+	if(hw->mac_type > e1000_82544) {
+		eecd |= E1000_EECD_REQ;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		eecd = E1000_READ_REG(hw, EECD);
+		while((!(eecd & E1000_EECD_GNT)) &&
+		      (i < E1000_EEPROM_GRANT_ATTEMPTS)) {
+			i++;
+			udelay(5);
+			eecd = E1000_READ_REG(hw, EECD);
+		}
+		if(!(eecd & E1000_EECD_GNT)) {
+			eecd &= ~E1000_EECD_REQ;
+			E1000_WRITE_REG(hw, EECD, eecd);
+			DEBUGOUT("Could not acquire EEPROM grant\n");
+			return -E1000_ERR_EEPROM;
+		}
+	}
+
+	/* Setup EEPROM for Read/Write */
+
+	if (eeprom->type == e1000_eeprom_microwire) {
+		/* Clear SK and DI */
+		eecd &= ~(E1000_EECD_DI | E1000_EECD_SK);
+		E1000_WRITE_REG(hw, EECD, eecd);
+
+		/* Set CS */
+		eecd |= E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+	} else if (eeprom->type == e1000_eeprom_spi) {
+		/* Clear SK and CS */
+		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
+		E1000_WRITE_REG(hw, EECD, eecd);
+		udelay(1);
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Returns EEPROM to a "standby" state
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_standby_eeprom(struct e1000_hw *hw)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd;
+	
+	eecd = E1000_READ_REG(hw, EECD);
+
+	if(eeprom->type == e1000_eeprom_microwire) {
+
+		/* Deselect EEPROM */
+		eecd &= ~(E1000_EECD_CS | E1000_EECD_SK);
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	
+		/* Clock high */
+		eecd |= E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	
+		/* Select EEPROM */
+		eecd |= E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+
+		/* Clock low */
+		eecd &= ~E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	} else if(eeprom->type == e1000_eeprom_spi) {
+		/* Toggle CS to flush commands */
+		eecd |= E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+		eecd &= ~E1000_EECD_CS;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(eeprom->delay_usec);
+	}
+}
+
+/******************************************************************************
+ * Terminates a command by inverting the EEPROM's chip select pin
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_release_eeprom(struct e1000_hw *hw)
+{
+	uint32_t eecd;
+
+	eecd = E1000_READ_REG(hw, EECD);
+
+	if (hw->eeprom.type == e1000_eeprom_spi) {
+		eecd |= E1000_EECD_CS;  /* Pull CS high */
+		eecd &= ~E1000_EECD_SK; /* Lower SCK */
+
+		E1000_WRITE_REG(hw, EECD, eecd);
+
+		udelay(hw->eeprom.delay_usec);
+	} else if(hw->eeprom.type == e1000_eeprom_microwire) {
+		/* cleanup eeprom */
+
+		/* CS on Microwire is active-high */
+		eecd &= ~(E1000_EECD_CS | E1000_EECD_DI);
+
+		E1000_WRITE_REG(hw, EECD, eecd);
+
+		/* Rising edge of clock */
+		eecd |= E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(hw->eeprom.delay_usec);
+
+		/* Falling edge of clock */
+		eecd &= ~E1000_EECD_SK;
+		E1000_WRITE_REG(hw, EECD, eecd);
+		E1000_WRITE_FLUSH(hw);
+		udelay(hw->eeprom.delay_usec);
+	}
+
+	/* Stop requesting EEPROM access */
+	if(hw->mac_type > e1000_82544) {
+		eecd &= ~E1000_EECD_REQ;
+		E1000_WRITE_REG(hw, EECD, eecd);
+	}
+}
+
+/******************************************************************************
+ * Reads a 16 bit word from the EEPROM.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int32_t
+e1000_spi_eeprom_ready(struct e1000_hw *hw)
+{
+	uint16_t retry_count = 0;
+	uint8_t spi_stat_reg;
+
+	/* Read "Status Register" repeatedly until the LSB is cleared.  The
+	 * EEPROM will signal that the command has been completed by clearing
+	 * bit 0 of the internal status register.  If it's not cleared within
+	 * 5 milliseconds, then error out.
+	 */
+	retry_count = 0;
+	do {
+		e1000_shift_out_ee_bits(hw, EEPROM_RDSR_OPCODE_SPI,
+		hw->eeprom.opcode_bits);
+		spi_stat_reg = (uint8_t)e1000_shift_in_ee_bits(hw, 8);
+		if (!(spi_stat_reg & EEPROM_STATUS_RDY_SPI))
+			break;
+
+		udelay(5);
+		retry_count += 5;
+
+	} while(retry_count < EEPROM_MAX_RETRY_SPI);
+
+	/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and
+	 * only 0-5mSec on 5V devices)
+	 */
+	if(retry_count >= EEPROM_MAX_RETRY_SPI) {
+		DEBUGOUT("SPI EEPROM Status error\n");
+		return -E1000_ERR_EEPROM;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Reads a 16 bit word from the EEPROM.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * offset - offset of  word in the EEPROM to read
+ * data - word read from the EEPROM
+ * words - number of words to read
+ *****************************************************************************/
+static int
+e1000_read_eeprom(struct e1000_hw *hw,
+                  uint16_t offset,
+		  uint16_t words,
+                  uint16_t *data)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t i = 0;
+	
+	DEBUGFUNC("e1000_read_eeprom");
+
+	/* A check for invalid values:  offset too large, too many words, and not
+	 * enough words.
+	 */
+	if((offset > eeprom->word_size) || (words > eeprom->word_size - offset) ||
+	   (words == 0)) {
+		DEBUGOUT("\"words\" parameter out of bounds\n");
+		return -E1000_ERR_EEPROM;
+	}
+
+	/*  Prepare the EEPROM for reading  */
+	if (e1000_acquire_eeprom(hw) != E1000_SUCCESS)
+		return -E1000_ERR_EEPROM;
+
+	if(eeprom->type == e1000_eeprom_spi) {
+		uint8_t read_opcode = EEPROM_READ_OPCODE_SPI;
+
+		if(e1000_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
+
+		e1000_standby_eeprom(hw);
+
+		/* Some SPI eeproms use the 8th address bit embedded in the opcode */
+		if((eeprom->address_bits == 8) && (offset >= 128))
+			read_opcode |= EEPROM_A8_OPCODE_SPI;
+
+		/* Send the READ command (opcode + addr)  */
+		e1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
+		e1000_shift_out_ee_bits(hw, (uint16_t)(offset*2), eeprom->address_bits);
+	}
+	else if(eeprom->type == e1000_eeprom_microwire) {
+		/*  Send the READ command (opcode + addr)  */
+		e1000_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
+					eeprom->opcode_bits);
+		e1000_shift_out_ee_bits(hw, offset, eeprom->address_bits);
+	}
+
+	/* Read the data.  The address of the eeprom internally increments with
+	 * each word (microwire) or byte (spi) being read, saving on the overhead
+	 * of eeprom setup and tear-down.  The address counter will roll over if
+	 * reading beyond the size of the eeprom, thus allowing the entire memory
+	 * to be read starting from any offset. */
+	for (i = 0; i < words; i++) {
+		uint16_t word_in = e1000_shift_in_ee_bits(hw, 16);
+		if (eeprom->type == e1000_eeprom_spi)
+			word_in = (word_in >> 8) | (word_in << 8);
+		data[i] = word_in;
+	}
+
+	/* End this read operation */
+	e1000_release_eeprom(hw);
+
+	return 0;
+}
+
+/******************************************************************************
+ * Verifies that the EEPROM has a valid checksum
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Reads the first 64 16 bit words of the EEPROM and sums the values read.
+ * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM's checksum is
+ * valid.
+ *****************************************************************************/
+static int
+e1000_validate_eeprom_checksum(struct e1000_hw *hw)
+{
+	uint16_t checksum = 0;
+	uint16_t i, eeprom_data;
+
+	DEBUGFUNC("e1000_validate_eeprom_checksum");
+
+	for(i = 0; i < (EEPROM_CHECKSUM_REG + 1); i++) {
+		if(e1000_read_eeprom(hw, i, 1, &eeprom_data) < 0) {
+			DEBUGOUT("EEPROM Read Error\n");
+			return -E1000_ERR_EEPROM;
+		}
+		checksum += eeprom_data;
+	}
+	
+	if(checksum == (uint16_t) EEPROM_SUM) {
+		return 0;
+	} else {
+		DEBUGOUT("EEPROM Checksum Invalid\n");    
+		return -E1000_ERR_EEPROM;
+	}
+}
+
+/******************************************************************************
+ * Reads the adapter's MAC address from the EEPROM and inverts the LSB for the
+ * second function of dual function devices
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int 
+e1000_read_mac_addr(struct e1000_hw *hw)
+{
+	uint16_t offset;
+	uint16_t eeprom_data;
+	int i;
+
+	DEBUGFUNC("e1000_read_mac_addr");
+
+	for(i = 0; i < NODE_ADDRESS_SIZE; i += 2) {
+		offset = i >> 1;
+		if(e1000_read_eeprom(hw, offset, 1, &eeprom_data) < 0) {
+			DEBUGOUT("EEPROM Read Error\n");
+			return -E1000_ERR_EEPROM;
+		}
+		hw->mac_addr[i] = eeprom_data & 0xff;
+		hw->mac_addr[i+1] = (eeprom_data >> 8) & 0xff;
+	}
+	if((hw->mac_type == e1000_82546) &&
+		(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
+		/* Invert the last bit if this is the second device */
+		hw->mac_addr[5] ^= 1;
+	}
+	return 0;
+}
+
+/******************************************************************************
+ * Initializes receive address filters.
+ *
+ * hw - Struct containing variables accessed by shared code 
+ *
+ * Places the MAC address in receive address register 0 and clears the rest
+ * of the receive addresss registers. Clears the multicast table. Assumes
+ * the receiver is in reset when the routine is called.
+ *****************************************************************************/
+static void
+e1000_init_rx_addrs(struct e1000_hw *hw)
+{
+	uint32_t i;
+	uint32_t addr_low;
+	uint32_t addr_high;
+	
+	DEBUGFUNC("e1000_init_rx_addrs");
+	
+	/* Setup the receive address. */
+	DEBUGOUT("Programming MAC Address into RAR[0]\n");
+	addr_low = (hw->mac_addr[0] |
+		(hw->mac_addr[1] << 8) |
+		(hw->mac_addr[2] << 16) | (hw->mac_addr[3] << 24));
+	
+	addr_high = (hw->mac_addr[4] |
+		(hw->mac_addr[5] << 8) | E1000_RAH_AV);
+	
+	E1000_WRITE_REG_ARRAY(hw, RA, 0, addr_low);
+	E1000_WRITE_REG_ARRAY(hw, RA, 1, addr_high);
+	
+	/* Zero out the other 15 receive addresses. */
+	DEBUGOUT("Clearing RAR[1-15]\n");
+	for(i = 1; i < E1000_RAR_ENTRIES; i++) {
+		E1000_WRITE_REG_ARRAY(hw, RA, (i << 1), 0);
+		E1000_WRITE_REG_ARRAY(hw, RA, ((i << 1) + 1), 0);
+	}
+}
+
+/******************************************************************************
+ * Clears the VLAN filer table
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_clear_vfta(struct e1000_hw *hw)
+{
+	uint32_t offset;
+    
+	for(offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++)
+		E1000_WRITE_REG_ARRAY(hw, VFTA, offset, 0);
+}
+
+/******************************************************************************
+ * Set the phy type member in the hw struct.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int32_t
+e1000_set_phy_type(struct e1000_hw *hw)
+{
+	DEBUGFUNC("e1000_set_phy_type");
+
+	switch(hw->phy_id) {
+	case M88E1000_E_PHY_ID:
+	case M88E1000_I_PHY_ID:
+	case M88E1011_I_PHY_ID:
+		hw->phy_type = e1000_phy_m88;
+		break;
+	case IGP01E1000_I_PHY_ID:
+		hw->phy_type = e1000_phy_igp;
+		break;
+	default:
+		/* Should never have loaded on this device */
+		hw->phy_type = e1000_phy_undefined;
+		return -E1000_ERR_PHY_TYPE;
+	}
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * IGP phy init script - initializes the GbE PHY
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_phy_init_script(struct e1000_hw *hw)
+{
+	DEBUGFUNC("e1000_phy_init_script");
+
+	if(hw->phy_init_script) {
+		mdelay(10);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
+		e1000_write_phy_reg(hw,0x0000,0x0140);
+
+		mdelay(5);
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F95);
+		e1000_write_phy_reg(hw,0x0015,0x0001);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F71);
+		e1000_write_phy_reg(hw,0x0011,0xBD21);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F79);
+		e1000_write_phy_reg(hw,0x0019,0x0018);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F30);
+		e1000_write_phy_reg(hw,0x0010,0x1600);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F31);
+		e1000_write_phy_reg(hw,0x0011,0x0014);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F32);
+		e1000_write_phy_reg(hw,0x0012,0x161C);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F94);
+		e1000_write_phy_reg(hw,0x0014,0x0003);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F96);
+		e1000_write_phy_reg(hw,0x0016,0x003F);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x2010);
+		e1000_write_phy_reg(hw,0x0010,0x0008);
+
+		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
+		e1000_write_phy_reg(hw,0x0000,0x3300);
+
+
+		if(hw->mac_type == e1000_82547) {
+			uint16_t fused, fine, coarse;
+
+			/* Move to analog registers page */
+			e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+					IGP01E1000_ANALOG_REGS_PAGE);
+
+			e1000_read_phy_reg(hw, IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);
+
+			if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
+				e1000_read_phy_reg(hw, IGP01E1000_ANALOG_FUSE_STATUS, &fused);
+
+				fine = fused & IGP01E1000_ANALOG_FUSE_FINE_MASK;
+				coarse = fused & IGP01E1000_ANALOG_FUSE_COARSE_MASK;
+
+				if(coarse > IGP01E1000_ANALOG_FUSE_COARSE_THRESH) {
+					coarse -= IGP01E1000_ANALOG_FUSE_COARSE_10;
+					fine -= IGP01E1000_ANALOG_FUSE_FINE_1;
+				} else if(coarse == IGP01E1000_ANALOG_FUSE_COARSE_THRESH)
+					fine -= IGP01E1000_ANALOG_FUSE_FINE_10;
+
+				fused = (fused & IGP01E1000_ANALOG_FUSE_POLY_MASK) |
+					(fine & IGP01E1000_ANALOG_FUSE_FINE_MASK) |
+					(coarse & IGP01E1000_ANALOG_FUSE_COARSE_MASK);
+
+				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_CONTROL, fused);
+				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_BYPASS,
+						IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
+			}
+			/* Return to first page of registers */
+			e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
+					IGP01E1000_IEEE_REGS_PAGE);
+		}
+	}
+}
+
+/******************************************************************************
+ * Set the mac type member in the hw struct.
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static int
+e1000_set_mac_type(struct e1000_hw *hw)
+{
+	DEBUGFUNC("e1000_set_mac_type");
+
+	switch (hw->device_id) {
+	case E1000_DEV_ID_82542:
+		switch (hw->revision_id) {
+		case E1000_82542_2_0_REV_ID:
+			hw->mac_type = e1000_82542_rev2_0;
+			break;
+		case E1000_82542_2_1_REV_ID:
+			hw->mac_type = e1000_82542_rev2_1;
+			break;
+		default:
+			/* Invalid 82542 revision ID */
+			return -E1000_ERR_MAC_TYPE;
+		}
+		break;
+	case E1000_DEV_ID_82543GC_FIBER:
+	case E1000_DEV_ID_82543GC_COPPER:
+		hw->mac_type = e1000_82543;
+		break;
+	case E1000_DEV_ID_82544EI_COPPER:
+	case E1000_DEV_ID_82544EI_FIBER:
+	case E1000_DEV_ID_82544GC_COPPER:
+	case E1000_DEV_ID_82544GC_LOM:
+		hw->mac_type = e1000_82544;
+		break;
+	case E1000_DEV_ID_82540EM:
+	case E1000_DEV_ID_82540EM_LOM:
+	case E1000_DEV_ID_82540EP:
+	case E1000_DEV_ID_82540EP_LOM:
+	case E1000_DEV_ID_82540EP_LP:
+		hw->mac_type = e1000_82540;
+		break;
+	case E1000_DEV_ID_82545EM_COPPER:
+	case E1000_DEV_ID_82545EM_FIBER:
+		hw->mac_type = e1000_82545;
+		break;
+	case E1000_DEV_ID_82546EB_COPPER:
+	case E1000_DEV_ID_82546EB_FIBER:
+	case E1000_DEV_ID_82546EB_QUAD_COPPER:
+		hw->mac_type = e1000_82546;
+		break;
+	case E1000_DEV_ID_82541EI:
+	case E1000_DEV_ID_82541EP:
+		hw->mac_type = e1000_82541;
+		break;
+	case E1000_DEV_ID_82547EI:
+		hw->mac_type = e1000_82547;
+		break;
+	default:
+		/* Should never have loaded on this device */
+		return -E1000_ERR_MAC_TYPE;
+	}
+
+
+	return E1000_SUCCESS;
+}
+
+/******************************************************************************
+ * Reset the transmit and receive units; mask and clear all interrupts.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_reset_hw(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint32_t ctrl_ext;
+	uint32_t icr;
+	uint32_t manc;
+	
+	DEBUGFUNC("e1000_reset_hw");
+	
+	/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+		e1000_pci_clear_mwi(hw);
+	}
+
+	/* Clear interrupt mask to stop board from generating interrupts */
+	DEBUGOUT("Masking off all interrupts\n");
+	E1000_WRITE_REG(hw, IMC, 0xffffffff);
+	
+	/* Disable the Transmit and Receive units.  Then delay to allow
+	 * any pending transactions to complete before we hit the MAC with
+	 * the global reset.
+	 */
+	E1000_WRITE_REG(hw, RCTL, 0);
+	E1000_WRITE_REG(hw, TCTL, E1000_TCTL_PSP);
+	E1000_WRITE_FLUSH(hw);
+
+	/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
+	hw->tbi_compatibility_on = FALSE;
+
+	/* Delay to allow any outstanding PCI transactions to complete before
+	 * resetting the device
+	 */ 
+	mdelay(10);
+
+	/* Issue a global reset to the MAC.  This will reset the chip's
+	 * transmit, receive, DMA, and link units.  It will not effect
+	 * the current PCI configuration.  The global reset bit is self-
+	 * clearing, and should clear within a microsecond.
+	 */
+	DEBUGOUT("Issuing a global reset to MAC\n");
+	ctrl = E1000_READ_REG(hw, CTRL);
+
+	/* Must reset the PHY before resetting the MAC */
+	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+#ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
+#else
+		E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
+#endif
+		mdelay(5);
+	}
+
+#ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+	switch(hw->mac_type) {
+		case e1000_82544:
+		case e1000_82540:
+		case e1000_82545:
+		case e1000_82546:
+		case e1000_82541:
+			/* These controllers can't ack the 64-bit write when issuing the
+			 * reset, so use IO-mapping as a workaround to issue the reset */
+			E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
+			break;
+		default:
+#endif
+			E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
+#ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+			break;
+	}
+#endif
+
+	/* Force a reload from the EEPROM if necessary */
+	if(hw->mac_type < e1000_82540) {
+		/* Wait for reset to complete */
+		udelay(10);
+		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+		ctrl_ext |= E1000_CTRL_EXT_EE_RST;
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+		E1000_WRITE_FLUSH(hw);
+		/* Wait for EEPROM reload */
+		mdelay(2);
+	} else {
+		/* Wait for EEPROM reload (it happens automatically) */
+		mdelay(5);
+		/* Dissable HW ARPs on ASF enabled adapters */
+		manc = E1000_READ_REG(hw, MANC);
+		manc &= ~(E1000_MANC_ARP_EN);
+		E1000_WRITE_REG(hw, MANC, manc);
+	}
+
+	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+		e1000_phy_init_script(hw);
+	}
+
+	/* Clear interrupt mask to stop board from generating interrupts */
+	DEBUGOUT("Masking off all interrupts\n");
+	E1000_WRITE_REG(hw, IMC, 0xffffffff);
+	
+	/* Clear any pending interrupt events. */
+	icr = E1000_READ_REG(hw, ICR);
+
+	/* If MWI was previously enabled, reenable it. */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+#ifdef LINUX_DRIVER
+		if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
+#endif
+			e1000_pci_set_mwi(hw);
+	}
+}
+
+/******************************************************************************
+ * Performs basic configuration of the adapter.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * 
+ * Assumes that the controller has previously been reset and is in a 
+ * post-reset uninitialized state. Initializes the receive address registers,
+ * multicast table, and VLAN filter table. Calls routines to setup link
+ * configuration and flow control settings. Clears all on-chip counters. Leaves
+ * the transmit and receive units disabled and uninitialized.
+ *****************************************************************************/
+static int
+e1000_init_hw(struct e1000_hw *hw)
+{
+	uint32_t ctrl, status;
+	uint32_t i;
+	int32_t ret_val;
+	uint16_t pcix_cmd_word;
+	uint16_t pcix_stat_hi_word;
+	uint16_t cmd_mmrbc;
+	uint16_t stat_mmrbc;
+	e1000_bus_type bus_type = e1000_bus_type_unknown;
+
+	DEBUGFUNC("e1000_init_hw");
+
+#if 0
+	/* Initialize Identification LED */
+	ret_val = e1000_id_led_init(hw);
+	if(ret_val < 0) {
+		DEBUGOUT("Error Initializing Identification LED\n");
+		return ret_val;
+	}
+#endif
+	
+	/* Set the Media Type and exit with error if it is not valid. */
+	if(hw->mac_type != e1000_82543) {
+		/* tbi_compatibility is only valid on 82543 */
+		hw->tbi_compatibility_en = FALSE;
+	}
+	
+	if(hw->mac_type >= e1000_82543) {
+		status = E1000_READ_REG(hw, STATUS);
+		if(status & E1000_STATUS_TBIMODE) {
+			hw->media_type = e1000_media_type_fiber;
+			/* tbi_compatibility not valid on fiber */
+			hw->tbi_compatibility_en = FALSE;
+		} else {
+			hw->media_type = e1000_media_type_copper;
+		}
+	} else {
+		/* This is an 82542 (fiber only) */
+		hw->media_type = e1000_media_type_fiber;
+	}
+	
+	/* Disabling VLAN filtering. */
+	DEBUGOUT("Initializing the IEEE VLAN\n");
+	E1000_WRITE_REG(hw, VET, 0);
+	
+	e1000_clear_vfta(hw);
+	
+	/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+		DEBUGOUT("Disabling MWI on 82542 rev 2.0\n");
+		e1000_pci_clear_mwi(hw);
+		E1000_WRITE_REG(hw, RCTL, E1000_RCTL_RST);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(5);
+	}
+	
+	/* Setup the receive address. This involves initializing all of the Receive
+	 * Address Registers (RARs 0 - 15).
+	 */
+	e1000_init_rx_addrs(hw);
+	
+	/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
+	if(hw->mac_type == e1000_82542_rev2_0) {
+		E1000_WRITE_REG(hw, RCTL, 0);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(1);
+#ifdef LINUX_DRIVER
+		if(hw->pci_cmd_word & CMD_MEM_WRT_INVALIDATE)
+#endif
+			e1000_pci_set_mwi(hw);
+	}
+	
+	/* Zero out the Multicast HASH table */
+	DEBUGOUT("Zeroing the MTA\n");
+	for(i = 0; i < E1000_MC_TBL_SIZE; i++)
+		E1000_WRITE_REG_ARRAY(hw, MTA, i, 0);
+	
+#if 0
+	/* Set the PCI priority bit correctly in the CTRL register.  This
+	 * determines if the adapter gives priority to receives, or if it
+	 * gives equal priority to transmits and receives.
+	 */
+	if(hw->dma_fairness) {
+		ctrl = E1000_READ_REG(hw, CTRL);
+		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PRIOR);
+	}
+#endif
+	if (hw->mac_type >= e1000_82543) {
+		status = E1000_READ_REG(hw, STATUS);
+		bus_type = (status & E1000_STATUS_PCIX_MODE) ?
+			e1000_bus_type_pcix : e1000_bus_type_pci;
+	}
+	
+	/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
+	if(bus_type == e1000_bus_type_pcix) {
+		pci_read_config_word(hw->pdev, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
+		pci_read_config_word(hw->pdev, PCIX_STATUS_REGISTER_HI, &pcix_stat_hi_word);
+		cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
+			PCIX_COMMAND_MMRBC_SHIFT;
+		stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
+			PCIX_STATUS_HI_MMRBC_SHIFT;
+		if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
+			stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
+		if(cmd_mmrbc > stat_mmrbc) {
+			pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
+			pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
+			pci_write_config_word(hw->pdev, PCIX_COMMAND_REGISTER, pcix_cmd_word);
+		}
+	}
+	
+	/* Call a subroutine to configure the link and setup flow control. */
+	ret_val = e1000_setup_link(hw);
+	
+	/* Set the transmit descriptor write-back policy */
+	if(hw->mac_type > e1000_82544) {
+		ctrl = E1000_READ_REG(hw, TXDCTL);
+		ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
+		E1000_WRITE_REG(hw, TXDCTL, ctrl);
+	}
+#if 0
+	/* Clear all of the statistics registers (clear on read).  It is
+	 * important that we do this after we have tried to establish link
+	 * because the symbol error count will increment wildly if there
+	 * is no link.
+	 */
+	e1000_clear_hw_cntrs(hw);
+#endif
+
+	return ret_val;
+}
+
+/******************************************************************************
+ * Configures flow control and link settings.
+ * 
+ * hw - Struct containing variables accessed by shared code
+ * 
+ * Determines which flow control settings to use. Calls the apropriate media-
+ * specific link configuration function. Configures the flow control settings.
+ * Assuming the adapter has a valid link partner, a valid link should be
+ * established. Assumes the hardware has previously been reset and the 
+ * transmitter and receiver are not enabled.
+ *****************************************************************************/
+static int
+e1000_setup_link(struct e1000_hw *hw)
+{
+	uint32_t ctrl_ext;
+	int32_t ret_val;
+	uint16_t eeprom_data;
+
+	DEBUGFUNC("e1000_setup_link");
+	
+	/* Read and store word 0x0F of the EEPROM. This word contains bits
+	 * that determine the hardware's default PAUSE (flow control) mode,
+	 * a bit that determines whether the HW defaults to enabling or
+	 * disabling auto-negotiation, and the direction of the
+	 * SW defined pins. If there is no SW over-ride of the flow
+	 * control setting, then the variable hw->fc will
+	 * be initialized based on a value in the EEPROM.
+	 */
+	if(e1000_read_eeprom(hw, EEPROM_INIT_CONTROL2_REG, 1, &eeprom_data) < 0) {
+		DEBUGOUT("EEPROM Read Error\n");
+		return -E1000_ERR_EEPROM;
+	}
+	
+	if(hw->fc == e1000_fc_default) {
+		if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 0)
+			hw->fc = e1000_fc_none;
+		else if((eeprom_data & EEPROM_WORD0F_PAUSE_MASK) == 
+			EEPROM_WORD0F_ASM_DIR)
+			hw->fc = e1000_fc_tx_pause;
+		else
+			hw->fc = e1000_fc_full;
+	}
+	
+	/* We want to save off the original Flow Control configuration just
+	 * in case we get disconnected and then reconnected into a different
+	 * hub or switch with different Flow Control capabilities.
+	 */
+	if(hw->mac_type == e1000_82542_rev2_0)
+		hw->fc &= (~e1000_fc_tx_pause);
+	
+	if((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
+		hw->fc &= (~e1000_fc_rx_pause);
+	
+	hw->original_fc = hw->fc;
+	
+	DEBUGOUT1("After fix-ups FlowControl is now = %x\n", hw->fc);
+	
+	/* Take the 4 bits from EEPROM word 0x0F that determine the initial
+	 * polarity value for the SW controlled pins, and setup the
+	 * Extended Device Control reg with that info.
+	 * This is needed because one of the SW controlled pins is used for
+	 * signal detection.  So this should be done before e1000_setup_pcs_link()
+	 * or e1000_phy_setup() is called.
+	 */
+	if(hw->mac_type == e1000_82543) {
+		ctrl_ext = ((eeprom_data & EEPROM_WORD0F_SWPDIO_EXT) << 
+			SWDPIO__EXT_SHIFT);
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+	}
+	
+	/* Call the necessary subroutine to configure the link. */
+	ret_val = (hw->media_type == e1000_media_type_fiber) ?
+		e1000_setup_fiber_link(hw) :
+		e1000_setup_copper_link(hw);
+	if (ret_val < 0) {
+		return ret_val;
+	}
+	
+	/* Initialize the flow control address, type, and PAUSE timer
+	 * registers to their default values.  This is done even if flow
+	 * control is disabled, because it does not hurt anything to
+	 * initialize these registers.
+	 */
+	DEBUGOUT("Initializing the Flow Control address, type and timer regs\n");
+	
+	E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
+	E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
+	E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
+	E1000_WRITE_REG(hw, FCTTV, hw->fc_pause_time);
+	
+	/* Set the flow control receive threshold registers.  Normally,
+	 * these registers will be set to a default threshold that may be
+	 * adjusted later by the driver's runtime code.  However, if the
+	 * ability to transmit pause frames in not enabled, then these
+	 * registers will be set to 0. 
+	 */
+	if(!(hw->fc & e1000_fc_tx_pause)) {
+		E1000_WRITE_REG(hw, FCRTL, 0);
+		E1000_WRITE_REG(hw, FCRTH, 0);
+	} else {
+		/* We need to set up the Receive Threshold high and low water marks
+		 * as well as (optionally) enabling the transmission of XON frames.
+		 */
+		if(hw->fc_send_xon) {
+			E1000_WRITE_REG(hw, FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
+			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
+		} else {
+			E1000_WRITE_REG(hw, FCRTL, hw->fc_low_water);
+			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
+		}
+	}
+	return ret_val;
+}
+
+/******************************************************************************
+ * Sets up link for a fiber based adapter
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Manipulates Physical Coding Sublayer functions in order to configure
+ * link. Assumes the hardware has been previously reset and the transmitter
+ * and receiver are not enabled.
+ *****************************************************************************/
+static int
+e1000_setup_fiber_link(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint32_t status;
+	uint32_t txcw = 0;
+	uint32_t i;
+	uint32_t signal;
+	int32_t ret_val;
+
+	DEBUGFUNC("e1000_setup_fiber_link");
+
+	/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
+	 * set when the optics detect a signal. On older adapters, it will be 
+	 * cleared when there is a signal
+	 */
+	ctrl = E1000_READ_REG(hw, CTRL);
+	if(hw->mac_type > e1000_82544) signal = E1000_CTRL_SWDPIN1;
+	else signal = 0;
+	
+	/* Take the link out of reset */
+	ctrl &= ~(E1000_CTRL_LRST);
+	
+	e1000_config_collision_dist(hw);
+	
+	/* Check for a software override of the flow control settings, and setup
+	 * the device accordingly.  If auto-negotiation is enabled, then software
+	 * will have to set the "PAUSE" bits to the correct value in the Tranmsit
+	 * Config Word Register (TXCW) and re-start auto-negotiation.  However, if
+	 * auto-negotiation is disabled, then software will have to manually 
+	 * configure the two flow control enable bits in the CTRL register.
+	 *
+	 * The possible values of the "fc" parameter are:
+	 *      0:  Flow control is completely disabled
+	 *      1:  Rx flow control is enabled (we can receive pause frames, but 
+	 *          not send pause frames).
+	 *      2:  Tx flow control is enabled (we can send pause frames but we do
+	 *          not support receiving pause frames).
+	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
+	 */
+	switch (hw->fc) {
+	case e1000_fc_none:
+		/* Flow control is completely disabled by a software over-ride. */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD);
+		break;
+	case e1000_fc_rx_pause:
+		/* RX Flow control is enabled and TX Flow control is disabled by a 
+		 * software over-ride. Since there really isn't a way to advertise 
+		 * that we are capable of RX Pause ONLY, we will advertise that we
+		 * support both symmetric and asymmetric RX PAUSE. Later, we will
+		 *  disable the adapter's ability to send PAUSE frames.
+		 */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+		break;
+	case e1000_fc_tx_pause:
+		/* TX Flow control is enabled, and RX Flow control is disabled, by a 
+		 * software over-ride.
+		 */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_ASM_DIR);
+		break;
+	case e1000_fc_full:
+		/* Flow control (both RX and TX) is enabled by a software over-ride. */
+		txcw = (E1000_TXCW_ANE | E1000_TXCW_FD | E1000_TXCW_PAUSE_MASK);
+		break;
+	default:
+		DEBUGOUT("Flow control param set incorrectly\n");
+		return -E1000_ERR_CONFIG;
+		break;
+	}
+	
+	/* Since auto-negotiation is enabled, take the link out of reset (the link
+	 * will be in reset, because we previously reset the chip). This will
+	 * restart auto-negotiation.  If auto-neogtiation is successful then the
+	 * link-up status bit will be set and the flow control enable bits (RFCE
+	 * and TFCE) will be set according to their negotiated value.
+	 */
+	DEBUGOUT("Auto-negotiation enabled\n");
+	
+	E1000_WRITE_REG(hw, TXCW, txcw);
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	E1000_WRITE_FLUSH(hw);
+	
+	hw->txcw = txcw;
+	mdelay(1);
+	
+	/* If we have a signal (the cable is plugged in) then poll for a "Link-Up"
+	 * indication in the Device Status Register.  Time-out if a link isn't 
+	 * seen in 500 milliseconds seconds (Auto-negotiation should complete in 
+	 * less than 500 milliseconds even if the other end is doing it in SW).
+	 */
+	if((E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
+		DEBUGOUT("Looking for Link\n");
+		for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
+			mdelay(10);
+			status = E1000_READ_REG(hw, STATUS);
+			if(status & E1000_STATUS_LU) break;
+		}
+		if(i == (LINK_UP_TIMEOUT / 10)) {
+			/* AutoNeg failed to achieve a link, so we'll call 
+			 * e1000_check_for_link. This routine will force the link up if we
+			 * detect a signal. This will allow us to communicate with
+			 * non-autonegotiating link partners.
+			 */
+			DEBUGOUT("Never got a valid link from auto-neg!!!\n");
+			hw->autoneg_failed = 1;
+			ret_val = e1000_check_for_link(hw);
+			if(ret_val < 0) {
+				DEBUGOUT("Error while checking for link\n");
+				return ret_val;
+			}
+			hw->autoneg_failed = 0;
+		} else {
+			hw->autoneg_failed = 0;
+			DEBUGOUT("Valid Link Found\n");
+		}
+	} else {
+		DEBUGOUT("No Signal Detected\n");
+	}
+	return 0;
+}
+
+/******************************************************************************
+* Detects which PHY is present and the speed and duplex
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_setup_copper_link(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	int32_t ret_val;
+	uint16_t i;
+	uint16_t phy_data;
+	
+	DEBUGFUNC("e1000_setup_copper_link");
+	
+	ctrl = E1000_READ_REG(hw, CTRL);
+	/* With 82543, we need to force speed and duplex on the MAC equal to what
+	 * the PHY speed and duplex configuration is. In addition, we need to
+	 * perform a hardware reset on the PHY to take it out of reset.
+	 */
+	if(hw->mac_type > e1000_82543) {
+		ctrl |= E1000_CTRL_SLU;
+		ctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+	} else {
+		ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX | E1000_CTRL_SLU);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		e1000_phy_hw_reset(hw);
+	}
+	
+	/* Make sure we have a valid PHY */
+	ret_val = e1000_detect_gig_phy(hw);
+	if(ret_val < 0) {
+		DEBUGOUT("Error, did not detect valid phy.\n");
+		return ret_val;
+	}
+	DEBUGOUT1("Phy ID = %x \n", hw->phy_id);
+
+	if (hw->phy_type == e1000_phy_igp) {
+
+		ret_val = e1000_phy_reset(hw);
+		if(ret_val < 0) {
+			DEBUGOUT("Error Resetting the PHY\n");
+			return ret_val;
+		}
+
+		/* Wait 10ms for MAC to configure PHY from eeprom settings */
+		mdelay(15);
+
+		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
+			DEBUGOUT("PHY Write Error\n");
+			return -E1000_ERR_PHY;
+		}
+
+		if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
+			/* Disable SmartSpeed */
+			if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
+						&phy_data) < 0) {
+				DEBUGOUT("PHY Read Error\n");
+				return -E1000_ERR_PHY;
+			}
+			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
+			if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
+						phy_data) < 0) {
+				DEBUGOUT("PHY Write Error\n");
+				return -E1000_ERR_PHY;
+			}
+			/* Set auto Master/Slave resolution process */
+			if(e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data) < 0) {
+				DEBUGOUT("PHY Read Error\n");
+				return -E1000_ERR_PHY;
+			}
+			phy_data &= ~CR_1000T_MS_ENABLE;
+			if(e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data) < 0) {
+				DEBUGOUT("PHY Write Error\n");
+				return -E1000_ERR_PHY;
+			}
+		}
+
+		if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+
+		/* Force MDI for IGP PHY */
+		phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
+			      IGP01E1000_PSCR_FORCE_MDI_MDIX);
+
+		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data) < 0) {
+			DEBUGOUT("PHY Write Error\n");
+			return -E1000_ERR_PHY;
+		}
+
+	} else {
+		/* Enable CRS on TX. This must be set for half-duplex operation. */
+		if(e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
+		phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+
+		/* Options:
+		 *   disable_polarity_correction = 0 (default)
+		 *       Automatic Correction for Reversed Cable Polarity
+		 *   0 - Disabled
+		 *   1 - Enabled
+		 */
+		phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
+		if(e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
+			DEBUGOUT("PHY Write Error\n");
+			return -E1000_ERR_PHY;
+		}
+
+		/* Force TX_CLK in the Extended PHY Specific Control Register
+		 * to 25MHz clock.
+		 */
+		if(e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		phy_data |= M88E1000_EPSCR_TX_CLK_25;
+
+#ifdef LINUX_DRIVER
+		if (hw->phy_revision < M88E1011_I_REV_4) {
+#endif
+			/* Configure Master and Slave downshift values */
+			phy_data &= ~(M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK |
+				M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
+			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
+				M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
+			if(e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+					       phy_data) < 0) {
+				DEBUGOUT("PHY Write Error\n");
+				return -E1000_ERR_PHY;
+			}
+		}
+	
+		/* SW Reset the PHY so all changes take effect */
+		ret_val = e1000_phy_reset(hw);
+		if(ret_val < 0) {
+			DEBUGOUT("Error Resetting the PHY\n");
+			return ret_val;
+#ifdef LINUX_DRIVER
+		}
+#endif
+	}
+	
+	/* Options:
+	 *   autoneg = 1 (default)
+	 *      PHY will advertise value(s) parsed from
+	 *      autoneg_advertised and fc
+	 *   autoneg = 0
+	 *      PHY will be set to 10H, 10F, 100H, or 100F
+	 *      depending on value parsed from forced_speed_duplex.
+	 */
+	
+	/* Is autoneg enabled?  This is enabled by default or by software override.
+	 * If so, call e1000_phy_setup_autoneg routine to parse the
+	 * autoneg_advertised and fc options. If autoneg is NOT enabled, then the
+	 * user should have provided a speed/duplex override.  If so, then call
+	 * e1000_phy_force_speed_duplex to parse and set this up.
+	 */
+	/* Perform some bounds checking on the hw->autoneg_advertised
+	 * parameter.  If this variable is zero, then set it to the default.
+	 */
+	hw->autoneg_advertised &= AUTONEG_ADVERTISE_SPEED_DEFAULT;
+	
+	/* If autoneg_advertised is zero, we assume it was not defaulted
+	 * by the calling code so we set to advertise full capability.
+	 */
+	if(hw->autoneg_advertised == 0)
+		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+	
+	DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
+	ret_val = e1000_phy_setup_autoneg(hw);
+	if(ret_val < 0) {
+		DEBUGOUT("Error Setting up Auto-Negotiation\n");
+		return ret_val;
+	}
+	DEBUGOUT("Restarting Auto-Neg\n");
+	
+	/* Restart auto-negotiation by setting the Auto Neg Enable bit and
+	 * the Auto Neg Restart bit in the PHY control register.
+	 */
+	if(e1000_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
+		DEBUGOUT("PHY Read Error\n");
+		return -E1000_ERR_PHY;
+	}
+	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
+	if(e1000_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
+		DEBUGOUT("PHY Write Error\n");
+		return -E1000_ERR_PHY;
+	}
+
+#if 0	
+	/* Does the user want to wait for Auto-Neg to complete here, or
+	 * check at a later time (for example, callback routine).
+	 */
+	if(hw->wait_autoneg_complete) {
+		ret_val = e1000_wait_autoneg(hw);
+		if(ret_val < 0) {
+			DEBUGOUT("Error while waiting for autoneg to complete\n");
+			return ret_val;
+		}
+	}
+#else
+	/* If we do not wait for autonegotiation to complete I 
+	 * do not see a valid link status.
+	 */
+	ret_val = e1000_wait_autoneg(hw);
+	if(ret_val < 0) {
+		DEBUGOUT("Error while waiting for autoneg to complete\n");
+		return ret_val;
+	}
+#endif
+	
+	/* Check link status. Wait up to 100 microseconds for link to become
+	 * valid.
+	 */
+	for(i = 0; i < 10; i++) {
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(phy_data & MII_SR_LINK_STATUS) {
+			/* We have link, so we need to finish the config process:
+			 *   1) Set up the MAC to the current PHY speed/duplex
+			 *      if we are on 82543.  If we
+			 *      are on newer silicon, we only need to configure
+			 *      collision distance in the Transmit Control Register.
+			 *   2) Set up flow control on the MAC to that established with
+			 *      the link partner.
+			 */
+			if(hw->mac_type >= e1000_82544) {
+				e1000_config_collision_dist(hw);
+			} else {
+				ret_val = e1000_config_mac_to_phy(hw);
+				if(ret_val < 0) {
+					DEBUGOUT("Error configuring MAC to PHY settings\n");
+					return ret_val;
+				}
+			}
+			ret_val = e1000_config_fc_after_link_up(hw);
+			if(ret_val < 0) {
+				DEBUGOUT("Error Configuring Flow Control\n");
+				return ret_val;
+			}
+			DEBUGOUT("Valid link established!!!\n");
+			return 0;
+		}
+		udelay(10);
+	}
+	
+	DEBUGOUT("Unable to establish link!!!\n");
+	return -E1000_ERR_NOLINK;
+}
+
+/******************************************************************************
+* Configures PHY autoneg and flow control advertisement settings
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_phy_setup_autoneg(struct e1000_hw *hw)
+{
+	uint16_t mii_autoneg_adv_reg;
+	uint16_t mii_1000t_ctrl_reg;
+
+	DEBUGFUNC("e1000_phy_setup_autoneg");
+	
+	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
+	if(e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg) < 0) {
+		DEBUGOUT("PHY Read Error\n");
+		return -E1000_ERR_PHY;
+	}
+
+	/* Read the MII 1000Base-T Control Register (Address 9). */
+	if(e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg) < 0) {
+		DEBUGOUT("PHY Read Error\n");
+		return -E1000_ERR_PHY;
+	}
+
+	/* Need to parse both autoneg_advertised and fc and set up
+	 * the appropriate PHY registers.  First we will parse for
+	 * autoneg_advertised software override.  Since we can advertise
+	 * a plethora of combinations, we need to check each bit
+	 * individually.
+	 */
+	
+	/* First we clear all the 10/100 mb speed bits in the Auto-Neg
+	 * Advertisement Register (Address 4) and the 1000 mb speed bits in
+	 * the  1000Base-T Control Register (Address 9).
+	 */
+	mii_autoneg_adv_reg &= ~REG4_SPEED_MASK;
+	mii_1000t_ctrl_reg &= ~REG9_SPEED_MASK;
+
+	DEBUGOUT1("autoneg_advertised %x\n", hw->autoneg_advertised);
+
+	/* Do we want to advertise 10 Mb Half Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_10_HALF) {
+		DEBUGOUT("Advertise 10mb Half duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_10T_HD_CAPS;
+	}
+
+	/* Do we want to advertise 10 Mb Full Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_10_FULL) {
+		DEBUGOUT("Advertise 10mb Full duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_10T_FD_CAPS;
+	}
+
+	/* Do we want to advertise 100 Mb Half Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_100_HALF) {
+		DEBUGOUT("Advertise 100mb Half duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_100TX_HD_CAPS;
+	}
+
+	/* Do we want to advertise 100 Mb Full Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_100_FULL) {
+		DEBUGOUT("Advertise 100mb Full duplex\n");
+		mii_autoneg_adv_reg |= NWAY_AR_100TX_FD_CAPS;
+	}
+
+	/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
+	if(hw->autoneg_advertised & ADVERTISE_1000_HALF) {
+		DEBUGOUT("Advertise 1000mb Half duplex requested, request denied!\n");
+	}
+
+	/* Do we want to advertise 1000 Mb Full Duplex? */
+	if(hw->autoneg_advertised & ADVERTISE_1000_FULL) {
+		DEBUGOUT("Advertise 1000mb Full duplex\n");
+		mii_1000t_ctrl_reg |= CR_1000T_FD_CAPS;
+	}
+
+	/* Check for a software override of the flow control settings, and
+	 * setup the PHY advertisement registers accordingly.  If
+	 * auto-negotiation is enabled, then software will have to set the
+	 * "PAUSE" bits to the correct value in the Auto-Negotiation
+	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.
+	 *
+	 * The possible values of the "fc" parameter are:
+	 *      0:  Flow control is completely disabled
+	 *      1:  Rx flow control is enabled (we can receive pause frames
+	 *          but not send pause frames).
+	 *      2:  Tx flow control is enabled (we can send pause frames
+	 *          but we do not support receiving pause frames).
+	 *      3:  Both Rx and TX flow control (symmetric) are enabled.
+	 *  other:  No software override.  The flow control configuration
+	 *          in the EEPROM is used.
+	 */
+	switch (hw->fc) {
+	case e1000_fc_none: /* 0 */
+		/* Flow control (RX & TX) is completely disabled by a
+		 * software over-ride.
+		 */
+		mii_autoneg_adv_reg &= ~(NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+		break;
+	case e1000_fc_rx_pause: /* 1 */
+		/* RX Flow control is enabled, and TX Flow control is
+		 * disabled, by a software over-ride.
+		 */
+		/* Since there really isn't a way to advertise that we are
+		 * capable of RX Pause ONLY, we will advertise that we
+		 * support both symmetric and asymmetric RX PAUSE.  Later
+		 * (in e1000_config_fc_after_link_up) we will disable the
+		 *hw's ability to send PAUSE frames.
+		 */
+		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+		break;
+	case e1000_fc_tx_pause: /* 2 */
+		/* TX Flow control is enabled, and RX Flow control is
+		 * disabled, by a software over-ride.
+		 */
+		mii_autoneg_adv_reg |= NWAY_AR_ASM_DIR;
+		mii_autoneg_adv_reg &= ~NWAY_AR_PAUSE;
+		break;
+	case e1000_fc_full: /* 3 */
+		/* Flow control (both RX and TX) is enabled by a software
+		 * over-ride.
+		 */
+		mii_autoneg_adv_reg |= (NWAY_AR_ASM_DIR | NWAY_AR_PAUSE);
+		break;
+	default:
+		DEBUGOUT("Flow control param set incorrectly\n");
+		return -E1000_ERR_CONFIG;
+	}
+
+	if(e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg) < 0) {
+		DEBUGOUT("PHY Write Error\n");
+		return -E1000_ERR_PHY;
+	}
+
+	DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
+
+	if(e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg) < 0) {
+		DEBUGOUT("PHY Write Error\n");
+		return -E1000_ERR_PHY;
+	}
+	return 0;
+}
+
+/******************************************************************************
+* Sets the collision distance in the Transmit Control register
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Link should have been established previously. Reads the speed and duplex
+* information from the Device Status register.
+******************************************************************************/
+static void
+e1000_config_collision_dist(struct e1000_hw *hw)
+{
+	uint32_t tctl;
+
+	tctl = E1000_READ_REG(hw, TCTL);
+	
+	tctl &= ~E1000_TCTL_COLD;
+	tctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;
+	
+	E1000_WRITE_REG(hw, TCTL, tctl);
+	E1000_WRITE_FLUSH(hw);
+}
+
+/******************************************************************************
+* Sets MAC speed and duplex settings to reflect the those in the PHY
+*
+* hw - Struct containing variables accessed by shared code
+* mii_reg - data to write to the MII control register
+*
+* The contents of the PHY register containing the needed information need to
+* be passed in.
+******************************************************************************/
+static int
+e1000_config_mac_to_phy(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint16_t phy_data;
+
+	DEBUGFUNC("e1000_config_mac_to_phy");
+
+	/* Read the Device Control Register and set the bits to Force Speed
+	 * and Duplex.
+	 */
+	ctrl = E1000_READ_REG(hw, CTRL);
+	ctrl |= (E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);
+	ctrl &= ~(E1000_CTRL_SPD_SEL | E1000_CTRL_ILOS);
+
+	/* Set up duplex in the Device Control and Transmit Control
+	 * registers depending on negotiated values.
+	 */
+	if (hw->phy_type == e1000_phy_igp) {
+		if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
+		else ctrl &= ~E1000_CTRL_FD;
+
+		e1000_config_collision_dist(hw);
+
+		/* Set up speed in the Device Control register depending on
+		 * negotiated values.
+		 */
+		if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
+		   IGP01E1000_PSSR_SPEED_1000MBPS)
+			ctrl |= E1000_CTRL_SPD_1000;
+		else if((phy_data & IGP01E1000_PSSR_SPEED_MASK) ==
+			IGP01E1000_PSSR_SPEED_100MBPS)
+			ctrl |= E1000_CTRL_SPD_100;
+	} else {
+		if(e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
+		else ctrl &= ~E1000_CTRL_FD;
+
+		e1000_config_collision_dist(hw);
+
+		/* Set up speed in the Device Control register depending on
+		 * negotiated values.
+		 */
+		if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_1000MBS)
+			ctrl |= E1000_CTRL_SPD_1000;
+		else if((phy_data & M88E1000_PSSR_SPEED) == M88E1000_PSSR_100MBS)
+			ctrl |= E1000_CTRL_SPD_100;
+	}
+	/* Write the configured values back to the Device Control Reg. */
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	return 0;
+}
+
+/******************************************************************************
+ * Forces the MAC's flow control settings.
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Sets the TFCE and RFCE bits in the device control register to reflect
+ * the adapter settings. TFCE and RFCE need to be explicitly set by
+ * software when a Copper PHY is used because autonegotiation is managed
+ * by the PHY rather than the MAC. Software must also configure these
+ * bits when link is forced on a fiber connection.
+ *****************************************************************************/
+static int
+e1000_force_mac_fc(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	
+	DEBUGFUNC("e1000_force_mac_fc");
+	
+	/* Get the current configuration of the Device Control Register */
+	ctrl = E1000_READ_REG(hw, CTRL);
+	
+	/* Because we didn't get link via the internal auto-negotiation
+	 * mechanism (we either forced link or we got link via PHY
+	 * auto-neg), we have to manually enable/disable transmit an
+	 * receive flow control.
+	 *
+	 * The "Case" statement below enables/disable flow control
+	 * according to the "hw->fc" parameter.
+	 *
+	 * The possible values of the "fc" parameter are:
+	 *      0:  Flow control is completely disabled
+	 *      1:  Rx flow control is enabled (we can receive pause
+	 *          frames but not send pause frames).
+	 *      2:  Tx flow control is enabled (we can send pause frames
+	 *          frames but we do not receive pause frames).
+	 *      3:  Both Rx and TX flow control (symmetric) is enabled.
+	 *  other:  No other values should be possible at this point.
+	 */
+	
+	switch (hw->fc) {
+	case e1000_fc_none:
+		ctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));
+		break;
+	case e1000_fc_rx_pause:
+		ctrl &= (~E1000_CTRL_TFCE);
+		ctrl |= E1000_CTRL_RFCE;
+		break;
+	case e1000_fc_tx_pause:
+		ctrl &= (~E1000_CTRL_RFCE);
+		ctrl |= E1000_CTRL_TFCE;
+		break;
+	case e1000_fc_full:
+		ctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);
+		break;
+	default:
+		DEBUGOUT("Flow control param set incorrectly\n");
+		return -E1000_ERR_CONFIG;
+	}
+	
+	/* Disable TX Flow Control for 82542 (rev 2.0) */
+	if(hw->mac_type == e1000_82542_rev2_0)
+		ctrl &= (~E1000_CTRL_TFCE);
+	
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	return 0;
+}
+
+/******************************************************************************
+ * Configures flow control settings after link is established
+ * 
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Should be called immediately after a valid link has been established.
+ * Forces MAC flow control settings if link was forced. When in MII/GMII mode
+ * and autonegotiation is enabled, the MAC flow control settings will be set
+ * based on the flow control negotiated by the PHY. In TBI mode, the TFCE
+ * and RFCE bits will be automaticaly set to the negotiated flow control mode.
+ *****************************************************************************/
+static int
+e1000_config_fc_after_link_up(struct e1000_hw *hw)
+{
+	int32_t ret_val;
+	uint16_t mii_status_reg;
+	uint16_t mii_nway_adv_reg;
+	uint16_t mii_nway_lp_ability_reg;
+	uint16_t speed;
+	uint16_t duplex;
+	
+	DEBUGFUNC("e1000_config_fc_after_link_up");
+	
+	/* Check for the case where we have fiber media and auto-neg failed
+	 * so we had to force link.  In this case, we need to force the
+	 * configuration of the MAC to match the "fc" parameter.
+	 */
+	if((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) {
+		ret_val = e1000_force_mac_fc(hw);
+		if(ret_val < 0) {
+			DEBUGOUT("Error forcing flow control settings\n");
+			return ret_val;
+		}
+	}
+	
+	/* Check for the case where we have copper media and auto-neg is
+	 * enabled.  In this case, we need to check and see if Auto-Neg
+	 * has completed, and if so, how the PHY and link partner has
+	 * flow control configured.
+	 */
+	if(hw->media_type == e1000_media_type_copper) {
+		/* Read the MII Status Register and check to see if AutoNeg
+		 * has completed.  We read this twice because this reg has
+		 * some "sticky" (latched) bits.
+		 */
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
+			DEBUGOUT("PHY Read Error \n");
+			return -E1000_ERR_PHY;
+		}
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
+			DEBUGOUT("PHY Read Error \n");
+			return -E1000_ERR_PHY;
+		}
+		
+		if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
+			/* The AutoNeg process has completed, so we now need to
+			 * read both the Auto Negotiation Advertisement Register
+			 * (Address 4) and the Auto_Negotiation Base Page Ability
+			 * Register (Address 5) to determine how flow control was
+			 * negotiated.
+			 */
+			if(e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_nway_adv_reg) < 0) {
+				DEBUGOUT("PHY Read Error\n");
+				return -E1000_ERR_PHY;
+			}
+			if(e1000_read_phy_reg(hw, PHY_LP_ABILITY, &mii_nway_lp_ability_reg) < 0) {
+				DEBUGOUT("PHY Read Error\n");
+				return -E1000_ERR_PHY;
+			}
+
+			/* Two bits in the Auto Negotiation Advertisement Register
+			 * (Address 4) and two bits in the Auto Negotiation Base
+			 * Page Ability Register (Address 5) determine flow control
+			 * for both the PHY and the link partner.  The following
+			 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,
+			 * 1999, describes these PAUSE resolution bits and how flow
+			 * control is determined based upon these settings.
+			 * NOTE:  DC = Don't Care
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution
+			 *-------|---------|-------|---------|--------------------
+			 *   0   |    0    |  DC   |   DC    | e1000_fc_none
+			 *   0   |    1    |   0   |   DC    | e1000_fc_none
+			 *   0   |    1    |   1   |    0    | e1000_fc_none
+			 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+			 *   1   |    0    |   0   |   DC    | e1000_fc_none
+			 *   1   |   DC    |   1   |   DC    | e1000_fc_full
+			 *   1   |    1    |   0   |    0    | e1000_fc_none
+			 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+			 *
+			 */
+			/* Are both PAUSE bits set to 1?  If so, this implies
+			 * Symmetric Flow Control is enabled at both ends.  The
+			 * ASM_DIR bits are irrelevant per the spec.
+			 *
+			 * For Symmetric Flow Control:
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+			 *-------|---------|-------|---------|--------------------
+			 *   1   |   DC    |   1   |   DC    | e1000_fc_full
+			 *
+			 */
+			if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {
+				/* Now we need to check if the user selected RX ONLY
+				 * of pause frames.  In this case, we had to advertise
+				 * FULL flow control because we could not advertise RX
+				 * ONLY. Hence, we must now check to see if we need to
+				 * turn OFF  the TRANSMISSION of PAUSE frames.
+				 */
+				if(hw->original_fc == e1000_fc_full) {
+					hw->fc = e1000_fc_full;
+					DEBUGOUT("Flow Control = FULL.\r\n");
+				} else {
+					hw->fc = e1000_fc_rx_pause;
+					DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+				}
+			}
+			/* For receiving PAUSE frames ONLY.
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+			 *-------|---------|-------|---------|--------------------
+			 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause
+			 *
+			 */
+			else if(!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+				(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+				hw->fc = e1000_fc_tx_pause;
+				DEBUGOUT("Flow Control = TX PAUSE frames only.\r\n");
+			}
+			/* For transmitting PAUSE frames ONLY.
+			 *
+			 *   LOCAL DEVICE  |   LINK PARTNER
+			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result
+			 *-------|---------|-------|---------|--------------------
+			 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause
+			 *
+			 */
+			else if((mii_nway_adv_reg & NWAY_AR_PAUSE) &&
+				(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&
+				!(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&
+				(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {
+				hw->fc = e1000_fc_rx_pause;
+				DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+			}
+			/* Per the IEEE spec, at this point flow control should be
+			 * disabled.  However, we want to consider that we could
+			 * be connected to a legacy switch that doesn't advertise
+			 * desired flow control, but can be forced on the link
+			 * partner.  So if we advertised no flow control, that is
+			 * what we will resolve to.  If we advertised some kind of
+			 * receive capability (Rx Pause Only or Full Flow Control)
+			 * and the link partner advertised none, we will configure
+			 * ourselves to enable Rx Flow Control only.  We can do
+			 * this safely for two reasons:  If the link partner really
+			 * didn't want flow control enabled, and we enable Rx, no
+			 * harm done since we won't be receiving any PAUSE frames
+			 * anyway.  If the intent on the link partner was to have
+			 * flow control enabled, then by us enabling RX only, we
+			 * can at least receive pause frames and process them.
+			 * This is a good idea because in most cases, since we are
+			 * predominantly a server NIC, more times than not we will
+			 * be asked to delay transmission of packets than asking
+			 * our link partner to pause transmission of frames.
+			 */
+			else if(hw->original_fc == e1000_fc_none ||
+				hw->original_fc == e1000_fc_tx_pause) {
+				hw->fc = e1000_fc_none;
+				DEBUGOUT("Flow Control = NONE.\r\n");
+			} else {
+				hw->fc = e1000_fc_rx_pause;
+				DEBUGOUT("Flow Control = RX PAUSE frames only.\r\n");
+			}
+			
+			/* Now we need to do one last check...  If we auto-
+			 * negotiated to HALF DUPLEX, flow control should not be
+			 * enabled per IEEE 802.3 spec.
+			 */
+			e1000_get_speed_and_duplex(hw, &speed, &duplex);
+			
+			if(duplex == HALF_DUPLEX)
+				hw->fc = e1000_fc_none;
+			
+			/* Now we call a subroutine to actually force the MAC
+			 * controller to use the correct flow control settings.
+			 */
+			ret_val = e1000_force_mac_fc(hw);
+			if(ret_val < 0) {
+				DEBUGOUT("Error forcing flow control settings\n");
+				return ret_val;
+			}
+		} else {
+			DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
+		}
+	}
+	return 0;
+}
+
+/******************************************************************************
+ * Checks to see if the link status of the hardware has changed.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *
+ * Called by any function that needs to check the link status of the adapter.
+ *****************************************************************************/
+static int
+e1000_check_for_link(struct e1000_hw *hw)
+{
+	uint32_t rxcw;
+	uint32_t ctrl;
+	uint32_t status;
+	uint32_t rctl;
+	uint32_t signal;
+	int32_t ret_val;
+	uint16_t phy_data;
+	uint16_t lp_capability;
+	
+	DEBUGFUNC("e1000_check_for_link");
+	
+	/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
+	 * set when the optics detect a signal. On older adapters, it will be 
+	 * cleared when there is a signal
+	 */
+	if(hw->mac_type > e1000_82544) signal = E1000_CTRL_SWDPIN1;
+	else signal = 0;
+	
+	ctrl = E1000_READ_REG(hw, CTRL);
+	status = E1000_READ_REG(hw, STATUS);
+	rxcw = E1000_READ_REG(hw, RXCW);
+	
+	/* If we have a copper PHY then we only want to go out to the PHY
+	 * registers to see if Auto-Neg has completed and/or if our link
+	 * status has changed.  The get_link_status flag will be set if we
+	 * receive a Link Status Change interrupt or we have Rx Sequence
+	 * Errors.
+	 */
+	if((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
+		/* First we want to see if the MII Status Register reports
+		 * link.  If so, then we want to get the current speed/duplex
+		 * of the PHY.
+		 * Read the register twice since the link bit is sticky.
+		 */
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		
+		if(phy_data & MII_SR_LINK_STATUS) {
+			hw->get_link_status = FALSE;
+		} else {
+			/* No link detected */
+			return -E1000_ERR_NOLINK;
+		}
+
+		/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we
+		 * have Si on board that is 82544 or newer, Auto
+		 * Speed Detection takes care of MAC speed/duplex
+		 * configuration.  So we only need to configure Collision
+		 * Distance in the MAC.  Otherwise, we need to force
+		 * speed/duplex on the MAC to the current PHY speed/duplex
+		 * settings.
+		 */
+		if(hw->mac_type >= e1000_82544)
+			e1000_config_collision_dist(hw);
+		else {
+			ret_val = e1000_config_mac_to_phy(hw);
+			if(ret_val < 0) {
+				DEBUGOUT("Error configuring MAC to PHY settings\n");
+				return ret_val;
+			}
+		}
+		
+		/* Configure Flow Control now that Auto-Neg has completed. First, we 
+		 * need to restore the desired flow control settings because we may
+		 * have had to re-autoneg with a different link partner.
+		 */
+		ret_val = e1000_config_fc_after_link_up(hw);
+		if(ret_val < 0) {
+			DEBUGOUT("Error configuring flow control\n");
+			return ret_val;
+		}
+		
+		/* At this point we know that we are on copper and we have
+		 * auto-negotiated link.  These are conditions for checking the link
+		 * parter capability register.  We use the link partner capability to
+		 * determine if TBI Compatibility needs to be turned on or off.  If
+		 * the link partner advertises any speed in addition to Gigabit, then
+		 * we assume that they are GMII-based, and TBI compatibility is not
+		 * needed. If no other speeds are advertised, we assume the link
+		 * partner is TBI-based, and we turn on TBI Compatibility.
+		 */
+		if(hw->tbi_compatibility_en) {
+			if(e1000_read_phy_reg(hw, PHY_LP_ABILITY, &lp_capability) < 0) {
+				DEBUGOUT("PHY Read Error\n");
+				return -E1000_ERR_PHY;
+			}
+			if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
+                                NWAY_LPAR_10T_FD_CAPS |
+                                NWAY_LPAR_100TX_HD_CAPS |
+                                NWAY_LPAR_100TX_FD_CAPS |
+                                NWAY_LPAR_100T4_CAPS)) {
+				/* If our link partner advertises anything in addition to 
+				 * gigabit, we do not need to enable TBI compatibility.
+				 */
+				if(hw->tbi_compatibility_on) {
+					/* If we previously were in the mode, turn it off. */
+					rctl = E1000_READ_REG(hw, RCTL);
+					rctl &= ~E1000_RCTL_SBP;
+					E1000_WRITE_REG(hw, RCTL, rctl);
+					hw->tbi_compatibility_on = FALSE;
+				}
+			} else {
+				/* If TBI compatibility is was previously off, turn it on. For
+				 * compatibility with a TBI link partner, we will store bad
+				 * packets. Some frames have an additional byte on the end and
+				 * will look like CRC errors to to the hardware.
+				 */
+				if(!hw->tbi_compatibility_on) {
+					hw->tbi_compatibility_on = TRUE;
+					rctl = E1000_READ_REG(hw, RCTL);
+					rctl |= E1000_RCTL_SBP;
+					E1000_WRITE_REG(hw, RCTL, rctl);
+				}
+			}
+		}
+	}
+	/* If we don't have link (auto-negotiation failed or link partner cannot
+	 * auto-negotiate), the cable is plugged in (we have signal), and our
+	 * link partner is not trying to auto-negotiate with us (we are receiving
+	 * idles or data), we need to force link up. We also need to give
+	 * auto-negotiation time to complete, in case the cable was just plugged
+	 * in. The autoneg_failed flag does this.
+	 */
+	else if((hw->media_type == e1000_media_type_fiber) &&
+		(!(status & E1000_STATUS_LU)) &&
+		((ctrl & E1000_CTRL_SWDPIN1) == signal) &&
+		(!(rxcw & E1000_RXCW_C))) {
+		if(hw->autoneg_failed == 0) {
+			hw->autoneg_failed = 1;
+			return 0;
+		}
+		DEBUGOUT("NOT RXing /C/, disable AutoNeg and force link.\r\n");
+		
+		/* Disable auto-negotiation in the TXCW register */
+		E1000_WRITE_REG(hw, TXCW, (hw->txcw & ~E1000_TXCW_ANE));
+		
+		/* Force link-up and also force full-duplex. */
+		ctrl = E1000_READ_REG(hw, CTRL);
+		ctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		
+		/* Configure Flow Control after forcing link up. */
+		ret_val = e1000_config_fc_after_link_up(hw);
+		if(ret_val < 0) {
+			DEBUGOUT("Error configuring flow control\n");
+			return ret_val;
+		}
+	}
+	/* If we are forcing link and we are receiving /C/ ordered sets, re-enable
+	 * auto-negotiation in the TXCW register and disable forced link in the
+	 * Device Control register in an attempt to auto-negotiate with our link
+	 * partner.
+	 */
+	else if((hw->media_type == e1000_media_type_fiber) &&
+		(ctrl & E1000_CTRL_SLU) &&
+		(rxcw & E1000_RXCW_C)) {
+		DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
+		E1000_WRITE_REG(hw, TXCW, hw->txcw);
+		E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));
+	}
+	return 0;
+}
+
+/******************************************************************************
+ * Detects the current speed and duplex settings of the hardware.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * speed - Speed of the connection
+ * duplex - Duplex setting of the connection
+ *****************************************************************************/
+static void 
+e1000_get_speed_and_duplex(struct e1000_hw *hw,
+                           uint16_t *speed,
+                           uint16_t *duplex)
+{
+	uint32_t status;
+	
+	DEBUGFUNC("e1000_get_speed_and_duplex");
+	
+	if(hw->mac_type >= e1000_82543) {
+		status = E1000_READ_REG(hw, STATUS);
+		if(status & E1000_STATUS_SPEED_1000) {
+			*speed = SPEED_1000;
+			DEBUGOUT("1000 Mbs, ");
+		} else if(status & E1000_STATUS_SPEED_100) {
+			*speed = SPEED_100;
+			DEBUGOUT("100 Mbs, ");
+		} else {
+			*speed = SPEED_10;
+			DEBUGOUT("10 Mbs, ");
+		}
+		
+		if(status & E1000_STATUS_FD) {
+			*duplex = FULL_DUPLEX;
+			DEBUGOUT("Full Duplex\r\n");
+		} else {
+			*duplex = HALF_DUPLEX;
+			DEBUGOUT(" Half Duplex\r\n");
+		}
+	} else {
+		DEBUGOUT("1000 Mbs, Full Duplex\r\n");
+		*speed = SPEED_1000;
+		*duplex = FULL_DUPLEX;
+	}
+}
+
+/******************************************************************************
+* Blocks until autoneg completes or times out (~4.5 seconds)
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_wait_autoneg(struct e1000_hw *hw)
+{
+	uint16_t i;
+	uint16_t phy_data;
+	
+	DEBUGFUNC("e1000_wait_autoneg");
+	DEBUGOUT("Waiting for Auto-Neg to complete.\n");
+	
+	/* We will wait for autoneg to complete or 4.5 seconds to expire. */
+	for(i = PHY_AUTO_NEG_TIME; i > 0; i--) {
+		/* Read the MII Status Register and wait for Auto-Neg
+		 * Complete bit to be set.
+		 */
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
+			DEBUGOUT("PHY Read Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if(phy_data & MII_SR_AUTONEG_COMPLETE) {
+			DEBUGOUT("Auto-Neg complete.\n");
+			return 0;
+		}
+		mdelay(100);
+	}
+	DEBUGOUT("Auto-Neg timedout.\n");
+	return -E1000_ERR_TIMEOUT;
+}
+
+/******************************************************************************
+* Raises the Management Data Clock
+*
+* hw - Struct containing variables accessed by shared code
+* ctrl - Device control register's current value
+******************************************************************************/
+static void
+e1000_raise_mdi_clk(struct e1000_hw *hw,
+                    uint32_t *ctrl)
+{
+	/* Raise the clock input to the Management Data Clock (by setting the MDC
+	 * bit), and then delay 2 microseconds.
+	 */
+	E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
+	E1000_WRITE_FLUSH(hw);
+	udelay(2);
+}
+
+/******************************************************************************
+* Lowers the Management Data Clock
+*
+* hw - Struct containing variables accessed by shared code
+* ctrl - Device control register's current value
+******************************************************************************/
+static void
+e1000_lower_mdi_clk(struct e1000_hw *hw,
+                    uint32_t *ctrl)
+{
+	/* Lower the clock input to the Management Data Clock (by clearing the MDC
+	 * bit), and then delay 2 microseconds.
+	 */
+	E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
+	E1000_WRITE_FLUSH(hw);
+	udelay(2);
+}
+
+/******************************************************************************
+* Shifts data bits out to the PHY
+*
+* hw - Struct containing variables accessed by shared code
+* data - Data to send out to the PHY
+* count - Number of bits to shift out
+*
+* Bits are shifted out in MSB to LSB order.
+******************************************************************************/
+static void
+e1000_shift_out_mdi_bits(struct e1000_hw *hw,
+                         uint32_t data,
+                         uint16_t count)
+{
+	uint32_t ctrl;
+	uint32_t mask;
+
+	/* We need to shift "count" number of bits out to the PHY. So, the value
+	 * in the "data" parameter will be shifted out to the PHY one bit at a 
+	 * time. In order to do this, "data" must be broken down into bits.
+	 */
+	mask = 0x01;
+	mask <<= (count - 1);
+	
+	ctrl = E1000_READ_REG(hw, CTRL);
+	
+	/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
+	ctrl |= (E1000_CTRL_MDIO_DIR | E1000_CTRL_MDC_DIR);
+	
+	while(mask) {
+		/* A "1" is shifted out to the PHY by setting the MDIO bit to "1" and
+		 * then raising and lowering the Management Data Clock. A "0" is
+		 * shifted out to the PHY by setting the MDIO bit to "0" and then
+		 * raising and lowering the clock.
+		 */
+		if(data & mask) ctrl |= E1000_CTRL_MDIO;
+		else ctrl &= ~E1000_CTRL_MDIO;
+		
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		E1000_WRITE_FLUSH(hw);
+		
+		udelay(2);
+
+		e1000_raise_mdi_clk(hw, &ctrl);
+		e1000_lower_mdi_clk(hw, &ctrl);
+
+		mask = mask >> 1;
+	}
+}
+
+/******************************************************************************
+* Shifts data bits in from the PHY
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Bits are shifted in in MSB to LSB order. 
+******************************************************************************/
+static uint16_t
+e1000_shift_in_mdi_bits(struct e1000_hw *hw)
+{
+	uint32_t ctrl;
+	uint16_t data = 0;
+	uint8_t i;
+
+	/* In order to read a register from the PHY, we need to shift in a total
+	 * of 18 bits from the PHY. The first two bit (turnaround) times are used
+	 * to avoid contention on the MDIO pin when a read operation is performed.
+	 * These two bits are ignored by us and thrown away. Bits are "shifted in"
+	 * by raising the input to the Management Data Clock (setting the MDC bit),
+	 * and then reading the value of the MDIO bit.
+	 */ 
+	ctrl = E1000_READ_REG(hw, CTRL);
+	
+	/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
+	ctrl &= ~E1000_CTRL_MDIO_DIR;
+	ctrl &= ~E1000_CTRL_MDIO;
+	
+	E1000_WRITE_REG(hw, CTRL, ctrl);
+	E1000_WRITE_FLUSH(hw);
+	
+	/* Raise and Lower the clock before reading in the data. This accounts for
+	 * the turnaround bits. The first clock occurred when we clocked out the
+	 * last bit of the Register Address.
+	 */
+	e1000_raise_mdi_clk(hw, &ctrl);
+	e1000_lower_mdi_clk(hw, &ctrl);
+	
+	for(data = 0, i = 0; i < 16; i++) {
+		data = data << 1;
+		e1000_raise_mdi_clk(hw, &ctrl);
+		ctrl = E1000_READ_REG(hw, CTRL);
+		/* Check to see if we shifted in a "1". */
+		if(ctrl & E1000_CTRL_MDIO) data |= 1;
+		e1000_lower_mdi_clk(hw, &ctrl);
+	}
+	
+	e1000_raise_mdi_clk(hw, &ctrl);
+	e1000_lower_mdi_clk(hw, &ctrl);
+	
+	return data;
+}
+
+/*****************************************************************************
+* Reads the value from a PHY register
+*
+* hw - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to read
+******************************************************************************/
+static int
+e1000_read_phy_reg(struct e1000_hw *hw,
+                   uint32_t reg_addr,
+                   uint16_t *phy_data)
+{
+	uint32_t i;
+	uint32_t mdic = 0;
+	const uint32_t phy_addr = 1;
+
+	DEBUGFUNC("e1000_read_phy_reg");
+	
+	if(reg_addr > MAX_PHY_REG_ADDRESS) {
+		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
+		return -E1000_ERR_PARAM;
+	}
+	
+	if(hw->mac_type > e1000_82543) {
+		/* Set up Op-code, Phy Address, and register address in the MDI
+		 * Control register.  The MAC will take care of interfacing with the
+		 * PHY to retrieve the desired data.
+		 */
+		mdic = ((reg_addr << E1000_MDIC_REG_SHIFT) |
+			(phy_addr << E1000_MDIC_PHY_SHIFT) | 
+			(E1000_MDIC_OP_READ));
+		
+		E1000_WRITE_REG(hw, MDIC, mdic);
+
+		/* Poll the ready bit to see if the MDI read completed */
+		for(i = 0; i < 64; i++) {
+			udelay(10);
+			mdic = E1000_READ_REG(hw, MDIC);
+			if(mdic & E1000_MDIC_READY) break;
+		}
+		if(!(mdic & E1000_MDIC_READY)) {
+			DEBUGOUT("MDI Read did not complete\n");
+			return -E1000_ERR_PHY;
+		}
+		if(mdic & E1000_MDIC_ERROR) {
+			DEBUGOUT("MDI Error\n");
+			return -E1000_ERR_PHY;
+		}
+		*phy_data = (uint16_t) mdic;
+	} else {
+		/* We must first send a preamble through the MDIO pin to signal the
+		 * beginning of an MII instruction.  This is done by sending 32
+		 * consecutive "1" bits.
+		 */
+		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+		
+		/* Now combine the next few fields that are required for a read
+		 * operation.  We use this method instead of calling the
+		 * e1000_shift_out_mdi_bits routine five different times. The format of
+		 * a MII read instruction consists of a shift out of 14 bits and is
+		 * defined as follows:
+		 *    <Preamble><SOF><Op Code><Phy Addr><Reg Addr>
+		 * followed by a shift in of 18 bits.  This first two bits shifted in
+		 * are TurnAround bits used to avoid contention on the MDIO pin when a
+		 * READ operation is performed.  These two bits are thrown away
+		 * followed by a shift in of 16 bits which contains the desired data.
+		 */
+		mdic = ((reg_addr) | (phy_addr << 5) | 
+			(PHY_OP_READ << 10) | (PHY_SOF << 12));
+		
+		e1000_shift_out_mdi_bits(hw, mdic, 14);
+		
+		/* Now that we've shifted out the read command to the MII, we need to
+		 * "shift in" the 16-bit value (18 total bits) of the requested PHY
+		 * register address.
+		 */
+		*phy_data = e1000_shift_in_mdi_bits(hw);
+	}
+	return 0;
+}
+
+/******************************************************************************
+* Writes a value to a PHY register
+*
+* hw - Struct containing variables accessed by shared code
+* reg_addr - address of the PHY register to write
+* data - data to write to the PHY
+******************************************************************************/
+static int 
+e1000_write_phy_reg(struct e1000_hw *hw,
+                    uint32_t reg_addr,
+                    uint16_t phy_data)
+{
+	uint32_t i;
+	uint32_t mdic = 0;
+	const uint32_t phy_addr = 1;
+	
+	DEBUGFUNC("e1000_write_phy_reg");
+	
+	if(reg_addr > MAX_PHY_REG_ADDRESS) {
+		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
+		return -E1000_ERR_PARAM;
+	}
+	
+	if(hw->mac_type > e1000_82543) {
+		/* Set up Op-code, Phy Address, register address, and data intended
+		 * for the PHY register in the MDI Control register.  The MAC will take
+		 * care of interfacing with the PHY to send the desired data.
+		 */
+		mdic = (((uint32_t) phy_data) |
+			(reg_addr << E1000_MDIC_REG_SHIFT) |
+			(phy_addr << E1000_MDIC_PHY_SHIFT) | 
+			(E1000_MDIC_OP_WRITE));
+		
+		E1000_WRITE_REG(hw, MDIC, mdic);
+		
+		/* Poll the ready bit to see if the MDI read completed */
+		for(i = 0; i < 64; i++) {
+			udelay(10);
+			mdic = E1000_READ_REG(hw, MDIC);
+			if(mdic & E1000_MDIC_READY) break;
+		}
+		if(!(mdic & E1000_MDIC_READY)) {
+			DEBUGOUT("MDI Write did not complete\n");
+			return -E1000_ERR_PHY;
+		}
+	} else {
+		/* We'll need to use the SW defined pins to shift the write command
+		 * out to the PHY. We first send a preamble to the PHY to signal the
+		 * beginning of the MII instruction.  This is done by sending 32 
+		 * consecutive "1" bits.
+		 */
+		e1000_shift_out_mdi_bits(hw, PHY_PREAMBLE, PHY_PREAMBLE_SIZE);
+		
+		/* Now combine the remaining required fields that will indicate a 
+		 * write operation. We use this method instead of calling the
+		 * e1000_shift_out_mdi_bits routine for each field in the command. The
+		 * format of a MII write instruction is as follows:
+		 * <Preamble><SOF><Op Code><Phy Addr><Reg Addr><Turnaround><Data>.
+		 */
+		mdic = ((PHY_TURNAROUND) | (reg_addr << 2) | (phy_addr << 7) |
+			(PHY_OP_WRITE << 12) | (PHY_SOF << 14));
+		mdic <<= 16;
+		mdic |= (uint32_t) phy_data;
+		
+		e1000_shift_out_mdi_bits(hw, mdic, 32);
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+* Returns the PHY to the power-on reset state
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static void
+e1000_phy_hw_reset(struct e1000_hw *hw)
+{
+	uint32_t ctrl, ctrl_ext;
+
+	DEBUGFUNC("e1000_phy_hw_reset");
+	
+	DEBUGOUT("Resetting Phy...\n");
+	
+	if(hw->mac_type > e1000_82543) {
+		/* Read the device control register and assert the E1000_CTRL_PHY_RST
+		 * bit. Then, take it out of reset.
+		 */
+		ctrl = E1000_READ_REG(hw, CTRL);
+		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PHY_RST);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(10);
+		E1000_WRITE_REG(hw, CTRL, ctrl);
+		E1000_WRITE_FLUSH(hw);
+	} else {
+		/* Read the Extended Device Control Register, assert the PHY_RESET_DIR
+		 * bit to put the PHY into reset. Then, take it out of reset.
+		 */
+		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+		ctrl_ext |= E1000_CTRL_EXT_SDP4_DIR;
+		ctrl_ext &= ~E1000_CTRL_EXT_SDP4_DATA;
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+		E1000_WRITE_FLUSH(hw);
+		mdelay(10);
+		ctrl_ext |= E1000_CTRL_EXT_SDP4_DATA;
+		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+		E1000_WRITE_FLUSH(hw);
+	}
+	udelay(150);
+
+	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
+			DEBUGOUT("PHY Write Error\n");
+			return;
+		}
+	}
+}
+
+/******************************************************************************
+* Resets the PHY
+*
+* hw - Struct containing variables accessed by shared code
+*
+* Sets bit 15 of the MII Control regiser
+******************************************************************************/
+static int 
+e1000_phy_reset(struct e1000_hw *hw)
+{
+	uint16_t phy_data;
+
+	DEBUGFUNC("e1000_phy_reset");
+	
+	if(e1000_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
+		DEBUGOUT("PHY Read Error\n");
+		return -E1000_ERR_PHY;
+	}
+	phy_data |= MII_CR_RESET;
+	if(e1000_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
+		DEBUGOUT("PHY Write Error\n");
+		return -E1000_ERR_PHY;
+	}
+	udelay(1);
+	if (hw->phy_type == e1000_phy_igp) {
+		e1000_phy_init_script(hw);
+	}
+	return 0;
+}
+
+/******************************************************************************
+* Probes the expected PHY address for known PHY IDs
+*
+* hw - Struct containing variables accessed by shared code
+******************************************************************************/
+static int
+e1000_detect_gig_phy(struct e1000_hw *hw)
+{
+	uint16_t phy_id_high, phy_id_low;
+	boolean_t match = FALSE;
+	int32_t phy_init_status;
+
+	DEBUGFUNC("e1000_detect_gig_phy");
+	
+	/* Read the PHY ID Registers to identify which PHY is onboard. */
+	if(e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high) < 0) {
+		DEBUGOUT("PHY Read Error\n");
+		return -E1000_ERR_PHY;
+	}
+	hw->phy_id = (uint32_t) (phy_id_high << 16);
+	udelay(20);
+	if(e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low) < 0) {
+		DEBUGOUT("PHY Read Error\n");
+		return -E1000_ERR_PHY;
+	}
+	hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
+#ifdef LINUX_DRIVER
+	hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;
+#endif
+	
+	switch(hw->mac_type) {
+	case e1000_82543:
+		if(hw->phy_id == M88E1000_E_PHY_ID) match = TRUE;
+		break;
+	case e1000_82544:
+		if(hw->phy_id == M88E1000_I_PHY_ID) match = TRUE;
+		break;
+	case e1000_82540:
+	case e1000_82545:
+	case e1000_82546:
+		if(hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
+		break;
+	case e1000_82541:
+	case e1000_82547:
+		if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
+		break;
+	default:
+		DEBUGOUT1("Invalid MAC type %d\n", hw->mac_type);
+		return -E1000_ERR_CONFIG;
+	}
+	phy_init_status = e1000_set_phy_type(hw);
+
+	if ((match) && (phy_init_status == E1000_SUCCESS)) {
+		DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
+		return 0;
+	}
+	DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
+	return -E1000_ERR_PHY;
+}
+
+/******************************************************************************
+ * Sets up eeprom variables in the hw struct.  Must be called after mac_type
+ * is configured.
+ *
+ * hw - Struct containing variables accessed by shared code
+ *****************************************************************************/
+static void
+e1000_init_eeprom_params(struct e1000_hw *hw)
+{
+	struct e1000_eeprom_info *eeprom = &hw->eeprom;
+	uint32_t eecd = E1000_READ_REG(hw, EECD);
+	uint16_t eeprom_size;
+
+	DEBUGFUNC("e1000_init_eeprom_params");
+
+	switch (hw->mac_type) {
+	case e1000_82542_rev2_0:
+	case e1000_82542_rev2_1:
+	case e1000_82543:
+	case e1000_82544:
+		eeprom->type = e1000_eeprom_microwire;
+		eeprom->word_size = 64;
+		eeprom->opcode_bits = 3;
+		eeprom->address_bits = 6;
+		eeprom->delay_usec = 50;
+		break;
+	case e1000_82540:
+	case e1000_82545:
+	case e1000_82546:
+		eeprom->type = e1000_eeprom_microwire;
+		eeprom->opcode_bits = 3;
+		eeprom->delay_usec = 50;
+		if(eecd & E1000_EECD_SIZE) {
+			eeprom->word_size = 256;
+			eeprom->address_bits = 8;
+		} else {
+			eeprom->word_size = 64;
+			eeprom->address_bits = 6;
+		}
+		break;
+	case e1000_82541:
+	case e1000_82547:
+	default:
+		if (eecd & E1000_EECD_TYPE) {
+			eeprom->type = e1000_eeprom_spi;
+			eeprom->opcode_bits = 8;
+			eeprom->delay_usec = 1;
+			if (eecd & E1000_EECD_ADDR_BITS) {
+				eeprom->page_size = 32;
+				eeprom->address_bits = 16;
+			} else {
+				eeprom->page_size = 8;
+				eeprom->address_bits = 8;
+			}
+		} else {
+			eeprom->type = e1000_eeprom_microwire;
+			eeprom->opcode_bits = 3;
+			eeprom->delay_usec = 50;
+			if (eecd & E1000_EECD_ADDR_BITS) {
+				eeprom->word_size = 256;
+				eeprom->address_bits = 8;
+			} else {
+				eeprom->word_size = 64;
+				eeprom->address_bits = 6;
+			}
+		}
+		break;
+	}
+
+	if (eeprom->type == e1000_eeprom_spi) {
+		eeprom->word_size = 64;
+		if (e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size) == 0) {
+			eeprom_size &= EEPROM_SIZE_MASK;
+
+			switch (eeprom_size) {
+			case EEPROM_SIZE_16KB:
+				eeprom->word_size = 8192;
+				break;
+			case EEPROM_SIZE_8KB:
+				eeprom->word_size = 4096;
+				break;
+			case EEPROM_SIZE_4KB:
+				eeprom->word_size = 2048;
+				break;
+			case EEPROM_SIZE_2KB:
+				eeprom->word_size = 1024;
+				break;
+			case EEPROM_SIZE_1KB:
+				eeprom->word_size = 512;
+				break;
+			case EEPROM_SIZE_512B:
+				eeprom->word_size = 256;
+				break;
+			case EEPROM_SIZE_128B:
+			default:
+				eeprom->word_size = 64;
+				break;
+			}
+		}
+	}
+}
+
+/**
+ * e1000_reset - Reset the adapter
+ */
+
+static int
+e1000_reset(struct e1000_hw *hw)
+{
+	int ret_val;
+	uint32_t pba;
+	/* Repartition Pba for greater than 9k mtu
+	 * To take effect CTRL.RST is required.
+	 */
+
+	if(hw->mac_type < e1000_82547) {
+		pba = E1000_PBA_48K;
+	} else {
+		pba = E1000_PBA_30K;
+	}
+	E1000_WRITE_REG(hw, PBA, pba);
+
+	hw->fc = hw->original_fc;
+	e1000_reset_hw(hw);
+	if(hw->mac_type >= e1000_82544)
+		E1000_WRITE_REG(hw, WUC, 0);
+	ret_val = e1000_init_hw(hw);
+	if (ret_val < 0) {
+		return ret_val;
+	}
+	return ret_val;
+}
+
+/**
+ * e1000_sw_init - Initialize general software structures (struct e1000_adapter)
+ * @adapter: board private structure to initialize
+ *
+ * e1000_sw_init initializes the Adapter private data structure.
+ * Fields are initialized based on PCI device information and
+ * OS network device settings (MTU size).
+ **/
+
+static int 
+e1000_sw_init(struct pci_device *pdev, struct e1000_hw *hw)
+{
+	int result;
+
+	/* PCI config space info */
+	pci_read_config_word(pdev, PCI_VENDOR_ID, &hw->vendor_id);
+	pci_read_config_word(pdev, PCI_DEVICE_ID, &hw->device_id);
+	pci_read_config_byte(pdev, PCI_REVISION, &hw->revision_id);
+	pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
+                             &hw->subsystem_vendor_id);
+	pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &hw->subsystem_id);
+
+	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
+
+	/* identify the MAC */
+
+	result = e1000_set_mac_type(hw);
+	if (result) {
+		E1000_ERR("Unknown MAC Type\n");
+		return result;
+	}
+
+	/* initialize eeprom parameters */
+
+	e1000_init_eeprom_params(hw);
+
+	/* flow control settings */
+
+	hw->fc_high_water = FC_DEFAULT_HI_THRESH;
+	hw->fc_low_water = FC_DEFAULT_LO_THRESH;
+	hw->fc_pause_time = FC_DEFAULT_TX_TIMER;
+	hw->fc_send_xon = 1;
+
+	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547))
+		hw->phy_init_script = 1;
+
+	/* Media type - copper or fiber */
+
+	if(hw->mac_type >= e1000_82543) {
+		uint32_t status = E1000_READ_REG(hw, STATUS);
+
+		if(status & E1000_STATUS_TBIMODE)
+			hw->media_type = e1000_media_type_fiber;
+		else
+			hw->media_type = e1000_media_type_copper;
+	} else {
+		hw->media_type = e1000_media_type_fiber;
+	}
+
+	if(hw->mac_type < e1000_82543)
+		hw->report_tx_early = 0;
+	else
+		hw->report_tx_early = 1;
+
+	hw->tbi_compatibility_en = TRUE;
+#if 0
+	hw->wait_autoneg_complete = FALSE;
+	hw->adaptive_ifs = TRUE;
+
+	/* Copper options */
+	if(hw->media_type == e1000_media_type_copper) {
+		hw->mdix = AUTO_ALL_MODES;
+		hw->disable_polarity_correction = FALSE;
+	}
+#endif
+	return E1000_SUCCESS;
+}
+
+static void fill_rx (void)
+{
+	struct e1000_rx_desc *rd;
+	rx_last = rx_tail;
+	rd = rx_base + rx_tail;
+	rx_tail = (rx_tail + 1) % 8;
+	memset (rd, 0, 16);
+	rd->buffer_addr = virt_to_bus(&packet);
+	E1000_WRITE_REG (&hw, RDT, rx_tail);
+}
+
+static void init_descriptor (void)
+{
+	unsigned long ptr;
+	unsigned long tctl;
+
+	ptr = virt_to_phys(tx_pool);
+	if (ptr & 0xf)
+		ptr = (ptr + 0x10) & (~0xf);
+
+	tx_base = phys_to_virt(ptr);
+
+	E1000_WRITE_REG (&hw, TDBAL, virt_to_bus(tx_base));
+	E1000_WRITE_REG (&hw, TDBAH, 0);
+	E1000_WRITE_REG (&hw, TDLEN, 128);
+
+	/* Setup the HW Tx Head and Tail descriptor pointers */
+
+	E1000_WRITE_REG (&hw, TDH, 0);
+	E1000_WRITE_REG (&hw, TDT, 0);
+	tx_tail = 0;
+
+	/* Program the Transmit Control Register */
+
+#ifdef LINUX_DRIVER_TCTL
+	tctl = E1000_READ_REG(&hw, TCTL);
+
+	tctl &= ~E1000_TCTL_CT;
+	tctl |= E1000_TCTL_EN | E1000_TCTL_PSP |
+		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);
+#else
+	tctl = E1000_TCTL_PSP | E1000_TCTL_EN |
+		(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT) | 
+		(E1000_HDX_COLLISION_DISTANCE << E1000_COLD_SHIFT);
+#endif
+
+	E1000_WRITE_REG (&hw, TCTL, tctl);
+
+	e1000_config_collision_dist(&hw);
+
+
+	rx_tail = 0;
+	/* disable receive */
+	E1000_WRITE_REG (&hw, RCTL, 0);
+	ptr = virt_to_phys(rx_pool);
+	if (ptr & 0xf)
+		ptr = (ptr + 0x10) & (~0xf);
+	rx_base = phys_to_virt(ptr);
+
+	/* Setup the Base and Length of the Rx Descriptor Ring */
+
+	E1000_WRITE_REG (&hw, RDBAL, virt_to_bus(rx_base));
+	E1000_WRITE_REG (&hw, RDBAH, 0);
+
+	E1000_WRITE_REG (&hw, RDLEN, 128);
+
+	/* Setup the HW Rx Head and Tail Descriptor Pointers */
+	E1000_WRITE_REG (&hw, RDH, 0);
+	E1000_WRITE_REG (&hw, RDT, 0);
+
+	E1000_WRITE_REG (&hw, RCTL, 
+		E1000_RCTL_EN | 
+		E1000_RCTL_BAM | 
+		E1000_RCTL_SZ_2048 | 
+		E1000_RCTL_MPE);
+	fill_rx();
+}
+
+
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int
+e1000_poll (struct nic *nic)
+{
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	struct e1000_rx_desc *rd;
+	
+	rd = rx_base + rx_last;
+	if (!rd->status & E1000_RXD_STAT_DD)
+		return 0;
+	//      printf("recv: packet %! -> %! len=%d \n", packet+6, packet,rd->Length);
+	memcpy (nic->packet, packet, rd->length);
+	nic->packetlen = rd->length;
+	fill_rx ();
+	return 1;
+}
+
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void
+e1000_transmit (struct nic *nic, const char *d,	/* Destination */
+		    unsigned int type,	/* Type */
+		    unsigned int size,	/* size */
+		    const char *p)	/* Packet */
+{
+	/* send the packet to destination */
+	struct eth_hdr {
+		unsigned char dst_addr[ETH_ALEN];
+		unsigned char src_addr[ETH_ALEN];
+		unsigned short type;
+	} hdr;
+	struct e1000_tx_desc *txhd;	/* header */
+	struct e1000_tx_desc *txp;	/* payload */
+	DEBUGFUNC("send");
+
+	memcpy (&hdr.dst_addr, d, ETH_ALEN);
+	memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
+
+	hdr.type = htons (type);
+	txhd = tx_base + tx_tail;
+	tx_tail = (tx_tail + 1) % 8;
+	txp = tx_base + tx_tail;
+	tx_tail = (tx_tail + 1) % 8;
+
+	txhd->buffer_addr = virt_to_bus (&hdr);
+	txhd->lower.data = sizeof (hdr);
+	txhd->upper.data = 0;
+
+	txp->buffer_addr = virt_to_bus(p);
+	txp->lower.data = E1000_TXD_CMD_RPS | E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS | size;
+	txp->upper.data = 0;
+
+	E1000_WRITE_REG (&hw, TDT, tx_tail);
+	while (!(txp->upper.data & E1000_TXD_STAT_DD)) {
+		udelay(10);	/* give the nic a chance to write to the register */
+		poll_interruptions();
+	}
+	DEBUGFUNC("send end");
+}
+
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+static void e1000_disable (struct dev *dev __unused)
+{
+	/* Clear the transmit ring */
+	E1000_WRITE_REG (&hw, TDH, 0);
+	E1000_WRITE_REG (&hw, TDT, 0);
+
+	/* Clear the receive ring */
+	E1000_WRITE_REG (&hw, RDH, 0);
+	E1000_WRITE_REG (&hw, RDT, 0);
+
+	/* put the card in its initial state */
+	E1000_WRITE_REG (&hw, CTRL, E1000_CTRL_RST);
+
+	/* Turn off the ethernet interface */
+	E1000_WRITE_REG (&hw, RCTL, 0);
+	E1000_WRITE_REG (&hw, TCTL, 0);
+	mdelay (10);
+
+	/* Unmap my window to the device */
+	iounmap(hw.hw_addr);
+}
+
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+You should omit the last argument struct pci_device * for a non-PCI NIC
+***************************************************************************/
+static int e1000_probe(struct dev *dev, struct pci_device *p)
+{
+	struct nic *nic = (struct nic *)dev;
+	unsigned long mmio_start, mmio_len;
+	int ret_val;
+
+	if (p == 0)
+		return 0;
+	/* Initialize hw with default values */
+	memset(&hw, 0, sizeof(hw));
+	hw.pdev = p;
+
+#if 1
+	/* Are these variables needed? */
+	hw.fc                    = e1000_fc_none;
+	hw.original_fc           = e1000_fc_none;
+	hw.autoneg_failed        = 0;
+	hw.get_link_status       = TRUE;
+#endif
+
+	mmio_start = pci_bar_start(p, PCI_BASE_ADDRESS_0);
+	mmio_len   = pci_bar_size(p,  PCI_BASE_ADDRESS_0);
+	hw.hw_addr = ioremap(mmio_start, mmio_len);
+
+	hw.mac_type = e1000_undefined;
+	adjust_pci_device(p);
+
+	/* From Matt Hortman <mbhortman@acpthinclient.com> */
+	/* MAC and Phy settings */
+
+	/* setup the private structure */
+	if (e1000_sw_init(p, &hw) < 0) {
+		iounmap(hw.hw_addr);
+		return 0;
+	}
+
+	/* make sure the EEPROM is good */
+
+	if (e1000_validate_eeprom_checksum(&hw) < 0) {
+		printf ("The EEPROM Checksum Is Not Valid\n");
+		iounmap(hw.hw_addr);
+		return 0;
+	}
+
+	/* copy the MAC address out of the EEPROM */
+
+	e1000_read_mac_addr(&hw);
+	memcpy (nic->node_addr, hw.mac_addr, ETH_ALEN);
+	
+	printf("Ethernet addr: %!\n", nic->node_addr);
+
+	/* reset the hardware with the new settings */
+
+	ret_val = e1000_reset(&hw);
+	if (ret_val < 0) {
+		if ((ret_val == -E1000_ERR_NOLINK) ||
+			(ret_val == -E1000_ERR_TIMEOUT)) {
+			E1000_ERR("Valid Link not detected\n");
+		} else {
+			E1000_ERR("Hardware Initialization Failed\n");
+		}
+		iounmap(hw.hw_addr);
+		return 0;
+	}
+	init_descriptor();
+
+	/* point to NIC specific routines */
+	dev->disable  = e1000_disable;
+	nic->poll     = e1000_poll;
+	nic->transmit = e1000_transmit;
+	return 1;
+}
+
+static struct pci_id e1000_nics[] = {
+PCI_ROM(0x8086, 0x1000, "e1000-82542",               "Intel EtherExpressPro1000"),
+PCI_ROM(0x8086, 0x1001, "e1000-82543gc-fiber",       "Intel EtherExpressPro1000 82543GC Fiber"),
+PCI_ROM(0x8086, 0x1004, "e1000-82543gc-copper",	     "Intel EtherExpressPro1000 82543GC Copper"),
+PCI_ROM(0x8086, 0x1008, "e1000-82544ei-copper",      "Intel EtherExpressPro1000 82544EI Copper"),
+PCI_ROM(0x8086, 0x1009, "e1000-82544ei-fiber",       "Intel EtherExpressPro1000 82544EI Fiber"),
+PCI_ROM(0x8086, 0x100C, "e1000-82544gc-copper",      "Intel EtherExpressPro1000 82544GC Copper"),
+PCI_ROM(0x8086, 0x100D, "e1000-82544gc-lom",         "Intel EtherExpressPro1000 82544GC LOM"),
+PCI_ROM(0x8086, 0x100E, "e1000-82540em",     	     "Intel EtherExpressPro1000 82540EM"),
+PCI_ROM(0x8086, 0x100F, "e1000-82545em-copper",      "Intel EtherExpressPro1000 82545EM Copper"),
+PCI_ROM(0x8086, 0x1010, "e1000-82546eb-copper",      "Intel EtherExpressPro1000 82546EB Copper"),
+PCI_ROM(0x8086, 0x1011, "e1000-82545em-fiber",       "Intel EtherExpressPro1000 82545EM Fiber"),
+PCI_ROM(0x8086, 0x1012, "e1000-82546eb-fiber", 	     "Intel EtherExpressPro1000 82546EB Copper"),
+PCI_ROM(0x8086, 0x1013, "e1000-82541ei",	     "Intel EtherExpressPro1000 82541EI"),
+PCI_ROM(0x8086, 0x1015, "e1000-82540em-lom",  	     "Intel EtherExpressPro1000 82540EM LOM"),
+PCI_ROM(0x8086, 0x1016, "e1000-82540ep-lom",	     "Intel EtherExpressPro1000 82540EP LOM"),
+PCI_ROM(0x8086, 0x1017, "e1000-82540ep",	     "Intel EtherExpressPro1000 82540EP"),
+PCI_ROM(0x8086, 0x1018, "e1000-82541ep",	     "Intel EtherExpressPro1000 82541EP"),
+PCI_ROM(0x8086, 0x1019, "e1000-82547ei",	     "Intel EtherExpressPro1000 82547EI"),
+PCI_ROM(0x8086, 0x101d, "e1000-82546eb-quad-copper", "Intel EtherExpressPro1000 82546EB Quad Copper"),
+PCI_ROM(0x8086, 0x101e, "e1000-82540ep-lp",	     "Intel EtherExpressPro1000 82540EP LP"),
+};
+
+struct pci_driver e1000_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "E1000",
+	.probe    = e1000_probe,
+	.ids      = e1000_nics,
+	.id_count = sizeof(e1000_nics)/sizeof(e1000_nics[0]),
+	.class    = 0,
+};
Index: netboot/rtl8139.c
===================================================================
--- netboot/rtl8139.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/rtl8139.c	(.../trunk)	(revision 112)
@@ -17,6 +17,8 @@
 /*********************************************************************/
 
 /*
+  28 Dec 2002	ken_yap@users.sourceforge.net (Ken Yap)
+     Put in virt_to_bus calls to allow Etherboot relocation.
 
   06 Apr 2001	ken_yap@users.sourceforge.net (Ken Yap)
      Following email from Hyun-Joon Cha, added a disable routine, otherwise
@@ -63,7 +65,6 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
 #define RTL_TIMEOUT (1*TICKS_PER_SEC)
@@ -160,54 +161,40 @@
 
 /* The RTL8139 can only transmit from a contiguous, aligned memory block.  */
 static unsigned char tx_buffer[TX_BUF_SIZE] __attribute__((aligned(4)));
-
-/* I know that this is a MEGA HACK, but the tagged boot image specification
- * states that we can do whatever we want below 0x10000 - so we do!  */
-/* But we still give the user the choice of using an internal buffer
-   just in case - Ken */
-#ifdef	USE_LOWMEM_BUFFER
-#define rx_ring ((unsigned char *)(0x10000 - (RX_BUF_LEN + 16)))
-#else
 static unsigned char rx_ring[RX_BUF_LEN+16] __attribute__((aligned(4)));
-#endif
 
-struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
-	struct pci_device *pci);
-static int read_eeprom(int location);
+static int rtl8139_probe(struct dev *dev, struct pci_device *pci);
+static int read_eeprom(int location, int addr_len);
 static void rtl_reset(struct nic *nic);
 static void rtl_transmit(struct nic *nic, const char *destaddr,
 	unsigned int type, unsigned int len, const char *data);
 static int rtl_poll(struct nic *nic);
-static void rtl_disable(struct nic*);
+static void rtl_disable(struct dev *);
 
 
-struct nic *rtl8139_probe(struct nic *nic, unsigned short *probeaddrs,
-	struct pci_device *pci)
+static int rtl8139_probe(struct dev *dev, struct pci_device *pci)
 {
+	struct nic *nic = (struct nic *)dev;
 	int i;
 	int speed10, fullduplex;
+	int addr_len;
+	unsigned short *ap = (unsigned short*)nic->node_addr;
 
 	/* There are enough "RTL8139" strings on the console already, so
 	 * be brief and concentrate on the interesting pieces of info... */
 	printf(" - ");
 
 	/* Mask the bit that says "this is an io addr" */
-	ioaddr = probeaddrs[0] & ~3;
+	ioaddr = pci->ioaddr & ~3;
 
 	adjust_pci_device(pci);
 
 	/* Bring the chip out of low-power mode. */
 	outb(0x00, ioaddr + Config1);
 
-	if (read_eeprom(0) != 0xffff) {
-		unsigned short *ap = (unsigned short*)nic->node_addr;
-		for (i = 0; i < 3; i++)
-			*ap++ = read_eeprom(i + 7);
-	} else {
-		unsigned char *ap = (unsigned char*)nic->node_addr;
-		for (i = 0; i < ETH_ALEN; i++)
-			*ap++ = inb(ioaddr + MAC0 + i);
-	}
+	addr_len = read_eeprom(0,8) == 0x8129 ? 8 : 6;
+	for (i = 0; i < 3; i++)
+	  *ap++ = read_eeprom(i + 7,addr_len);
 
 	speed10 = inb(ioaddr + MediaStatus) & MSRSpeed10;
 	fullduplex = inw(ioaddr + MII_BMCR) & BMCRDuplex;
@@ -217,12 +204,16 @@
 
 	rtl_reset(nic);
 
-	nic->reset = rtl_reset;
-	nic->poll = rtl_poll;
+	if (inb(ioaddr + MediaStatus) & MSRLinkFail) {
+		printf("Cable not connected or other link failure\n");
+		return(0);
+	}
+
+	dev->disable  = rtl_disable;
+	nic->poll     = rtl_poll;
 	nic->transmit = rtl_transmit;
-	nic->disable = rtl_disable;
 
-	return nic;
+	return 1;
 }
 
 /* Serial EEPROM section. */
@@ -244,22 +235,23 @@
 #define eeprom_delay()  inl(ee_addr)
 
 /* The EEPROM commands include the alway-set leading bit. */
-#define EE_WRITE_CMD    (5 << 6)
-#define EE_READ_CMD     (6 << 6)
-#define EE_ERASE_CMD    (7 << 6)
+#define EE_WRITE_CMD    (5)
+#define EE_READ_CMD     (6)
+#define EE_ERASE_CMD    (7)
 
-static int read_eeprom(int location)
+static int read_eeprom(int location, int addr_len)
 {
 	int i;
 	unsigned int retval = 0;
 	long ee_addr = ioaddr + Cfg9346;
-	int read_cmd = location | EE_READ_CMD;
+	int read_cmd = location | (EE_READ_CMD << addr_len);
 
 	outb(EE_ENB & ~EE_CS, ee_addr);
 	outb(EE_ENB, ee_addr);
+	eeprom_delay();
 
 	/* Shift the read command bits out. */
-	for (i = 10; i >= 0; i--) {
+	for (i = 4 + addr_len; i >= 0; i--) {
 		int dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;
 		outb(EE_ENB | dataval, ee_addr);
 		eeprom_delay();
@@ -279,9 +271,28 @@
 
 	/* Terminate the EEPROM access. */
 	outb(~EE_CS, ee_addr);
+	eeprom_delay();
 	return retval;
 }
 
+static const unsigned int rtl8139_rx_config = 
+	(RX_BUF_LEN_IDX << 11) |
+	(RX_FIFO_THRESH << 13) |
+	(RX_DMA_BURST << 8);
+	
+static void set_rx_mode(struct nic *nic) {
+	unsigned int mc_filter[2];
+	int rx_mode;
+	/* !IFF_PROMISC */
+	rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+	mc_filter[1] = mc_filter[0] = 0xffffffff;
+
+	outl(rtl8139_rx_config | rx_mode, ioaddr + RxConfig);
+
+	outl(mc_filter[0], ioaddr + MAR0 + 0);
+	outl(mc_filter[1], ioaddr + MAR0 + 4);
+}
+	
 static void rtl_reset(struct nic* nic)
 {
 	int i;
@@ -316,17 +327,24 @@
 #ifdef	DEBUG_RX
 	printf("rx ring address is %X\n",(unsigned long)rx_ring);
 #endif
-	outl((unsigned long)rx_ring, ioaddr + RxBuf);
+	outl((unsigned long)virt_to_bus(rx_ring), ioaddr + RxBuf);
 
-	/* Start the chip's Tx and Rx process. */
-	outl(0, ioaddr + RxMissed);
-	/* set_rx_mode */
-	outb(AcceptBroadcast|AcceptMyPhys, ioaddr + RxConfig);
+
+
 	/* If we add multicast support, the MAR0 register would have to be
 	 * initialized to 0xffffffffffffffff (two 32 bit accesses).  Etherboot
 	 * only needs broadcast (for ARP/RARP/BOOTP/DHCP) and unicast.  */
+
 	outb(CmdRxEnb | CmdTxEnb, ioaddr + ChipCmd);
+	
+	outl(rtl8139_rx_config, ioaddr + RxConfig);
+	
+	/* Start the chip's Tx and Rx process. */
+	outl(0, ioaddr + RxMissed);
 
+	/* set_rx_mode */
+	set_rx_mode(nic);
+	
 	/* Disable all known interrupts by setting the interrupt mask. */
 	outw(0, ioaddr + IntrMask);
 }
@@ -337,10 +355,11 @@
 	unsigned int status, to, nstype;
 	unsigned long txstatus;
 
+	/* nstype assignment moved up here to avoid gcc 3.0.3 compiler bug */
+	nstype = htons(type);
 	memcpy(tx_buffer, destaddr, ETH_ALEN);
 	memcpy(tx_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
-	nstype = htons(type);
-	memcpy(tx_buffer + 2 * ETH_ALEN, (char*)&nstype, 2);
+	memcpy(tx_buffer + 2 * ETH_ALEN, &nstype, 2);
 	memcpy(tx_buffer + ETH_HLEN, data, len);
 
 	len += ETH_HLEN;
@@ -354,7 +373,7 @@
 		tx_buffer[len++] = '\0';
 	}
 
-	outl((unsigned long)tx_buffer, ioaddr + TxAddr0 + cur_tx*4);
+	outl((unsigned long)virt_to_bus(tx_buffer), ioaddr + TxAddr0 + cur_tx*4);
 	outl(((TX_FIFO_THRESH<<11) & 0x003f0000) | len,
 		ioaddr + TxStatus0 + cur_tx*4);
 
@@ -446,8 +465,12 @@
 	return 1;
 }
 
-static void rtl_disable(struct nic *nic)
+static void rtl_disable(struct dev *dev)
 {
+	struct nic *nic = (struct nic *)dev;
+	/* merge reset and disable */
+	rtl_reset(nic);
+
 	/* reset the chip */
 	outb(CmdReset, ioaddr + ChipCmd);
 
@@ -456,3 +479,29 @@
 	while ((inb(ioaddr + ChipCmd) & CmdReset) != 0 && timer2_running())
 		/* wait */;
 }
+
+static struct pci_id rtl8139_nics[] = {
+PCI_ROM(0x10ec, 0x8129, "rtl8129",       "Realtek 8129"),
+PCI_ROM(0x10ec, 0x8139, "rtl8139",       "Realtek 8139"),
+PCI_ROM(0x10ec, 0x8138, "rtl8139b",      "Realtek 8139B"),
+PCI_ROM(0x1186, 0x1300, "dfe538",        "DFE530TX+/DFE538TX"),
+PCI_ROM(0x1113, 0x1211, "smc1211-1",     "SMC EZ10/100"),
+PCI_ROM(0x1112, 0x1211, "smc1211",       "SMC EZ10/100"),
+PCI_ROM(0x1500, 0x1360, "delta8139",     "Delta Electronics 8139"),
+PCI_ROM(0x4033, 0x1360, "addtron8139",   "Addtron Technology 8139"),
+PCI_ROM(0x1186, 0x1340, "dfe690txd",     "D-Link DFE690TXD"),
+PCI_ROM(0x13d1, 0xab06, "fe2000vx",      "AboCom FE2000VX"),
+PCI_ROM(0x1259, 0xa117, "allied8139",    "Allied Telesyn 8139"),
+PCI_ROM(0x14ea, 0xab06, "fnw3603tx",     "Planex FNW-3603-TX"),
+PCI_ROM(0x14ea, 0xab07, "fnw3800tx",     "Planex FNW-3800-TX"),
+PCI_ROM(0xffff, 0x8139, "clone-rtl8139", "Cloned 8139"),
+};
+
+struct pci_driver rtl8139_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "RTL8139",
+	.probe    = rtl8139_probe,
+	.ids      = rtl8139_nics,
+	.id_count = sizeof(rtl8139_nics)/sizeof(rtl8139_nics[0]),
+	.class    = 0,
+};
Index: netboot/w89c840.c
===================================================================
--- netboot/w89c840.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/w89c840.c	(.../trunk)	(revision 112)
@@ -43,6 +43,9 @@
  *                                       using timer2 routines. Proposed
  *                                       by Ken Yap to eliminate CPU speed
  *                                       dependency.
+ *             Dec 12 2003  V0.94   timlegge	Fixed issues in 5.2, removed 
+ *             					interrupt usage, enabled
+ *             					multicast support
  *
  * This is the etherboot driver for cards based on Winbond W89c840F chip.
  *
@@ -77,10 +80,9 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
-static const char *w89c840_version = "diver Version 0.92 - August 27, 2000";
+static const char *w89c840_version = "driver Version 0.94 - December 12, 2003";
 
 typedef unsigned char  u8;
 typedef   signed char  s8;
@@ -90,9 +92,6 @@
 typedef   signed int   s32;
 
 /* Linux support functions */
-#define virt_to_bus(x) ((unsigned long)x)
-#define bus_to_virt(x) ((void *)x)
-
 #define virt_to_le32desc(addr)  virt_to_bus(addr)
 #define le32desc_to_virt(addr)  bus_to_virt(addr)
 
@@ -109,7 +108,6 @@
    bonding and packet priority.
    There are no ill effects from too-large receive rings. */
 #define TX_RING_SIZE    2
-
 #define RX_RING_SIZE    2
 
 /* The presumed FIFO size for working around the Tx-FIFO-overflow bug.
@@ -260,14 +258,8 @@
 
 static int ioaddr;
 static unsigned short eeprom [0x40];
-
-#ifdef    USE_LOWMEM_BUFFER
-#define rx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE)
-#define tx_packet ((char *)0x10000 - PKT_BUF_SZ * RX_RING_SIZE - PKT_BUF_SZ * TX_RING_SIZE)
-#else
 static char        rx_packet[PKT_BUF_SZ * RX_RING_SIZE];
 static char        tx_packet[PKT_BUF_SZ * TX_RING_SIZE];
-#endif
 
 static int  eeprom_read(long ioaddr, int location);
 static int  mdio_read(int base_address, int phy_id, int location);
@@ -277,14 +269,6 @@
 static void set_rx_mode(void);
 static void init_ring(void);
 
-/*
-static void wait_long_time(void)
-{
-    printf("Paused - please read output above this line\n");
-    sleep(3);
-}
-*/
-
 #if defined W89C840_DEBUG
 static void decode_interrupt(u32 intr_status)
 {
@@ -349,10 +333,11 @@
     check_duplex();
     set_rx_mode();
 
-    /* Clear and Enable interrupts by setting the interrupt mask. */
+    /* Do not enable the interrupts Etherboot doesn't need them */
+/*
     writel(0x1A0F5, ioaddr + IntrStatus);
     writel(0x1A0F5, ioaddr + IntrEnable);
-
+*/
 #if defined(W89C840_DEBUG)
     printf("winbond-840 : Done reset.\n");
 #endif
@@ -395,7 +380,6 @@
     int packet_received = 0;
 
     u32 intr_status = readl(ioaddr + IntrStatus);
-    /* handle_intr(intr_status); */ /* -- handled later */
 
     do {
         /* Code from netdev_rx(dev) */
@@ -478,11 +462,7 @@
         entry = (++w840private.cur_rx) % RX_RING_SIZE;
         w840private.rx_head_desc = &w840private.rx_ring[entry];
     } while (0);
-
-    if (intr_status & (AbnormalIntr | TxFIFOUnderflow | IntrPCIErr |TimerInt | IntrTxStopped)) {
-        handle_intr(intr_status);
-    }
-
+    
     return packet_received;
 }
 
@@ -521,13 +501,13 @@
 
     w840private.tx_ring[entry].buffer1 = virt_to_le32desc(tx_packet);
 
-    w840private.tx_ring[entry].length = (DescWholePkt | s);
+    w840private.tx_ring[entry].length = (DescWholePkt | (u32) s);
     if (entry >= TX_RING_SIZE-1)         /* Wrap ring */
         w840private.tx_ring[entry].length |= (DescIntr | DescEndRing);
     w840private.tx_ring[entry].status = (DescOwn);
     w840private.cur_tx++;
 
-    w840private.tx_q_bytes += s;
+    w840private.tx_q_bytes = (u16) s;
     writel(0, ioaddr + TxStartDemand);
 
     /* Work around horrible bug in the chip by marking the queue as full
@@ -554,29 +534,24 @@
 
         while (1) {
 
-            intr_stat = readl(ioaddr + IntrStatus);
 #if defined(W89C840_DEBUG)
-            decode_interrupt(intr_stat);
+	      decode_interrupt(intr_stat);
 #endif
 
-            if (intr_stat & (NormalIntr | IntrTxDone)) {
-
                 while ( (transmit_status & DescOwn) && timer2_running()) {
 
                     transmit_status = w840private.tx_ring[entry].status;
                 }
 
-                writel(intr_stat & 0x0001ffff, ioaddr + IntrStatus);
                 break;
-            }
         }
     }
 
     if ((transmit_status & DescOwn) == 0) {
 
 #if defined(W89C840_DEBUG)
-        printf("winbond-840 : transmission complete after %d wait loop iterations, status %X\n",
-               TX_LOOP_COUNT - transmit_loop_counter, w840private.tx_ring[entry].status);
+        printf("winbond-840 : transmission complete after wait loop iterations, status %X\n",
+                w840private.tx_ring[entry].status);
 #endif
 
         return;
@@ -592,8 +567,12 @@
 /**************************************************************************
 w89c840_disable - Turn off ethernet interface
 ***************************************************************************/
-static void w89c840_disable(struct nic *nic)
+static void w89c840_disable(struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
+    /* merge reset and disable */
+    w89c840_reset(nic);
+
     /* Don't know what to do to disable the board. Is this needed at all? */
     /* Yes, a live NIC can corrupt the loaded memory later [Ken] */
     /* Stop the chip's Tx and Rx processes. */
@@ -603,18 +582,17 @@
 /**************************************************************************
 w89c840_probe - Look for an adapter, this routine's visible to the outside
 ***************************************************************************/
-struct nic *w89c840_probe(struct nic *nic, unsigned short *probe_addrs, struct pci_device *p)
+static int w89c840_probe(struct dev *dev, struct pci_device *p)
 {
+    struct nic *nic = (struct nic *)dev;
     u16 sum = 0;
-    int i, j, to;
+    int i, j;
     unsigned short value;
-    int options;
-    int promisc;
 
-    if (probe_addrs == 0 || probe_addrs[0] == 0)
+    if (p->ioaddr == 0)
         return 0;
 
-    ioaddr = probe_addrs[0]; /* Mask the bit that says "this is an io addr" */
+    ioaddr = p->ioaddr;
 
 #if defined(W89C840_DEBUG)
     printf("winbond-840: PCI bus %hhX device function %hhX: I/O address: %hX\n", p->bus, p->devfn, ioaddr);
@@ -622,8 +600,6 @@
 
     ioaddr = ioaddr & ~3; /* Mask the bit that says "this is an io addr" */
 
-    /* if probe_addrs is 0, then routine can use a hardwired default */
-
     /* From Matt Hortman <mbhortman@acpthinclient.com> */
     if (p->vendor == PCI_VENDOR_ID_WINBOND2
         && p->dev_id == PCI_DEVICE_ID_WINBOND2_89C840) {
@@ -689,14 +665,13 @@
     }
 
     /* point to NIC specific routines */
-    nic->reset = w89c840_reset;
-    nic->poll = w89c840_poll;
+    dev->disable  = w89c840_disable;
+    nic->poll     = w89c840_poll;
     nic->transmit = w89c840_transmit;
-    nic->disable = w89c840_disable;
 
     w89c840_reset(nic);
 
-    return nic;
+    return 1;
 }
 
 /* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.  These are
@@ -877,13 +852,11 @@
     memset(mc_filter, 0xff, sizeof(mc_filter));
 
 /*
- * Actually, should work OK with multicast enabled. -- iko
+ * works OK with multicast enabled. 
  */
-/*
- *  rx_mode = AcceptBroadcast | AcceptMyPhys | AcceptMulticast;
- */
-    rx_mode = AcceptBroadcast | AcceptMyPhys;
 
+    rx_mode = AcceptBroadcast | AcceptMyPhys | AcceptMulticast;
+
     writel(mc_filter[0], ioaddr + MulticastFilter0);
     writel(mc_filter[1], ioaddr + MulticastFilter1);
     w840private.csr6 &= ~0x00F8;
@@ -932,3 +905,18 @@
     }
     return;
 }
+
+
+static struct pci_id w89c840_nics[] = {
+PCI_ROM(0x1050, 0x0840, "winbond840",     "Winbond W89C840F"),
+PCI_ROM(0x11f6, 0x2011, "compexrl100atx", "Compex RL100ATX"),
+};
+
+struct pci_driver w89c840_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "W89C840F",
+	.probe    = w89c840_probe,
+	.ids      = w89c840_nics,
+	.id_count = sizeof(w89c840_nics)/sizeof(w89c840_nics[0]),
+	.class    = 0,
+};
Index: netboot/bootp.h
===================================================================
--- netboot/bootp.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/bootp.h	(.../trunk)	(revision 112)
@@ -0,0 +1,182 @@
+#ifndef	_BOOTP_H
+#define	_BOOTP_H
+
+#include "if_ether.h"
+#include "ip.h"
+#include "udp.h"
+
+#ifndef	MAX_BOOTP_RETRIES
+#define MAX_BOOTP_RETRIES	20
+#endif
+
+#ifdef	ALTERNATE_DHCP_PORTS_1067_1068
+#undef	NON_STANDARD_BOOTP_SERVER
+#define	NON_STANDARD_BOOTP_SERVER	1067
+#undef	NON_STANDARD_BOOTP_CLIENT
+#define	NON_STANDARD_BOOTP_CLIENT	1068
+#endif
+
+#ifdef	NON_STANDARD_BOOTP_SERVER
+#define	BOOTP_SERVER	NON_STANDARD_BOOTP_SERVER
+#else
+#define BOOTP_SERVER	67
+#endif
+#ifdef	NON_STANDARD_BOOTP_CLIENT
+#define	BOOTP_CLIENT	NON_STANDARD_BOOTP_CLIENT
+#else
+#define BOOTP_CLIENT	68
+#endif
+
+#define BOOTP_REQUEST	1
+#define BOOTP_REPLY	2
+
+#define TAG_LEN(p)		(*((p)+1))
+#define RFC1533_COOKIE		99, 130, 83, 99
+#define RFC1533_PAD		0
+#define RFC1533_NETMASK		1
+#define RFC1533_TIMEOFFSET	2
+#define RFC1533_GATEWAY		3
+#define RFC1533_TIMESERVER	4
+#define RFC1533_IEN116NS	5
+#define RFC1533_DNS		6
+#define RFC1533_LOGSERVER	7
+#define RFC1533_COOKIESERVER	8
+#define RFC1533_LPRSERVER	9
+#define RFC1533_IMPRESSSERVER	10
+#define RFC1533_RESOURCESERVER	11
+#define RFC1533_HOSTNAME	12
+#define RFC1533_BOOTFILESIZE	13
+#define RFC1533_MERITDUMPFILE	14
+#define RFC1533_DOMAINNAME	15
+#define RFC1533_SWAPSERVER	16
+#define RFC1533_ROOTPATH	17
+#define RFC1533_EXTENSIONPATH	18
+#define RFC1533_IPFORWARDING	19
+#define RFC1533_IPSOURCEROUTING	20
+#define RFC1533_IPPOLICYFILTER	21
+#define RFC1533_IPMAXREASSEMBLY	22
+#define RFC1533_IPTTL		23
+#define RFC1533_IPMTU		24
+#define RFC1533_IPMTUPLATEAU	25
+#define RFC1533_INTMTU		26
+#define RFC1533_INTLOCALSUBNETS	27
+#define RFC1533_INTBROADCAST	28
+#define RFC1533_INTICMPDISCOVER	29
+#define RFC1533_INTICMPRESPOND	30
+#define RFC1533_INTROUTEDISCOVER 31
+#define RFC1533_INTROUTESOLICIT	32
+#define RFC1533_INTSTATICROUTES	33
+#define RFC1533_LLTRAILERENCAP	34
+#define RFC1533_LLARPCACHETMO	35
+#define RFC1533_LLETHERNETENCAP	36
+#define RFC1533_TCPTTL		37
+#define RFC1533_TCPKEEPALIVETMO	38
+#define RFC1533_TCPKEEPALIVEGB	39
+#define RFC1533_NISDOMAIN	40
+#define RFC1533_NISSERVER	41
+#define RFC1533_NTPSERVER	42
+#define RFC1533_VENDOR		43
+#define RFC1533_NBNS		44
+#define RFC1533_NBDD		45
+#define RFC1533_NBNT		46
+#define RFC1533_NBSCOPE		47
+#define RFC1533_XFS		48
+#define RFC1533_XDM		49
+#ifndef	NO_DHCP_SUPPORT
+#define RFC2132_REQ_ADDR	50
+#define RFC2132_MSG_TYPE	53
+#define RFC2132_SRV_ID		54
+#define RFC2132_PARAM_LIST	55
+#define RFC2132_MAX_SIZE	57
+#define	RFC2132_VENDOR_CLASS_ID	60
+
+#define DHCPDISCOVER		1
+#define DHCPOFFER		2
+#define DHCPREQUEST		3
+#define DHCPACK			5
+#endif	/* NO_DHCP_SUPPORT */
+
+#define RFC1533_VENDOR_MAJOR	0
+#define RFC1533_VENDOR_MINOR	0
+
+#define RFC1533_VENDOR_MAGIC	128
+#define RFC1533_VENDOR_ADDPARM	129
+#define	RFC1533_VENDOR_ETHDEV	130
+#ifdef	IMAGE_FREEBSD
+#define RFC1533_VENDOR_HOWTO    132
+#define RFC1533_VENDOR_KERNEL_ENV    133
+#endif
+#define RFC1533_VENDOR_ETHERBOOT_ENCAP 150
+#define RFC1533_VENDOR_MNUOPTS	160
+#define RFC1533_VENDOR_NIC_DEV_ID 175
+#define RFC1533_VENDOR_SELECTION 176
+#define RFC1533_VENDOR_ARCH     177
+#define RFC1533_VENDOR_MOTD	184
+#define RFC1533_VENDOR_NUMOFMOTD 8
+#define RFC1533_VENDOR_IMG	192
+#define RFC1533_VENDOR_NUMOFIMG	16
+
+#define RFC1533_VENDOR_CONFIGFILE 150
+
+#define RFC1533_END		255
+
+#define BOOTP_VENDOR_LEN	64
+
+#define DHCP_OPT_LEN		312
+
+/* Format of a bootp packet */
+struct bootp_t {
+	uint8_t  bp_op;
+	uint8_t  bp_htype;
+	uint8_t  bp_hlen;
+	uint8_t  bp_hops;
+	uint32_t bp_xid;
+	uint16_t bp_secs;
+	uint16_t unused;
+	in_addr bp_ciaddr;
+	in_addr bp_yiaddr;
+	in_addr bp_siaddr;
+	in_addr bp_giaddr;
+	uint8_t  bp_hwaddr[16];
+	uint8_t  bp_sname[64];
+	char     bp_file[128];
+	uint8_t  bp_vend[BOOTP_VENDOR_LEN];
+};
+
+struct dhcp_t {
+	uint8_t  bp_op;
+	uint8_t  bp_htype;
+	uint8_t  bp_hlen;
+	uint8_t  bp_hops;
+	uint32_t bp_xid;
+	uint16_t bp_secs;
+	uint16_t bp_flag;
+	in_addr bp_ciaddr;
+	in_addr bp_yiaddr;
+	in_addr bp_siaddr;
+	in_addr bp_giaddr;
+	uint8_t  bp_hwaddr[16];
+	uint8_t  bp_sname[64];
+	char     bp_file[128];
+	uint8_t  bp_vend[DHCP_OPT_LEN];
+};
+
+/* Format of a bootp IP packet */
+struct bootpip_t
+{
+	struct iphdr ip;
+	struct udphdr udp;
+	struct bootp_t bp;
+};
+struct dhcpip_t
+{
+	struct iphdr ip;
+	struct udphdr udp;
+	struct dhcp_t bp;
+};
+
+#define MAX_RFC1533_VENDLEN (ETH_MAX_MTU - sizeof(struct bootpip_t) + BOOTP_VENDOR_LEN)
+
+#define BOOTP_DATA_ADDR (&bootp_data)
+
+#endif	/* _BOOTP_H */
Index: netboot/rpc.h
===================================================================
--- netboot/rpc.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/rpc.h	(.../trunk)	(revision 112)
@@ -0,0 +1,364 @@
+#ifndef RPC_H
+#define RPC_H
+
+#include "types.h"
+#include "in.h"
+#include "timer.h"
+
+enum xdr_op {
+	XDR_ENCODE = 0,
+	XDR_DECODE = 1,
+	XDR_FREE = 2
+};
+
+#define BYTES_PER_XDR_UNIT	(4)
+
+#define RNDUP(x)  (((x) + BYTES_PER_XDR_UNIT - 1) & ~(BYTES_PER_XDR_UNIT - 1))
+
+typedef struct XDR XDR;
+struct XDR {
+	enum xdr_op x_op;		/* operation; fast additional param */
+	
+	/* We use following private */
+	caddr_t x_public;		/* users' data */
+	caddr_t x_private;		/* pointer to private data */
+	caddr_t x_base;		/* private used for position info */
+	int x_handy;		/* extra private word */
+};
+
+typedef bool_t (*xdrproc_t) (XDR *, void *,...);
+
+#define XDR_INLINE xdr_inline
+
+#define NULL_xdrproc_t ((xdrproc_t)0)
+struct xdr_discrim {
+	int value;
+	xdrproc_t proc;
+};
+
+#define IXDR_GET_INT32(buf)           ((int32_t)ntohl((uint32_t)*(buf)++))
+#define IXDR_PUT_INT32(buf, v)        (*(buf)++ = (int32_t)htonl((uint32_t)(v)))
+#define IXDR_GET_U_INT32(buf)         ((uint32_t)IXDR_GET_INT32(buf))
+#define IXDR_PUT_U_INT32(buf, v)      IXDR_PUT_INT32(buf, (int32_t)(v))
+
+/* WARNING: The IXDR_*_LONG defines are removed by Sun for new platforms
+ * and shouldn't be used any longer. Code which use this defines or longs
+ * in the RPC code will not work on 64bit Solaris platforms !
+ */
+#define IXDR_GET_LONG(buf) ((long)IXDR_GET_U_INT32(buf))
+#define IXDR_PUT_LONG(buf, v) ((long)IXDR_PUT_INT32(buf, (long)(v)))
+#define IXDR_GET_U_LONG(buf)	      ((u_long)IXDR_GET_LONG(buf))
+#define IXDR_PUT_U_LONG(buf, v)	      IXDR_PUT_LONG(buf, (long)(v))
+
+
+#define IXDR_GET_BOOL(buf)            ((bool_t)IXDR_GET_LONG(buf))
+#define IXDR_GET_ENUM(buf, t)         ((t)IXDR_GET_LONG(buf))
+#define IXDR_GET_SHORT(buf)           ((short)IXDR_GET_LONG(buf))
+#define IXDR_GET_U_SHORT(buf)         ((u_short)IXDR_GET_LONG(buf))
+
+#define IXDR_PUT_BOOL(buf, v)         IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_PUT_ENUM(buf, v)         IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_PUT_SHORT(buf, v)        IXDR_PUT_LONG(buf, (long)(v))
+#define IXDR_PUT_U_SHORT(buf, v)      IXDR_PUT_LONG(buf, (long)(v))
+
+/*
+ * These are the "generic" xdr routines.
+ * None of these can have const applied because it's not possible to
+ * know whether the call is a read or a write to the passed parameter
+ * also, the XDR structure is always updated by some of these calls.
+ */
+extern bool_t xdr_void (void)  ;
+extern bool_t xdr_short (XDR *__xdrs, short *__sp)  ;
+extern bool_t xdr_u_short (XDR *__xdrs, u_short *__usp)  ;
+extern bool_t xdr_int (XDR *__xdrs, int *__ip)  ;
+extern bool_t xdr_u_int (XDR *__xdrs, u_int *__up)  ;
+extern bool_t xdr_long (XDR *__xdrs, long *__lp)  ;
+extern bool_t xdr_u_long (XDR *__xdrs, u_long *__ulp)  ;
+extern bool_t xdr_hyper (XDR *__xdrs, quad_t *__llp)  ;
+extern bool_t xdr_u_hyper (XDR *__xdrs, u_quad_t *__ullp)  ;
+extern bool_t xdr_longlong_t (XDR *__xdrs, quad_t *__llp)  ;
+extern bool_t xdr_u_longlong_t (XDR *__xdrs, u_quad_t *__ullp)  ;
+extern bool_t xdr_int8_t (XDR *__xdrs, int8_t *__ip)  ;
+extern bool_t xdr_uint8_t (XDR *__xdrs, uint8_t *__up)  ;
+extern bool_t xdr_int16_t (XDR *__xdrs, int16_t *__ip)  ;
+extern bool_t xdr_uint16_t (XDR *__xdrs, uint16_t *__up)  ;
+extern bool_t xdr_int32_t (XDR *__xdrs, int32_t *__ip)  ;
+extern bool_t xdr_uint32_t (XDR *__xdrs, uint32_t *__up)  ;
+extern bool_t xdr_int64_t (XDR *__xdrs, int64_t *__ip)  ;
+extern bool_t xdr_uint64_t (XDR *__xdrs, uint64_t *__up)  ;
+extern bool_t xdr_bool (XDR *__xdrs, bool_t *__bp)  ;
+extern bool_t xdr_enum (XDR *__xdrs, enum_t *__ep)  ;
+extern bool_t xdr_array (XDR * _xdrs, caddr_t *__addrp, u_int *__sizep,
+			 u_int __maxsize, u_int __elsize, xdrproc_t __elproc)
+      ;
+extern bool_t xdr_bytes (XDR *__xdrs, char **__cpp, u_int *__sizep,
+			 u_int __maxsize)  ;
+extern bool_t xdr_opaque (XDR *__xdrs, caddr_t __cp, u_int __cnt)  ;
+extern bool_t xdr_string (XDR *__xdrs, char **__cpp, u_int __maxsize)  ;
+extern bool_t xdr_union (XDR *__xdrs, enum_t *__dscmp, char *__unp,
+			 __const struct xdr_discrim *__choices,
+			 xdrproc_t dfault)  ;
+extern bool_t xdr_char (XDR *__xdrs, char *__cp)  ;
+extern bool_t xdr_u_char (XDR *__xdrs, u_char *__cp)  ;
+extern bool_t xdr_vector (XDR *__xdrs, char *__basep, u_int __nelem,
+			  u_int __elemsize, xdrproc_t __xdr_elem)  ;
+extern bool_t xdr_float (XDR *__xdrs, float *__fp)  ;
+extern bool_t xdr_double (XDR *__xdrs, double *__dp)  ;
+extern bool_t xdr_reference (XDR *__xdrs, caddr_t *__xpp, u_int __size,
+			     xdrproc_t __proc)  ;
+extern bool_t xdr_pointer (XDR *__xdrs, char **__objpp,
+			   u_int __obj_size, xdrproc_t __xdr_obj)  ;
+extern bool_t xdr_wrapstring (XDR *__xdrs, char **__cpp)  ;
+extern u_long xdr_sizeof (xdrproc_t, void *)  ;
+
+/*
+ * Common opaque bytes objects used by many rpc protocols;
+ * declared here due to commonality.
+ */
+#define MAX_NETOBJ_SZ 1024
+struct netobj {
+	u_int n_len;
+	char *n_bytes;
+};
+typedef struct netobj netobj;
+extern bool_t xdr_netobj (XDR *__xdrs, struct netobj *__np)  ;
+
+
+/*
+ * Rpc calls return an enum clnt_stat.  This should be looked at more,
+ * since each implementation is required to live with this (implementation
+ * independent) list of errors.
+ */
+enum clnt_stat {
+	RPC_SUCCESS=0,			/* call succeeded */
+	/*
+	 * local errors
+	 */
+	RPC_CANTENCODEARGS=1,		/* can't encode arguments */
+	RPC_CANTDECODERES=2,		/* can't decode results */
+	RPC_CANTSEND=3,			/* failure in sending call */
+	RPC_CANTRECV=4,			/* failure in receiving result */
+	RPC_TIMEDOUT=5,			/* call timed out */
+	/*
+	 * remote errors
+	 */
+	RPC_VERSMISMATCH=6,		/* rpc versions not compatible */
+	RPC_AUTHERROR=7,		/* authentication error */
+	RPC_PROGUNAVAIL=8,		/* program not available */
+	RPC_PROGVERSMISMATCH=9,		/* program version mismatched */
+	RPC_PROCUNAVAIL=10,		/* procedure unavailable */
+	RPC_CANTDECODEARGS=11,		/* decode arguments error */
+	RPC_SYSTEMERROR=12,		/* generic "other problem" */
+	RPC_NOBROADCAST = 21,		/* Broadcasting not supported */
+	/*
+	 * callrpc & clnt_create errors
+	 */
+	RPC_UNKNOWNHOST=13,		/* unknown host name */
+	RPC_UNKNOWNPROTO=17,		/* unknown protocol */
+	RPC_UNKNOWNADDR = 19,		/* Remote address unknown */
+
+	/*
+	 * rpcbind errors
+	 */
+	RPC_RPCBFAILURE=14,		/* portmapper failed in its call */
+#define RPC_PMAPFAILURE RPC_RPCBFAILURE
+	RPC_PROGNOTREGISTERED=15,	/* remote program is not registered */
+	RPC_N2AXLATEFAILURE = 22,	/* Name to addr translation failed */
+	/*
+	 * unspecified error
+	 */
+	RPC_FAILED=16,
+	RPC_INTR=18,
+	RPC_TLIERROR=20,
+	RPC_UDERROR=23,
+        /*
+         * asynchronous errors
+         */
+        RPC_INPROGRESS = 24,
+        RPC_STALERACHANDLE = 25
+};
+
+/*
+ * Status returned from authentication check
+ */
+enum auth_stat {
+	AUTH_OK=0,
+	/*
+	 * failed at remote end
+	 */
+	AUTH_BADCRED=1,			/* bogus credentials (seal broken) */
+	AUTH_REJECTEDCRED=2,		/* client should begin new session */
+	AUTH_BADVERF=3,			/* bogus verifier (seal broken) */
+	AUTH_REJECTEDVERF=4,		/* verifier expired or was replayed */
+	AUTH_TOOWEAK=5,			/* rejected due to security reasons */
+	/*
+	 * failed locally
+	*/
+	AUTH_INVALIDRESP=6,		/* bogus response verifier */
+	AUTH_FAILED=7			/* some unknown reason */
+};
+
+
+
+
+/*
+ * Error info.
+ */
+struct rpc_err {
+	enum clnt_stat re_status;
+	union {
+		int RE_errno;		/* related system error */
+		enum auth_stat RE_why;	/* why the auth error occurred */
+		struct {
+			u_long low;		/* lowest verion supported */
+			u_long high;		/* highest verion supported */
+		} RE_vers;
+		struct {			/* maybe meaningful if RPC_FAILED */
+			long s1;
+			long s2;
+		} RE_lb;			/* life boot & debugging only */
+	} ru;
+#define	re_errno	ru.RE_errno
+#define	re_why		ru.RE_why
+#define	re_vers		ru.RE_vers
+#define	re_lb		ru.RE_lb
+};
+
+struct opaque_auth{
+	long flavor;
+	long length;
+	long data[0];
+};
+extern long *add_auth_unix(struct opaque_auth *_auth);
+extern long *add_auth_none(struct opaque_auth *_auth);
+
+typedef struct AUTH AUTH;
+struct AUTH{
+	long *(* add_auth)(struct opaque_auth *);
+
+};
+extern AUTH *__authnone_create(AUTH *_auth);
+extern void auth_destroy(AUTH *_auth);
+
+/*
+ * Client rpc handle.
+ * Created by individual implementations, see e.g. rpc_udp.c.
+ * Client is responsible for initializing auth, see e.g. auth_none.c.
+ */
+typedef struct CLIENT CLIENT;
+struct CLIENT {
+	AUTH	*cl_auth;	/* authenticator */
+	unsigned long xid;	/* RPC id */
+	int server;		/* entry in ARP table */
+	u_short port;		/* RPC server port */
+	u_short sport;		/* Local port */
+	u_long prognum;		/* RPC program number */
+	u_long versnum;		/* RPC program version */
+};
+
+/*
+ * control operations that apply to all transports
+ *
+ * Note: options marked XXX are no-ops in this implementation of RPC.
+ * The are present in TI-RPC but can't be implemented here since they
+ * depend on the presence of STREAMS/TLI, which we don't have.
+ */
+#define CLSET_TIMEOUT        1    /* set timeout (timeval) */
+#define CLGET_TIMEOUT        2    /* get timeout (timeval) */
+#define CLGET_SERVER_ADDR    3    /* get server's address (sockaddr) */
+#define CLGET_FD             6    /* get connections file descriptor */
+#define CLGET_SVC_ADDR       7    /* get server's address (netbuf)      XXX */
+#define CLSET_FD_CLOSE       8    /* close fd while clnt_destroy */
+#define CLSET_FD_NCLOSE      9    /* Do not close fd while clnt_destroy*/
+#define CLGET_XID            10   /* Get xid */
+#define CLSET_XID            11   /* Set xid */
+#define CLGET_VERS           12   /* Get version number */
+#define CLSET_VERS           13   /* Set version number */
+#define CLGET_PROG           14   /* Get program number */
+#define CLSET_PROG           15   /* Set program number */
+#define CLSET_SVC_ADDR       16   /* get server's address (netbuf)      XXX */
+#define CLSET_PUSH_TIMOD     17   /* push timod if not already present  XXX */
+#define CLSET_POP_TIMOD      18   /* pop timod                          XXX */
+/*
+ * Connectionless only control operations
+ */
+#define CLSET_RETRY_TIMEOUT	4	/* set retry timeout (timeval) */
+#define CLGET_RETRY_TIMEOUT	5	/* get retry timeout (timeval) */
+
+
+#define UDPMSGSIZE	8800	/* rpc imposed limit on udp msg size */
+#define RPCSMALLMSGSIZE	400	/* a more reasonable packet size */
+
+#define clnt_call clntudp_call
+
+CLIENT *__clntudp_create(CLIENT *__clnt, AUTH *__auth, int __server,
+			 u_short __port, u_long __prognum, u_long __versnum);
+
+struct rpc_pkg{
+	struct iphdr ip;
+	struct udphdr udp;
+	union{
+		char data[300];		/* longest RPC call must fit!!!! */
+		/* The call body */
+		struct{
+			long xid;
+			long mtype;
+			long rpcvers;
+			long prog;
+			long vers;
+			long proc;
+			struct opaque_auth auth[0];
+		}call;
+		/* The reply body */
+		struct{
+			long xid;
+			long mtype;
+			long stat;
+			long verifier;
+			long v2;
+			long astatus;
+			long data[0];
+		}reply;
+	}u;
+};
+#define cbody u.call
+#define rbody u.reply
+#define areply u.reply.u
+
+#define AUTH_NONE	0		/* no authentication */
+#define	AUTH_NULL	0		/* backward compatibility */
+#define	AUTH_SYS	1		/* unix style (uid, gids) */
+#define	AUTH_UNIX	AUTH_SYS
+#define	AUTH_SHORT	2		/* short hand unix style */
+#define AUTH_DES	3		/* des style (encrypted timestamps) */
+#define AUTH_DH		AUTH_DES	/* Diffie-Hellman (this is DES) */
+#define AUTH_KERB       4               /* kerberos style */
+
+#define PMAP_PORT 111
+
+struct mapping {
+	u_int prog;
+	u_int vers;
+	u_int prot;
+	u_int port;
+};
+
+typedef struct mapping mappping;
+#define IPPROTO_TCP 6
+#define IPPROTO_UDP 17
+
+#define PMAP_PROG 100000
+#define PMAP_VERS 2
+
+#define PMAPROC_GETPORT 3
+extern  bool_t xdr_mappping (XDR *, mappping*);
+
+
+enum msg_type {
+	MSG_CALL = 0,
+	MSG_REPLY = 1
+};
+
+
+
+#endif /*RPC_H*/
Index: netboot/pxe_tftp.c
===================================================================
--- netboot/pxe_tftp.c	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/pxe_tftp.c	(.../trunk)	(revision 112)
@@ -0,0 +1,694 @@
+/**************************************************************************
+Etherboot -  BOOTP/TFTP Bootstrap Program
+UNDI NIC driver for Etherboot
+
+This file Copyright (C) 2003 Michael Brown <mbrown@fensystems.co.uk>
+of Fen Systems Ltd. (http://www.fensystems.co.uk/).  All rights
+reserved.
+
+$Id$
+***************************************************************************/
+
+/*
+ * Support for most UNDI code removed since not needed and support for PXE
+ * TFTP added.
+ * Reformatted.
+ *
+ * Adam Lackorzynski <adam@os.inf.tu-dresden.de>
+ *
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+
+#include "etherboot.h"
+#include "nic.h"
+#include "pci.h"
+#include "undi.h"
+#include "pxe_tftp.h"
+
+/* NIC specific static variables go here */
+static undi_t undi = { NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		       NULL, NULL, 0, NULL, 0, NULL,
+		       0, 0, 0, 0,
+		       { 0, 0, 0, NULL, 0, 0, 0, 0, 0, NULL },
+		       IRQ_NONE };
+static undi_base_mem_data_t undi_base_mem_data;
+
+static int pxe_tftp_driver_active_value;
+static int pxe_tftp_opened;
+
+/* Function prototypes */
+static int allocate_base_mem_data ( void );
+static int free_base_mem_data ( void );
+
+/**************************************************************************
+ * Utility functions
+ **************************************************************************/
+
+static inline uint32_t get_free_base_memory(void)
+{
+  return *((uint16_t *)phys_to_virt(0x413)) << 10;
+}
+
+
+/* Checksum a block.
+ */
+
+static uint8_t checksum (void *block, size_t size)
+{
+  uint8_t sum = 0;
+  uint16_t i;
+
+  for (i = 0; i < size; i++)
+    sum += ((uint8_t *)block)[i];
+
+  return sum;
+}
+
+/* Print the status of a !PXE structure
+ */
+static void pxe_dump (void)
+{
+  printf("API %hx:%hx St %hx:%hx UD %hx:%hx UC %hx:%hx "
+         "BD %hx:%hx BC %hx:%hx\n",
+         undi.pxe->EntryPointSP.segment, undi.pxe->EntryPointSP.offset,
+         undi.pxe->Stack.Seg_Addr, undi.pxe->Stack.Seg_Size,
+         undi.pxe->UNDIData.Seg_Addr, undi.pxe->UNDIData.Seg_Size,
+         undi.pxe->UNDICode.Seg_Addr, undi.pxe->UNDICode.Seg_Size,
+         undi.pxe->BC_Data.Seg_Addr, undi.pxe->BC_Data.Seg_Size,
+         undi.pxe->BC_Code.Seg_Addr, undi.pxe->BC_Code.Seg_Size );
+}
+
+/* Allocate/free space for structures that must reside in base memory
+ */
+int allocate_base_mem_data(void)
+{
+  /* In GRUB, anything is in base address, so we do not need
+   * allocate anything */
+  undi.base_mem_data  = &undi_base_mem_data;
+  memset(undi.base_mem_data, 0, sizeof(undi_base_mem_data_t));
+  undi.undi_call_info = &undi.base_mem_data->undi_call_info;
+  undi.pxs            = &undi.base_mem_data->pxs;
+  undi.xmit_data      = &undi.base_mem_data->xmit_data;
+  undi.xmit_buffer    = undi.base_mem_data->xmit_buffer;
+
+  return 1;
+}
+
+int free_base_mem_data(void)
+{
+  /* Just pretend to free something :-) */
+  undi.base_mem_data  = NULL;
+  undi.undi_call_info = NULL;
+  undi.pxs            = NULL;
+  undi.xmit_data      = NULL;
+  undi.xmit_buffer    = NULL;
+
+  return 1;
+}
+
+/* Debug macros
+ */
+
+#define TRACE_UNDI
+#ifdef TRACE_UNDI
+#define DBG(...) printf ( __VA_ARGS__ )
+#else
+#define DBG(...)
+#endif
+
+#define UNDI_STATUS(pxs) ( (pxs)->Status == PXENV_EXIT_SUCCESS ? \
+			      "SUCCESS" : \
+			      ( (pxs)->Status == PXENV_EXIT_FAILURE ? \
+				"FAILURE" : "UNKNOWN" ) )
+
+/**************************************************************************
+ * Base memory scanning functions
+ **************************************************************************/
+
+/* Locate the $PnP structure indicating a PnP BIOS.
+ */
+
+static int hunt_pnp_bios(void)
+{
+  uint32_t off = 0x10000;
+
+  printf("Hunting for PnP BIOS...");
+  while (off > 0)
+    {
+      off -= 16;
+      undi.pnp_bios = (pnp_bios_t *)phys_to_virt(0xf0000 + off);
+      if (undi.pnp_bios->signature == PNP_BIOS_SIGNATURE)
+        {
+          printf("found $PnP at f000:%hx...", off);
+          if (checksum(undi.pnp_bios,sizeof(pnp_bios_t)))
+            {
+              printf("invalid checksum\n...");
+              continue;
+            }
+          printf("ok\n");
+          return 1;
+        }
+    }
+  printf("none found\n");
+  undi.pnp_bios = NULL;
+  return 0;
+}
+
+/* Locate the !PXE structure indicating a loaded UNDI driver.
+ */
+
+static int hunt_pixie (void)
+{
+  static uint32_t ptr = 0;
+  pxe_t *pxe = NULL;
+
+  printf("Hunting for pixies...");
+  if (ptr == 0)
+    ptr = 0xa0000;
+  while (ptr > 0x10000 )
+    {
+      ptr -= 16;
+      pxe = (pxe_t *)phys_to_virt(ptr);
+      if (memcmp(pxe->Signature, "!PXE", 4) == 0)
+        {
+          printf("found !PXE at %x...", ptr);
+          if (checksum(pxe, sizeof(pxe_t)) != 0)
+            {
+              printf("invalid checksum\n...");
+              continue;
+            }
+          if (ptr < get_free_base_memory())
+            {
+              printf("in free base memory!\n\n"
+                     "WARNING: a valid !PXE structure was "
+                     "found in an area of memory marked "
+                     "as free!\n\n" );
+              undi.pxe = pxe;
+              pxe_dump();
+              undi.pxe = NULL;
+              printf("\nIgnoring and continuing, but this "
+                     "may cause problems later!\n\n" );
+              continue;
+            }
+          printf("ok\n");
+          undi.pxe = pxe;
+          return 1;
+      }
+  }
+  printf("none found\n");
+  ptr = 0;
+  return 0;
+}
+
+/**************************************************************************
+ * Low-level UNDI API call wrappers
+ **************************************************************************/
+
+/* Make a real-mode UNDI API call to the UNDI routine at
+ * routine_seg:routine_off, passing in three uint16 parameters on the
+ * real-mode stack.
+ * Calls the assembler wrapper routine __undi_call.
+ */
+
+static inline PXENV_EXIT_t _undi_call(uint16_t routine_seg,
+                                      uint16_t routine_off, uint16_t st0,
+                                      uint16_t st1, uint16_t st2)
+{
+  PXENV_EXIT_t ret = PXENV_EXIT_FAILURE;
+
+  undi.undi_call_info->routine.segment = routine_seg;
+  undi.undi_call_info->routine.offset = routine_off;
+  undi.undi_call_info->stack[0] = st0;
+  undi.undi_call_info->stack[1] = st1;
+  undi.undi_call_info->stack[2] = st2;
+  ret = __undi_call(SEGMENT(undi.undi_call_info), OFFSET(undi.undi_call_info));
+
+  /* UNDI API calls may rudely change the status of A20 and not
+   * bother to restore it afterwards.  Intel is known to be
+   * guilty of this.
+   *
+   * Note that we will return to this point even if A20 gets
+   * screwed up by the UNDI driver, because Etherboot always
+   * resides in an even megabyte of RAM.
+   */
+  gateA20_set();
+
+  return ret;
+}
+
+/* Make a real-mode UNDI API call, passing in the opcode and the
+ * seg:off address of a pxenv_structure on the real-mode stack.
+ *
+ * Two versions: undi_call() will automatically report any failure
+ * codes, undi_call_silent() will not.
+ */
+
+static int undi_call_silent(uint16_t opcode)
+{
+  PXENV_EXIT_t pxenv_exit = PXENV_EXIT_FAILURE;
+
+  pxenv_exit = _undi_call(undi.pxe->EntryPointSP.segment,
+                          undi.pxe->EntryPointSP.offset,
+                          opcode, OFFSET(undi.pxs), SEGMENT(undi.pxs));
+
+  /* Return 1 for success, to be consistent with other routines */
+  return pxenv_exit == PXENV_EXIT_SUCCESS ? 1 : 0;
+}
+
+static int undi_call(uint16_t opcode)
+{
+  if (undi_call_silent(opcode))
+    return 1;
+  printf("UNDI API call %#hx failed with status %#hx\n",
+         opcode, undi.pxs->Status);
+  return 0;
+}
+
+
+
+/**************************************************************************
+ * High-level PXE API call wrappers
+ **************************************************************************/
+
+static int pxe_get_cache_info(void)
+{
+  int ret;
+  BOOTPLAYER bp;
+
+  memset(&bp, 0, sizeof(bp));
+
+  undi.pxs->cached_info.PacketType = PXENV_PACKET_TYPE_DHCP_ACK;
+  undi.pxs->cached_info.BufferSize = sizeof(BOOTPLAYER);
+  undi.pxs->cached_info.Buffer.segment = SEGMENT(&bp);
+  undi.pxs->cached_info.Buffer.offset  = OFFSET(&bp);
+
+  ret = undi_call(PXENV_GET_CACHED_INFO);
+
+  if (undi.pxs->cached_info.BufferSize != sizeof(BOOTPLAYER))
+    printf("strange copied: %d vs %d\n",
+	   undi.pxs->cached_info.BufferSize, sizeof(BOOTPLAYER));
+
+  arptable[ARP_CLIENT].ipaddr.s_addr  = bp.yip;
+  arptable[ARP_GATEWAY].ipaddr.s_addr = bp.gip;
+  arptable[ARP_SERVER].ipaddr.s_addr  = bp.sip;
+
+  store_ip_in_var(arptable[ARP_CLIENT].ipaddr);
+
+  decode_rfc1533(bp.vendor.d, 0, sizeof(bp.vendor), 1);
+  printf("configfile: %s\n", config_file);
+
+  return ret;
+}
+
+static void __stop(void)
+{
+  printf("--HALTED--\n");
+  while (1) { asm volatile ("hlt"); }
+}
+
+/**
+ * return 1 if active, 0 if not active
+ */
+int pxe_tftp_driver_active(void)
+{
+  return pxe_tftp_driver_active_value;
+}
+
+enum { PXE_TFTP_BUFFER_SIZE = 512 }; // ATT: minimum 512 Bytes!
+
+// enum { PXE_TFTP_BUFFER_SIZE = 1432 };
+// some TFTP servers ignore the block size and always use 512 bytes and do
+// not care about the negotiation, thus we do not really detect this
+// we will just fail then. If you have such a broken TFTP server, you have
+// to use the 512 Byte default. If your ROM is not as broken, you may also
+// try to change the packetsize to 1432 bytes and enjoy bigger packet sizes
+// (and hopefully better performance).
+// Unfortunately it also does not work if we ask for some really large
+// (>MTU) packet size because e.g. my e1000 ROM just hangs on open there.
+// The wish would be, that if the NIC ignores the packetsize, we just use
+// 512 Bytes.
+//
+// Also: if you change the PXE_TFTP_BUFFER_SIZE to something greather than
+// 512 and your ROM does not support this, operating will somewhat silently
+// fail as the end-of-file detection will hit for the first transfered
+// packet (read-bytes < buffer-size) and your menu.lst will not fully be
+// transmitted.
+static char pxe_tftp_read_buf[PXE_TFTP_BUFFER_SIZE];
+static int  pxe_tftp_negotiated_buffer_size;
+static char pxe_tftp_read_filename[128]; // filename, needed for seeking
+static int  pxe_tftp_read_buf_size; // size still available to read
+static int  pxe_tftp_packet_size;   // size of current buffer
+static int  pxe_tftp_read_buf_pos;  // current position in buf
+   // i.e.: pxe_tftp_read_buf_pos + pxe_tftp_read_buf_size
+   //       == pxe_tftp_packet_size
+static int  pxe_tftp_read_last_packet; // bool, indicate last packet
+static int  pxe_tftp_saved_filepos;    // position in file as a whole, in bytes
+static int  pxe_tftp_buf_pos_in_file; // position in file where buf is
+
+/**
+ * \param filename file to open
+ * \return 1 success, 0 failed
+ */
+int pxe_tftp_open(const char *filename)
+{
+  int ret;
+
+  undi.pxs->tftp_open.ServerIPAddress  = arptable[ARP_SERVER].ipaddr.s_addr;
+  undi.pxs->tftp_open.GatewayIPAddress = arptable[ARP_GATEWAY].ipaddr.s_addr;
+
+  if (strlen(filename) + 1 > sizeof(undi.pxs->tftp_open.FileName))
+    {
+      printf("%s: filename too large.\n", __func__);
+      return 0;
+    }
+
+  memcpy(undi.pxs->tftp_open.FileName, filename, strlen(filename) + 1);
+  memcpy(pxe_tftp_read_filename, filename, strlen(filename) + 1);
+  undi.pxs->tftp_open.TFTPPort = htons(TFTP_PORT);
+  undi.pxs->tftp_open.PacketSize = PXE_TFTP_BUFFER_SIZE;
+
+  ret = undi_call(PXENV_TFTP_OPEN);
+
+  if (ret)
+    {
+      pxe_tftp_negotiated_buffer_size = undi.pxs->tftp_open.PacketSize;
+
+      pxe_tftp_read_buf_pos = 0;
+      pxe_tftp_read_buf_size = 0;
+      pxe_tftp_read_last_packet = 0;
+      pxe_tftp_saved_filepos = 0;
+      pxe_tftp_buf_pos_in_file = 0;
+      pxe_tftp_packet_size = 0;
+      pxe_tftp_opened = 1;
+    }
+
+  return ret;
+}
+
+
+/**
+ * Read a packet of size PXE_TFTP_BUFFER_SIZE bytes to internal
+ * buffer. Reset state variables.
+ *
+ * \return 1 success, 0 failure
+ */
+static int pxe_tftp_read_packet(void)
+{
+  int ret;
+
+  pxe_tftp_buf_pos_in_file += pxe_tftp_packet_size;
+
+  undi.pxs->tftp_read.Buffer.segment = SEGMENT(pxe_tftp_read_buf);
+  undi.pxs->tftp_read.Buffer.offset  = OFFSET(pxe_tftp_read_buf);
+
+  ret = undi_call(PXENV_TFTP_READ);
+
+  pxe_tftp_read_buf_size    = undi.pxs->tftp_read.BufferSize;
+  pxe_tftp_packet_size      = pxe_tftp_read_buf_size;
+  pxe_tftp_read_buf_pos     = 0;
+  pxe_tftp_read_last_packet = pxe_tftp_read_buf_size
+                               < pxe_tftp_negotiated_buffer_size;
+
+  return ret;
+}
+
+/**
+ * \param seekto    Position to seek file to, in bytes
+ *                    This operation is expensive with backwards == 1
+ * \param backwards Seek backwards, need to close and reopen the file
+ *
+ * \return 1 success, 0 failure
+ */
+static int pxe_tftp_read_seek(unsigned seekto, int backwards)
+{
+  if (backwards)
+    {
+       pxe_tftp_close();
+
+       if (!pxe_tftp_open(pxe_tftp_read_filename))
+	 return 0;
+    }
+
+  if (!pxe_tftp_packet_size)
+    pxe_tftp_read_packet();
+
+  while (seekto > pxe_tftp_buf_pos_in_file + pxe_tftp_packet_size)
+    {
+      pxe_tftp_read_packet();
+    }
+
+  if (seekto > pxe_tftp_buf_pos_in_file + pxe_tftp_packet_size)
+    return 0;
+
+  pxe_tftp_saved_filepos = filepos = seekto;
+
+  pxe_tftp_read_buf_pos = seekto - pxe_tftp_buf_pos_in_file;
+  pxe_tftp_read_buf_size = pxe_tftp_packet_size - pxe_tftp_read_buf_pos;
+
+  return 1;
+}
+
+/**
+ * The API forces us to read packets, minimum size 512 Bytes,
+ * but Grub requests smaller chunks, i.e. we need to do some buffering...
+ *
+ * \param buf       buffer to fill, must be min of 512 Bytes
+ * \param len       size in bytes to read in
+ *
+ * \return bytes read, or -1 in failure
+ */
+int pxe_tftp_read(char *buf, int len)
+{
+  int bytes_read = 0;
+
+  if (!pxe_tftp_opened)
+    return -1;
+
+  if (filepos < pxe_tftp_saved_filepos)
+    {
+      // someone did a seek... grmbl
+      // see, if we have filepos still in the current buf
+      if (filepos >= pxe_tftp_buf_pos_in_file)
+        {
+          // Yes, adjust variables
+          int diff = pxe_tftp_saved_filepos - filepos;
+          pxe_tftp_read_buf_pos -= diff;
+          pxe_tftp_read_buf_size += diff;
+          pxe_tftp_saved_filepos = filepos;
+        }
+      else
+        {
+	  if (!pxe_tftp_read_seek(filepos, 1))
+	    return -1;
+        }
+    }
+  else if (pxe_tftp_saved_filepos < filepos)
+    {
+      if (!pxe_tftp_read_seek(filepos, 0))
+        return -1;
+    }
+
+  while (len)
+    {
+      if (pxe_tftp_read_buf_size == 0)
+	{
+          if (pxe_tftp_read_last_packet)
+            return 0;
+
+	  if (!pxe_tftp_read_packet())
+	    return -1;
+	}
+
+      if (pxe_tftp_read_buf_size >= len)
+	{
+	  memcpy(buf, &pxe_tftp_read_buf[pxe_tftp_read_buf_pos], len);
+          bytes_read             += len;
+          pxe_tftp_read_buf_size -= len;
+          pxe_tftp_read_buf_pos  += len;
+          pxe_tftp_saved_filepos += len;
+          filepos                += len;
+
+
+          if (pxe_tftp_read_buf_size < 0) {
+            printf("ASSERT: pxe_tftp_read_buf_size(%d) < 0\n",
+                pxe_tftp_read_buf_size);
+            __stop();
+          }
+          if (pxe_tftp_read_buf_pos > pxe_tftp_negotiated_buffer_size) {
+            printf("ASSERT: pxe_tftp_read_buf_pos(%d) >= pxe_tftp_negotiated_buffer_size\n", pxe_tftp_read_buf_pos);
+            __stop();
+          }
+	  return bytes_read;
+	}
+
+      memcpy(buf, &pxe_tftp_read_buf[pxe_tftp_read_buf_pos], pxe_tftp_read_buf_size);
+      bytes_read             += pxe_tftp_read_buf_size;
+      buf                    += pxe_tftp_read_buf_size;
+      len                    -= pxe_tftp_read_buf_size;
+      pxe_tftp_saved_filepos += pxe_tftp_read_buf_size;
+      filepos                += pxe_tftp_read_buf_size;
+
+      pxe_tftp_read_buf_pos += pxe_tftp_read_buf_size;
+      if (pxe_tftp_read_buf_pos != pxe_tftp_negotiated_buffer_size) {
+          printf("ASSERT: pxe_tftp_read_buf_pos != pxe_tftp_negotiated_buffer_size\n");
+          __stop();
+      }
+
+      pxe_tftp_read_buf_size = 0;
+    }
+
+  return bytes_read;
+}
+
+/**
+ * \return 1 on success, 0 on failure
+ */
+int pxe_tftp_close(void)
+{
+  int ret;
+
+  if (!pxe_tftp_opened)
+    return 1;
+
+  ret = undi_call(PXENV_TFTP_CLOSE);
+  pxe_tftp_opened = 0;
+
+  return ret;
+}
+
+/**
+ * \param filename   path to get size of
+ * \return -1 on error, size in bytes otherwise
+ */
+int pxe_tftp_get_file_size(const char *filename)
+{
+  int ret, size;
+
+  undi.pxs->tftp_get_fsize.ServerIPAddress = arptable[ARP_SERVER].ipaddr.s_addr;
+  undi.pxs->tftp_get_fsize.GatewayIPAddress = 0;
+  memcpy(undi.pxs->tftp_get_fsize.FileName, filename, strlen(filename) + 1);
+  ret = undi_call(PXENV_TFTP_GET_FSIZE);
+
+  if (ret) // file size extension supported by TFTP server
+    return undi.pxs->tftp_get_fsize.FileSize;
+
+  if (!pxe_tftp_open(filename))
+    return -1;
+
+  printf("Requesting %s:\n"
+         "TFTP server at %@ does not support TSIZE extension, upgrade!\n",
+         filename, arptable[ARP_SERVER].ipaddr);
+
+  while (!pxe_tftp_read_last_packet)
+    if (!pxe_tftp_read_packet())
+      return -1;
+
+  size = pxe_tftp_buf_pos_in_file + pxe_tftp_read_buf_size;
+
+  __stop();
+
+  if (!pxe_tftp_close())
+    return -1;
+
+  return size;
+}
+
+static int pxe_tftp_poll(struct nic *nic_struct)
+{
+  printf("%s called\n", __func__);
+  __stop();
+  return 0;
+}
+
+static void pxe_tftp_transmit(struct nic *nic_struct,
+                              const char *d,	/* Destination */
+                              unsigned int t,	/* Type */
+                              unsigned int s,	/* size */
+                              const char *p)	/* Packet */
+{
+  printf("%s called\n", __func__);
+  __stop();
+}
+
+static int eb_pxenv_stop_base(void)
+{
+  int success = 0;
+
+  DBG("PXENV_STOP_BASE => (void)\n");
+  success = undi_call ( PXENV_STOP_BASE );
+  DBG("PXENV_STOP_BASE <= Status=%s\n", UNDI_STATUS(undi.pxs));
+  return success;
+}
+
+static void pxe_tftp_disable(struct dev *dev)
+{
+  eb_pxenv_stop_base();
+  free_base_mem_data();
+}
+
+/* ======================= */
+
+static int pxe_probe(struct dev *dev, struct pci_device *pci)
+{
+  struct nic *nic_struct = (struct nic *)dev;
+
+  /* Zero out global undi structure */
+  memset(&undi, 0, sizeof(undi));
+
+#if 0
+  /* Find the BIOS' $PnP structure */
+  if (!hunt_pnp_bios())
+    {
+      printf ( "No PnP BIOS found; aborting\n" );
+      return 0;
+    }
+#endif
+
+  /* Allocate base memory data structures */
+  if (!allocate_base_mem_data())
+    return 0;
+
+  if (!hunt_pixie())
+    {
+      printf("hunting for PXE image failed\n");
+      return 0;
+    }
+
+  if (!pxe_get_cache_info())
+    {
+      printf("PXE: Could not get boot info\n");
+      return 0;
+    }
+
+  pxe_tftp_driver_active_value = 1;
+
+  dev->disable         = pxe_tftp_disable;
+  nic_struct->poll     = pxe_tftp_poll;
+  nic_struct->transmit = pxe_tftp_transmit;
+
+  return 1;
+}
+
+/* UNDI driver states that it is suitable for any PCI NIC (i.e. any
+ * PCI device of class PCI_CLASS_NETWORK_ETHERNET).  If there are any
+ * obscure UNDI NICs that have the incorrect PCI class, add them to
+ * this list.
+ */
+static struct pci_id pxe_nics[] = {
+	/* PCI_ROM(0x0000, 0x0000, "pxe", "PXE adaptor"), */
+};
+
+struct pci_driver pxe_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "PXE",
+	.probe    = pxe_probe,
+	.ids      = pxe_nics,
+	.id_count = sizeof(pxe_nics)/sizeof(pxe_nics[0]),
+	.class    = PCI_CLASS_NETWORK_ETHERNET,
+};
Index: netboot/cpu.h
===================================================================
--- netboot/cpu.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/cpu.h	(.../trunk)	(revision 112)
@@ -0,0 +1,243 @@
+#ifndef I386_BITS_CPU_H
+#define I386_BITS_CPU_H
+
+
+/* Sample usage: CPU_FEATURE_P(cpu.x86_capability, FPU) */
+#define CPU_FEATURE_P(CAP, FEATURE) \
+	(!!(CAP[(X86_FEATURE_##FEATURE)/32] & ((X86_FEATURE_##FEATURE) & 0x1f)))
+
+#define NCAPINTS	4	/* Currently we have 4 32-bit words worth of info */
+
+/* Intel-defined CPU features, CPUID level 0x00000001, word 0 */
+#define X86_FEATURE_FPU		(0*32+ 0) /* Onboard FPU */
+#define X86_FEATURE_VME		(0*32+ 1) /* Virtual Mode Extensions */
+#define X86_FEATURE_DE		(0*32+ 2) /* Debugging Extensions */
+#define X86_FEATURE_PSE 	(0*32+ 3) /* Page Size Extensions */
+#define X86_FEATURE_TSC		(0*32+ 4) /* Time Stamp Counter */
+#define X86_FEATURE_MSR		(0*32+ 5) /* Model-Specific Registers, RDMSR, WRMSR */
+#define X86_FEATURE_PAE		(0*32+ 6) /* Physical Address Extensions */
+#define X86_FEATURE_MCE		(0*32+ 7) /* Machine Check Architecture */
+#define X86_FEATURE_CX8		(0*32+ 8) /* CMPXCHG8 instruction */
+#define X86_FEATURE_APIC	(0*32+ 9) /* Onboard APIC */
+#define X86_FEATURE_SEP		(0*32+11) /* SYSENTER/SYSEXIT */
+#define X86_FEATURE_MTRR	(0*32+12) /* Memory Type Range Registers */
+#define X86_FEATURE_PGE		(0*32+13) /* Page Global Enable */
+#define X86_FEATURE_MCA		(0*32+14) /* Machine Check Architecture */
+#define X86_FEATURE_CMOV	(0*32+15) /* CMOV instruction (FCMOVCC and FCOMI too if FPU present) */
+#define X86_FEATURE_PAT		(0*32+16) /* Page Attribute Table */
+#define X86_FEATURE_PSE36	(0*32+17) /* 36-bit PSEs */
+#define X86_FEATURE_PN		(0*32+18) /* Processor serial number */
+#define X86_FEATURE_CLFLSH	(0*32+19) /* Supports the CLFLUSH instruction */
+#define X86_FEATURE_DTES	(0*32+21) /* Debug Trace Store */
+#define X86_FEATURE_ACPI	(0*32+22) /* ACPI via MSR */
+#define X86_FEATURE_MMX		(0*32+23) /* Multimedia Extensions */
+#define X86_FEATURE_FXSR	(0*32+24) /* FXSAVE and FXRSTOR instructions (fast save and restore */
+				          /* of FPU context), and CR4.OSFXSR available */
+#define X86_FEATURE_XMM		(0*32+25) /* Streaming SIMD Extensions */
+#define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
+#define X86_FEATURE_SELFSNOOP	(0*32+27) /* CPU self snoop */
+#define X86_FEATURE_HT		(0*32+28) /* Hyper-Threading */
+#define X86_FEATURE_ACC		(0*32+29) /* Automatic clock control */
+#define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
+
+/* AMD-defined CPU features, CPUID level 0x80000001, word 1 */
+/* Don't duplicate feature flags which are redundant with Intel! */
+#define X86_FEATURE_SYSCALL	(1*32+11) /* SYSCALL/SYSRET */
+#define X86_FEATURE_MMXEXT	(1*32+22) /* AMD MMX extensions */
+#define X86_FEATURE_LM		(1*32+29) /* Long Mode (x86-64) */
+#define X86_FEATURE_3DNOWEXT	(1*32+30) /* AMD 3DNow! extensions */
+#define X86_FEATURE_3DNOW	(1*32+31) /* 3DNow! */
+
+/* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 */
+#define X86_FEATURE_RECOVERY	(2*32+ 0) /* CPU in recovery mode */
+#define X86_FEATURE_LONGRUN	(2*32+ 1) /* Longrun power control */
+#define X86_FEATURE_LRTI	(2*32+ 3) /* LongRun table interface */
+
+/* Other features, Linux-defined mapping, word 3 */
+/* This range is used for feature bits which conflict or are synthesized */
+#define X86_FEATURE_CXMMX	(3*32+ 0) /* Cyrix MMX extensions */
+#define X86_FEATURE_K6_MTRR	(3*32+ 1) /* AMD K6 nonstandard MTRRs */
+#define X86_FEATURE_CYRIX_ARR	(3*32+ 2) /* Cyrix ARRs (= MTRRs) */
+#define X86_FEATURE_CENTAUR_MCR	(3*32+ 3) /* Centaur MCRs (= MTRRs) */
+
+#define MAX_X86_VENDOR_ID 16
+struct cpuinfo_x86 {
+	uint8_t	 x86;		/* CPU family */
+	uint8_t	 x86_model;
+	uint8_t	 x86_mask;
+
+       	int	 cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
+	unsigned x86_capability[NCAPINTS];
+	char	 x86_vendor_id[MAX_X86_VENDOR_ID];
+};
+
+
+#define X86_VENDOR_INTEL 0
+#define X86_VENDOR_CYRIX 1
+#define X86_VENDOR_AMD 2
+#define X86_VENDOR_UMC 3
+#define X86_VENDOR_NEXGEN 4
+#define X86_VENDOR_CENTAUR 5
+#define X86_VENDOR_RISE 6
+#define X86_VENDOR_TRANSMETA 7
+#define X86_VENDOR_NSC 8
+#define X86_VENDOR_UNKNOWN 0xff
+
+/*
+ * EFLAGS bits
+ */
+#define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
+#define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
+#define X86_EFLAGS_AF	0x00000010 /* Auxillary carry Flag */
+#define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
+#define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
+#define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
+#define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
+#define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
+#define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
+#define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
+#define X86_EFLAGS_NT	0x00004000 /* Nested Task */
+#define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
+#define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
+#define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
+#define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
+#define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
+#define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
+
+/*
+ * Generic CPUID function
+ */
+static inline void cpuid(int op, 
+	unsigned int *eax, unsigned int *ebx, unsigned int *ecx, unsigned int *edx)
+{
+	__asm__("cpuid"
+		: "=a" (*eax),
+		  "=b" (*ebx),
+		  "=c" (*ecx),
+		  "=d" (*edx)
+		: "0" (op));
+}
+
+/*
+ * CPUID functions returning a single datum
+ */
+static inline unsigned int cpuid_eax(unsigned int op)
+{
+	unsigned int eax;
+
+	__asm__("cpuid"
+		: "=a" (eax)
+		: "0" (op)
+		: "bx", "cx", "dx");
+	return eax;
+}
+static inline unsigned int cpuid_ebx(unsigned int op)
+{
+	unsigned int eax, ebx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=b" (ebx)
+		: "0" (op)
+		: "cx", "dx" );
+	return ebx;
+}
+static inline unsigned int cpuid_ecx(unsigned int op)
+{
+	unsigned int eax, ecx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=c" (ecx)
+		: "0" (op)
+		: "bx", "dx" );
+	return ecx;
+}
+static inline unsigned int cpuid_edx(unsigned int op)
+{
+	unsigned int eax, edx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=d" (edx)
+		: "0" (op)
+		: "bx", "cx");
+	return edx;
+}
+
+/*
+ * Intel CPU features in CR4
+ */
+#define X86_CR4_VME		0x0001	/* enable vm86 extensions */
+#define X86_CR4_PVI		0x0002	/* virtual interrupts flag enable */
+#define X86_CR4_TSD		0x0004	/* disable time stamp at ipl 3 */
+#define X86_CR4_DE		0x0008	/* enable debugging extensions */
+#define X86_CR4_PSE		0x0010	/* enable page size extensions */
+#define X86_CR4_PAE		0x0020	/* enable physical address extensions */
+#define X86_CR4_MCE		0x0040	/* Machine check enable */
+#define X86_CR4_PGE		0x0080	/* enable global pages */
+#define X86_CR4_PCE		0x0100	/* enable performance counters at ipl 3 */
+#define X86_CR4_OSFXSR		0x0200	/* enable fast FPU save and restore */
+#define X86_CR4_OSXMMEXCPT	0x0400	/* enable unmasked SSE exceptions */
+
+
+#define MSR_K6_EFER			0xC0000080
+/* EFER bits: */ 
+#define _EFER_SCE 0  /* SYSCALL/SYSRET */
+#define _EFER_LME 8  /* Long mode enable */
+#define _EFER_LMA 10 /* Long mode active (read-only) */
+#define _EFER_NX 11  /* No execute enable */
+
+#define EFER_SCE (1<<_EFER_SCE)
+#define EFER_LME (1<<EFER_LME)
+#define EFER_LMA (1<<EFER_LMA)
+#define EFER_NX (1<<_EFER_NX)
+
+#define rdmsr(msr,val1,val2) \
+     __asm__ __volatile__("rdmsr" \
+			  : "=a" (val1), "=d" (val2) \
+			  : "c" (msr))
+
+#define wrmsr(msr,val1,val2) \
+     __asm__ __volatile__("wrmsr" \
+			  : /* no outputs */ \
+			  : "c" (msr), "a" (val1), "d" (val2))
+
+
+#define read_cr0()	({ \
+	unsigned int __dummy; \
+	__asm__( \
+		"movl %%cr0, %0\n\t" \
+		:"=r" (__dummy)); \
+	__dummy; \
+})
+#define write_cr0(x) \
+	__asm__("movl %0,%%cr0": :"r" (x));
+
+#define read_cr3()	({ \
+	unsigned int __dummy; \
+	__asm__( \
+		"movl %%cr3, %0\n\t" \
+		:"=r" (__dummy)); \
+	__dummy; \
+})
+#define write_cr3x(x) \
+	__asm__("movl %0,%%cr3": :"r" (x));
+
+
+#define read_cr4()	({ \
+	unsigned int __dummy; \
+	__asm__( \
+		"movl %%cr4, %0\n\t" \
+		:"=r" (__dummy)); \
+	__dummy; \
+})
+#define write_cr4x(x) \
+	__asm__("movl %0,%%cr4": :"r" (x));
+
+
+extern struct cpuinfo_x86 cpu_info;
+#ifdef CONFIG_X86_64
+extern void cpu_setup(void);
+#else
+#define cpu_setup() do {} while(0)
+#endif
+
+#endif /* I386_BITS_CPU_H */
Index: netboot/pxe_tftp.h
===================================================================
--- netboot/pxe_tftp.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/pxe_tftp.h	(.../trunk)	(revision 112)
@@ -0,0 +1,29 @@
+#ifndef __NETBOOT_PXE_TFTP_H__
+#define __NETBOOT_PXE_TFTP_H__
+
+#include "grub.h"
+
+#ifdef INCLUDE_PXE_TFTP
+
+int pxe_tftp_driver_active(void);
+int pxe_tftp_open(const char *filename);
+int pxe_tftp_read(char *buf, int size);
+int pxe_tftp_close(void);
+int pxe_tftp_get_file_size(const char *filename);
+
+#else
+
+static inline int pxe_tftp_driver_active(void)
+{ return 0; }
+static inline int pxe_tftp_open(const char *filename)
+{ return 0; }
+static inline int pxe_tftp_read(char *buf, int size)
+{ return -1; }
+static inline int pxe_tftp_close(void)
+{ return 0; }
+static inline int pxe_tftp_get_file_size(const char *filename)
+{ return -1; }
+
+#endif
+
+#endif /* ! __NETBOOT_PXE_TFTP_H__ */
Index: netboot/tlan.c
===================================================================
--- netboot/tlan.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/tlan.c	(.../trunk)	(revision 112)
@@ -1,377 +1,915 @@
+#define EB51
+
+#ifdef EB50
+#define __unused __attribute__((unused))
+#endif
+
 /**************************************************************************
-Etherboot -  BOOTP/TFTP Bootstrap Program
-TLAN driver for Etherboot
+*
+*    tlan.c -- Etherboot device driver for the Texas Instruments ThunderLAN
+*    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code based on:
+*	lan.c: Linux ThunderLan Driver:
+*
+*	by James Banks
+*
+*  	(C) 1997-1998 Caldera, Inc.
+*	(C) 1998 James Banks
+*	(C) 1999-2001 Torben Mathiasen
+*	(C) 2002 Samuel Chessman
+*
+*    $Revision$
+*    $Author$
+*    $Date 2003/07/18 $
+*
+*    REVISION HISTORY:
+*    ================
+*    v1.0	07-08-2003	timlegge	Initial not quite working version
+*    v1.1	07-27-2003	timlegge	Sync 5.0 and 5.1 versions
+*    v1.2	08-19-2003	timlegge	Implement Multicast Support
+*    v1.3	08-23-2003	timlegge	Fix the transmit Function
+*    
+*    Indent Options: indent -kr -i8
 ***************************************************************************/
 
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
-
 /* to get some global routines like printf */
 #include "etherboot.h"
 /* to get the interface to the body of the program */
 #include "nic.h"
 /* to get the PCI support functions, if this is a PCI NIC */
 #include "pci.h"
-/* to get our own prototype */
-#include "cards.h"
+/* to get the ISA support functions, if this is an ISA NIC */
+/* #include "isa.h" */
+#include "timer.h"
+#include "tlan.h"
 
-	/*****************************************************************
-	 * TLan Definitions
-	 *
-	 ****************************************************************/
+#define drv_version "v1.3"
+#define drv_date "08-23-2003"
 
-#define TLAN_MIN_FRAME_SIZE	64
-#define TLAN_MAX_FRAME_SIZE	1600
+/* NIC specific static variables go here */
+#define HZ 100
+#define TX_TIME_OUT	  (6*HZ)
 
-#define TLAN_NUM_RX_LISTS	32
-#define TLAN_NUM_TX_LISTS	64
+#ifdef EB50
+#define	cpu_to_le32(val) (val)
+#define	le32_to_cpu(val) (val)
+#define	virt_to_bus(x) ((unsigned long) x)
+#define	bus_to_virt(x) ((unsigned long) x)
+#endif
 
-#define TLAN_IGNORE		0
-#define TLAN_RECORD		1
+/* Condensed operations for readability. */
+#define virt_to_le32desc(addr)  cpu_to_le32(virt_to_bus(addr))
+#define le32desc_to_virt(addr)  bus_to_virt(le32_to_cpu(addr))
 
-#define TLAN_DBG(lvl, format, args...)	if (debug&lvl) printf("TLAN: " format, ##args );
-#define TLAN_DEBUG_GNRL		0x0001
-#define TLAN_DEBUG_TX		0x0002
-#define TLAN_DEBUG_RX		0x0004 
-#define TLAN_DEBUG_LIST		0x0008
-#define TLAN_DEBUG_PROBE	0x0010
 
-#define MAX_TLAN_BOARDS		8	 /* Max number of boards installed at a time */
+static void TLan_ResetLists(struct nic *nic __unused);
+static void TLan_ResetAdapter(struct nic *nic __unused);
+static void TLan_FinishReset(struct nic *nic __unused);
 
-	/*****************************************************************
-	 * Device Identification Definitions
-	 *
-	 ****************************************************************/
-		
-#define PCI_DEVICE_ID_NETELLIGENT_10_T2			0xB012
-#define PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100	0xB030
-#ifndef PCI_DEVICE_ID_OLICOM_OC2183
-#define PCI_DEVICE_ID_OLICOM_OC2183			0x0013
+static void TLan_EeSendStart(u16);
+static int TLan_EeSendByte(u16, u8, int);
+static void TLan_EeReceiveByte(u16, u8 *, int);
+static int TLan_EeReadByte(u16 io_base, u8, u8 *);
+
+static void TLan_PhyDetect(struct nic *nic);
+static void TLan_PhyPowerDown(struct nic *nic);
+static void TLan_PhyPowerUp(struct nic *nic);
+
+
+static void TLan_SetMac(struct nic *nic __unused, int areg, char *mac);
+
+static void TLan_PhyReset(struct nic *nic);
+static void TLan_PhyStartLink(struct nic *nic);
+static void TLan_PhyFinishAutoNeg(struct nic *nic);
+
+#ifdef MONITOR
+static void TLan_PhyMonitor(struct nic *nic);
 #endif
-#ifndef PCI_DEVICE_ID_OLICOM_OC2325
-#define PCI_DEVICE_ID_OLICOM_OC2325			0x0012
-#endif
-#ifndef PCI_DEVICE_ID_OLICOM_OC2326
-#define PCI_DEVICE_ID_OLICOM_OC2326			0x0014
-#endif
-#define TLAN_ADAPTER_NONE		0x00000000
-#define TLAN_ADAPTER_UNMANAGED_PHY	0x00000001
-#define TLAN_ADAPTER_BIT_RATE_PHY	0x00000002
-#define TLAN_ADAPTER_USE_INTERN_10	0x00000004
-#define TLAN_ADAPTER_ACTIVITY_LED	0x00000008
-#define TLAN_SPEED_DEFAULT	0
-#define TLAN_SPEED_10		10
-#define TLAN_SPEED_100		100
-#define TLAN_DUPLEX_DEFAULT	0
-#define TLAN_DUPLEX_HALF	1
-#define TLAN_DUPLEX_FULL	2
-#define TLAN_BUFFERS_PER_LIST	10
-#define TLAN_LAST_BUFFER	0x80000000
-#define TLAN_CSTAT_UNUSED	0x8000
-#define TLAN_CSTAT_FRM_CMP	0x4000
-#define TLAN_CSTAT_READY	0x3000
-#define TLAN_CSTAT_EOC		0x0800
-#define TLAN_CSTAT_RX_ERROR	0x0400
-#define TLAN_CSTAT_PASS_CRC	0x0200
-#define TLAN_CSTAT_DP_PR	0x0100
 
-	/*****************************************************************
-	 * PHY definitions
-	 *
-	 ****************************************************************/
 
-#define TLAN_PHY_MAX_ADDR	0x1F
-#define TLAN_PHY_NONE		0x20
+static void refill_rx(struct nic *nic __unused);
 
-	/*****************************************************************
-	 * TLan Driver Timer Definitions
-	 *
-	 ****************************************************************/
+static int TLan_MiiReadReg(struct nic *nic __unused, u16, u16, u16 *);
+static void TLan_MiiSendData(u16, u32, unsigned);
+static void TLan_MiiSync(u16);
+static void TLan_MiiWriteReg(struct nic *nic __unused, u16, u16, u16);
 
-#define TLAN_TIMER_LINK_BEAT		1
-#define TLAN_TIMER_ACTIVITY		2
-#define TLAN_TIMER_PHY_PDOWN		3
-#define TLAN_TIMER_PHY_PUP		4
-#define TLAN_TIMER_PHY_RESET		5
-#define TLAN_TIMER_PHY_START_LINK	6
-#define TLAN_TIMER_PHY_FINISH_AN	7
-#define TLAN_TIMER_FINISH_RESET		8
-#define TLAN_TIMER_ACT_DELAY		(HZ/10)
 
-	/*****************************************************************
-	 * TLan Driver Eeprom Definitions
-	 *
-	 ****************************************************************/
+const char *media[] = {
+	"10BaseT-HD ", "10BaseT-FD ", "100baseTx-HD ",
+	"100baseTx-FD", "100baseT4", 0
+};
 
-#define TLAN_EEPROM_ACK		0
-#define TLAN_EEPROM_STOP	1
+/* This much match tlan_pci_tbl[]!  */
+enum tlan_nics {
+	NETEL10 = 0, NETEL100 = 1, NETFLEX3I = 2, THUNDER = 3, NETFLEX3B =
+	    4, NETEL100PI = 5,
+	NETEL100D = 6, NETEL100I = 7, OC2183 = 8, OC2325 = 9, OC2326 =
+	    10, NETELLIGENT_10_100_WS_5100 = 11,
+	NETELLIGENT_10_T2 = 12
+};
 
-	/*****************************************************************
-	 * Host Register Offsets and Contents
-	 *
-	 ****************************************************************/
+struct pci_id_info {
+	const char *name;
+	int nic_id;
+	struct match_info {
+		u32 pci, pci_mask, subsystem, subsystem_mask;
+		u32 revision, revision_mask;	/* Only 8 bits. */
+	} id;
+	u32 flags;
+	u16 addrOfs;		/* Address Offset */
+};
 
-#define TLAN_HOST_CMD			0x00
-#define 	TLAN_HC_GO		0x80000000
-#define		TLAN_HC_STOP		0x40000000
-#define		TLAN_HC_ACK		0x20000000
-#define		TLAN_HC_CS_MASK		0x1FE00000
-#define		TLAN_HC_EOC		0x00100000
-#define		TLAN_HC_RT		0x00080000
-#define		TLAN_HC_NES		0x00040000
-#define		TLAN_HC_AD_RST		0x00008000
-#define		TLAN_HC_LD_TMR		0x00004000
-#define		TLAN_HC_LD_THR		0x00002000
-#define		TLAN_HC_REQ_INT		0x00001000
-#define		TLAN_HC_INT_OFF		0x00000800
-#define		TLAN_HC_INT_ON		0x00000400
-#define		TLAN_HC_AC_MASK		0x000000FF
-#define TLAN_CH_PARM			0x04
-#define TLAN_DIO_ADR			0x08
-#define		TLAN_DA_ADR_INC		0x8000
-#define		TLAN_DA_RAM_ADR		0x4000
-#define TLAN_HOST_INT			0x0A
-#define		TLAN_HI_IV_MASK		0x1FE0
-#define		TLAN_HI_IT_MASK		0x001C
-#define TLAN_DIO_DATA			0x0C
+static struct pci_id_info tlan_pci_tbl[] = {
+	{"Compaq Netelligent 10 T PCI UTP", NETEL10,
+	 {0xae340e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Netelligent 10/100 TX PCI UTP", NETEL100,
+	 {0xae320e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Integrated NetFlex-3/P", NETFLEX3I,
+	 {0xae350e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq NetFlex-3/P", THUNDER,
+	 {0xf1300e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83},
+	{"Compaq NetFlex-3/P", NETFLEX3B,
+	 {0xf1500e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq Netelligent Integrated 10/100 TX UTP", NETEL100PI,
+	 {0xae430e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Netelligent Dual 10/100 TX PCI UTP", NETEL100D,
+	 {0xae400e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq Netelligent 10/100 TX Embedded UTP", NETEL100I,
+	 {0xb0110e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Olicom OC-2183/2185", OC2183,
+	 {0x0013108d, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_USE_INTERN_10, 0x83},
+	{"Olicom OC-2325", OC2325,
+	 {0x0012108d, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_UNMANAGED_PHY, 0xF8},
+	{"Olicom OC-2326", OC2326,
+	 {0x0014108d, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_USE_INTERN_10, 0xF8},
+	{"Compaq Netelligent 10/100 TX UTP", NETELLIGENT_10_100_WS_5100,
+	 {0xb0300e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{"Compaq Netelligent 10 T/2 PCI UTP/Coax", NETELLIGENT_10_T2,
+	 {0xb0120e11, 0xffffffff, 0, 0, 0, 0},
+	 TLAN_ADAPTER_NONE, 0x83},
+	{"Compaq NetFlex-3/E", 0,	/* EISA card */
+	 {0, 0, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED | TLAN_ADAPTER_UNMANAGED_PHY |
+	 TLAN_ADAPTER_BIT_RATE_PHY, 0x83},
+	{"Compaq NetFlex-3/E", 0,	/* EISA card */
+	 {0, 0, 0, 0, 0, 0},
+	 TLAN_ADAPTER_ACTIVITY_LED, 0x83},
+	{0, 0,
+	 {0, 0, 0, 0, 0, 0},
+	 0, 0},
+};
 
-/* ThunderLAN Internal Register DIO Offsets */
 
-#define TLAN_NET_CMD			0x00
-#define		TLAN_NET_CMD_NRESET	0x80
-#define		TLAN_NET_CMD_NWRAP	0x40
-#define		TLAN_NET_CMD_CSF	0x20
-#define		TLAN_NET_CMD_CAF	0x10
-#define		TLAN_NET_CMD_NOBRX	0x08
-#define		TLAN_NET_CMD_DUPLEX	0x04
-#define		TLAN_NET_CMD_TRFRAM	0x02
-#define		TLAN_NET_CMD_TXPACE	0x01
-#define TLAN_NET_SIO			0x01
-#define 	TLAN_NET_SIO_MINTEN	0x80
-#define		TLAN_NET_SIO_ECLOK	0x40
-#define		TLAN_NET_SIO_ETXEN	0x20
-#define		TLAN_NET_SIO_EDATA	0x10
-#define		TLAN_NET_SIO_NMRST	0x08
-#define		TLAN_NET_SIO_MCLK	0x04
-#define		TLAN_NET_SIO_MTXEN	0x02
-#define		TLAN_NET_SIO_MDATA	0x01
-#define TLAN_NET_STS			0x02
-#define		TLAN_NET_STS_MIRQ	0x80
-#define		TLAN_NET_STS_HBEAT	0x40
-#define		TLAN_NET_STS_TXSTOP	0x20
-#define		TLAN_NET_STS_RXSTOP	0x10
-#define		TLAN_NET_STS_RSRVD	0x0F
-#define TLAN_NET_MASK			0x03
-#define		TLAN_NET_MASK_MASK7	0x80
-#define		TLAN_NET_MASK_MASK6	0x40
-#define		TLAN_NET_MASK_MASK5	0x20
-#define		TLAN_NET_MASK_MASK4	0x10
-#define		TLAN_NET_MASK_RSRVD	0x0F
-#define TLAN_NET_CONFIG			0x04
-#define 	TLAN_NET_CFG_RCLK	0x8000
-#define		TLAN_NET_CFG_TCLK	0x4000
-#define		TLAN_NET_CFG_BIT	0x2000
-#define		TLAN_NET_CFG_RXCRC	0x1000
-#define		TLAN_NET_CFG_PEF	0x0800
-#define		TLAN_NET_CFG_1FRAG	0x0400
-#define		TLAN_NET_CFG_1CHAN	0x0200
-#define		TLAN_NET_CFG_MTEST	0x0100
-#define		TLAN_NET_CFG_PHY_EN	0x0080
-#define		TLAN_NET_CFG_MSMASK	0x007F
-#define TLAN_MAN_TEST			0x06
-#define TLAN_DEF_VENDOR_ID		0x08
-#define TLAN_DEF_DEVICE_ID		0x0A
-#define TLAN_DEF_REVISION		0x0C
-#define TLAN_DEF_SUBCLASS		0x0D
-#define TLAN_DEF_MIN_LAT		0x0E
-#define TLAN_DEF_MAX_LAT		0x0F
-#define TLAN_AREG_0			0x10
-#define TLAN_AREG_1			0x16
-#define TLAN_AREG_2			0x1C
-#define TLAN_AREG_3			0x22
-#define TLAN_HASH_1			0x28
-#define TLAN_HASH_2			0x2C
-#define TLAN_GOOD_TX_FRMS		0x30
-#define TLAN_TX_UNDERUNS		0x33
-#define TLAN_GOOD_RX_FRMS		0x34
-#define TLAN_RX_OVERRUNS		0x37
-#define TLAN_DEFERRED_TX		0x38
-#define TLAN_CRC_ERRORS			0x3A
-#define TLAN_CODE_ERRORS		0x3B
-#define TLAN_MULTICOL_FRMS		0x3C
-#define TLAN_SINGLECOL_FRMS		0x3E
-#define TLAN_EXCESSCOL_FRMS		0x40
-#define TLAN_LATE_COLS			0x41
-#define TLAN_CARRIER_LOSS		0x42
-#define TLAN_ACOMMIT			0x43
-#define TLAN_LED_REG			0x44
-#define		TLAN_LED_ACT		0x10
-#define		TLAN_LED_LINK		0x01
-#define TLAN_BSIZE_REG			0x45
-#define TLAN_MAX_RX			0x46
-#define TLAN_INT_DIS			0x48
-#define		TLAN_ID_TX_EOC		0x04
-#define		TLAN_ID_RX_EOF		0x02
-#define		TLAN_ID_RX_EOC		0x01
+struct TLanList {
+	u32 forward;
+	u16 cStat;
+	u16 frameSize;
+	struct {
+		u32 count;
+		u32 address;
+	} buffer[TLAN_BUFFERS_PER_LIST];
+};
 
-/* ThunderLAN Interrupt Codes */
 
-#define TLAN_INT_NUMBER_OF_INTS	8
 
-#define TLAN_INT_NONE			0x0000
-#define TLAN_INT_TX_EOF			0x0001
-#define TLAN_INT_STAT_OVERFLOW		0x0002
-#define TLAN_INT_RX_EOF			0x0003
-#define TLAN_INT_DUMMY			0x0004
-#define TLAN_INT_TX_EOC			0x0005
-#define TLAN_INT_STATUS_CHECK		0x0006
-#define TLAN_INT_RX_EOC			0x0007
-#define TLAN_TLPHY_ID			0x10
-#define TLAN_TLPHY_CTL			0x11
-#define 	TLAN_TC_IGLINK		0x8000
-#define		TLAN_TC_SWAPOL		0x4000
-#define		TLAN_TC_AUISEL		0x2000
-#define		TLAN_TC_SQEEN		0x1000
-#define		TLAN_TC_MTEST		0x0800
-#define		TLAN_TC_RESERVED	0x07F8
-#define		TLAN_TC_NFEW		0x0004
-#define		TLAN_TC_INTEN		0x0002
-#define		TLAN_TC_TINT		0x0001
-#define TLAN_TLPHY_STS			0x12
-#define		TLAN_TS_MINT		0x8000
-#define		TLAN_TS_PHOK		0x4000
-#define		TLAN_TS_POLOK		0x2000
-#define		TLAN_TS_TPENERGY	0x1000
-#define		TLAN_TS_RESERVED	0x0FFF
-#define TLAN_TLPHY_PAR			0x19
-#define		TLAN_PHY_CIM_STAT	0x0020
-#define		TLAN_PHY_SPEED_100	0x0040
-#define		TLAN_PHY_DUPLEX_FULL	0x0080
-#define		TLAN_PHY_AN_EN_STAT     0x0400
+struct TLanList tx_ring[TLAN_NUM_TX_LISTS];
+static unsigned char txb[TLAN_MAX_FRAME_SIZE * TLAN_NUM_TX_LISTS];
 
+struct TLanList rx_ring[TLAN_NUM_RX_LISTS];
+static unsigned char rxb[TLAN_MAX_FRAME_SIZE * TLAN_NUM_RX_LISTS];
 
-/* ThunderLAN MII Registers */
+typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZE];
 
-/* Generic MII/PHY Registers */
 
-#define MII_GEN_CTL			0x00
-#define 	MII_GC_RESET		0x8000
-#define		MII_GC_LOOPBK		0x4000
-#define		MII_GC_SPEEDSEL		0x2000
-#define		MII_GC_AUTOENB		0x1000
-#define		MII_GC_PDOWN		0x0800
-#define		MII_GC_ISOLATE		0x0400
-#define		MII_GC_AUTORSRT		0x0200
-#define		MII_GC_DUPLEX		0x0100
-#define		MII_GC_COLTEST		0x0080
-#define		MII_GC_RESERVED		0x007F
-#define MII_GEN_STS			0x01
-#define		MII_GS_100BT4		0x8000
-#define		MII_GS_100BTXFD		0x4000
-#define		MII_GS_100BTXHD		0x2000
-#define		MII_GS_10BTFD		0x1000
-#define		MII_GS_10BTHD		0x0800
-#define		MII_GS_RESERVED		0x07C0
-#define		MII_GS_AUTOCMPLT	0x0020
-#define		MII_GS_RFLT		0x0010
-#define		MII_GS_AUTONEG		0x0008
-#define		MII_GS_LINK		0x0004
-#define		MII_GS_JABBER		0x0002
-#define		MII_GS_EXTCAP		0x0001
-#define MII_GEN_ID_HI			0x02
-#define MII_GEN_ID_LO			0x03
-#define 	MII_GIL_OUI		0xFC00
-#define 	MII_GIL_MODEL		0x03F0
-#define 	MII_GIL_REVISION	0x000F
-#define MII_AN_ADV			0x04
-#define MII_AN_LPA			0x05
-#define MII_AN_EXP			0x06
+int chip_idx;
 
-/* ThunderLAN Specific MII/PHY Registers */
 
-#define 	TLAN_TC_IGLINK		0x8000
-#define		TLAN_TC_SWAPOL		0x4000
-#define		TLAN_TC_AUISEL		0x2000
-#define		TLAN_TC_SQEEN		0x1000
-#define		TLAN_TC_MTEST		0x0800
-#define		TLAN_TC_RESERVED	0x07F8
-#define		TLAN_TC_NFEW		0x0004
-#define		TLAN_TC_INTEN		0x0002
-#define		TLAN_TC_TINT		0x0001
-#define		TLAN_TS_MINT		0x8000
-#define		TLAN_TS_PHOK		0x4000
-#define		TLAN_TS_POLOK		0x2000
-#define		TLAN_TS_TPENERGY	0x1000
-#define		TLAN_TS_RESERVED	0x0FFF
-#define		TLAN_PHY_CIM_STAT	0x0020
-#define		TLAN_PHY_SPEED_100	0x0040
-#define		TLAN_PHY_DUPLEX_FULL	0x0080
-#define		TLAN_PHY_AN_EN_STAT     0x0400
+/*****************************************************************
+* TLAN Private Information Structure
+*
+****************************************************************/
+struct tlan_private {
+	unsigned short vendor_id;	/* PCI Vendor code */
+	unsigned short dev_id;	/* PCI Device code */
+	const char *nic_name;
+	u8 *padBuffer;
+	u8 *rxBuffer;
+	struct TLanList *rx_head_desc;
+	u32 rxHead;
+	u32 rxTail;
+	u32 rxEocCount;
+	unsigned int cur_rx, dirty_rx;	/* Producer/consumer ring indicies */
+	unsigned int cur_tx, dirty_tx;
+	unsigned rx_buf_sz;	/* Based on mtu + Slack */
+	struct TLanList *txList;
+	struct TLanList *rxList;
+	u8 *txBuffer;
+	u32 txHead;
+	u32 txInProgress;
+	u32 txTail;
+	int eoc;
+	u32 txBusyCount;
+	u32 phyOnline;
+	u32 timerSetAt;
+	u32 timerType;
+	u32 adapterRev;
+	u32 aui;
+	u32 debug;
+	u32 duplex;
+	u32 phy[2];
+	u32 phyNum;
+	u32 speed;
+	u8 tlanRev;
+	u8 tlanFullDuplex;
+	char devName[8];
+	u8 link;
+	u8 is_eisa;
+	u8 neg_be_verbose;
+} TLanPrivateInfo;
 
-/* National Sem. & Level1 PHY id's */
-#define NAT_SEM_ID1			0x2000
-#define NAT_SEM_ID2			0x5C01
-#define LEVEL1_ID1			0x7810
-#define LEVEL1_ID2			0x0000
+static struct tlan_private *priv;
 
-#define TLan_ClearBit( bit, port )	outb_p(inb_p(port) & ~bit, port)
-#define TLan_GetBit( bit, port )	((int) (inb_p(port) & bit))
-#define TLan_SetBit( bit, port )	outb_p(inb_p(port) | bit, port)
+u32 BASE;
 
-typedef	unsigned int	u32;
-typedef	unsigned short	u16;
-typedef	unsigned char	u8;
 
-/* Routines to access internal registers. */
 
-inline u8 TLan_DioRead8(u16 base_addr, u16 internal_addr)
+/***************************************************************
+*	TLan_ResetLists
+*
+*	Returns:
+*		Nothing
+*	Parms:
+*		dev	The device structure with the list
+*			stuctures to be reset.
+*
+*	This routine sets the variables associated with managing
+*	the TLAN lists to their initial values.
+*
+**************************************************************/
+
+void TLan_ResetLists(struct nic *nic __unused)
 {
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	return (inb((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x3)));
-	
-} /* TLan_DioRead8 */
 
-inline u16 TLan_DioRead16(u16 base_addr, u16 internal_addr)
+	int i;
+	struct TLanList *list;
+	priv->txHead = 0;
+	priv->txTail = 0;
+
+	for (i = 0; i < TLAN_NUM_TX_LISTS; i++) {
+		list = &tx_ring[i];
+		list->cStat = TLAN_CSTAT_UNUSED;
+/*		list->buffer[0].address = 0; */
+		list->buffer[0].address = virt_to_bus(txb + 
+				(i * TLAN_MAX_FRAME_SIZE)); 
+		list->buffer[2].count = 0;
+		list->buffer[2].address = 0;
+		list->buffer[9].address = 0;
+/*		list->forward = 0; */
+	}
+
+	priv->cur_rx = 0;
+	priv->rx_buf_sz = (TLAN_MAX_FRAME_SIZE);
+	priv->rx_head_desc = &rx_ring[0];
+
+	/* Initialize all the Rx descriptors */
+	for (i = 0; i < TLAN_NUM_RX_LISTS; i++) {
+		rx_ring[i].forward = virt_to_le32desc(&rx_ring[i + 1]);
+		rx_ring[i].cStat = TLAN_CSTAT_READY;
+		rx_ring[i].frameSize = TLAN_MAX_FRAME_SIZE;
+		rx_ring[i].buffer[0].count =
+		    TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
+		rx_ring[i].buffer[0].address =
+		    virt_to_le32desc(&rxb[i * TLAN_MAX_FRAME_SIZE]);
+		rx_ring[i].buffer[1].count = 0;
+		rx_ring[i].buffer[1].address = 0;
+	}
+
+	/* Mark the last entry as wrapping the ring */
+	rx_ring[i - 1].forward = virt_to_le32desc(&rx_ring[0]);
+	priv->dirty_rx = (unsigned int) (i - TLAN_NUM_RX_LISTS);
+
+} /* TLan_ResetLists */
+
+/***************************************************************
+*	TLan_Reset
+*
+*	Returns:
+*		0
+*	Parms:
+*		dev	Pointer to device structure of adapter
+*			to be reset.
+*
+*	This function resets the adapter and it's physical
+*	device.  See Chap. 3, pp. 9-10 of the "ThunderLAN
+*	Programmer's Guide" for details.  The routine tries to
+*	implement what is detailed there, though adjustments
+*	have been made.
+*
+**************************************************************/
+
+void TLan_ResetAdapter(struct nic *nic __unused)
 {
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	return (inw((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x2)));
+	int i;
+	u32 addr;
+	u32 data;
+	u8 data8;
 
-} /* TLan_DioRead16 */
+	priv->tlanFullDuplex = FALSE;
+	priv->phyOnline = 0;
+/*  1.	Assert reset bit. */
 
-inline u32 TLan_DioRead32(u16 base_addr, u16 internal_addr)
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_AD_RST;
+	outl(data, BASE + TLAN_HOST_CMD);
+
+	udelay(1000);
+
+/*  2.	Turn off interrupts. ( Probably isn't necessary ) */
+
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_INT_OFF;
+	outl(data, BASE + TLAN_HOST_CMD);
+/*  3.	Clear AREGs and HASHs. */
+
+	for (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4) {
+		TLan_DioWrite32(BASE, (u16) i, 0);
+	}
+
+/*  4.	Setup NetConfig register. */
+
+	data =
+	    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
+	TLan_DioWrite16(BASE, TLAN_NET_CONFIG, (u16) data);
+
+/*  5.	Load Ld_Tmr and Ld_Thr in HOST_CMD. */
+
+	outl(TLAN_HC_LD_TMR | 0x3f, BASE + TLAN_HOST_CMD);
+	outl(TLAN_HC_LD_THR | 0x0, BASE + TLAN_HOST_CMD);
+
+/*  6.	Unreset the MII by setting NMRST (in NetSio) to 1. */
+
+	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
+	addr = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
+	TLan_SetBit(TLAN_NET_SIO_NMRST, addr);
+
+/*  7.	Setup the remaining registers. */
+
+	if (priv->tlanRev >= 0x30) {
+		data8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;
+		TLan_DioWrite8(BASE, TLAN_INT_DIS, data8);
+	}
+	TLan_PhyDetect(nic);
+	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;
+
+	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_BIT_RATE_PHY) {
+		data |= TLAN_NET_CFG_BIT;
+		if (priv->aui == 1) {
+			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x0a);
+		} else if (priv->duplex == TLAN_DUPLEX_FULL) {
+			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x00);
+			priv->tlanFullDuplex = TRUE;
+		} else {
+			TLan_DioWrite8(BASE, TLAN_ACOMMIT, 0x08);
+		}
+	}
+
+	if (priv->phyNum == 0) {
+		data |= TLAN_NET_CFG_PHY_EN;
+	}
+	TLan_DioWrite16(BASE, TLAN_NET_CONFIG, (u16) data);
+
+	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY) {
+		TLan_FinishReset(nic);
+	} else {
+		TLan_PhyPowerDown(nic);
+	}
+
+}	/* TLan_ResetAdapter */
+
+void TLan_FinishReset(struct nic *nic)
 {
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	return (inl(base_addr + TLAN_DIO_DATA));
 
-} /* TLan_DioRead32 */
+	u8 data;
+	u32 phy;
+	u8 sio;
+	u16 status;
+	u16 partner;
+	u16 tlphy_ctl;
+	u16 tlphy_par;
+	u16 tlphy_id1, tlphy_id2;
+	int i;
 
-inline void TLan_DioWrite8(u16 base_addr, u16 internal_addr, u8 data)
+	phy = priv->phy[priv->phyNum];
+
+	data = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;
+	if (priv->tlanFullDuplex) {
+		data |= TLAN_NET_CMD_DUPLEX;
+	}
+	TLan_DioWrite8(BASE, TLAN_NET_CMD, data);
+	data = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5;
+	if (priv->phyNum == 0) {
+		data |= TLAN_NET_MASK_MASK7;
+	}
+	TLan_DioWrite8(BASE, TLAN_NET_MASK, data);
+	TLan_DioWrite16(BASE, TLAN_MAX_RX, ((1536) + 7) & ~7);
+	TLan_MiiReadReg(nic, phy, MII_GEN_ID_HI, &tlphy_id1);
+	TLan_MiiReadReg(nic, phy, MII_GEN_ID_LO, &tlphy_id2);
+
+	if ((tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY)
+	    || (priv->aui)) {
+		status = MII_GS_LINK;
+		printf("TLAN:  %s: Link forced.\n", priv->nic_name);
+	} else {
+		TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+		udelay(1000);
+		TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+		if ((status & MII_GS_LINK) &&	/* We only support link info on Nat.Sem. PHY's */
+		    (tlphy_id1 == NAT_SEM_ID1)
+		    && (tlphy_id2 == NAT_SEM_ID2)) {
+			TLan_MiiReadReg(nic, phy, MII_AN_LPA, &partner);
+			TLan_MiiReadReg(nic, phy, TLAN_TLPHY_PAR,
+					&tlphy_par);
+
+			printf("TLAN: %s: Link active with ",
+			       priv->nic_name);
+			if (!(tlphy_par & TLAN_PHY_AN_EN_STAT)) {
+				printf("forced 10%sMbps %s-Duplex\n",
+				       tlphy_par & TLAN_PHY_SPEED_100 ? ""
+				       : "0",
+				       tlphy_par & TLAN_PHY_DUPLEX_FULL ?
+				       "Full" : "Half");
+			} else {
+				printf
+				    ("AutoNegotiation enabled, at 10%sMbps %s-Duplex\n",
+				     tlphy_par & TLAN_PHY_SPEED_100 ? "" :
+				     "0",
+				     tlphy_par & TLAN_PHY_DUPLEX_FULL ?
+				     "Full" : "Half");
+				printf("TLAN: Partner capability: ");
+				for (i = 5; i <= 10; i++)
+					if (partner & (1 << i))
+						printf("%s", media[i - 5]);
+				printf("\n");
+			}
+
+			TLan_DioWrite8(BASE, TLAN_LED_REG, TLAN_LED_LINK);
+#ifdef MONITOR
+			/* We have link beat..for now anyway */
+			priv->link = 1;
+			/*Enabling link beat monitoring */
+			/* TLan_SetTimer( nic, (10*HZ), TLAN_TIMER_LINK_BEAT ); */
+			mdelay(10000);
+			TLan_PhyMonitor(nic);
+#endif
+		} else if (status & MII_GS_LINK) {
+			printf("TLAN: %s: Link active\n", priv->nic_name);
+			TLan_DioWrite8(BASE, TLAN_LED_REG, TLAN_LED_LINK);
+		}
+	}
+
+	if (priv->phyNum == 0) {
+		TLan_MiiReadReg(nic, phy, TLAN_TLPHY_CTL, &tlphy_ctl);
+		tlphy_ctl |= TLAN_TC_INTEN;
+		TLan_MiiWriteReg(nic, phy, TLAN_TLPHY_CTL, tlphy_ctl);
+		sio = TLan_DioRead8(BASE, TLAN_NET_SIO);
+		sio |= TLAN_NET_SIO_MINTEN;
+		TLan_DioWrite8(BASE, TLAN_NET_SIO, sio);
+	}
+
+	if (status & MII_GS_LINK) {
+		TLan_SetMac(nic, 0, nic->node_addr);
+		priv->phyOnline = 1;
+		outb((TLAN_HC_INT_ON >> 8), BASE + TLAN_HOST_CMD + 1);
+/*		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
+			outb( ( TLAN_HC_REQ_INT >> 8 ), BASE + TLAN_HOST_CMD + 1 );
+		}
+
+		*/
+		outl(virt_to_bus(&rx_ring), BASE + TLAN_CH_PARM);
+		outl(TLAN_HC_GO | TLAN_HC_RT, BASE + TLAN_HOST_CMD);
+	} else {
+		printf
+		    ("TLAN: %s: Link inactive, will retry in 10 secs...\n",
+		     priv->nic_name);
+		/* TLan_SetTimer( nic, (10*HZ), TLAN_TIMER_FINISH_RESET ); */
+		mdelay(10000);
+		TLan_FinishReset(nic);
+		return;
+
+	}
+
+}	/* TLan_FinishReset */
+
+/**************************************************************************
+POLL - Wait for a frame
+***************************************************************************/
+static int tlan_poll(struct nic *nic)
 {
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	outb(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x3));
+	/* return true if there's an ethernet packet ready to read */
+	/* nic->packet should contain data on return */
+	/* nic->packetlen should contain length of data */
+	u32 framesize;
+	u32 host_cmd = 0;
+	u32 ack = 1;
+	int eoc = 0;
+	int entry = priv->cur_rx % TLAN_NUM_RX_LISTS;
+	u16 tmpCStat = le32_to_cpu(rx_ring[entry].cStat);
+	
+	u16 host_int = inw(BASE + TLAN_HOST_INT);
+	outw(host_int, BASE + TLAN_HOST_INT);
 
+	if (!(tmpCStat & TLAN_CSTAT_FRM_CMP))
+		return 0;
+
+	/* printf("PI-1: 0x%hX\n", host_int); */
+	if (tmpCStat & TLAN_CSTAT_EOC)
+		eoc = 1;
+
+	framesize = rx_ring[entry].frameSize;
+
+	nic->packetlen = framesize;
+
+#ifdef EBDEBUG
+     printf(".%d.", framesize); 
+#endif
+     
+	memcpy(nic->packet, rxb +
+	       (priv->cur_rx * TLAN_MAX_FRAME_SIZE), nic->packetlen);
+
+	rx_ring[entry].cStat = 0;
+#ifdef EBDEBUG
+	hex_dump(nic->packet, nic->packetlen);
+	printf("%d", entry);  
+#endif
+	entry = (entry + 1) % TLAN_NUM_RX_LISTS;
+	priv->cur_rx = entry;
+	if (eoc) {
+		if ((rx_ring[entry].cStat & TLAN_CSTAT_READY) ==
+		    TLAN_CSTAT_READY) {
+			ack |= TLAN_HC_GO | TLAN_HC_RT;
+			host_cmd = TLAN_HC_ACK | ack | 0x001C0000;
+			outl(host_cmd, BASE + TLAN_HOST_CMD);
+		}
+	} else {
+		host_cmd = TLAN_HC_ACK | ack | (0x000C0000);
+		outl(host_cmd, BASE + TLAN_HOST_CMD);
+#ifdef EBDEBUG
+		printf("AC: 0x%hX\n", inw(BASE + TLAN_CH_PARM)); 
+		host_int = inw(BASE + TLAN_HOST_INT);
+		printf("PI-2: 0x%hX\n", host_int); 
+#endif
+	}
+	refill_rx(nic);
+	return (1);		/* initially as this is called to flush the input */
 }
 
-inline void TLan_DioWrite16(u16 base_addr, u16 internal_addr, u16 data)
+static void refill_rx(struct nic *nic __unused)
 {
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	outw(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+	int entry = 0;
 
+	for (;
+	     (priv->cur_rx - priv->dirty_rx +
+	      TLAN_NUM_RX_LISTS) % TLAN_NUM_RX_LISTS > 0;
+	     priv->dirty_rx = (priv->dirty_rx + 1) % TLAN_NUM_RX_LISTS) {
+		entry = priv->dirty_rx % TLAN_NUM_TX_LISTS;
+		rx_ring[entry].frameSize = TLAN_MAX_FRAME_SIZE;
+		rx_ring[entry].cStat = TLAN_CSTAT_READY;
+	}
+
 }
 
-inline void TLan_DioWrite32(u16 base_addr, u16 internal_addr, u32 data)
+/* #define EBDEBUG */
+/**************************************************************************
+TRANSMIT - Transmit a frame
+***************************************************************************/
+static void tlan_transmit(struct nic *nic, const char *d,	/* Destination */
+			  unsigned int t,	/* Type */
+			  unsigned int s,	/* size */
+			  const char *p)
+{				/* Packet */
+	u16 nstype;
+	u32 to;
+	struct TLanList *tail_list;
+	struct TLanList *head_list;
+	u8 *tail_buffer;
+	u32 ack = 0;
+	u32 host_cmd;
+	int eoc = 0;
+	u16 tmpCStat;
+#ifdef EBDEBUG
+	u16 host_int = inw(BASE + TLAN_HOST_INT);
+#endif
+	int entry = 0;
+
+#ifdef EBDEBUG
+	printf("INT0-0x%hX\n", host_int);
+#endif
+
+	if (!priv->phyOnline) {
+		printf("TRANSMIT:  %s PHY is not ready\n", priv->nic_name);
+		return;
+	}
+
+	tail_list = priv->txList + priv->txTail;
+
+	if (tail_list->cStat != TLAN_CSTAT_UNUSED) {
+		printf("TRANSMIT: %s is busy (Head=%d Tail=%d)\n",
+		       priv->nic_name, priv->txList, priv->txTail);
+		tx_ring[entry].cStat = TLAN_CSTAT_UNUSED;
+		priv->txBusyCount++;
+		return;
+	}
+
+	tail_list->forward = 0;
+
+	tail_buffer = txb + (priv->txTail * TLAN_MAX_FRAME_SIZE);
+
+	/* send the packet to destination */
+	memcpy(tail_buffer, d, ETH_ALEN);
+	memcpy(tail_buffer + ETH_ALEN, nic->node_addr, ETH_ALEN);
+	nstype = htons((u16) t);
+	memcpy(tail_buffer + 2 * ETH_ALEN, (u8 *) & nstype, 2);
+	memcpy(tail_buffer + ETH_HLEN, p, s);
+
+	s += ETH_HLEN;
+	s &= 0x0FFF;
+	while (s < ETH_ZLEN)
+		tail_buffer[s++] = '\0';
+
+	/*=====================================================*/
+	/* Receive
+	 * 0000 0000 0001 1100
+	 * 0000 0000 0000 1100
+	 * 0000 0000 0000 0011 = 0x0003
+	 *
+	 * 0000 0000 0000 0000 0000 0000 0000 0011
+	 * 0000 0000 0000 1100 0000 0000 0000 0000 = 0x000C0000
+	 *
+	 * Transmit
+	 * 0000 0000 0001 1100
+	 * 0000 0000 0000 0100
+	 * 0000 0000 0000 0001 = 0x0001
+	 *
+	 * 0000 0000 0000 0000 0000 0000 0000 0001
+	 * 0000 0000 0000 0100 0000 0000 0000 0000 = 0x00040000
+	 * */
+
+	/* Setup the transmit descriptor */
+	tail_list->frameSize = (u16) s;
+	tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) s;
+	tail_list->buffer[1].count = 0;
+	tail_list->buffer[1].address = 0;
+
+	tail_list->cStat = TLAN_CSTAT_READY;
+
+#ifdef EBDEBUG
+	host_int = inw(BASE + TLAN_HOST_INT);
+	printf("INT1-0x%hX\n", host_int);
+#endif
+
+	if (!priv->txInProgress) {
+		priv->txInProgress = 1;
+		outl(virt_to_le32desc(tail_list), BASE + TLAN_CH_PARM);
+		outl(TLAN_HC_GO, BASE + TLAN_HOST_CMD);
+	} else {
+		if (priv->txTail == 0) {
+#ifdef EBDEBUG
+			printf("Out buffer\n");
+#endif
+			(priv->txList + (TLAN_NUM_TX_LISTS - 1))->forward =
+			    virt_to_le32desc(tail_list);
+		} else {
+#ifdef EBDEBUG
+			printf("Fix this \n");
+#endif
+			(priv->txList + (priv->txTail - 1))->forward =
+			    virt_to_le32desc(tail_list);
+		}
+	}
+	
+	CIRC_INC(priv->txTail, TLAN_NUM_TX_LISTS);
+
+#ifdef EBDEBUG
+	host_int = inw(BASE + TLAN_HOST_INT);
+	printf("INT2-0x%hX\n", host_int);
+#endif
+
+	to = currticks() + TX_TIME_OUT;
+	while ((tail_list->cStat == TLAN_CSTAT_READY) && currticks() < to);
+
+	head_list = priv->txList + priv->txHead;
+	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) 
+			&& (ack < 255)) {
+		ack++;
+		if(tmpCStat & TLAN_CSTAT_EOC)
+			eoc =1;
+		head_list->cStat = TLAN_CSTAT_UNUSED;
+		CIRC_INC(priv->txHead, TLAN_NUM_TX_LISTS);
+		head_list = priv->txList + priv->txHead;
+		
+	}
+	if(!ack)
+		printf("Incomplete TX Frame\n");
+
+	if(eoc) {
+		head_list = priv->txList + priv->txHead;
+		if ((head_list->cStat & TLAN_CSTAT_READY) == TLAN_CSTAT_READY) {
+			outl(virt_to_le32desc(head_list), BASE + TLAN_CH_PARM);
+			ack |= TLAN_HC_GO;
+		} else {
+			priv->txInProgress = 0;
+		}
+	}
+	if(ack) {
+		host_cmd = TLAN_HC_ACK | ack;
+		outl(host_cmd, BASE + TLAN_HOST_CMD);
+	}
+	
+	if(priv->tlanRev < 0x30 ) {
+		ack = 1;
+		head_list = priv->txList + priv->txHead;
+		if ((head_list->cStat & TLAN_CSTAT_READY) == TLAN_CSTAT_READY) {
+			outl(virt_to_le32desc(head_list), BASE + TLAN_CH_PARM);
+			ack |= TLAN_HC_GO;
+		} else {
+			priv->txInProgress = 0;
+		}
+		host_cmd = TLAN_HC_ACK | ack | 0x00140000;
+		outl(host_cmd, BASE + TLAN_HOST_CMD);
+		
+	}
+			
+	if (currticks() >= to) {
+		printf("TX Time Out");
+	}
+}
+
+/**************************************************************************
+DISABLE - Turn off ethernet interface
+***************************************************************************/
+#ifdef EB51
+static void tlan_disable(struct dev *dev __unused)
+#else
+static void tlan_disable(struct nic *nic __unused)
+#endif
 {
-	outw(internal_addr, base_addr + TLAN_DIO_ADR);
-	outl(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+	/* put the card in its initial state */
+	/* This function serves 3 purposes.
+	 * This disables DMA and interrupts so we don't receive
+	 *  unexpected packets or interrupts from the card after
+	 *  etherboot has finished.
+	 * This frees resources so etherboot may use
+	 *  this driver on another interface
+	 * This allows etherboot to reinitialize the interface
+	 *  if something is something goes wrong.
+	 *
+	 */
+	outl(TLAN_HC_AD_RST, BASE + TLAN_HOST_CMD);
+}
 
+static void TLan_SetMulticastList(struct nic *nic) {
+	int i;
+	u8 tmp;
+
+	/* !IFF_PROMISC */
+	tmp = TLan_DioRead8(BASE, TLAN_NET_CMD);
+	TLan_DioWrite8(BASE, TLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF);
+
+	/* IFF_ALLMULTI */
+	for(i = 0; i< 3; i++)
+		TLan_SetMac(nic, i + 1, NULL);
+	TLan_DioWrite32(BASE, TLAN_HASH_1, 0xFFFFFFFF);
+	TLan_DioWrite32(BASE, TLAN_HASH_2, 0xFFFFFFFF);
+
+	
 }
+/**************************************************************************
+PROBE - Look for an adapter, this routine's visible to the outside
+***************************************************************************/
 
-/* NIC specific static variables go here */
+#define board_found 1
+#define valid_link 0
+#ifdef EB51
+static int tlan_probe(struct dev *dev, struct pci_device *pci)
+{
+	struct nic *nic = (struct nic *) dev;
+#else
+struct nic *tlan_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
+{
+#endif
+		u16 data = 0;
+	int err;
+	int i;
 
+	if (pci->ioaddr == 0)
+		return 0;
+
+	BASE = pci->ioaddr;
+	printf("\n");
+	printf("tlan.c: %s, %s Written by Timothy Legge (tlegge@rogers.com)\n", drv_version, drv_date);
+	printf("%s: Probing for Vendor 0x%hX, Device 0x%hX",
+	       pci->name, pci->vendor, pci->dev_id);
+
+
+	/* I really must find out what this does */
+	adjust_pci_device(pci);
+
+	/* Point to private storage */
+	priv = &TLanPrivateInfo;
+	/* Figure out which chip we're dealing with */
+	i = 0;
+	chip_idx = -1;
+
+	while (tlan_pci_tbl[i].name) {
+		if ((((u32) pci->dev_id << 16) | pci->vendor) ==
+		    (tlan_pci_tbl[i].id.pci & 0xffffffff)) {
+			chip_idx = i;
+			break;
+		}
+		i++;
+	}
+
+	priv->vendor_id = pci->vendor;
+	priv->dev_id = pci->dev_id;
+	priv->nic_name = pci->name;
+	priv->eoc = 0;
+
+	err = 0;
+	for (i = 0; i < 6; i++)
+		err |= TLan_EeReadByte(BASE,
+				       (u8) tlan_pci_tbl[chip_idx].
+				       addrOfs + i,
+				       (u8 *) & nic->node_addr[i]);
+	if (err) {
+		printf("TLAN: %s: Error reading MAC from eeprom: %d\n",
+		       pci->name, err);
+	} else
+		printf("\nAddress: %!\n", nic->node_addr);
+
+	priv->tlanRev = TLan_DioRead8(BASE, TLAN_DEF_REVISION);
+	printf("\nRevision = 0x%hX\n", priv->tlanRev);
+
+	TLan_ResetLists(nic);
+	TLan_ResetAdapter(nic);
+/*
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_EOC;
+	outw(data, BASE + TLAN_HOST_CMD);
+*/
+
+	data = inl(BASE + TLAN_HOST_CMD);
+	data |= TLAN_HC_INT_OFF;
+	outw(data, BASE + TLAN_HOST_CMD);
+
+	TLan_SetMulticastList(nic);
+	udelay(100); 
+	priv->txList = tx_ring;
+	priv->rxList = rx_ring;
+/*	if (board_found && valid_link)
+	{*/
+	/* point to NIC specific routines */
+#ifdef EB51
+	dev->disable = tlan_disable;
+	nic->poll = tlan_poll;
+	nic->transmit = tlan_transmit;
+	return 1;
+#else
+	nic->disable = tlan_disable;
+	nic->poll = tlan_poll;
+	nic->transmit = tlan_transmit;
+	return nic;
+#endif
+}
+
+
 /*****************************************************************************
 ******************************************************************************
 
@@ -385,12 +923,13 @@
 ******************************************************************************
 *****************************************************************************/
 
+
 	/***************************************************************
 	 *	TLan_EeSendStart
 	 *
 	 *	Returns:
 	 *		Nothing
-	 *	Parms:	
+	 *	Parms:
 	 *		io_base		The IO port base address for the
 	 *				TLAN device with the EEPROM to
 	 *				use.
@@ -400,21 +939,24 @@
 	 *
 	 **************************************************************/
 
-static void TLan_EeSendStart( u16 io_base )
+void TLan_EeSendStart(u16 io_base)
 {
-	u16	sio;
+	u16 sio;
 
-	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
+	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
 
-	TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-	TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
-	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
-	TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );
-	TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
+	TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+	TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
+	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
+	TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);
+	TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
 
-} /* TLan_EeSendStart */
+}				/* TLan_EeSendStart */
 
+
+
+
 	/***************************************************************
 	 *	TLan_EeSendByte
 	 *
@@ -437,40 +979,43 @@
 	 *
 	 **************************************************************/
 
-static int TLan_EeSendByte( u16 io_base, u8 data, int stop )
+int TLan_EeSendByte(u16 io_base, u8 data, int stop)
 {
-	int	err;
-	u8	place;
-	u16	sio;
+	int err;
+	u8 place;
+	u16 sio;
 
-	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
+	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
 
 	/* Assume clock is low, tx is enabled; */
-	for ( place = 0x80; place != 0; place >>= 1 ) {
-		if ( place & data )
-			TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
+	for (place = 0x80; place != 0; place >>= 1) {
+		if (place & data)
+			TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
 		else
-			TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
+			TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
 	}
-	TLan_ClearBit( TLAN_NET_SIO_ETXEN, sio );
-	TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-	err = TLan_GetBit( TLAN_NET_SIO_EDATA, sio );
-	TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
-	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
+	TLan_ClearBit(TLAN_NET_SIO_ETXEN, sio);
+	TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+	err = TLan_GetBit(TLAN_NET_SIO_EDATA, sio);
+	TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
 
-	if ( ( ! err ) && stop ) {
-		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* STOP, raise data while clock is high */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
+	if ((!err) && stop) {
+		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* STOP, raise data while clock is high */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
 	}
 
-	return ( err );
+	return (err);
 
-} /* TLan_EeSendByte */
+}				/* TLan_EeSendByte */
 
+
+
+
 	/***************************************************************
 	 *	TLan_EeReceiveByte
 	 *
@@ -495,40 +1040,42 @@
 	 *
 	 **************************************************************/
 
-static void TLan_EeReceiveByte( u16 io_base, u8 *data, int stop )
+void TLan_EeReceiveByte(u16 io_base, u8 * data, int stop)
 {
-	u8  place;
+	u8 place;
 	u16 sio;
 
-	outw( TLAN_NET_SIO, io_base + TLAN_DIO_ADR );
+	outw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);
 	sio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;
 	*data = 0;
 
 	/* Assume clock is low, tx is enabled; */
-	TLan_ClearBit( TLAN_NET_SIO_ETXEN, sio );
-	for ( place = 0x80; place; place >>= 1 ) {
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		if ( TLan_GetBit( TLAN_NET_SIO_EDATA, sio ) )
+	TLan_ClearBit(TLAN_NET_SIO_ETXEN, sio);
+	for (place = 0x80; place; place >>= 1) {
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		if (TLan_GetBit(TLAN_NET_SIO_EDATA, sio))
 			*data |= place;
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
 	}
 
-	TLan_SetBit( TLAN_NET_SIO_ETXEN, sio );
-	if ( ! stop ) {
-		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* Ack = 0 */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
+	TLan_SetBit(TLAN_NET_SIO_ETXEN, sio);
+	if (!stop) {
+		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* Ack = 0 */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
 	} else {
-		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );		/* No ack = 1 (?) */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_ClearBit( TLAN_NET_SIO_EDATA, sio );	/* STOP, raise data while clock is high */
-		TLan_SetBit( TLAN_NET_SIO_ECLOK, sio );
-		TLan_SetBit( TLAN_NET_SIO_EDATA, sio );
+		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);	/* No ack = 1 (?) */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_ClearBit(TLAN_NET_SIO_EDATA, sio);	/* STOP, raise data while clock is high */
+		TLan_SetBit(TLAN_NET_SIO_ECLOK, sio);
+		TLan_SetBit(TLAN_NET_SIO_EDATA, sio);
 	}
 
-} /* TLan_EeReceiveByte */
+}				/* TLan_EeReceiveByte */
 
+
+
 	/***************************************************************
 	 *	TLan_EeReadByte
 	 *
@@ -550,420 +1097,37 @@
 	 *
 	 **************************************************************/
 
-static int TLan_EeReadByte( u16 io_base, u8 ee_addr, u8 *data )
+int TLan_EeReadByte(u16 io_base, u8 ee_addr, u8 * data)
 {
 	int err;
-	unsigned long flags = 0;
-	int ret=0;
+	int ret = 0;
 
-	TLan_EeSendStart( io_base );
-	err = TLan_EeSendByte( io_base, 0xA0, TLAN_EEPROM_ACK );
-	if (err)
-	{
-		ret=1;
+
+	TLan_EeSendStart(io_base);
+	err = TLan_EeSendByte(io_base, 0xA0, TLAN_EEPROM_ACK);
+	if (err) {
+		ret = 1;
 		goto fail;
 	}
-	err = TLan_EeSendByte( io_base, ee_addr, TLAN_EEPROM_ACK );
-	if (err)
-	{
-		ret=2;
+	err = TLan_EeSendByte(io_base, ee_addr, TLAN_EEPROM_ACK);
+	if (err) {
+		ret = 2;
 		goto fail;
 	}
-	TLan_EeSendStart( io_base );
-	err = TLan_EeSendByte( io_base, 0xA1, TLAN_EEPROM_ACK );
-	if (err)
-	{
-		ret=3;
+	TLan_EeSendStart(io_base);
+	err = TLan_EeSendByte(io_base, 0xA1, TLAN_EEPROM_ACK);
+	if (err) {
+		ret = 3;
 		goto fail;
 	}
-	TLan_EeReceiveByte( io_base, data, TLAN_EEPROM_STOP );
-fail:
+	TLan_EeReceiveByte(io_base, data, TLAN_EEPROM_STOP);
+      fail:
 
 	return ret;
 
-} /* TLan_EeReadByte */
+}				/* TLan_EeReadByte */
 
-#if	0
-/* Not yet converted from Linux driver */
-/*****************************************************************************
-******************************************************************************
 
-	ThunderLAN Driver PHY Layer Routines
-
-******************************************************************************
-*****************************************************************************/
-
-	/*********************************************************************
-	 *	TLan_PhyPrint
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	A pointer to the device structure of the
-	 *			TLAN device having the PHYs to be detailed.
-	 *				
-	 *	This function prints the registers a PHY (aka tranceiver).
-	 *
-	 ********************************************************************/
-
-void TLan_PhyPrint( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	u16 i, data0, data1, data2, data3, phy;
-
-	phy = priv->phy[priv->phyNum];
-
-	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
-		printk( "TLAN:   Device %s, Unmanaged PHY.\n", dev->name );
-	} else if ( phy <= TLAN_PHY_MAX_ADDR ) {
-		printk( "TLAN:   Device %s, PHY 0x%02x.\n", dev->name, phy );
-		printk( "TLAN:      Off.  +0     +1     +2     +3 \n" );
-                for ( i = 0; i < 0x20; i+= 4 ) {
-			printk( "TLAN:      0x%02x", i );
-			TLan_MiiReadReg( dev, phy, i, &data0 );
-			printk( " 0x%04hx", data0 );
-			TLan_MiiReadReg( dev, phy, i + 1, &data1 );
-			printk( " 0x%04hx", data1 );
-			TLan_MiiReadReg( dev, phy, i + 2, &data2 );
-			printk( " 0x%04hx", data2 );
-			TLan_MiiReadReg( dev, phy, i + 3, &data3 );
-			printk( " 0x%04hx\n", data3 );
-		}
-	} else {
-		printk( "TLAN:   Device %s, Invalid PHY.\n", dev->name );
-	}
-
-} /* TLan_PhyPrint */
-
-	/*********************************************************************
-	 *	TLan_PhyDetect
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	A pointer to the device structure of the adapter
-	 *			for which the PHY needs determined.
-	 *
-	 *	So far I've found that adapters which have external PHYs
-	 *	may also use the internal PHY for part of the functionality.
-	 *	(eg, AUI/Thinnet).  This function finds out if this TLAN
-	 *	chip has an internal PHY, and then finds the first external
-	 *	PHY (starting from address 0) if it exists).
-	 *
-	 ********************************************************************/
-
-void TLan_PhyDetect( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	u16		control;
-	u16		hi;
-	u16		lo;
-	u32		phy;
-
-	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
-		priv->phyNum = 0xFFFF;
-		return;
-	}
-
-	TLan_MiiReadReg( dev, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi );
-	
-	if ( hi != 0xFFFF ) {
-		priv->phy[0] = TLAN_PHY_MAX_ADDR;
-	} else {
-		priv->phy[0] = TLAN_PHY_NONE;
-	}
-
-	priv->phy[1] = TLAN_PHY_NONE;
-	for ( phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++ ) {
-		TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &control );
-		TLan_MiiReadReg( dev, phy, MII_GEN_ID_HI, &hi );
-		TLan_MiiReadReg( dev, phy, MII_GEN_ID_LO, &lo );
-		if ( ( control != 0xFFFF ) || ( hi != 0xFFFF ) || ( lo != 0xFFFF ) ) {
-			TLAN_DBG( TLAN_DEBUG_GNRL, "PHY found at %02x %04x %04x %04x\n", phy, control, hi, lo );
-			if ( ( priv->phy[1] == TLAN_PHY_NONE ) && ( phy != TLAN_PHY_MAX_ADDR ) ) {
-				priv->phy[1] = phy;
-			}
-		}
-	}
-
-	if ( priv->phy[1] != TLAN_PHY_NONE ) {
-		priv->phyNum = 1;
-	} else if ( priv->phy[0] != TLAN_PHY_NONE ) {
-		priv->phyNum = 0;
-	} else {
-		printk( "TLAN:  Cannot initialize device, no PHY was found!\n" );
-	}
-
-} /* TLan_PhyDetect */
-
-void TLan_PhyPowerDown( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		value;
-
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Powering down PHY(s).\n", dev->name );
-	value = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;
-	TLan_MiiSync( dev->base_addr );
-	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
-	if ( ( priv->phyNum == 0 ) && ( priv->phy[1] != TLAN_PHY_NONE ) && ( ! ( priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10 ) ) ) {
-		TLan_MiiSync( dev->base_addr );
-		TLan_MiiWriteReg( dev, priv->phy[1], MII_GEN_CTL, value );
-	}
-
-	/* Wait for 50 ms and powerup
-	 * This is abitrary.  It is intended to make sure the
-	 * tranceiver settles.
-	 */
-	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP );
-
-} /* TLan_PhyPowerDown */
-
-void TLan_PhyPowerUp( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		value;
-
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Powering up PHY.\n", dev->name );
-	TLan_MiiSync( dev->base_addr );
-	value = MII_GC_LOOPBK;
-	TLan_MiiWriteReg( dev, priv->phy[priv->phyNum], MII_GEN_CTL, value );
-	TLan_MiiSync(dev->base_addr);
-	/* Wait for 500 ms and reset the
-	 * tranceiver.  The TLAN docs say both 50 ms and
-	 * 500 ms, so do the longer, just in case.
-	 */
-	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET );
-
-} /* TLan_PhyPowerUp */
-
-void TLan_PhyReset( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		phy;
-	u16		value;
-
-	phy = priv->phy[priv->phyNum];
-
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Reseting PHY.\n", dev->name );
-	TLan_MiiSync( dev->base_addr );
-	value = MII_GC_LOOPBK | MII_GC_RESET;
-	TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, value );
-	TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &value );
-	while ( value & MII_GC_RESET ) {
-		TLan_MiiReadReg( dev, phy, MII_GEN_CTL, &value );
-	}
-
-	/* Wait for 500 ms and initialize.
-	 * I don't remember why I wait this long.
-	 * I've changed this to 50ms, as it seems long enough.
-	 */
-	TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_START_LINK );
-
-} /* TLan_PhyReset */
-
-void TLan_PhyStartLink( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		ability;
-	u16		control;
-	u16		data;
-	u16		phy;
-	u16		status;
-	u16		tctl;
-
-	phy = priv->phy[priv->phyNum];
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Trying to activate link.\n", dev->name );
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &ability );
-
-	if ( ( status & MII_GS_AUTONEG ) && 
-	     ( ! priv->aui ) ) {
-		ability = status >> 11;
-		if ( priv->speed  == TLAN_SPEED_10 && 
-		     priv->duplex == TLAN_DUPLEX_HALF) {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x0000);
-		} else if ( priv->speed == TLAN_SPEED_10 &&
-			    priv->duplex == TLAN_DUPLEX_FULL) {
-			priv->tlanFullDuplex = TRUE;
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x0100);
-		} else if ( priv->speed == TLAN_SPEED_100 &&
-			    priv->duplex == TLAN_DUPLEX_HALF) {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x2000);
-		} else if ( priv->speed == TLAN_SPEED_100 &&
-			    priv->duplex == TLAN_DUPLEX_FULL) {
-			priv->tlanFullDuplex = TRUE;
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x2100);
-		} else {
-	
-			/* Set Auto-Neg advertisement */
-			TLan_MiiWriteReg( dev, phy, MII_AN_ADV, (ability << 5) | 1);
-			/* Enablee Auto-Neg */
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x1000 );
-			/* Restart Auto-Neg */
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, 0x1200 );
-			/* Wait for 4 sec for autonegotiation
-		 	* to complete.  The max spec time is less than this
-		 	* but the card need additional time to start AN.
-		 	* .5 sec should be plenty extra.
-		 	*/
-			printk( "TLAN: %s: Starting autonegotiation.\n", dev->name );
-			TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN );
-			return;
-		}
-		
-	}	
-	
-	if ( ( priv->aui ) && ( priv->phyNum != 0 ) ) {
-		priv->phyNum = 0;
-		data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
-		TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, data );
-		TLan_SetTimer( dev, (40*HZ/1000), TLAN_TIMER_PHY_PDOWN );
-		return;
-	}  else if ( priv->phyNum == 0 ) {
-        	TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tctl );
-		if ( priv->aui ) {
-                	tctl |= TLAN_TC_AUISEL;
-		} else { 
-                	tctl &= ~TLAN_TC_AUISEL;
-			control = 0;
-			if ( priv->duplex == TLAN_DUPLEX_FULL ) {
-				control |= MII_GC_DUPLEX;
-				priv->tlanFullDuplex = TRUE;
-			}
-			if ( priv->speed == TLAN_SPEED_100 ) {
-				control |= MII_GC_SPEEDSEL;
-			}
-       			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, control );
-		}
-        	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tctl );
-	}
-
-	/* Wait for 2 sec to give the tranceiver time
-	 * to establish link.
-	 */
-	TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET );
-
-} /* TLan_PhyStartLink */
-
-void TLan_PhyFinishAutoNeg( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u16		an_adv;
-	u16		an_lpa;
-	u16		data;
-	u16		mode;
-	u16		phy;
-	u16		status;
-	
-	phy = priv->phy[priv->phyNum];
-
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-	udelay( 1000 );
-	TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-
-	if ( ! ( status & MII_GS_AUTOCMPLT ) ) {
-		/* Wait for 8 sec to give the process
-		 * more time.  Perhaps we should fail after a while.
-		 */
-		 if (!priv->neg_be_verbose++) {
-			 printk(KERN_INFO "TLAN:  Giving autonegotiation more time.\n");
-		 	 printk(KERN_INFO "TLAN:  Please check that your adapter has\n");
-		 	 printk(KERN_INFO "TLAN:  been properly connected to a HUB or Switch.\n");
-			 printk(KERN_INFO "TLAN:  Trying to establish link in the background...\n");
-		 }
-		TLan_SetTimer( dev, (8*HZ), TLAN_TIMER_PHY_FINISH_AN );
-		return;
-	}
-
-	printk( "TLAN: %s: Autonegotiation complete.\n", dev->name );
-	TLan_MiiReadReg( dev, phy, MII_AN_ADV, &an_adv );
-	TLan_MiiReadReg( dev, phy, MII_AN_LPA, &an_lpa );
-	mode = an_adv & an_lpa & 0x03E0;
-	if ( mode & 0x0100 ) {
-		priv->tlanFullDuplex = TRUE;
-	} else if ( ! ( mode & 0x0080 ) && ( mode & 0x0040 ) ) {
-		priv->tlanFullDuplex = TRUE;
-	}
-
-	if ( ( ! ( mode & 0x0180 ) ) && ( priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10 ) && ( priv->phyNum != 0 ) ) {
-		priv->phyNum = 0;
-		data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
-		TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, data );
-		TLan_SetTimer( dev, (400*HZ/1000), TLAN_TIMER_PHY_PDOWN );
-		return;
-	}
-
-	if ( priv->phyNum == 0 ) {
-		if ( ( priv->duplex == TLAN_DUPLEX_FULL ) || ( an_adv & an_lpa & 0x0040 ) ) {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, MII_GC_AUTOENB | MII_GC_DUPLEX );
-			printk( "TLAN:  Starting internal PHY with FULL-DUPLEX\n" );
-		} else {
-			TLan_MiiWriteReg( dev, phy, MII_GEN_CTL, MII_GC_AUTOENB );
-			printk( "TLAN:  Starting internal PHY with HALF-DUPLEX\n" );
-		}
-	}
-
-	/* Wait for 100 ms.  No reason in partiticular.
-	 */
-	TLan_SetTimer( dev, (HZ/10), TLAN_TIMER_FINISH_RESET );
-		
-} /* TLan_PhyFinishAutoNeg */
-
-#ifdef MONITOR
-
-        /*********************************************************************
-        *
-        *      TLan_phyMonitor
-        *
-        *      Returns: 
-        *              None
-        *
-        *      Params:
-        *              dev             The device structure of this device.
-        *
-        *      
-        *      This function monitors PHY condition by reading the status
-        *      register via the MII bus. This can be used to give info
-        *      about link changes (up/down), and possible switch to alternate
-        *      media.
-        *
-        * ******************************************************************/
-
-void TLan_PhyMonitor( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	u16     phy;
-	u16     phy_status;
-
-	phy = priv->phy[priv->phyNum];
-
-        /* Get PHY status register */
-        TLan_MiiReadReg( dev, phy, MII_GEN_STS, &phy_status );
-
-        /* Check if link has been lost */
-        if (!(phy_status & MII_GS_LINK)) { 
- 	       if (priv->link) {
-		      priv->link = 0;
-	              printk(KERN_DEBUG "TLAN: %s has lost link\n", dev->name);
-	              dev->flags &= ~IFF_RUNNING;
-		      TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT );
-		      return;
-		}
-	}
-
-        /* Link restablished? */
-        if ((phy_status & MII_GS_LINK) && !priv->link) {
- 		priv->link = 1;
-        	printk(KERN_DEBUG "TLAN: %s has reestablished link\n", dev->name);
-        	dev->flags |= IFF_RUNNING;
-        }
-
-	/* Setup a new monitor */
-	TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT );
-}	
-
-#endif /* MONITOR */
-
 /*****************************************************************************
 ******************************************************************************
 
@@ -975,6 +1139,7 @@
 ******************************************************************************
 *****************************************************************************/
 
+
 	/***************************************************************
 	 *	TLan_MiiReadReg
 	 *
@@ -999,50 +1164,46 @@
 	 *
 	 **************************************************************/
 
-int TLan_MiiReadReg( struct net_device *dev, u16 phy, u16 reg, u16 *val )
+int TLan_MiiReadReg(struct nic *nic __unused, u16 phy, u16 reg, u16 * val)
 {
-	u8	nack;
-	u16	sio, tmp;
- 	u32	i;
-	int	err;
-	int	minten;
-	TLanPrivateInfo *priv = dev->priv;
-	unsigned long flags = 0;
+	u8 nack;
+	u16 sio, tmp;
+	u32 i;
+	int err;
+	int minten;
 
 	err = FALSE;
-	outw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);
-	sio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
-	
-	if (!in_irq())
-		spin_lock_irqsave(&priv->lock, flags);
+	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
+	sio = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
 
-	TLan_MiiSync(dev->base_addr);
+	TLan_MiiSync(BASE);
 
-	minten = TLan_GetBit( TLAN_NET_SIO_MINTEN, sio );
-	if ( minten )
+	minten = TLan_GetBit(TLAN_NET_SIO_MINTEN, sio);
+	if (minten)
 		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
 
-	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Start ( 01b ) */
-	TLan_MiiSendData( dev->base_addr, 0x2, 2 );	/* Read  ( 10b ) */
-	TLan_MiiSendData( dev->base_addr, phy, 5 );	/* Device #      */
-	TLan_MiiSendData( dev->base_addr, reg, 5 );	/* Register #    */
+	TLan_MiiSendData(BASE, 0x1, 2);	/* Start ( 01b ) */
+	TLan_MiiSendData(BASE, 0x2, 2);	/* Read  ( 10b ) */
+	TLan_MiiSendData(BASE, phy, 5);	/* Device #      */
+	TLan_MiiSendData(BASE, reg, 5);	/* Register #    */
 
-	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);		/* Change direction */
 
-	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Clock Idle bit */
+	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);	/* Change direction */
+
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Clock Idle bit */
 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
-	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Wait 300ns */
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Wait 300ns */
 
 	nack = TLan_GetBit(TLAN_NET_SIO_MDATA, sio);	/* Check for ACK */
-	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);		/* Finish ACK */
-	if (nack) {					/* No ACK, so fake it */
+	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);	/* Finish ACK */
+	if (nack) {		/* No ACK, so fake it */
 		for (i = 0; i < 16; i++) {
 			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
 			TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
 		}
 		tmp = 0xffff;
 		err = TRUE;
-	} else {					/* ACK, so read data */
+	} else {		/* ACK, so read data */
 		for (tmp = 0, i = 0x8000; i; i >>= 1) {
 			TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
 			if (TLan_GetBit(TLAN_NET_SIO_MDATA, sio))
@@ -1051,20 +1212,18 @@
 		}
 	}
 
-	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);		/* Idle cycle */
+
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Idle cycle */
 	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
 
-	if ( minten )
+	if (minten)
 		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
 
 	*val = tmp;
-	
-	if (!in_irq())
-		spin_unlock_irqrestore(&priv->lock, flags);
 
 	return err;
 
-} /* TLan_MiiReadReg */
+}				/* TLan_MiiReadReg */
 
 	/***************************************************************
 	 *	TLan_MiiSendData
@@ -1084,31 +1243,34 @@
 	 *
 	 **************************************************************/
 
-void TLan_MiiSendData( u16 base_port, u32 data, unsigned num_bits )
+void TLan_MiiSendData(u16 base_port, u32 data, unsigned num_bits)
 {
 	u16 sio;
 	u32 i;
 
-	if ( num_bits == 0 )
+	if (num_bits == 0)
 		return;
 
-	outw( TLAN_NET_SIO, base_port + TLAN_DIO_ADR );
+	outw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);
 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
-	TLan_SetBit( TLAN_NET_SIO_MTXEN, sio );
+	TLan_SetBit(TLAN_NET_SIO_MTXEN, sio);
 
-	for ( i = ( 0x1 << ( num_bits - 1 ) ); i; i >>= 1 ) {
-		TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );
-		(void) TLan_GetBit( TLAN_NET_SIO_MCLK, sio );
-		if ( data & i )
-			TLan_SetBit( TLAN_NET_SIO_MDATA, sio );
+	for (i = (0x1 << (num_bits - 1)); i; i >>= 1) {
+		TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
+		(void) TLan_GetBit(TLAN_NET_SIO_MCLK, sio);
+		if (data & i)
+			TLan_SetBit(TLAN_NET_SIO_MDATA, sio);
 		else
-			TLan_ClearBit( TLAN_NET_SIO_MDATA, sio );
-		TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
-		(void) TLan_GetBit( TLAN_NET_SIO_MCLK, sio );
+			TLan_ClearBit(TLAN_NET_SIO_MDATA, sio);
+		TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
+		(void) TLan_GetBit(TLAN_NET_SIO_MCLK, sio);
 	}
 
-} /* TLan_MiiSendData */
+}				/* TLan_MiiSendData */
 
+
+
+
 	/***************************************************************
 	 *	TLan_MiiSync
 	 *
@@ -1123,22 +1285,25 @@
 	 *
 	 **************************************************************/
 
-void TLan_MiiSync( u16 base_port )
+void TLan_MiiSync(u16 base_port)
 {
 	int i;
 	u16 sio;
 
-	outw( TLAN_NET_SIO, base_port + TLAN_DIO_ADR );
+	outw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);
 	sio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;
 
-	TLan_ClearBit( TLAN_NET_SIO_MTXEN, sio );
-	for ( i = 0; i < 32; i++ ) {
-		TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );
-		TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
+	TLan_ClearBit(TLAN_NET_SIO_MTXEN, sio);
+	for (i = 0; i < 32; i++) {
+		TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);
+		TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
 	}
 
-} /* TLan_MiiSync */
+}				/* TLan_MiiSync */
 
+
+
+
 	/***************************************************************
 	 *	TLan_MiiWriteReg
 	 *
@@ -1159,2588 +1324,473 @@
 	 *
 	 **************************************************************/
 
-void TLan_MiiWriteReg( struct net_device *dev, u16 phy, u16 reg, u16 val )
+void TLan_MiiWriteReg(struct nic *nic __unused, u16 phy, u16 reg, u16 val)
 {
-	u16	sio;
-	int	minten;
-	unsigned long flags = 0;
-	TLanPrivateInfo *priv = dev->priv;
+	u16 sio;
+	int minten;
 
-	outw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);
-	sio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
-	
-	if (!in_irq())
-		spin_lock_irqsave(&priv->lock, flags);
+	outw(TLAN_NET_SIO, BASE + TLAN_DIO_ADR);
+	sio = BASE + TLAN_DIO_DATA + TLAN_NET_SIO;
 
-	TLan_MiiSync( dev->base_addr );
+	TLan_MiiSync(BASE);
 
-	minten = TLan_GetBit( TLAN_NET_SIO_MINTEN, sio );
-	if ( minten )
-		TLan_ClearBit( TLAN_NET_SIO_MINTEN, sio );
+	minten = TLan_GetBit(TLAN_NET_SIO_MINTEN, sio);
+	if (minten)
+		TLan_ClearBit(TLAN_NET_SIO_MINTEN, sio);
 
-	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Start ( 01b ) */
-	TLan_MiiSendData( dev->base_addr, 0x1, 2 );	/* Write ( 01b ) */
-	TLan_MiiSendData( dev->base_addr, phy, 5 );	/* Device #      */
-	TLan_MiiSendData( dev->base_addr, reg, 5 );	/* Register #    */
+	TLan_MiiSendData(BASE, 0x1, 2);	/* Start ( 01b ) */
+	TLan_MiiSendData(BASE, 0x1, 2);	/* Write ( 01b ) */
+	TLan_MiiSendData(BASE, phy, 5);	/* Device #      */
+	TLan_MiiSendData(BASE, reg, 5);	/* Register #    */
 
-	TLan_MiiSendData( dev->base_addr, 0x2, 2 );	/* Send ACK */
-	TLan_MiiSendData( dev->base_addr, val, 16 );	/* Send Data */
+	TLan_MiiSendData(BASE, 0x2, 2);	/* Send ACK */
+	TLan_MiiSendData(BASE, val, 16);	/* Send Data */
 
-	TLan_ClearBit( TLAN_NET_SIO_MCLK, sio );	/* Idle cycle */
-	TLan_SetBit( TLAN_NET_SIO_MCLK, sio );
+	TLan_ClearBit(TLAN_NET_SIO_MCLK, sio);	/* Idle cycle */
+	TLan_SetBit(TLAN_NET_SIO_MCLK, sio);
 
-	if ( minten )
-		TLan_SetBit( TLAN_NET_SIO_MINTEN, sio );
-	
-	if (!in_irq())
-		spin_unlock_irqrestore(&priv->lock, flags);
+	if (minten)
+		TLan_SetBit(TLAN_NET_SIO_MINTEN, sio);
 
-} /* TLan_MiiWriteReg */
-#endif
 
-/**************************************************************************
-RESET - Reset adapter
-***************************************************************************/
-static void skel_reset(struct nic *nic)
-{
-	/* put the card in its initial state */
-}
+}				/* TLan_MiiWriteReg */
 
-/**************************************************************************
-POLL - Wait for a frame
-***************************************************************************/
-static int skel_poll(struct nic *nic)
-{
-	/* return true if there's an ethernet packet ready to read */
-	/* nic->packet should contain data on return */
-	/* nic->packetlen should contain length of data */
-	return (0);	/* initially as this is called to flush the input */
-}
-
-/**************************************************************************
-TRANSMIT - Transmit a frame
-***************************************************************************/
-static void skel_transmit(
-	struct nic *nic,
-	const char *d,			/* Destination */
-	unsigned int t,			/* Type */
-	unsigned int s,			/* size */
-	const char *p)			/* Packet */
-{
-	/* send the packet to destination */
-}
-
-/**************************************************************************
-DISABLE - Turn off ethernet interface
-***************************************************************************/
-static void skel_disable(struct nic *nic)
-{
-}
-
-/**************************************************************************
-PROBE - Look for an adapter, this routine's visible to the outside
-You should omit the last argument struct pci_device * for a non-PCI NIC
-***************************************************************************/
-struct nic *tlan_probe(struct nic *nic, unsigned short *probe_addrs,
-	struct pci_device *p)
-{
-	/* if probe_addrs is 0, then routine can use a hardwired default */
-	/* if board found */
-	{
-		/* point to NIC specific routines */
-		nic->reset = skel_reset;
-		nic->poll = skel_poll;
-		nic->transmit = skel_transmit;
-		nic->disable = skel_disable;
-		return nic;
-	}
-	/* else */
-	return 0;
-}
-
-#if	0
-#ifndef TLAN_H
-#define TLAN_H
-/********************************************************************
- *
- *  Linux ThunderLAN Driver
- *
- *  tlan.h
- *  by James Banks
- *
- *  (C) 1997-1998 Caldera, Inc.
- *  (C) 1999-2001 Torben Mathiasen
- * 
- *  This software may be used and distributed according to the terms
- *  of the GNU General Public License, incorporated herein by reference.
- *
- ** This file is best viewed/edited with tabstop=4, colums>=132
- *
- *  
- *  Dec 10, 1999	Torben Mathiasen <torben.mathiasen@compaq.com>
- *			New Maintainer
- *
- ********************************************************************/
-
-#include <asm/io.h>
-#include <asm/types.h>
-#include <linux/netdevice.h>
-
-#define FALSE			0
-#define TRUE			1
-
-#define TX_TIMEOUT		(10*HZ)	 /* We need time for auto-neg */
-
-typedef struct tlan_adapter_entry {
-	u16	vendorId;
-	u16	deviceId;
-	char	*deviceLabel;
-	u32	flags;
-	u16	addrOfs;
-} TLanAdapterEntry;
-
-	/*****************************************************************
-	 * EISA Definitions
-	 *
-	 ****************************************************************/
-
-#define EISA_ID      0xc80   /* EISA ID Registers */ 
-#define EISA_ID0     0xc80   /* EISA ID Register 0 */ 
-#define EISA_ID1     0xc81   /* EISA ID Register 1 */ 
-#define EISA_ID2     0xc82   /* EISA ID Register 2 */ 
-#define EISA_ID3     0xc83   /* EISA ID Register 3 */ 
-#define EISA_CR      0xc84   /* EISA Control Register */
-#define EISA_REG0    0xc88   /* EISA Configuration Register 0 */
-#define EISA_REG1    0xc89   /* EISA Configuration Register 1 */
-#define EISA_REG2    0xc8a   /* EISA Configuration Register 2 */
-#define EISA_REG3    0xc8f   /* EISA Configuration Register 3 */
-#define EISA_APROM   0xc90   /* Ethernet Address PROM */
-
-	/*****************************************************************
-	 * Rx/Tx List Definitions
-	 *
-	 ****************************************************************/
-
-typedef struct tlan_buffer_ref_tag {
-	u32	count;
-	u32	address;
-} TLanBufferRef;
-
-typedef struct tlan_list_tag {
-	u32		forward;
-	u16		cStat;
-	u16		frameSize;
-	TLanBufferRef	buffer[TLAN_BUFFERS_PER_LIST];
-} TLanList;
-
-typedef u8 TLanBuffer[TLAN_MAX_FRAME_SIZE];
-
-	/*****************************************************************
-	 * TLAN Private Information Structure
-	 *
-	 ****************************************************************/
-
-typedef struct tlan_private_tag {
-	struct net_device       *nextDevice;
-	void			*dmaStorage;
-	u8			*padBuffer;
-	TLanList                *rxList;
-	u8			*rxBuffer;
-	u32                     rxHead;
-	u32                     rxTail;
-	u32			rxEocCount;
-	TLanList                *txList;
-	u8			*txBuffer;
-	u32                     txHead;
-	u32                     txInProgress;
-	u32                     txTail;
-	u32			txBusyCount;
-	u32                     phyOnline;
-	u32			timerSetAt;
-	u32			timerType;
-	struct timer_list	timer;
-	struct net_device_stats	stats;
-	struct board		*adapter;
-	u32			adapterRev;
-	u32			aui;
-	u32			debug;
-	u32			duplex;
-	u32			phy[2];
-	u32			phyNum;
-	u32			speed;
-	u8			tlanRev;
-	u8			tlanFullDuplex;
-	char                    devName[8];
-	spinlock_t		lock;
-	u8			link;
-	u8			is_eisa;
-	struct tq_struct	tlan_tqueue;
-	u8			neg_be_verbose;
-} TLanPrivateInfo;
-
-#define 	TLAN_HC_GO		0x80000000
-#define		TLAN_HC_STOP		0x40000000
-#define		TLAN_HC_ACK		0x20000000
-#define		TLAN_HC_CS_MASK		0x1FE00000
-#define		TLAN_HC_EOC		0x00100000
-#define		TLAN_HC_RT		0x00080000
-#define		TLAN_HC_NES		0x00040000
-#define		TLAN_HC_AD_RST		0x00008000
-#define		TLAN_HC_LD_TMR		0x00004000
-#define		TLAN_HC_LD_THR		0x00002000
-#define		TLAN_HC_REQ_INT		0x00001000
-#define		TLAN_HC_INT_OFF		0x00000800
-#define		TLAN_HC_INT_ON		0x00000400
-#define		TLAN_HC_AC_MASK		0x000000FF
-#define		TLAN_DA_ADR_INC		0x8000
-#define		TLAN_DA_RAM_ADR		0x4000
-#define		TLAN_HI_IV_MASK		0x1FE0
-#define		TLAN_HI_IT_MASK		0x001C
-
-#define		TLAN_NET_CMD_NRESET	0x80
-#define		TLAN_NET_CMD_NWRAP	0x40
-#define		TLAN_NET_CMD_CSF	0x20
-#define		TLAN_NET_CMD_CAF	0x10
-#define		TLAN_NET_CMD_NOBRX	0x08
-#define		TLAN_NET_CMD_DUPLEX	0x04
-#define		TLAN_NET_CMD_TRFRAM	0x02
-#define		TLAN_NET_CMD_TXPACE	0x01
-#define 	TLAN_NET_SIO_MINTEN	0x80
-#define		TLAN_NET_SIO_ECLOK	0x40
-#define		TLAN_NET_SIO_ETXEN	0x20
-#define		TLAN_NET_SIO_EDATA	0x10
-#define		TLAN_NET_SIO_NMRST	0x08
-#define		TLAN_NET_SIO_MCLK	0x04
-#define		TLAN_NET_SIO_MTXEN	0x02
-#define		TLAN_NET_SIO_MDATA	0x01
-#define		TLAN_NET_STS_MIRQ	0x80
-#define		TLAN_NET_STS_HBEAT	0x40
-#define		TLAN_NET_STS_TXSTOP	0x20
-#define		TLAN_NET_STS_RXSTOP	0x10
-#define		TLAN_NET_STS_RSRVD	0x0F
-#define		TLAN_NET_MASK_MASK7	0x80
-#define		TLAN_NET_MASK_MASK6	0x40
-#define		TLAN_NET_MASK_MASK5	0x20
-#define		TLAN_NET_MASK_MASK4	0x10
-#define		TLAN_NET_MASK_RSRVD	0x0F
-#define 	TLAN_NET_CFG_RCLK	0x8000
-#define		TLAN_NET_CFG_TCLK	0x4000
-#define		TLAN_NET_CFG_BIT	0x2000
-#define		TLAN_NET_CFG_RXCRC	0x1000
-#define		TLAN_NET_CFG_PEF	0x0800
-#define		TLAN_NET_CFG_1FRAG	0x0400
-#define		TLAN_NET_CFG_1CHAN	0x0200
-#define		TLAN_NET_CFG_MTEST	0x0100
-#define		TLAN_NET_CFG_PHY_EN	0x0080
-#define		TLAN_NET_CFG_MSMASK	0x007F
-#define		TLAN_LED_ACT		0x10
-#define		TLAN_LED_LINK		0x01
-#define		TLAN_ID_TX_EOC		0x04
-#define		TLAN_ID_RX_EOF		0x02
-#define		TLAN_ID_RX_EOC		0x01
-
-#define CIRC_INC( a, b ) if ( ++a >= b ) a = 0
-
-#ifdef I_LIKE_A_FAST_HASH_FUNCTION
-/* given 6 bytes, view them as 8 6-bit numbers and return the XOR of those */
-/* the code below is about seven times as fast as the original code */
-inline u32 TLan_HashFunc( u8 *a )
-{
-        u8     hash;
-
-        hash = (a[0]^a[3]);             /* & 077 */
-        hash ^= ((a[0]^a[3])>>6);       /* & 003 */
-        hash ^= ((a[1]^a[4])<<2);       /* & 074 */
-        hash ^= ((a[1]^a[4])>>4);       /* & 017 */
-        hash ^= ((a[2]^a[5])<<4);       /* & 060 */
-        hash ^= ((a[2]^a[5])>>2);       /* & 077 */
-
-        return (hash & 077);
-}
-
-#else /* original code */
-
-inline	u32	xor( u32 a, u32 b )
-{
-	return ( ( a && ! b ) || ( ! a && b ) );
-}
-#define XOR8( a, b, c, d, e, f, g, h )	xor( a, xor( b, xor( c, xor( d, xor( e, xor( f, xor( g, h ) ) ) ) ) ) )
-#define DA( a, bit )					( ( (u8) a[bit/8] ) & ( (u8) ( 1 << bit%8 ) ) )
-
-inline u32 TLan_HashFunc( u8 *a )
-{
-	u32	hash;
-
-	hash  = XOR8( DA(a,0), DA(a, 6), DA(a,12), DA(a,18), DA(a,24), DA(a,30), DA(a,36), DA(a,42) );
-	hash |= XOR8( DA(a,1), DA(a, 7), DA(a,13), DA(a,19), DA(a,25), DA(a,31), DA(a,37), DA(a,43) ) << 1;
-	hash |= XOR8( DA(a,2), DA(a, 8), DA(a,14), DA(a,20), DA(a,26), DA(a,32), DA(a,38), DA(a,44) ) << 2;
-	hash |= XOR8( DA(a,3), DA(a, 9), DA(a,15), DA(a,21), DA(a,27), DA(a,33), DA(a,39), DA(a,45) ) << 3;
-	hash |= XOR8( DA(a,4), DA(a,10), DA(a,16), DA(a,22), DA(a,28), DA(a,34), DA(a,40), DA(a,46) ) << 4;
-	hash |= XOR8( DA(a,5), DA(a,11), DA(a,17), DA(a,23), DA(a,29), DA(a,35), DA(a,41), DA(a,47) ) << 5;
-
-	return hash;
-
-} 
-
-#endif /* I_LIKE_A_FAST_HASH_FUNCTION */
-#endif
-/*******************************************************************************
- *
- *  Linux ThunderLAN Driver
- *
- *  tlan.c
- *  by James Banks
- *
- *  (C) 1997-1998 Caldera, Inc.
- *  (C) 1998 James Banks
- *  (C) 1999-2001 Torben Mathiasen
- *
- *  This software may be used and distributed according to the terms
- *  of the GNU General Public License, incorporated herein by reference.
- *
- ** This file is best viewed/edited with columns>=132.
- *
- ** Useful (if not required) reading:
- *
- *		Texas Instruments, ThunderLAN Programmer's Guide,
- *			TI Literature Number SPWU013A
- *			available in PDF format from www.ti.com
- *		Level One, LXT901 and LXT970 Data Sheets
- *			available in PDF format from www.level1.com
- *		National Semiconductor, DP83840A Data Sheet
- *			available in PDF format from www.national.com
- *		Microchip Technology, 24C01A/02A/04A Data Sheet
- *			available in PDF format from www.microchip.com
- *
- * Change History
- *
- *	Tigran Aivazian <tigran@sco.com>:	TLan_PciProbe() now uses
- *						new PCI BIOS interface.
- *	Alan Cox	<alan@redhat.com>:	Fixed the out of memory
- *						handling.
- *      
- *	Torben Mathiasen <torben.mathiasen@compaq.com> New Maintainer!
- *
- *	v1.1 Dec 20, 1999    - Removed linux version checking
- *			       Patch from Tigran Aivazian. 
- *			     - v1.1 includes Alan's SMP updates.
- *			     - We still have problems on SMP though,
- *			       but I'm looking into that. 
- *			
- *	v1.2 Jan 02, 2000    - Hopefully fixed the SMP deadlock.
- *			     - Removed dependency of HZ being 100.
- *			     - We now allow higher priority timers to 
- *			       overwrite timers like TLAN_TIMER_ACTIVITY
- *			       Patch from John Cagle <john.cagle@compaq.com>.
- *			     - Fixed a few compiler warnings.
- *
- *	v1.3 Feb 04, 2000    - Fixed the remaining HZ issues.
- *			     - Removed call to pci_present(). 
- *			     - Removed SA_INTERRUPT flag from irq handler.
- *			     - Added __init and __initdata to reduce resisdent 
- *			       code size.
- *			     - Driver now uses module_init/module_exit.
- *			     - Rewrote init_module and tlan_probe to
- *			       share a lot more code. We now use tlan_probe
- *			       with builtin and module driver.
- *			     - Driver ported to new net API. 
- *			     - tlan.txt has been reworked to reflect current 
- *			       driver (almost)
- *			     - Other minor stuff
- *
- *	v1.4 Feb 10, 2000    - Updated with more changes required after Dave's
- *	                       network cleanup in 2.3.43pre7 (Tigran & myself)
- *	                     - Minor stuff.
- *
- *	v1.5 March 22, 2000  - Fixed another timer bug that would hang the driver
- *			       if no cable/link were present.
- *			     - Cosmetic changes.
- *			     - TODO: Port completely to new PCI/DMA API
- *			     	     Auto-Neg fallback.
- *
- * 	v1.6 April 04, 2000  - Fixed driver support for kernel-parameters. Haven't
- * 			       tested it though, as the kernel support is currently 
- * 			       broken (2.3.99p4p3).
- * 			     - Updated tlan.txt accordingly.
- * 			     - Adjusted minimum/maximum frame length.
- * 			     - There is now a TLAN website up at 
- * 			       http://tlan.kernel.dk
- *
- * 	v1.7 April 07, 2000  - Started to implement custom ioctls. Driver now
- * 			       reports PHY information when used with Donald
- * 			       Beckers userspace MII diagnostics utility.
- *
- * 	v1.8 April 23, 2000  - Fixed support for forced speed/duplex settings.
- * 			     - Added link information to Auto-Neg and forced
- * 			       modes. When NIC operates with auto-neg the driver
- * 			       will report Link speed & duplex modes as well as
- * 			       link partner abilities. When forced link is used,
- * 			       the driver will report status of the established
- * 			       link.
- * 			       Please read tlan.txt for additional information. 
- * 			     - Removed call to check_region(), and used 
- * 			       return value of request_region() instead.
- *	
- *	v1.8a May 28, 2000   - Minor updates.
- *
- *	v1.9 July 25, 2000   - Fixed a few remaining Full-Duplex issues.
- *	                     - Updated with timer fixes from Andrew Morton.
- *	                     - Fixed module race in TLan_Open.
- *	                     - Added routine to monitor PHY status.
- *	                     - Added activity led support for Proliant devices.
- *
- *	v1.10 Aug 30, 2000   - Added support for EISA based tlan controllers 
- *			       like the Compaq NetFlex3/E. 
- *			     - Rewrote tlan_probe to better handle multiple
- *			       bus probes. Probing and device setup is now
- *			       done through TLan_Probe and TLan_init_one. Actual
- *			       hardware probe is done with kernel API and 
- *			       TLan_EisaProbe.
- *			     - Adjusted debug information for probing.
- *			     - Fixed bug that would cause general debug information 
- *			       to be printed after driver removal. 
- *			     - Added transmit timeout handling.
- *			     - Fixed OOM return values in tlan_probe. 
- *			     - Fixed possible mem leak in tlan_exit 
- *			       (now tlan_remove_one).
- *			     - Fixed timer bug in TLan_phyMonitor.
- *			     - This driver version is alpha quality, please
- *			       send me any bug issues you may encounter.
- *
- *	v1.11 Aug 31, 2000   - Do not try to register irq 0 if no irq line was 
- *			       set for EISA cards.
- *			     - Added support for NetFlex3/E with nibble-rate
- *			       10Base-T PHY. This is untestet as I haven't got
- *			       one of these cards.
- *			     - Fixed timer being added twice.
- *			     - Disabled PhyMonitoring by default as this is
- *			       work in progress. Define MONITOR to enable it.
- *			     - Now we don't display link info with PHYs that
- *			       doesn't support it (level1).
- *			     - Incresed tx_timeout beacuse of auto-neg.
- *			     - Adjusted timers for forced speeds.
- *
- *	v1.12 Oct 12, 2000   - Minor fixes (memleak, init, etc.)
- *
- * 	v1.13 Nov 28, 2000   - Stop flooding console with auto-neg issues
- * 			       when link can't be established.
- *			     - Added the bbuf option as a kernel parameter.
- *			     - Fixed ioaddr probe bug.
- *			     - Fixed stupid deadlock with MII interrupts.
- *			     - Added support for speed/duplex selection with 
- *			       multiple nics.
- *			     - Added partly fix for TX Channel lockup with
- *			       TLAN v1.0 silicon. This needs to be investigated
- *			       further.
- *
- * 	v1.14 Dec 16, 2000   - Added support for servicing multiple frames per.
- * 			       interrupt. Thanks goes to
- * 			       Adam Keys <adam@ti.com>
- * 			       Denis Beaudoin <dbeaudoin@ti.com>
- * 			       for providing the patch.
- * 			     - Fixed auto-neg output when using multiple
- * 			       adapters.
- * 			     - Converted to use new taskq interface.
- *
- * 	v1.14a Jan 6, 2001   - Minor adjustments (spinlocks, etc.)
- *
- *******************************************************************************/
-
-                                                                                
-#include <linux/module.h>
-
-#include "tlan.h"
-
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/pci.h>
-#include <linux/etherdevice.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include <linux/mii.h>
-
-typedef u32 (TLanIntVectorFunc)( struct net_device *, u16 );
-
-/* For removing EISA devices */
-static	struct net_device	*TLan_Eisa_Devices;
-
-static	int		TLanDevicesInstalled;
-
-/* Set speed, duplex and aui settings */
-static  int aui[MAX_TLAN_BOARDS];
-static  int duplex[MAX_TLAN_BOARDS];
-static  int speed[MAX_TLAN_BOARDS];
-static  int boards_found;
-
-MODULE_AUTHOR("Maintainer: Torben Mathiasen <torben.mathiasen@compaq.com>");
-MODULE_DESCRIPTION("Driver for TI ThunderLAN based ethernet PCI adapters");
-MODULE_LICENSE("GPL");
-
-MODULE_PARM(aui, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
-MODULE_PARM(duplex, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
-MODULE_PARM(speed, "1-" __MODULE_STRING(MAX_TLAN_BOARDS) "i");
-MODULE_PARM(debug, "i");
-MODULE_PARM(bbuf, "i");
-MODULE_PARM_DESC(aui, "ThunderLAN use AUI port(s) (0-1)");
-MODULE_PARM_DESC(duplex, "ThunderLAN duplex setting(s) (0-default, 1-half, 2-full)");
-MODULE_PARM_DESC(speed, "ThunderLAN port speen setting(s) (0,10,100)");
-MODULE_PARM_DESC(debug, "ThunderLAN debug mask");
-MODULE_PARM_DESC(bbuf, "ThunderLAN use big buffer (0-1)");
-EXPORT_NO_SYMBOLS;
-
-/* Define this to enable Link beat monitoring */
-#undef MONITOR
-
-/* Turn on debugging. See linux/Documentation/networking/tlan.txt for details */
-static  int		debug;
-
-static	int		bbuf;
-static	u8		*TLanPadBuffer;
-static	char		TLanSignature[] = "TLAN";
-static const char tlan_banner[] = "ThunderLAN driver v1.14a\n";
-static int tlan_have_pci;
-static int tlan_have_eisa;
-
-const char *media[] = {
-	"10BaseT-HD ", "10BaseT-FD ","100baseTx-HD ", 
-	"100baseTx-FD", "100baseT4", 0
-};
-
-int media_map[] = { 0x0020, 0x0040, 0x0080, 0x0100, 0x0200,};
-
-static struct board {
-	const char	*deviceLabel;
-	u32	   	flags;
-	u16	   	addrOfs;
-} board_info[] __devinitdata = {
-	{ "Compaq Netelligent 10 T PCI UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Netelligent 10/100 TX PCI UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Integrated NetFlex-3/P", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq NetFlex-3/P", TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },
-	{ "Compaq NetFlex-3/P", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq Netelligent Integrated 10/100 TX UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Netelligent Dual 10/100 TX PCI UTP", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq Netelligent 10/100 TX Embedded UTP", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Olicom OC-2183/2185", TLAN_ADAPTER_USE_INTERN_10, 0x83 },
-	{ "Olicom OC-2325", TLAN_ADAPTER_UNMANAGED_PHY, 0xF8 },
-	{ "Olicom OC-2326", TLAN_ADAPTER_USE_INTERN_10, 0xF8 },
-	{ "Compaq Netelligent 10/100 TX UTP", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },
-	{ "Compaq Netelligent 10 T/2 PCI UTP/Coax", TLAN_ADAPTER_NONE, 0x83 },
-	{ "Compaq NetFlex-3/E", TLAN_ADAPTER_ACTIVITY_LED | 	/* EISA card */
-	                        TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },	
-	{ "Compaq NetFlex-3/E", TLAN_ADAPTER_ACTIVITY_LED, 0x83 }, /* EISA card */
-};
-
-static struct pci_device_id tlan_pci_tbl[] __devinitdata = {
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL10,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3I,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_THUNDER,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3B,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100PI,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100D,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 6 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100I,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 7 },
-	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2183,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8 },
-	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2325,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 9 },
-	{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2326,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 10 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 11 },
-	{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_T2,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 12 },
-	{ 0,}
-};
-MODULE_DEVICE_TABLE(pci, tlan_pci_tbl);		
-
-static void	TLan_EisaProbe( void );
-static void	TLan_Eisa_Cleanup( void );
-static int      TLan_Init( struct net_device * );
-static int	TLan_Open( struct net_device *dev );
-static int	TLan_StartTx( struct sk_buff *, struct net_device *);
-static void	TLan_HandleInterrupt( int, void *, struct pt_regs *);
-static int	TLan_Close( struct net_device *);
-static struct	net_device_stats *TLan_GetStats( struct net_device *);
-static void	TLan_SetMulticastList( struct net_device *);
-static int	TLan_ioctl( struct net_device *dev, struct ifreq *rq, int cmd);
-static int      TLan_probe1( struct pci_dev *pdev, long ioaddr, int irq, int rev, const struct pci_device_id *ent);
-static void	TLan_tx_timeout( struct net_device *dev);
-static int 	tlan_init_one( struct pci_dev *pdev, const struct pci_device_id *ent);
-
-static u32	TLan_HandleInvalid( struct net_device *, u16 );
-static u32	TLan_HandleTxEOF( struct net_device *, u16 );
-static u32	TLan_HandleStatOverflow( struct net_device *, u16 );
-static u32	TLan_HandleRxEOF( struct net_device *, u16 );
-static u32	TLan_HandleDummy( struct net_device *, u16 );
-static u32	TLan_HandleTxEOC( struct net_device *, u16 );
-static u32	TLan_HandleStatusCheck( struct net_device *, u16 );
-static u32	TLan_HandleRxEOC( struct net_device *, u16 );
-
-static void	TLan_Timer( unsigned long );
-
-static void	TLan_ResetLists( struct net_device * );
-static void	TLan_FreeLists( struct net_device * );
-static void	TLan_PrintDio( u16 );
-static void	TLan_PrintList( TLanList *, char *, int );
-static void	TLan_ReadAndClearStats( struct net_device *, int );
-static void	TLan_ResetAdapter( struct net_device * );
-static void	TLan_FinishReset( struct net_device * );
-static void	TLan_SetMac( struct net_device *, int areg, char *mac );
-
-static void	TLan_PhyPrint( struct net_device * );
-static void	TLan_PhyDetect( struct net_device * );
-static void	TLan_PhyPowerDown( struct net_device * );
-static void	TLan_PhyPowerUp( struct net_device * );
-static void	TLan_PhyReset( struct net_device * );
-static void	TLan_PhyStartLink( struct net_device * );
-static void	TLan_PhyFinishAutoNeg( struct net_device * );
-#ifdef MONITOR
-static void     TLan_PhyMonitor( struct net_device * );
-#endif
-
-/*
-static int	TLan_PhyNop( struct net_device * );
-static int	TLan_PhyInternalCheck( struct net_device * );
-static int	TLan_PhyInternalService( struct net_device * );
-static int	TLan_PhyDp83840aCheck( struct net_device * );
-*/
-
-static int	TLan_MiiReadReg( struct net_device *, u16, u16, u16 * );
-static void	TLan_MiiSendData( u16, u32, unsigned );
-static void	TLan_MiiSync( u16 );
-static void	TLan_MiiWriteReg( struct net_device *, u16, u16, u16 );
-
-static void	TLan_EeSendStart( u16 );
-static int	TLan_EeSendByte( u16, u8, int );
-static void	TLan_EeReceiveByte( u16, u8 *, int );
-static int	TLan_EeReadByte( struct net_device *, u8, u8 * );
-
-static TLanIntVectorFunc *TLanIntVector[TLAN_INT_NUMBER_OF_INTS] = {
-	TLan_HandleInvalid,
-	TLan_HandleTxEOF,
-	TLan_HandleStatOverflow,
-	TLan_HandleRxEOF,
-	TLan_HandleDummy,
-	TLan_HandleTxEOC,
-	TLan_HandleStatusCheck,
-	TLan_HandleRxEOC
-};
-
-static inline void
-TLan_SetTimer( struct net_device *dev, u32 ticks, u32 type )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	unsigned long flags = 0;
-	
-	if (!in_irq())
-		spin_lock_irqsave(&priv->lock, flags);
-	if ( priv->timer.function != NULL &&
-		priv->timerType != TLAN_TIMER_ACTIVITY ) { 
-		if (!in_irq())
-			spin_unlock_irqrestore(&priv->lock, flags);
-		return;
-	}
-	priv->timer.function = &TLan_Timer;
-	if (!in_irq())
-		spin_unlock_irqrestore(&priv->lock, flags);
-
-	priv->timer.data = (unsigned long) dev;
-	priv->timerSetAt = jiffies;
-	priv->timerType = type;
-	mod_timer(&priv->timer, jiffies + ticks);
-	
-} /* TLan_SetTimer */
-
-/*****************************************************************************
-******************************************************************************
-
-	ThunderLAN Driver Primary Functions
-
-	These functions are more or less common to all Linux network drivers.
-
-******************************************************************************
-*****************************************************************************/
-
 	/***************************************************************
-	 *	tlan_remove_one
+	 *	TLan_SetMac
 	 *
 	 *	Returns:
 	 *		Nothing
 	 *	Parms:
-	 *		None
+	 *		dev	Pointer to device structure of adapter
+	 *			on which to change the AREG.
+	 *		areg	The AREG to set the address in (0 - 3).
+	 *		mac	A pointer to an array of chars.  Each
+	 *			element stores one byte of the address.
+	 *			IE, it isn't in ascii.
 	 *
-	 *	Goes through the TLanDevices list and frees the device
-	 *	structs and memory associated with each device (lists
-	 *	and buffers).  It also ureserves the IO port regions
-	 *	associated with this device.
+	 *	This function transfers a MAC address to one of the
+	 *	TLAN AREGs (address registers).  The TLAN chip locks
+	 *	the register on writing to offset 0 and unlocks the
+	 *	register after writing to offset 5.  If NULL is passed
+	 *	in mac, then the AREG is filled with 0's.
 	 *
 	 **************************************************************/
 
-static void __devexit tlan_remove_one( struct pci_dev *pdev)
+void TLan_SetMac(struct nic *nic __unused, int areg, char *mac)
 {
-	struct net_device *dev = pci_get_drvdata( pdev );
-	TLanPrivateInfo	*priv = dev->priv;
-	
-	unregister_netdev( dev );
+	int i;
 
-	if ( priv->dmaStorage ) {
-		kfree( priv->dmaStorage );
-	}
+	areg *= 6;
 
-	release_region( dev->base_addr, 0x10 );
-	
-	kfree( dev );
-		
-	pci_set_drvdata( pdev, NULL );
-} 
-
-static struct pci_driver tlan_driver = {
-	name:		"tlan",
-	id_table:	tlan_pci_tbl,
-	probe:		tlan_init_one,
-	remove:		tlan_remove_one,	
-};
-
-static int __init tlan_probe(void)
-{
-	static int	pad_allocated;
-	
-	printk(KERN_INFO "%s", tlan_banner);
-	
-	TLanPadBuffer = (u8 *) kmalloc(TLAN_MIN_FRAME_SIZE, 
-					GFP_KERNEL);
-
-	if (TLanPadBuffer == NULL) {
-		printk(KERN_ERR "TLAN: Could not allocate memory for pad buffer.\n");
-		return -ENOMEM;
-	}
-
-	memset(TLanPadBuffer, 0, TLAN_MIN_FRAME_SIZE);
-	pad_allocated = 1;
-
-	TLAN_DBG(TLAN_DEBUG_PROBE, "Starting PCI Probe....\n");
-	
-	/* Use new style PCI probing. Now the kernel will
-	   do most of this for us */
-	pci_register_driver(&tlan_driver);
-
-	TLAN_DBG(TLAN_DEBUG_PROBE, "Starting EISA Probe....\n");
-	TLan_EisaProbe();
-		
-	printk(KERN_INFO "TLAN: %d device%s installed, PCI: %d  EISA: %d\n", 
-		 TLanDevicesInstalled, TLanDevicesInstalled == 1 ? "" : "s",
-		 tlan_have_pci, tlan_have_eisa);
-
-	if (TLanDevicesInstalled == 0) {
-		pci_unregister_driver(&tlan_driver);
-		kfree(TLanPadBuffer);
-		return -ENODEV;
-	}
-	return 0;
-}
-	
-
-static int __devinit tlan_init_one( struct pci_dev *pdev,
-				    const struct pci_device_id *ent)
-{
-	return TLan_probe1( pdev, -1, -1, 0, ent);
-}
-
-/*
-	***************************************************************
-	 *	tlan_probe1
-	 *
-	 *	Returns:
-	 *		0 on success, error code on error
-	 *	Parms: 
-	 *		none
-	 *
-	 *	The name is lower case to fit in with all the rest of
-	 *	the netcard_probe names.  This function looks for 
-	 *	another TLan based adapter, setting it up with the
-	 *	allocated device struct if one is found.
-	 *	tlan_probe has been ported to the new net API and
-	 *	now allocates its own device structure. This function
-	 *	is also used by modules.
-	 *
-	 **************************************************************/
-
-static int __devinit TLan_probe1(struct pci_dev *pdev, 
-				long ioaddr, int irq, int rev, const struct pci_device_id *ent )
-{
-
-	struct net_device  *dev;
-	TLanPrivateInfo    *priv;
-	u8		   pci_rev;
-	u16		   device_id;
-	int		   reg;
-
-	if (pdev && pci_enable_device(pdev))
-		return -EIO;
-
-	dev = init_etherdev(NULL, sizeof(TLanPrivateInfo));
-	if (dev == NULL) {
-		printk(KERN_ERR "TLAN: Could not allocate memory for device.\n");
-		return -ENOMEM;
-	}
-	SET_MODULE_OWNER(dev);
-	
-	priv = dev->priv;
-
-	/* Is this a PCI device? */
-	if (pdev) {
-		u32 		   pci_io_base = 0;
-
-		priv->adapter = &board_info[ent->driver_data];
-
-		pci_read_config_byte ( pdev, PCI_REVISION_ID, &pci_rev);
-
-		for ( reg= 0; reg <= 5; reg ++ ) {
-			if (pci_resource_flags(pdev, reg) & IORESOURCE_IO) {
-				pci_io_base = pci_resource_start(pdev, reg);
-				TLAN_DBG( TLAN_DEBUG_GNRL, "IO mapping is available at %x.\n",
-						pci_io_base);
-				break;
-			}
-		}
-		if (!pci_io_base) {
-			printk(KERN_ERR "TLAN: No IO mappings available\n");
-			unregister_netdev(dev);
-			kfree(dev);
-			return -ENODEV;
-		}
-		
-		dev->base_addr = pci_io_base;
-		dev->irq = pdev->irq;
-		priv->adapterRev = pci_rev; 
-		pci_set_master(pdev);
-		pci_set_drvdata(pdev, dev);
-
-	} else	{     /* EISA card */
-		/* This is a hack. We need to know which board structure
-		 * is suited for this adapter */
-		device_id = inw(ioaddr + EISA_ID2);
-		priv->is_eisa = 1;
-		if (device_id == 0x20F1) {
-			priv->adapter = &board_info[13]; 	/* NetFlex-3/E */
-			priv->adapterRev = 23;			/* TLAN 2.3 */
-		} else {
-			priv->adapter = &board_info[14];
-			priv->adapterRev = 10;			/* TLAN 1.0 */
-		}
-		dev->base_addr = ioaddr;
-		dev->irq = irq;
-	}
-
-	/* Kernel parameters */
-	if (dev->mem_start) {
-		priv->aui    = dev->mem_start & 0x01;
-		priv->duplex = ((dev->mem_start & 0x06) == 0x06) ? 0 : (dev->mem_start & 0x06) >> 1;
-		priv->speed  = ((dev->mem_start & 0x18) == 0x18) ? 0 : (dev->mem_start & 0x18) >> 3;
-	
-		if (priv->speed == 0x1) {
-			priv->speed = TLAN_SPEED_10;
-		} else if (priv->speed == 0x2) {
-			priv->speed = TLAN_SPEED_100;
-		}
-		debug = priv->debug = dev->mem_end;
+	if (mac != NULL) {
+		for (i = 0; i < 6; i++)
+			TLan_DioWrite8(BASE, TLAN_AREG_0 + areg + i,
+				       mac[i]);
 	} else {
-		priv->aui    = aui[boards_found];
-		priv->speed  = speed[boards_found];
-		priv->duplex = duplex[boards_found];
-		priv->debug = debug;
+		for (i = 0; i < 6; i++)
+			TLan_DioWrite8(BASE, TLAN_AREG_0 + areg + i, 0);
 	}
-	
-	/* This will be used when we get an adapter error from
-	 * within our irq handler */
-	INIT_LIST_HEAD(&priv->tlan_tqueue.list);
-	priv->tlan_tqueue.sync = 0;
-	priv->tlan_tqueue.routine = (void *)(void*)TLan_tx_timeout;
-	priv->tlan_tqueue.data = dev;
 
-	spin_lock_init(&priv->lock);
-	
-	if (TLan_Init(dev)) {
-		printk(KERN_ERR "TLAN: Could not register device.\n");
-		unregister_netdev(dev);
-		kfree(dev);
-		return -EAGAIN;
-	} else {
-	
-	TLanDevicesInstalled++;
-	boards_found++;
-	
-	/* pdev is NULL if this is an EISA device */
-	if (pdev)
-		tlan_have_pci++;
-	else {
-		priv->nextDevice = TLan_Eisa_Devices;
-		TLan_Eisa_Devices = dev;
-		tlan_have_eisa++;
-	}
-	
-	printk(KERN_INFO "TLAN: %s irq=%2d, io=%04x, %s, Rev. %d\n",
-			dev->name,
-			(int) dev->irq,
-			(int) dev->base_addr,
-			priv->adapter->deviceLabel,
-			priv->adapterRev);
-	return 0;
-	}
+}				/* TLan_SetMac */
 
-}
-
-static void TLan_Eisa_Cleanup(void)
-{
-	struct net_device *dev;
-	TLanPrivateInfo *priv;
-	
-	while( tlan_have_eisa ) {
-		dev = TLan_Eisa_Devices;
-		priv = dev->priv;
-		if (priv->dmaStorage) {
-			kfree(priv->dmaStorage);
-		}
-		release_region( dev->base_addr, 0x10);
-		unregister_netdev( dev );
-		TLan_Eisa_Devices = priv->nextDevice;
-		kfree( dev );
-		tlan_have_eisa--;
-	}
-}
-	
-		
-static void __exit tlan_exit(void)
-{
-	pci_unregister_driver(&tlan_driver);
-
-	if (tlan_have_eisa)
-		TLan_Eisa_Cleanup();
-
-	kfree( TLanPadBuffer );
-
-}
-
-/* Module loading/unloading */
-module_init(tlan_probe);
-module_exit(tlan_exit);
-
-	/**************************************************************
-	 * 	TLan_EisaProbe
+	/*********************************************************************
+	 *	TLan_PhyDetect
 	 *
-	 *  	Returns: 0 on success, 1 otherwise
-	 *
-	 *  	Parms:	 None
-	 *
-	 *
-	 *  	This functions probes for EISA devices and calls 
-	 *  	TLan_probe1 when one is found. 
-	 *
-	 *************************************************************/
-
-static void  __init TLan_EisaProbe (void) 
-{
-	long 	ioaddr;
-	int 	rc = -ENODEV;
-	int 	irq;
-	u16	device_id;
-
-	if (!EISA_bus) {	
-		TLAN_DBG(TLAN_DEBUG_PROBE, "No EISA bus present\n");
-		return;
-	}
-	
-	/* Loop through all slots of the EISA bus */
-	for (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {
-		
-	TLAN_DBG(TLAN_DEBUG_PROBE,"EISA_ID 0x%4x: 0x%4x\n", (int) ioaddr + 0xC80, inw(ioaddr + EISA_ID));	
-	TLAN_DBG(TLAN_DEBUG_PROBE,"EISA_ID 0x%4x: 0x%4x\n", (int) ioaddr + 0xC82, inw(ioaddr + EISA_ID2));
-
-		TLAN_DBG(TLAN_DEBUG_PROBE, "Probing for EISA adapter at IO: 0x%4x : ",
-				   	(int) ioaddr);
-		if (request_region(ioaddr, 0x10, TLanSignature) == NULL) 
-			goto out;
-
-		if (inw(ioaddr + EISA_ID) != 0x110E) {		
-			release_region(ioaddr, 0x10);
-			goto out;
-		}
-		
-		device_id = inw(ioaddr + EISA_ID2);
-		if (device_id !=  0x20F1 && device_id != 0x40F1) { 		
-			release_region (ioaddr, 0x10);
-			goto out;
-		}
-		
-	 	if (inb(ioaddr + EISA_CR) != 0x1) { 	/* Check if adapter is enabled */
-			release_region (ioaddr, 0x10);
-			goto out2;
-		}
-		
-		if (debug == 0x10)		
-			printk("Found one\n");
-
-		/* Get irq from board */
-		switch (inb(ioaddr + 0xCC0)) {
-			case(0x10):
-				irq=5;
-				break;
-			case(0x20):
-				irq=9;
-				break;
-			case(0x40):
-				irq=10;
-				break;
-			case(0x80):
-				irq=11;
-				break;
-			default:
-				goto out;
-		}               
-		
-		
-		/* Setup the newly found eisa adapter */
-		rc = TLan_probe1( NULL, ioaddr, irq,
-					12, NULL);
-		continue;
-		
-		out:
-			if (debug == 0x10)
-				printk("None found\n");
-			continue;
-
-		out2:	if (debug == 0x10)
-				printk("Card found but it is not enabled, skipping\n");
-			continue;
-		
-	}
-
-} /* TLan_EisaProbe */
-
-	
-
-	/***************************************************************
-	 *	TLan_Init
-	 *
 	 *	Returns:
-	 *		0 on success, error code otherwise.
+	 *		Nothing
 	 *	Parms:
-	 *		dev	The structure of the device to be
-	 *			init'ed.
+	 *		dev	A pointer to the device structure of the adapter
+	 *			for which the PHY needs determined.
 	 *
-	 *	This function completes the initialization of the
-	 *	device structure and driver.  It reserves the IO
-	 *	addresses, allocates memory for the lists and bounce
-	 *	buffers, retrieves the MAC address from the eeprom
-	 *	and assignes the device's methods.
-	 *	
-	 **************************************************************/
-
-static int TLan_Init( struct net_device *dev )
-{
-	int		dma_size;
-	int 		err;
-	int		i;
-	TLanPrivateInfo	*priv;
-
-	priv = dev->priv;
-	
-	if (!priv->is_eisa)	/* EISA devices have already requested IO */
-		if (!request_region( dev->base_addr, 0x10, TLanSignature )) {
-			printk(KERN_ERR "TLAN: %s: IO port region 0x%lx size 0x%x in use.\n",
-				dev->name,
-				dev->base_addr,
-				0x10 );
-			return -EIO;
-		}
-	
-	if ( bbuf ) {
-		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
-	           * ( sizeof(TLanList) + TLAN_MAX_FRAME_SIZE );
-	} else {
-		dma_size = ( TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS )
-	           * ( sizeof(TLanList) );
-	}
-	priv->dmaStorage = kmalloc(dma_size, GFP_KERNEL | GFP_DMA);
-	if ( priv->dmaStorage == NULL ) {
-		printk(KERN_ERR "TLAN:  Could not allocate lists and buffers for %s.\n",
-			dev->name );
-		release_region( dev->base_addr, 0x10 );
-		return -ENOMEM;
-	}
-	memset( priv->dmaStorage, 0, dma_size );
-	priv->rxList = (TLanList *) 
-		       ( ( ( (u32) priv->dmaStorage ) + 7 ) & 0xFFFFFFF8 );
-	priv->txList = priv->rxList + TLAN_NUM_RX_LISTS;
-	if ( bbuf ) {
-		priv->rxBuffer = (u8 *) ( priv->txList + TLAN_NUM_TX_LISTS );
-		priv->txBuffer = priv->rxBuffer
-				 + ( TLAN_NUM_RX_LISTS * TLAN_MAX_FRAME_SIZE );
-	}
-
-	err = 0;
-	for ( i = 0;  i < 6 ; i++ )
-		err |= TLan_EeReadByte( dev,
-					(u8) priv->adapter->addrOfs + i,
-					(u8 *) &dev->dev_addr[i] );
-	if ( err ) {
-		printk(KERN_ERR "TLAN: %s: Error reading MAC from eeprom: %d\n",
-			dev->name,
-			err );
-	}
-	dev->addr_len = 6;
-	
-	/* Device methods */
-	dev->open = &TLan_Open;
-	dev->hard_start_xmit = &TLan_StartTx;
-	dev->stop = &TLan_Close;
-	dev->get_stats = &TLan_GetStats;
-	dev->set_multicast_list = &TLan_SetMulticastList;
-	dev->do_ioctl = &TLan_ioctl;
-	dev->tx_timeout = &TLan_tx_timeout;
-	dev->watchdog_timeo = TX_TIMEOUT;
-
-	return 0;
-
-} /* TLan_Init */
-
-	/***************************************************************
-	 *	TLan_Open
+	 *	So far I've found that adapters which have external PHYs
+	 *	may also use the internal PHY for part of the functionality.
+	 *	(eg, AUI/Thinnet).  This function finds out if this TLAN
+	 *	chip has an internal PHY, and then finds the first external
+	 *	PHY (starting from address 0) if it exists).
 	 *
-	 *	Returns:
-	 *		0 on success, error code otherwise.
-	 *	Parms:
-	 *		dev	Structure of device to be opened.
-	 *
-	 *	This routine puts the driver and TLAN adapter in a
-	 *	state where it is ready to send and receive packets.
-	 *	It allocates the IRQ, resets and brings the adapter
-	 *	out of reset, and allows interrupts.  It also delays
-	 *	the startup for autonegotiation or sends a Rx GO
-	 *	command to the adapter, as appropriate.
-	 *
-	 **************************************************************/
+	 ********************************************************************/
 
-static int TLan_Open( struct net_device *dev )
+void TLan_PhyDetect(struct nic *nic)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	int		err;
-	
-	priv->tlanRev = TLan_DioRead8( dev->base_addr, TLAN_DEF_REVISION );
-	err = request_irq( dev->irq, TLan_HandleInterrupt, SA_SHIRQ, TLanSignature, dev );
-	
-	if ( err ) {
-		printk(KERN_ERR "TLAN:  Cannot open %s because IRQ %d is already in use.\n", dev->name, dev->irq );
-		return err;
-	}
-	
-	init_timer(&priv->timer);
-	netif_start_queue(dev);
-	
-	/* NOTE: It might not be necessary to read the stats before a
-			 reset if you don't care what the values are.
-	*/
-	TLan_ResetLists( dev );
-	TLan_ReadAndClearStats( dev, TLAN_IGNORE );
-	TLan_ResetAdapter( dev );
+	u16 control;
+	u16 hi;
+	u16 lo;
+	u32 phy;
 
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Opened.  TLAN Chip Rev: %x\n", dev->name, priv->tlanRev );
-
-	return 0;
-
-} /* TLan_Open */
-
-	/**************************************************************
-	 *	TLan_ioctl
-	 *	
-	 *	Returns:
-	 *		0 on success, error code otherwise
-	 *	Params:
-	 *		dev	structure of device to receive ioctl.
-	 *		
-	 *		rq	ifreq structure to hold userspace data.
-	 *
-	 *		cmd	ioctl command.
-	 *
-	 *
-	 *************************************************************/
-
-static int TLan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	TLanPrivateInfo *priv = dev->priv;
-	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&rq->ifr_data;
-	u32 phy   = priv->phy[priv->phyNum];
-	
-	if (!priv->phyOnline)
-		return -EAGAIN;
-
-	switch(cmd) {
-	case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
-	case SIOCDEVPRIVATE:		/* for binary compat, remove in 2.5 */
-			data->phy_id = phy;
-
-	case SIOCGMIIREG:		/* Read MII PHY register. */
-	case SIOCDEVPRIVATE+1:		/* for binary compat, remove in 2.5 */
-			TLan_MiiReadReg(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, &data->val_out);
-			return 0;
-		
-
-	case SIOCSMIIREG:		/* Write MII PHY register. */
-	case SIOCDEVPRIVATE+2:		/* for binary compat, remove in 2.5 */
-			if (!capable(CAP_NET_ADMIN))
-				return -EPERM;
-			TLan_MiiWriteReg(dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);
-			return 0;
-		default:
-			return -EOPNOTSUPP;
+	if (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_UNMANAGED_PHY) {
+		priv->phyNum = 0xFFFF;
+		return;
 	}
-} /* tlan_ioctl */
 
-	/***************************************************************
-	 * 	TLan_tx_timeout
-	 *
-	 * 	Returns: nothing
-	 *
-	 * 	Params:
-	 * 		dev	structure of device which timed out 
-	 * 			during transmit.
-	 *
-	 **************************************************************/
+	TLan_MiiReadReg(nic, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi);
 
-static void TLan_tx_timeout(struct net_device *dev)
-{
-	
-	TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Transmit timed out.\n", dev->name);
-	
-	/* Ok so we timed out, lets see what we can do about it...*/
-	TLan_FreeLists( dev );
-	TLan_ResetLists( dev );		
-	TLan_ReadAndClearStats( dev, TLAN_IGNORE );
-	TLan_ResetAdapter( dev );
-	dev->trans_start = jiffies;
-	netif_wake_queue( dev );	
-
-}
-	
-
-	/***************************************************************
-	 *	TLan_StartTx
-	 *  
-	 *	Returns:
-	 *		0 on success, non-zero on failure.
-	 *	Parms:
-	 *		skb	A pointer to the sk_buff containing the
-	 *			frame to be sent.
-	 *		dev	The device to send the data on.
-	 *
-	 *	This function adds a frame to the Tx list to be sent
-	 *	ASAP.  First it	verifies that the adapter is ready and
-	 *	there is room in the queue.  Then it sets up the next
-	 *	available list, copies the frame to the	corresponding
-	 *	buffer.  If the adapter Tx channel is idle, it gives
-	 *	the adapter a Tx Go command on the list, otherwise it
-	 *	sets the forward address of the previous list to point
-	 *	to this one.  Then it frees the sk_buff.
-	 *
-	 **************************************************************/
-
-static int TLan_StartTx( struct sk_buff *skb, struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	TLanList	*tail_list;
-	u8		*tail_buffer;
-	int		pad;
-	unsigned long	flags;
-
-	if ( ! priv->phyOnline ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s PHY is not ready\n", dev->name );
-		dev_kfree_skb_any(skb);
-		return 0;
-	}
-
-	tail_list = priv->txList + priv->txTail;
-	
-	if ( tail_list->cStat != TLAN_CSTAT_UNUSED ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s is busy (Head=%d Tail=%d)\n", dev->name, priv->txHead, priv->txTail );
-		netif_stop_queue(dev);
-		priv->txBusyCount++;
-		return 1;
-	}
-
-	tail_list->forward = 0;
-
-	if ( bbuf ) {
-		tail_buffer = priv->txBuffer + ( priv->txTail * TLAN_MAX_FRAME_SIZE );
-		memcpy( tail_buffer, skb->data, skb->len );
+	if (hi != 0xFFFF) {
+		priv->phy[0] = TLAN_PHY_MAX_ADDR;
 	} else {
-		tail_list->buffer[0].address = virt_to_bus( skb->data );
-		tail_list->buffer[9].address = (u32) skb;
+		priv->phy[0] = TLAN_PHY_NONE;
 	}
 
-	pad = TLAN_MIN_FRAME_SIZE - skb->len;
-
-	if ( pad > 0 ) {
-		tail_list->frameSize = (u16) skb->len + pad;
-		tail_list->buffer[0].count = (u32) skb->len;
-		tail_list->buffer[1].count = TLAN_LAST_BUFFER | (u32) pad;
-		tail_list->buffer[1].address = virt_to_bus( TLanPadBuffer );
-	} else {
-		tail_list->frameSize = (u16) skb->len;
-		tail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) skb->len;
-		tail_list->buffer[1].count = 0;
-		tail_list->buffer[1].address = 0;
-	}
-
-	spin_lock_irqsave(&priv->lock, flags);
-	tail_list->cStat = TLAN_CSTAT_READY;
-	if ( ! priv->txInProgress ) {
-		priv->txInProgress = 1;
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Starting TX on buffer %d\n", priv->txTail );
-		outl( virt_to_bus( tail_list ), dev->base_addr + TLAN_CH_PARM );
-		outl( TLAN_HC_GO, dev->base_addr + TLAN_HOST_CMD );
-	} else {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Adding buffer %d to TX channel\n", priv->txTail );
-		if ( priv->txTail == 0 ) {
-			( priv->txList + ( TLAN_NUM_TX_LISTS - 1 ) )->forward = virt_to_bus( tail_list );
-		} else {
-			( priv->txList + ( priv->txTail - 1 ) )->forward = virt_to_bus( tail_list );
+	priv->phy[1] = TLAN_PHY_NONE;
+	for (phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++) {
+		TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &control);
+		TLan_MiiReadReg(nic, phy, MII_GEN_ID_HI, &hi);
+		TLan_MiiReadReg(nic, phy, MII_GEN_ID_LO, &lo);
+		if ((control != 0xFFFF) || (hi != 0xFFFF)
+		    || (lo != 0xFFFF)) {
+			printf("PHY found at %hX %hX %hX %hX\n", phy,
+			       control, hi, lo);
+			if ((priv->phy[1] == TLAN_PHY_NONE)
+			    && (phy != TLAN_PHY_MAX_ADDR)) {
+				priv->phy[1] = phy;
+			}
 		}
 	}
-	spin_unlock_irqrestore(&priv->lock, flags);
 
-	CIRC_INC( priv->txTail, TLAN_NUM_TX_LISTS );
-
-	if ( bbuf )
-		dev_kfree_skb_any(skb);
-		
-	dev->trans_start = jiffies;
-	return 0;
-
-} /* TLan_StartTx */
-
-	/***************************************************************
-	 *	TLan_HandleInterrupt
-	 *  
-	 *	Returns:	
-	 *		Nothing
-	 *	Parms:
-	 *		irq	The line on which the interrupt
-	 *			occurred.
-	 *		dev_id	A pointer to the device assigned to
-	 *			this irq line.
-	 *		regs	???
-	 *
-	 *	This function handles an interrupt generated by its
-	 *	assigned TLAN adapter.  The function deactivates
-	 *	interrupts on its adapter, records the type of
-	 *	interrupt, executes the appropriate subhandler, and
-	 *	acknowdges the interrupt to the adapter (thus
-	 *	re-enabling adapter interrupts.
-	 *
-	 **************************************************************/
-
-static void TLan_HandleInterrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	u32		ack;
-	struct net_device	*dev;
-	u32		host_cmd;
-	u16		host_int;
-	int		type;
-	TLanPrivateInfo *priv;
-
-	dev = dev_id;
-	priv = dev->priv;
-
-	spin_lock(&priv->lock);
-
-	host_int = inw( dev->base_addr + TLAN_HOST_INT );
-	outw( host_int, dev->base_addr + TLAN_HOST_INT );
-
-	type = ( host_int & TLAN_HI_IT_MASK ) >> 2;
-
-	ack = TLanIntVector[type]( dev, host_int );
-
-	if ( ack ) {
-		host_cmd = TLAN_HC_ACK | ack | ( type << 18 );
-		outl( host_cmd, dev->base_addr + TLAN_HOST_CMD );
-	}
-
-	spin_unlock(&priv->lock);
-
-} /* TLan_HandleInterrupts */
-
-	/***************************************************************
-	 *	TLan_Close
-	 *  
-	 * 	Returns:
-	 *		An error code.
-	 *	Parms:
-	 *		dev	The device structure of the device to
-	 *			close.
-	 *
-	 *	This function shuts down the adapter.  It records any
-	 *	stats, puts the adapter into reset state, deactivates
-	 *	its time as needed, and	frees the irq it is using.
-	 *
-	 **************************************************************/
-
-static int TLan_Close(struct net_device *dev)
-{
-	TLanPrivateInfo *priv = dev->priv;
-
-	netif_stop_queue(dev);
-	priv->neg_be_verbose = 0;
-
-	TLan_ReadAndClearStats( dev, TLAN_RECORD );
-	outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
-	if ( priv->timer.function != NULL ) {
-		del_timer_sync( &priv->timer );
-		priv->timer.function = NULL;
-	}
-	
-	free_irq( dev->irq, dev );
-	TLan_FreeLists( dev );
-	TLAN_DBG( TLAN_DEBUG_GNRL, "Device %s closed.\n", dev->name );
-
-	return 0;
-
-} /* TLan_Close */
-
-	/***************************************************************
-	 *	TLan_GetStats
-	 *  
-	 *	Returns:
-	 *		A pointer to the device's statistics structure.
-	 *	Parms:
-	 *		dev	The device structure to return the
-	 *			stats for.
-	 *
-	 *	This function updates the devices statistics by reading
-	 *	the TLAN chip's onboard registers.  Then it returns the
-	 *	address of the statistics structure.
-	 *
-	 **************************************************************/
-
-static struct net_device_stats *TLan_GetStats( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	int i;
-
-	/* Should only read stats if open ? */
-	TLan_ReadAndClearStats( dev, TLAN_RECORD );
-
-	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  %s EOC count = %d\n", dev->name, priv->rxEocCount );
-	TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  %s Busy count = %d\n", dev->name, priv->txBusyCount );
-	if ( debug & TLAN_DEBUG_GNRL ) {
-		TLan_PrintDio( dev->base_addr );
-		TLan_PhyPrint( dev );		
-	}
-	if ( debug & TLAN_DEBUG_LIST ) {
-		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ )
-			TLan_PrintList( priv->rxList + i, "RX", i );
-		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ )
-			TLan_PrintList( priv->txList + i, "TX", i );
-	}
-	
-	return ( &( (TLanPrivateInfo *) dev->priv )->stats );
-
-} /* TLan_GetStats */
-
-	/***************************************************************
-	 *	TLan_SetMulticastList
-	 *  
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	The device structure to set the
-	 *			multicast list for.
-	 *
-	 *	This function sets the TLAN adaptor to various receive
-	 *	modes.  If the IFF_PROMISC flag is set, promiscuous
-	 *	mode is acitviated.  Otherwise,	promiscuous mode is
-	 *	turned off.  If the IFF_ALLMULTI flag is set, then
-	 *	the hash table is set to receive all group addresses.
-	 *	Otherwise, the first three multicast addresses are
-	 *	stored in AREG_1-3, and the rest are selected via the
-	 *	hash table, as necessary.
-	 *
-	 **************************************************************/
-
-static void TLan_SetMulticastList( struct net_device *dev )
-{	
-	struct dev_mc_list	*dmi = dev->mc_list;
-	u32			hash1 = 0;
-	u32			hash2 = 0;
-	int			i;
-	u32			offset;
-	u8			tmp;
-
-	if ( dev->flags & IFF_PROMISC ) {
-		tmp = TLan_DioRead8( dev->base_addr, TLAN_NET_CMD );
-		TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, tmp | TLAN_NET_CMD_CAF );
+	if (priv->phy[1] != TLAN_PHY_NONE) {
+		priv->phyNum = 1;
+	} else if (priv->phy[0] != TLAN_PHY_NONE) {
+		priv->phyNum = 0;
 	} else {
-		tmp = TLan_DioRead8( dev->base_addr, TLAN_NET_CMD );
-		TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF );
-		if ( dev->flags & IFF_ALLMULTI ) {
-			for ( i = 0; i < 3; i++ ) 
-				TLan_SetMac( dev, i + 1, NULL );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_1, 0xFFFFFFFF );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_2, 0xFFFFFFFF );
-		} else {
-			for ( i = 0; i < dev->mc_count; i++ ) {
-				if ( i < 3 ) {
-					TLan_SetMac( dev, i + 1, (char *) &dmi->dmi_addr );
-				} else {
-					offset = TLan_HashFunc( (u8 *) &dmi->dmi_addr );
-					if ( offset < 32 ) 
-						hash1 |= ( 1 << offset );
-					else
-						hash2 |= ( 1 << ( offset - 32 ) );
-				}
-				dmi = dmi->next;
-			}
-			for ( ; i < 3; i++ ) 
-				TLan_SetMac( dev, i + 1, NULL );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_1, hash1 );
-			TLan_DioWrite32( dev->base_addr, TLAN_HASH_2, hash2 );
-		}
+		printf
+		    ("TLAN:  Cannot initialize device, no PHY was found!\n");
 	}
 
-} /* TLan_SetMulticastList */
+}				/* TLan_PhyDetect */
 
-/*****************************************************************************
-******************************************************************************
-
-        ThunderLAN Driver Interrupt Vectors and Table
-
-	Please see Chap. 4, "Interrupt Handling" of the "ThunderLAN
-	Programmer's Guide" for more informations on handling interrupts
-	generated by TLAN based adapters.  
-
-******************************************************************************
-*****************************************************************************/
-
-	/***************************************************************
-	 *	TLan_HandleInvalid
-	 *
-	 *	Returns:
-	 *		0
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles invalid interrupts.  This should
-	 *	never happen unless some other adapter is trying to use
-	 *	the IRQ line assigned to the device.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleInvalid( struct net_device *dev, u16 host_int )
+void TLan_PhyPowerDown(struct nic *nic)
 {
-	/* printk( "TLAN:  Invalid interrupt on %s.\n", dev->name ); */
-	return 0;
 
-} /* TLan_HandleInvalid */
-
-	/***************************************************************
-	 *	TLan_HandleTxEOF
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles Tx EOF interrupts which are raised
-	 *	by the adapter when it has completed sending the
-	 *	contents of a buffer.  If detemines which list/buffer
-	 *	was completed and resets it.  If the buffer was the last
-	 *	in the channel (EOC), then the function checks to see if
-	 *	another buffer is ready to send, and if so, sends a Tx
-	 *	Go command.  Finally, the driver activates/continues the
-	 *	activity LED.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleTxEOF( struct net_device *dev, u16 host_int )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	int		eoc = 0;
-	TLanList	*head_list;
-	u32		ack = 0;
-	u16		tmpCStat;
-	
-	TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOF (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
-	head_list = priv->txList + priv->txHead;
-
-	while (((tmpCStat = head_list->cStat ) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
-		ack++;
-		if ( ! bbuf ) {
-			dev_kfree_skb_any( (struct sk_buff *) head_list->buffer[9].address );
-			head_list->buffer[9].address = 0;
-		}
-	
-		if ( tmpCStat & TLAN_CSTAT_EOC )
-			eoc = 1;
-			
-		priv->stats.tx_bytes += head_list->frameSize;
-
-		head_list->cStat = TLAN_CSTAT_UNUSED;
-		netif_start_queue(dev);		
-		CIRC_INC( priv->txHead, TLAN_NUM_TX_LISTS ); 
-		head_list = priv->txList + priv->txHead;
+	u16 value;
+	printf("%s: Powering down PHY(s).\n", priv->nic_name);
+	value = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;
+	TLan_MiiSync(BASE);
+	TLan_MiiWriteReg(nic, priv->phy[priv->phyNum], MII_GEN_CTL, value);
+	if ((priv->phyNum == 0) && (priv->phy[1] != TLAN_PHY_NONE)
+	    &&
+	    (!(tlan_pci_tbl[chip_idx].
+	       flags & TLAN_ADAPTER_USE_INTERN_10))) {
+		TLan_MiiSync(BASE);
+		TLan_MiiWriteReg(nic, priv->phy[1], MII_GEN_CTL, value);
 	}
 
-	if (!ack)
-		printk(KERN_INFO "TLAN: Received interrupt for uncompleted TX frame.\n");
-	
-	if ( eoc ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d)\n", priv->txHead, priv->txTail );
-		head_list = priv->txList + priv->txHead;
-		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
-			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-			ack |= TLAN_HC_GO;
-		} else {
-			priv->txInProgress = 0;
-		}
-	}
-	
-	if ( priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED ) {
-		TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT );
-		if ( priv->timer.function == NULL ) {
-			 priv->timer.function = &TLan_Timer;
-			 priv->timer.data = (unsigned long) dev;
-			 priv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;
-			 priv->timerSetAt = jiffies;
-			 priv->timerType = TLAN_TIMER_ACTIVITY;
-			 add_timer(&priv->timer);
-		} else if ( priv->timerType == TLAN_TIMER_ACTIVITY ) {
-			priv->timerSetAt = jiffies;
-		}
-	}
+	/* Wait for 50 ms and powerup
+	 * This is abitrary.  It is intended to make sure the
+	 * tranceiver settles.
+	 */
+	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_PUP ); */
+	mdelay(50);
+	TLan_PhyPowerUp(nic);
 
-	return ack;
+}				/* TLan_PhyPowerDown */
 
-} /* TLan_HandleTxEOF */
 
-	/***************************************************************
-	 *	TLan_HandleStatOverflow
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles the Statistics Overflow interrupt
-	 *	which means that one or more of the TLAN statistics
-	 *	registers has reached 1/2 capacity and needs to be read.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleStatOverflow( struct net_device *dev, u16 host_int )
+void TLan_PhyPowerUp(struct nic *nic)
 {
-	TLan_ReadAndClearStats( dev, TLAN_RECORD );
+	u16 value;
 
-	return 1;
+	printf("%s: Powering up PHY.\n", priv->nic_name);
+	TLan_MiiSync(BASE);
+	value = MII_GC_LOOPBK;
+	TLan_MiiWriteReg(nic, priv->phy[priv->phyNum], MII_GEN_CTL, value);
+	TLan_MiiSync(BASE);
+	/* Wait for 500 ms and reset the
+	 * tranceiver.  The TLAN docs say both 50 ms and
+	 * 500 ms, so do the longer, just in case.
+	 */
+	mdelay(500);
+	TLan_PhyReset(nic);
+	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_RESET ); */
 
-} /* TLan_HandleStatOverflow */
+}				/* TLan_PhyPowerUp */
 
-	/***************************************************************
-	 *	TLan_HandleRxEOF
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles the Rx EOF interrupt which
-	 *	indicates a frame has been received by the adapter from
-	 *	the net and the frame has been transferred to memory.
-	 *	The function determines the bounce buffer the frame has
-	 *	been loaded into, creates a new sk_buff big enough to
-	 *	hold the frame, and sends it to protocol stack.  It
-	 *	then resets the used buffer and appends it to the end
-	 *	of the list.  If the frame was the last in the Rx
-	 *	channel (EOC), the function restarts the receive channel
-	 *	by sending an Rx Go command to the adapter.  Then it
-	 *	activates/continues the activity LED.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleRxEOF( struct net_device *dev, u16 host_int )
+void TLan_PhyReset(struct nic *nic)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		ack = 0;
-	int		eoc = 0;
-	u8		*head_buffer;
-	TLanList	*head_list;
-	struct sk_buff	*skb;
-	TLanList	*tail_list;
-	void		*t;
-	u32		frameSize;
-	u16		tmpCStat;
+	u16 phy;
+	u16 value;
 
-	TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOF (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
-	head_list = priv->rxList + priv->rxHead;
-	
-	while (((tmpCStat = head_list->cStat) & TLAN_CSTAT_FRM_CMP) && (ack < 255)) {
-		frameSize = head_list->frameSize;
-		ack++;
-		if (tmpCStat & TLAN_CSTAT_EOC)
-			eoc = 1;
-		
-		if (bbuf) {
-			skb = dev_alloc_skb(frameSize + 7);
-			if (skb == NULL)
-				printk(KERN_INFO "TLAN: Couldn't allocate memory for received data.\n");
-			else {
-				head_buffer = priv->rxBuffer + (priv->rxHead * TLAN_MAX_FRAME_SIZE);
-				skb->dev = dev;
-				skb_reserve(skb, 2);
-				t = (void *) skb_put(skb, frameSize);
-		
-				priv->stats.rx_bytes += head_list->frameSize;
+	phy = priv->phy[priv->phyNum];
 
-				memcpy( t, head_buffer, frameSize );
-				skb->protocol = eth_type_trans( skb, dev );
-				netif_rx( skb );
-			}
-		} else {
-			struct sk_buff *new_skb;
-		
-			/*
-		 	*	I changed the algorithm here. What we now do
-		 	*	is allocate the new frame. If this fails we
-		 	*	simply recycle the frame.
-		 	*/
-		
-			new_skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
-			
-			if ( new_skb != NULL ) {
-				/* If this ever happened it would be a problem */
-				/* not any more - ac */
-				skb = (struct sk_buff *) head_list->buffer[9].address;
-				skb_trim( skb, frameSize );
-
-				priv->stats.rx_bytes += frameSize;
-
-				skb->protocol = eth_type_trans( skb, dev );
-				netif_rx( skb );
-	
-				new_skb->dev = dev;
-				skb_reserve( new_skb, 2 );
-				t = (void *) skb_put( new_skb, TLAN_MAX_FRAME_SIZE );
-				head_list->buffer[0].address = virt_to_bus( t );
-				head_list->buffer[8].address = (u32) t;
-				head_list->buffer[9].address = (u32) new_skb;
-			} else 
-				printk(KERN_WARNING "TLAN:  Couldn't allocate memory for received data.\n" );
-		}
-
-		head_list->forward = 0;
-		head_list->cStat = 0;
-		tail_list = priv->rxList + priv->rxTail;
-		tail_list->forward = virt_to_bus( head_list );
-
-		CIRC_INC( priv->rxHead, TLAN_NUM_RX_LISTS );
-		CIRC_INC( priv->rxTail, TLAN_NUM_RX_LISTS );
-		head_list = priv->rxList + priv->rxHead;
+	printf("%s: Reseting PHY.\n", priv->nic_name);
+	TLan_MiiSync(BASE);
+	value = MII_GC_LOOPBK | MII_GC_RESET;
+	TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, value);
+	TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &value);
+	while (value & MII_GC_RESET) {
+		TLan_MiiReadReg(nic, phy, MII_GEN_CTL, &value);
 	}
 
-	if (!ack)
-		printk(KERN_INFO "TLAN: Received interrupt for uncompleted RX frame.\n");
-	
+	/* Wait for 500 ms and initialize.
+	 * I don't remember why I wait this long.
+	 * I've changed this to 50ms, as it seems long enough.
+	 */
+	/* TLan_SetTimer( dev, (HZ/20), TLAN_TIMER_PHY_START_LINK ); */
+	mdelay(50);
+	TLan_PhyStartLink(nic);
 
-	if ( eoc ) { 
-		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail );
-		head_list = priv->rxList + priv->rxHead;
-		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-		ack |= TLAN_HC_GO | TLAN_HC_RT;
-		priv->rxEocCount++;
-	}
+}				/* TLan_PhyReset */
 
-	if ( priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED ) {
-		TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT );
-		if ( priv->timer.function == NULL )  {
-			priv->timer.function = &TLan_Timer;
-			priv->timer.data = (unsigned long) dev;
-			priv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;
-			priv->timerSetAt = jiffies;
-			priv->timerType = TLAN_TIMER_ACTIVITY;
-			add_timer(&priv->timer);
-		} else if ( priv->timerType == TLAN_TIMER_ACTIVITY ) {
-			priv->timerSetAt = jiffies;
-		}
-	}
 
-	dev->last_rx = jiffies;
-	
-	return ack;
-
-} /* TLan_HandleRxEOF */
-
-	/***************************************************************
-	 *	TLan_HandleDummy
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles the Dummy interrupt, which is
-	 *	raised whenever a test interrupt is generated by setting
-	 *	the Req_Int bit of HOST_CMD to 1.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleDummy( struct net_device *dev, u16 host_int )
+void TLan_PhyStartLink(struct nic *nic)
 {
-	printk( "TLAN:  Test interrupt on %s.\n", dev->name );
-	return 1;
 
-} /* TLan_HandleDummy */
+	u16 ability;
+	u16 control;
+	u16 data;
+	u16 phy;
+	u16 status;
+	u16 tctl;
 
-	/***************************************************************
-	 *	TLan_HandleTxEOC
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This driver is structured to determine EOC occurances by
-	 *	reading the CSTAT member of the list structure.  Tx EOC
-	 *	interrupts are disabled via the DIO INTDIS register.
-	 *	However, TLAN chips before revision 3.0 didn't have this
-	 *	functionality, so process EOC events if this is the
-	 *	case.
-	 *
-	 **************************************************************/
+	phy = priv->phy[priv->phyNum];
+	printf("%s: Trying to activate link.\n", priv->nic_name);
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &ability);
 
-u32 TLan_HandleTxEOC( struct net_device *dev, u16 host_int )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	TLanList		*head_list;
-	u32			ack = 1;
-	
-	host_int = 0;
-	if ( priv->tlanRev < 0x30 ) {
-		TLAN_DBG( TLAN_DEBUG_TX, "TRANSMIT:  Handling TX EOC (Head=%d Tail=%d) -- IRQ\n", priv->txHead, priv->txTail );
-		head_list = priv->txList + priv->txHead;
-		if ( ( head_list->cStat & TLAN_CSTAT_READY ) == TLAN_CSTAT_READY ) {
-			netif_stop_queue(dev);
-			outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-			ack |= TLAN_HC_GO;
+	if ((status & MII_GS_AUTONEG) && (!priv->aui)) {
+		ability = status >> 11;
+		if (priv->speed == TLAN_SPEED_10 &&
+		    priv->duplex == TLAN_DUPLEX_HALF) {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x0000);
+		} else if (priv->speed == TLAN_SPEED_10 &&
+			   priv->duplex == TLAN_DUPLEX_FULL) {
+			priv->tlanFullDuplex = TRUE;
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x0100);
+		} else if (priv->speed == TLAN_SPEED_100 &&
+			   priv->duplex == TLAN_DUPLEX_HALF) {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x2000);
+		} else if (priv->speed == TLAN_SPEED_100 &&
+			   priv->duplex == TLAN_DUPLEX_FULL) {
+			priv->tlanFullDuplex = TRUE;
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x2100);
 		} else {
-			priv->txInProgress = 0;
-		}
-	}
 
-	return ack;
-
-} /* TLan_HandleTxEOC */
-
-	/***************************************************************
-	 *	TLan_HandleStatusCheck
-	 *
-	 *	Returns:
-	 *		0 if Adapter check, 1 if Network Status check.
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This function handles Adapter Check/Network Status
-	 *	interrupts generated by the adapter.  It checks the
-	 *	vector in the HOST_INT register to determine if it is
-	 *	an Adapter Check interrupt.  If so, it resets the
-	 *	adapter.  Otherwise it clears the status registers
-	 *	and services the PHY.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleStatusCheck( struct net_device *dev, u16 host_int )
-{	
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		ack;
-	u32		error;
-	u8		net_sts;
-	u32		phy;
-	u16		tlphy_ctl;
-	u16		tlphy_sts;
-	
-	ack = 1;
-	if ( host_int & TLAN_HI_IV_MASK ) {
-		netif_stop_queue( dev );
-		error = inl( dev->base_addr + TLAN_CH_PARM );
-		printk( "TLAN:  %s: Adaptor Error = 0x%x\n", dev->name, error );
-		TLan_ReadAndClearStats( dev, TLAN_RECORD );
-		outl( TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD );
-		
-		queue_task(&priv->tlan_tqueue, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-		
-		netif_wake_queue(dev);
-		ack = 0;
-	} else {
-		TLAN_DBG( TLAN_DEBUG_GNRL, "%s: Status Check\n", dev->name );
-		phy = priv->phy[priv->phyNum];
-
-		net_sts = TLan_DioRead8( dev->base_addr, TLAN_NET_STS );
-		if ( net_sts ) {
-			TLan_DioWrite8( dev->base_addr, TLAN_NET_STS, net_sts );
-			TLAN_DBG( TLAN_DEBUG_GNRL, "%s:    Net_Sts = %x\n", dev->name, (unsigned) net_sts );
+			/* Set Auto-Neg advertisement */
+			TLan_MiiWriteReg(nic, phy, MII_AN_ADV,
+					 (ability << 5) | 1);
+			/* Enablee Auto-Neg */
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x1000);
+			/* Restart Auto-Neg */
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, 0x1200);
+			/* Wait for 4 sec for autonegotiation
+			 * to complete.  The max spec time is less than this
+			 * but the card need additional time to start AN.
+			 * .5 sec should be plenty extra.
+			 */
+			printf("TLAN: %s: Starting autonegotiation.\n",
+			       priv->nic_name);
+			mdelay(4000);
+			TLan_PhyFinishAutoNeg(nic);
+			/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN ); */
+			return;
 		}
-		if ( ( net_sts & TLAN_NET_STS_MIRQ ) &&  ( priv->phyNum == 0 ) ) {
-			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_STS, &tlphy_sts );
-			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl );
-        		if ( ! ( tlphy_sts & TLAN_TS_POLOK ) && ! ( tlphy_ctl & TLAN_TC_SWAPOL ) ) {
-                		tlphy_ctl |= TLAN_TC_SWAPOL;
-                		TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);
-        		} else if ( ( tlphy_sts & TLAN_TS_POLOK ) && ( tlphy_ctl & TLAN_TC_SWAPOL ) ) {
-                		tlphy_ctl &= ~TLAN_TC_SWAPOL;
-                		TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);
-        		}
 
-			if (debug) {
-				TLan_PhyPrint( dev );		
-			}
-		}
 	}
 
-	return ack;
-
-} /* TLan_HandleStatusCheck */
-
-	/***************************************************************
-	 *	TLan_HandleRxEOC
-	 *
-	 *	Returns:
-	 *		1
-	 *	Parms:
-	 *		dev		Device assigned the IRQ that was
-	 *				raised.
-	 *		host_int	The contents of the HOST_INT
-	 *				port.
-	 *
-	 *	This driver is structured to determine EOC occurances by
-	 *	reading the CSTAT member of the list structure.  Rx EOC
-	 *	interrupts are disabled via the DIO INTDIS register.
-	 *	However, TLAN chips before revision 3.0 didn't have this
-	 *	CSTAT member or a INTDIS register, so if this chip is
-	 *	pre-3.0, process EOC interrupts normally.
-	 *
-	 **************************************************************/
-
-u32 TLan_HandleRxEOC( struct net_device *dev, u16 host_int )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	TLanList	*head_list;
-	u32		ack = 1;
-
-	if (  priv->tlanRev < 0x30 ) {
-		TLAN_DBG( TLAN_DEBUG_RX, "RECEIVE:  Handling RX EOC (Head=%d Tail=%d) -- IRQ\n", priv->rxHead, priv->rxTail );
-		head_list = priv->rxList + priv->rxHead;
-		outl( virt_to_bus( head_list ), dev->base_addr + TLAN_CH_PARM );
-		ack |= TLAN_HC_GO | TLAN_HC_RT;
-		priv->rxEocCount++;
-	}
-
-	return ack;
-
-} /* TLan_HandleRxEOC */
-
-/*****************************************************************************
-******************************************************************************
-
-	ThunderLAN Driver Timer Function
-
-******************************************************************************
-*****************************************************************************/
-
-	/***************************************************************
-	 *	TLan_Timer
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		data	A value given to add timer when
-	 *			add_timer was called.
-	 *
-	 *	This function handles timed functionality for the
-	 *	TLAN driver.  The two current timer uses are for
-	 *	delaying for autonegotionation and driving the ACT LED.
-	 *	-	Autonegotiation requires being allowed about
-	 *		2 1/2 seconds before attempting to transmit a
-	 *		packet.  It would be a very bad thing to hang
-	 *		the kernel this long, so the driver doesn't
-	 *		allow transmission 'til after this time, for
-	 *		certain PHYs.  It would be much nicer if all
-	 *		PHYs were interrupt-capable like the internal
-	 *		PHY.
-	 *	-	The ACT LED, which shows adapter activity, is
-	 *		driven by the driver, and so must be left on
-	 *		for a short period to power up the LED so it
-	 *		can be seen.  This delay can be changed by
-	 *		changing the TLAN_TIMER_ACT_DELAY in tlan.h,
-	 *		if desired.  100 ms  produces a slightly
-	 *		sluggish response.
-	 *
-	 **************************************************************/
-
-void TLan_Timer( unsigned long data )
-{
-	struct net_device	*dev = (struct net_device *) data;
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		elapsed;
-	unsigned long	flags = 0;
-
-	priv->timer.function = NULL;
-
-	switch ( priv->timerType ) {
-#ifdef MONITOR		
-		case TLAN_TIMER_LINK_BEAT:
-			TLan_PhyMonitor( dev );
-			break;
-#endif
-		case TLAN_TIMER_PHY_PDOWN:
-			TLan_PhyPowerDown( dev );
-			break;
-		case TLAN_TIMER_PHY_PUP:
-			TLan_PhyPowerUp( dev );
-			break;
-		case TLAN_TIMER_PHY_RESET:
-			TLan_PhyReset( dev );
-			break;
-		case TLAN_TIMER_PHY_START_LINK:
-			TLan_PhyStartLink( dev );
-			break;
-		case TLAN_TIMER_PHY_FINISH_AN:
-			TLan_PhyFinishAutoNeg( dev );
-			break;
-		case TLAN_TIMER_FINISH_RESET:
-			TLan_FinishReset( dev );
-			break;
-		case TLAN_TIMER_ACTIVITY:
-			spin_lock_irqsave(&priv->lock, flags);
-			if ( priv->timer.function == NULL ) {
-				elapsed = jiffies - priv->timerSetAt;
-				if ( elapsed >= TLAN_TIMER_ACT_DELAY ) {
-					TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
-				} else  {
-					priv->timer.function = &TLan_Timer;
-					priv->timer.expires = priv->timerSetAt + TLAN_TIMER_ACT_DELAY;
-					spin_unlock_irqrestore(&priv->lock, flags);
-					add_timer( &priv->timer );
-					break;
-				}
-			}
-			spin_unlock_irqrestore(&priv->lock, flags);
-			break;
-		default:
-			break;
-	}
-
-} /* TLan_Timer */
-
-/*****************************************************************************
-******************************************************************************
-
-	ThunderLAN Driver Adapter Related Routines
-
-******************************************************************************
-*****************************************************************************/
-
-	/***************************************************************
-	 *	TLan_ResetLists
-	 *  
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	The device structure with the list
-	 *			stuctures to be reset.
-	 *
-	 *	This routine sets the variables associated with managing
-	 *	the TLAN lists to their initial values.
-	 *
-	 **************************************************************/
-
-void TLan_ResetLists( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	int		i;
-	TLanList	*list;
-	struct sk_buff	*skb;
-	void		*t = NULL;
-
-	priv->txHead = 0;
-	priv->txTail = 0;
-	for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
-		list = priv->txList + i;
-		list->cStat = TLAN_CSTAT_UNUSED;
-		if ( bbuf ) {
-			list->buffer[0].address = virt_to_bus( priv->txBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
+	if ((priv->aui) && (priv->phyNum != 0)) {
+		priv->phyNum = 0;
+		data =
+		    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN |
+		    TLAN_NET_CFG_PHY_EN;
+		TLan_DioWrite16(BASE, TLAN_NET_CONFIG, data);
+		mdelay(50);
+		/* TLan_SetTimer( dev, (40*HZ/1000), TLAN_TIMER_PHY_PDOWN ); */
+		TLan_PhyPowerDown(nic);
+		return;
+	} else if (priv->phyNum == 0) {
+		control = 0;
+		TLan_MiiReadReg(nic, phy, TLAN_TLPHY_CTL, &tctl);
+		if (priv->aui) {
+			tctl |= TLAN_TC_AUISEL;
 		} else {
-			list->buffer[0].address = 0;
-		}
-		list->buffer[2].count = 0;
-		list->buffer[2].address = 0;
-		list->buffer[9].address = 0;
-	}
-
-	priv->rxHead = 0;
-	priv->rxTail = TLAN_NUM_RX_LISTS - 1;
-	for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
-		list = priv->rxList + i;
-		list->cStat = TLAN_CSTAT_READY;
-		list->frameSize = TLAN_MAX_FRAME_SIZE;
-		list->buffer[0].count = TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;
-		if ( bbuf ) {
-			list->buffer[0].address = virt_to_bus( priv->rxBuffer + ( i * TLAN_MAX_FRAME_SIZE ) );
-		} else {
-			skb = dev_alloc_skb( TLAN_MAX_FRAME_SIZE + 7 );
-			if ( skb == NULL ) {
-				printk( "TLAN:  Couldn't allocate memory for received data.\n" );
-				/* If this ever happened it would be a problem */
-			} else {
-				skb->dev = dev;
-				skb_reserve( skb, 2 );
-				t = (void *) skb_put( skb, TLAN_MAX_FRAME_SIZE );
+			tctl &= ~TLAN_TC_AUISEL;
+			if (priv->duplex == TLAN_DUPLEX_FULL) {
+				control |= MII_GC_DUPLEX;
+				priv->tlanFullDuplex = TRUE;
 			}
-			list->buffer[0].address = virt_to_bus( t );
-			list->buffer[8].address = (u32) t;
-			list->buffer[9].address = (u32) skb;
-		}
-		list->buffer[1].count = 0;
-		list->buffer[1].address = 0;
-		if ( i < TLAN_NUM_RX_LISTS - 1 )
-			list->forward = virt_to_bus( list + 1 );
-		else
-			list->forward = 0;
-	}
-
-} /* TLan_ResetLists */
-
-void TLan_FreeLists( struct net_device *dev )
-{
-	TLanPrivateInfo *priv = dev->priv;
-	int		i;
-	TLanList	*list;
-	struct sk_buff	*skb;
-
-	if ( ! bbuf ) {
-		for ( i = 0; i < TLAN_NUM_TX_LISTS; i++ ) {
-			list = priv->txList + i;
-			skb = (struct sk_buff *) list->buffer[9].address;
-			if ( skb ) {
-				dev_kfree_skb_any( skb );
-				list->buffer[9].address = 0;
+			if (priv->speed == TLAN_SPEED_100) {
+				control |= MII_GC_SPEEDSEL;
 			}
 		}
-
-		for ( i = 0; i < TLAN_NUM_RX_LISTS; i++ ) {
-			list = priv->rxList + i;
-			skb = (struct sk_buff *) list->buffer[9].address;
-			if ( skb ) {
-				dev_kfree_skb_any( skb );
-				list->buffer[9].address = 0;
-			}
-		}
+		TLan_MiiWriteReg(nic, phy, MII_GEN_CTL, control);
+		TLan_MiiWriteReg(nic, phy, TLAN_TLPHY_CTL, tctl);
 	}
 
-} /* TLan_FreeLists */
+	/* Wait for 2 sec to give the tranceiver time
+	 * to establish link.
+	 */
+	/* TLan_SetTimer( dev, (4*HZ), TLAN_TIMER_FINISH_RESET ); */
+	mdelay(2000);
+	TLan_FinishReset(nic);
 
-	/***************************************************************
-	 *	TLan_PrintDio
-	 *  
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		io_base		Base IO port of the device of
-	 *				which to print DIO registers.
-	 *
-	 *	This function prints out all the internal (DIO)
-	 *	registers of a TLAN chip.
-	 *
-	 **************************************************************/
+}				/* TLan_PhyStartLink */
 
-void TLan_PrintDio( u16 io_base )
+void TLan_PhyFinishAutoNeg(struct nic *nic)
 {
-	u32 data0, data1;
-	int	i;
 
-	printk( "TLAN:   Contents of internal registers for io base 0x%04hx.\n", io_base );
-	printk( "TLAN:      Off.  +0         +4\n" );
-	for ( i = 0; i < 0x4C; i+= 8 ) {
-		data0 = TLan_DioRead32( io_base, i );
-		data1 = TLan_DioRead32( io_base, i + 0x4 );
-		printk( "TLAN:      0x%02x  0x%08x 0x%08x\n", i, data0, data1 );
-	}
+	u16 an_adv;
+	u16 an_lpa;
+	u16 data;
+	u16 mode;
+	u16 phy;
+	u16 status;
 
-} /* TLan_PrintDio */
+	phy = priv->phy[priv->phyNum];
 
-	/***************************************************************
-	 *	TLan_PrintList
-	 *  
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		list	A pointer to the TLanList structure to
-	 *			be printed.
-	 *		type	A string to designate type of list,
-	 *			"Rx" or "Tx".
-	 *		num	The index of the list.
-	 *
-	 *	This function prints out the contents of the list
-	 *	pointed to by the list parameter.
-	 *
-	 **************************************************************/
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
+	udelay(1000);
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &status);
 
-void TLan_PrintList( TLanList *list, char *type, int num)
-{
-	int i;
-
-	printk( "TLAN:   %s List %d at 0x%08x\n", type, num, (u32) list );
-	printk( "TLAN:      Forward    = 0x%08x\n",  list->forward );
-	printk( "TLAN:      CSTAT      = 0x%04hx\n", list->cStat );
-	printk( "TLAN:      Frame Size = 0x%04hx\n", list->frameSize );
-	/* for ( i = 0; i < 10; i++ ) { */
-	for ( i = 0; i < 2; i++ ) {
-		printk( "TLAN:      Buffer[%d].count, addr = 0x%08x, 0x%08x\n", i, list->buffer[i].count, list->buffer[i].address );
+	if (!(status & MII_GS_AUTOCMPLT)) {
+		/* Wait for 8 sec to give the process
+		 * more time.  Perhaps we should fail after a while.
+		 */
+		if (!priv->neg_be_verbose++) {
+			printf
+			    ("TLAN:  Giving autonegotiation more time.\n");
+			printf
+			    ("TLAN:  Please check that your adapter has\n");
+			printf
+			    ("TLAN:  been properly connected to a HUB or Switch.\n");
+			printf
+			    ("TLAN:  Trying to establish link in the background...\n");
+		}
+		mdelay(8000);
+		TLan_PhyFinishAutoNeg(nic);
+		/* TLan_SetTimer( dev, (8*HZ), TLAN_TIMER_PHY_FINISH_AN ); */
+		return;
 	}
 
-} /* TLan_PrintList */
-
-	/***************************************************************
-	 *	TLan_ReadAndClearStats
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	Pointer to device structure of adapter
-	 *			to which to read stats.
-	 *		record	Flag indicating whether to add 
-	 *
-	 *	This functions reads all the internal status registers
-	 *	of the TLAN chip, which clears them as a side effect.
-	 *	It then either adds the values to the device's status
-	 *	struct, or discards them, depending on whether record
-	 *	is TLAN_RECORD (!=0)  or TLAN_IGNORE (==0).
-	 *
-	 **************************************************************/
-
-void TLan_ReadAndClearStats( struct net_device *dev, int record )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	u32		tx_good, tx_under;
-	u32		rx_good, rx_over;
-	u32		def_tx, crc, code;
-	u32		multi_col, single_col;
-	u32		excess_col, late_col, loss;
-
-	outw( TLAN_GOOD_TX_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	tx_good  = inb( dev->base_addr + TLAN_DIO_DATA );
-	tx_good += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	tx_good += inb( dev->base_addr + TLAN_DIO_DATA + 2 ) << 16;
-	tx_under = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
-
-	outw( TLAN_GOOD_RX_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	rx_good  = inb( dev->base_addr + TLAN_DIO_DATA );
-	rx_good += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	rx_good += inb( dev->base_addr + TLAN_DIO_DATA + 2 ) << 16;
-	rx_over  = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
-		
-	outw( TLAN_DEFERRED_TX, dev->base_addr + TLAN_DIO_ADR );
-	def_tx  = inb( dev->base_addr + TLAN_DIO_DATA );
-	def_tx += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	crc     = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
-	code    = inb( dev->base_addr + TLAN_DIO_DATA + 3 );
-	
-	outw( TLAN_MULTICOL_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	multi_col   = inb( dev->base_addr + TLAN_DIO_DATA );
-	multi_col  += inb( dev->base_addr + TLAN_DIO_DATA + 1 ) << 8;
-	single_col  = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
-	single_col += inb( dev->base_addr + TLAN_DIO_DATA + 3 ) << 8;
-
-	outw( TLAN_EXCESSCOL_FRMS, dev->base_addr + TLAN_DIO_ADR );
-	excess_col = inb( dev->base_addr + TLAN_DIO_DATA );
-	late_col   = inb( dev->base_addr + TLAN_DIO_DATA + 1 );
-	loss       = inb( dev->base_addr + TLAN_DIO_DATA + 2 );
-
-	if ( record ) {
-		priv->stats.rx_packets += rx_good;
-		priv->stats.rx_errors  += rx_over + crc + code;
-		priv->stats.tx_packets += tx_good;
-		priv->stats.tx_errors  += tx_under + loss;
-		priv->stats.collisions += multi_col + single_col + excess_col + late_col;
-
-		priv->stats.rx_over_errors    += rx_over;
-		priv->stats.rx_crc_errors     += crc;
-		priv->stats.rx_frame_errors   += code;
-
-		priv->stats.tx_aborted_errors += tx_under;
-		priv->stats.tx_carrier_errors += loss;
+	printf("TLAN: %s: Autonegotiation complete.\n", priv->nic_name);
+	TLan_MiiReadReg(nic, phy, MII_AN_ADV, &an_adv);
+	TLan_MiiReadReg(nic, phy, MII_AN_LPA, &an_lpa);
+	mode = an_adv & an_lpa & 0x03E0;
+	if (mode & 0x0100) {
+		printf("Full Duplex\n");
+		priv->tlanFullDuplex = TRUE;
+	} else if (!(mode & 0x0080) && (mode & 0x0040)) {
+		priv->tlanFullDuplex = TRUE;
+		printf("Full Duplex\n");
 	}
-			
-} /* TLan_ReadAndClearStats */
 
-	/***************************************************************
-	 *	TLan_Reset
-	 *
-	 *	Returns:
-	 *		0
-	 *	Parms:
-	 *		dev	Pointer to device structure of adapter
-	 *			to be reset.
-	 *
-	 *	This function resets the adapter and it's physical
-	 *	device.  See Chap. 3, pp. 9-10 of the "ThunderLAN
-	 *	Programmer's Guide" for details.  The routine tries to
-	 *	implement what is detailed there, though adjustments
-	 *	have been made.
-	 *
-	 **************************************************************/
-
-void
-TLan_ResetAdapter( struct net_device *dev )
-{
-	TLanPrivateInfo	*priv = dev->priv;
-	int		i;
-	u32		addr;
-	u32		data;
-	u8		data8;
-
-	priv->tlanFullDuplex = FALSE;
-	priv->phyOnline=0;
-/*  1.	Assert reset bit. */
-
-	data = inl(dev->base_addr + TLAN_HOST_CMD);
-	data |= TLAN_HC_AD_RST;
-	outl(data, dev->base_addr + TLAN_HOST_CMD);
-	
-	udelay(1000);
-
-/*  2.	Turn off interrupts. ( Probably isn't necessary ) */
-
-	data = inl(dev->base_addr + TLAN_HOST_CMD);
-	data |= TLAN_HC_INT_OFF;
-	outl(data, dev->base_addr + TLAN_HOST_CMD);
-
-/*  3.	Clear AREGs and HASHs. */
-
- 	for ( i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4 ) {
-		TLan_DioWrite32( dev->base_addr, (u16) i, 0 );
+	if ((!(mode & 0x0180))
+	    && (tlan_pci_tbl[chip_idx].flags & TLAN_ADAPTER_USE_INTERN_10)
+	    && (priv->phyNum != 0)) {
+		priv->phyNum = 0;
+		data =
+		    TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN |
+		    TLAN_NET_CFG_PHY_EN;
+		TLan_DioWrite16(BASE, TLAN_NET_CONFIG, data);
+		/* TLan_SetTimer( nic, (400*HZ/1000), TLAN_TIMER_PHY_PDOWN ); */
+		mdelay(400);
+		TLan_PhyPowerDown(nic);
+		return;
 	}
 
-/*  4.	Setup NetConfig register. */
-
-	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;
-	TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, (u16) data );
-
-/*  5.	Load Ld_Tmr and Ld_Thr in HOST_CMD. */
-
- 	outl( TLAN_HC_LD_TMR | 0x3f, dev->base_addr + TLAN_HOST_CMD );
- 	outl( TLAN_HC_LD_THR | 0x9, dev->base_addr + TLAN_HOST_CMD );
-
-/*  6.	Unreset the MII by setting NMRST (in NetSio) to 1. */
-
-	outw( TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR );
-	addr = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;
-	TLan_SetBit( TLAN_NET_SIO_NMRST, addr );
-
-/*  7.	Setup the remaining registers. */
-
-	if ( priv->tlanRev >= 0x30 ) {
-		data8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;
-		TLan_DioWrite8( dev->base_addr, TLAN_INT_DIS, data8 );
-	}
-	TLan_PhyDetect( dev );
-	data = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;
-	
-	if ( priv->adapter->flags & TLAN_ADAPTER_BIT_RATE_PHY ) {
-		data |= TLAN_NET_CFG_BIT;
-		if ( priv->aui == 1 ) {
-			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x0a );
-		} else if ( priv->duplex == TLAN_DUPLEX_FULL ) {
-			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x00 );
-			priv->tlanFullDuplex = TRUE;
+	if (priv->phyNum == 0) {
+		if ((priv->duplex == TLAN_DUPLEX_FULL)
+		    || (an_adv & an_lpa & 0x0040)) {
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL,
+					 MII_GC_AUTOENB | MII_GC_DUPLEX);
+			printf
+			    ("TLAN:  Starting internal PHY with FULL-DUPLEX\n");
 		} else {
-			TLan_DioWrite8( dev->base_addr, TLAN_ACOMMIT, 0x08 );
+			TLan_MiiWriteReg(nic, phy, MII_GEN_CTL,
+					 MII_GC_AUTOENB);
+			printf
+			    ("TLAN:  Starting internal PHY with HALF-DUPLEX\n");
 		}
 	}
 
-	if ( priv->phyNum == 0 ) {
-		data |= TLAN_NET_CFG_PHY_EN;
-	}
-	TLan_DioWrite16( dev->base_addr, TLAN_NET_CONFIG, (u16) data );
+	/* Wait for 100 ms.  No reason in partiticular.
+	 */
+	/* TLan_SetTimer( dev, (HZ/10), TLAN_TIMER_FINISH_RESET ); */
+	mdelay(100);
+	TLan_FinishReset(nic);
 
-	if ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) {
-		TLan_FinishReset( dev );
-	} else {
-		TLan_PhyPowerDown( dev );
-	}
+}				/* TLan_PhyFinishAutoNeg */
 
-} /* TLan_ResetAdapter */
+#ifdef MONITOR
 
-void
-TLan_FinishReset( struct net_device *dev )
+	/*********************************************************************
+        *
+        *      TLan_phyMonitor
+        *
+        *      Returns:
+        *              None
+        *
+        *      Params:
+        *              dev             The device structure of this device.
+        *
+        *
+        *      This function monitors PHY condition by reading the status
+        *      register via the MII bus. This can be used to give info
+        *      about link changes (up/down), and possible switch to alternate
+        *      media.
+        *
+        * ******************************************************************/
+
+void TLan_PhyMonitor(struct net_device *dev)
 {
-	TLanPrivateInfo	*priv = dev->priv;
-	u8		data;
-	u32		phy;
-	u8		sio;
-	u16		status;
-	u16		partner;
-	u16		tlphy_ctl;
-	u16 		tlphy_par;
-	u16		tlphy_id1, tlphy_id2;
-	int 		i;
+	TLanPrivateInfo *priv = dev->priv;
+	u16 phy;
+	u16 phy_status;
 
 	phy = priv->phy[priv->phyNum];
 
-	data = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;
-	if ( priv->tlanFullDuplex ) {
-		data |= TLAN_NET_CMD_DUPLEX;
-	}
-	TLan_DioWrite8( dev->base_addr, TLAN_NET_CMD, data );
-	data = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5; 
-	if ( priv->phyNum == 0 ) {
-		data |= TLAN_NET_MASK_MASK7; 
-	}
-	TLan_DioWrite8( dev->base_addr, TLAN_NET_MASK, data );
-	TLan_DioWrite16( dev->base_addr, TLAN_MAX_RX, ((1536)+7)&~7 );
-	TLan_MiiReadReg( dev, phy, MII_GEN_ID_HI, &tlphy_id1 );
-	TLan_MiiReadReg( dev, phy, MII_GEN_ID_LO, &tlphy_id2 );
-	
-	if ( ( priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY ) || ( priv->aui ) ) {
-		status = MII_GS_LINK;
-		printk( "TLAN:  %s: Link forced.\n", dev->name );
-	} else {
-		TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-		udelay( 1000 );
-		TLan_MiiReadReg( dev, phy, MII_GEN_STS, &status );
-		if ( (status & MII_GS_LINK) &&	 /* We only support link info on Nat.Sem. PHY's */ 
-			(tlphy_id1 == NAT_SEM_ID1) &&
-			(tlphy_id2 == NAT_SEM_ID2) ) {
-			TLan_MiiReadReg( dev, phy, MII_AN_LPA, &partner );
-			TLan_MiiReadReg( dev, phy, TLAN_TLPHY_PAR, &tlphy_par );
-			
-			printk( "TLAN: %s: Link active with ", dev->name );
-			if (!(tlphy_par & TLAN_PHY_AN_EN_STAT)) {
-			      	 printk( "forced 10%sMbps %s-Duplex\n", 
-						tlphy_par & TLAN_PHY_SPEED_100 ? "" : "0",
-						tlphy_par & TLAN_PHY_DUPLEX_FULL ? "Full" : "Half");
-			} else {
-				printk( "AutoNegotiation enabled, at 10%sMbps %s-Duplex\n",
-						tlphy_par & TLAN_PHY_SPEED_100 ? "" : "0",
-						tlphy_par & TLAN_PHY_DUPLEX_FULL ? "Full" : "Half");
-				printk("TLAN: Partner capability: ");
-					for (i = 5; i <= 10; i++)
-						if (partner & (1<<i))
-							printk("%s", media[i-5]);
-							printk("\n");
-			}
+	/* Get PHY status register */
+	TLan_MiiReadReg(nic, phy, MII_GEN_STS, &phy_status);
 
-			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
-#ifdef MONITOR			
-			/* We have link beat..for now anyway */
-	        	priv->link = 1;
-	        	/*Enabling link beat monitoring */
-			TLan_SetTimer( dev, (10*HZ), TLAN_TIMER_LINK_BEAT );
-#endif 
-		} else if (status & MII_GS_LINK)  {
-			printk( "TLAN: %s: Link active\n", dev->name );
-			TLan_DioWrite8( dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK );
+	/* Check if link has been lost */
+	if (!(phy_status & MII_GS_LINK)) {
+		if (priv->link) {
+			priv->link = 0;
+			printf("TLAN: %s has lost link\n", priv->nic_name);
+			priv->flags &= ~IFF_RUNNING;
+			mdelay(2000);
+			TLan_PhyMonitor(nic);
+			/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT ); */
+			return;
 		}
 	}
 
-	if ( priv->phyNum == 0 ) {
-        	TLan_MiiReadReg( dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl );
-        	tlphy_ctl |= TLAN_TC_INTEN;
-        	TLan_MiiWriteReg( dev, phy, TLAN_TLPHY_CTL, tlphy_ctl );
-        	sio = TLan_DioRead8( dev->base_addr, TLAN_NET_SIO );
-        	sio |= TLAN_NET_SIO_MINTEN;
-        	TLan_DioWrite8( dev->base_addr, TLAN_NET_SIO, sio );
+	/* Link restablished? */
+	if ((phy_status & MII_GS_LINK) && !priv->link) {
+		priv->link = 1;
+		printf("TLAN: %s has reestablished link\n",
+		       priv->nic_name);
+		priv->flags |= IFF_RUNNING;
 	}
 
-	if ( status & MII_GS_LINK ) {
-		TLan_SetMac( dev, 0, dev->dev_addr );
-		priv->phyOnline = 1;
-		outb( ( TLAN_HC_INT_ON >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
-		if ( debug >= 1 && debug != TLAN_DEBUG_PROBE ) {
-			outb( ( TLAN_HC_REQ_INT >> 8 ), dev->base_addr + TLAN_HOST_CMD + 1 );
-		}
-		outl( virt_to_bus( priv->rxList ), dev->base_addr + TLAN_CH_PARM );
-		outl( TLAN_HC_GO | TLAN_HC_RT, dev->base_addr + TLAN_HOST_CMD );
-	} else {
-		printk( "TLAN: %s: Link inactive, will retry in 10 secs...\n", dev->name );
-		TLan_SetTimer( dev, (10*HZ), TLAN_TIMER_FINISH_RESET );
-		return;
-	}
+	/* Setup a new monitor */
+	/* TLan_SetTimer( dev, (2*HZ), TLAN_TIMER_LINK_BEAT ); */
+	mdelay(2000);
+	TLan_PhyMonitor(nic);
+}
 
-} /* TLan_FinishReset */
+#endif				/* MONITOR */
 
-	/***************************************************************
-	 *	TLan_SetMac
-	 *
-	 *	Returns:
-	 *		Nothing
-	 *	Parms:
-	 *		dev	Pointer to device structure of adapter
-	 *			on which to change the AREG.
-	 *		areg	The AREG to set the address in (0 - 3).
-	 *		mac	A pointer to an array of chars.  Each
-	 *			element stores one byte of the address.
-	 *			IE, it isn't in ascii.
-	 *
-	 *	This function transfers a MAC address to one of the
-	 *	TLAN AREGs (address registers).  The TLAN chip locks
-	 *	the register on writing to offset 0 and unlocks the
-	 *	register after writing to offset 5.  If NULL is passed
-	 *	in mac, then the AREG is filled with 0's.
-	 *
-	 **************************************************************/
+#ifdef EB51
+static struct pci_id tlan_nics[] = {
+	PCI_ROM(0x0e11, 0xae34, "netel10", "Compaq Netelligent 10 T PCI UTP"),
+	PCI_ROM(0x0e11, 0xae32, "netel100","Compaq Netelligent 10/100 TX PCI UTP"),
+	PCI_ROM(0x0e11, 0xae35, "netflex3i", "Compaq Integrated NetFlex-3/P"),
+	PCI_ROM(0x0e11, 0xf130, "thunder", "Compaq NetFlex-3/P"),
+	PCI_ROM(0x0e11, 0xf150, "netflex3b", "Compaq NetFlex-3/P"),
+	PCI_ROM(0x0e11, 0xae43, "netel100pi", "Compaq Netelligent Integrated 10/100 TX UTP"),
+	PCI_ROM(0x0e11, 0xae40, "netel100d", "Compaq Netelligent Dual 10/100 TX PCI UTP"),
+	PCI_ROM(0x0e11, 0xb011, "netel100i", "Compaq Netelligent 10/100 TX Embedded UTP"),
+	PCI_ROM(0x108d, 0x0013, "oc2183", "Olicom OC-2183/2185"),
+	PCI_ROM(0x108d, 0x0012, "oc2325", "Olicom OC-2325"),
+	PCI_ROM(0x108d, 0x0014, "oc2326", "Olicom OC-2326"),
+	PCI_ROM(0x0e11, 0xb030, "netelligent_10_100_ws_5100", "Compaq Netelligent 10/100 TX UTP"),
+	PCI_ROM(0x0e11, 0xb012, "netelligent_10_t2", "Compaq Netelligent 10 T/2 PCI UTP/Coax"),
+};
 
-void TLan_SetMac( struct net_device *dev, int areg, char *mac )
-{
-	int i;
-			
-	areg *= 6;
-
-	if ( mac != NULL ) {
-		for ( i = 0; i < 6; i++ )
-			TLan_DioWrite8( dev->base_addr, TLAN_AREG_0 + areg + i, mac[i] );
-	} else {
-		for ( i = 0; i < 6; i++ )
-			TLan_DioWrite8( dev->base_addr, TLAN_AREG_0 + areg + i, 0 );
-	}
-
-} /* TLan_SetMac */
-
+struct pci_driver tlan_driver = {
+	.type = NIC_DRIVER,
+	.name = "TLAN/PCI",
+	.probe = tlan_probe,
+	.ids = tlan_nics,
+	.id_count = sizeof(tlan_nics) / sizeof(tlan_nics[0]),
+	.class = 0,
+};
 #endif
Index: netboot/pxe.h
===================================================================
--- netboot/pxe.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/pxe.h	(.../trunk)	(revision 112)
@@ -0,0 +1,521 @@
+/*
+ * Copyright (c) 2000 Alfred Perlstein <alfred@freebsd.org>
+ * All rights reserved.
+ * Copyright (c) 2000 Paul Saab <ps@freebsd.org>
+ * All rights reserved.
+ * Copyright (c) 2000 John Baldwin <jhb@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/boot/i386/libi386/pxe.h,v 1.4.2.2 2000/09/10 02:52:18 ps Exp $
+ */
+
+/*
+ * The typedefs and structures declared in this file
+ * clearly violate style(9), the reason for this is to conform to the
+ * typedefs/structure-names used in the Intel literature to avoid confusion.
+ *
+ * It's for your own good. :)
+ */
+
+/* SEGOFF16_t defined in separate header for Etherboot
+ */
+#include <segoff.h>
+
+/* It seems that intel didn't think about ABI,
+ * either that or 16bit ABI != 32bit ABI (which seems reasonable)
+ * I have to thank Intel for the hair loss I incurred trying to figure
+ * out why PXE was mis-reading structures I was passing it (at least
+ * from my point of view)
+ *
+ * Solution: use gcc's '__attribute__ ((packed))' to correctly align
+ * structures passed into PXE
+ * Question: does this really work for PXE's expected ABI?
+ */
+#define	PACKED		__attribute__ ((packed))
+
+#define	S_SIZE(s)	s, sizeof(s) - 1
+
+#define	IP_STR		"%d.%d.%d.%d"
+#define	IP_ARGS(ip)					\
+	(int)(ip >> 24) & 0xff, (int)(ip >> 16) & 0xff, \
+	(int)(ip >> 8) & 0xff, (int)ip & 0xff
+
+#define	MAC_STR		"%02x:%02x:%02x:%02x:%02x:%02x"
+#define	MAC_ARGS(mac)					\
+	mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] 
+
+#define	PXENFSROOTPATH	"/pxeroot"
+
+typedef struct {
+	uint16_t		Seg_Addr;
+	uint32_t		Phy_Addr;
+	uint16_t		Seg_Size;
+} PACKED SEGDESC_t; /* PACKED is required, otherwise gcc pads this out to 12
+		       bytes - mbrown@fensystems.co.uk (mcb30) 17/5/03 */
+
+typedef	uint16_t		SEGSEL_t;
+typedef	uint16_t		PXENV_STATUS_t;
+typedef	uint32_t		IP4_t;
+typedef	uint32_t		ADDR32_t;
+typedef	uint16_t		UDP_PORT_t;
+
+#define	MAC_ADDR_LEN		16
+typedef	uint8_t			MAC_ADDR[MAC_ADDR_LEN];
+
+/* PXENV+ */
+typedef struct {
+	uint8_t		Signature[6];	/* 'PXENV+' */
+	uint16_t	Version;	/* MSB = major, LSB = minor */
+	uint8_t		Length;		/* structure length */
+	uint8_t		Checksum;	/* checksum pad */
+	SEGOFF16_t	RMEntry;	/* SEG:OFF to PXE entry point */
+	/* don't use PMOffset and PMSelector (from the 2.1 PXE manual) */
+	uint32_t	PMOffset;	/* Protected mode entry */
+	SEGSEL_t	PMSelector;	/* Protected mode selector */
+	SEGSEL_t	StackSeg;	/* Stack segment address */
+	uint16_t	StackSize;	/* Stack segment size (bytes) */
+	SEGSEL_t	BC_CodeSeg;	/* BC Code segment address */
+	uint16_t	BC_CodeSize;	/* BC Code segment size (bytes) */
+	SEGSEL_t	BC_DataSeg;	/* BC Data segment address */
+	uint16_t	BC_DataSize;	/* BC Data segment size (bytes) */
+	SEGSEL_t	UNDIDataSeg;	/* UNDI Data segment address */
+	uint16_t	UNDIDataSize;	/* UNDI Data segment size (bytes) */
+	SEGSEL_t	UNDICodeSeg;	/* UNDI Code segment address */
+	uint16_t	UNDICodeSize;	/* UNDI Code segment size (bytes) */
+	SEGOFF16_t	PXEPtr;		/* SEG:OFF to !PXE struct, 
+					   only present when Version > 2.1 */
+} PACKED pxenv_t;
+
+/* !PXE */
+typedef struct {
+	uint8_t		Signature[4];
+	uint8_t		StructLength;
+	uint8_t		StructCksum;
+	uint8_t		StructRev;
+	uint8_t		reserved_1;
+	SEGOFF16_t	UNDIROMID;
+	SEGOFF16_t	BaseROMID;
+	SEGOFF16_t	EntryPointSP;
+	SEGOFF16_t	EntryPointESP;
+	SEGOFF16_t	StatusCallout;
+	uint8_t		reserved_2;
+	uint8_t		SegDescCn;
+	SEGSEL_t	FirstSelector;
+	SEGDESC_t	Stack;
+	SEGDESC_t	UNDIData;
+	SEGDESC_t	UNDICode;
+	SEGDESC_t	UNDICodeWrite;
+	SEGDESC_t	BC_Data;
+	SEGDESC_t	BC_Code;
+	SEGDESC_t	BC_CodeWrite;
+} PACKED pxe_t;
+
+#define	PXENV_START_UNDI		0x0000
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	ax;
+	uint16_t	bx;
+	uint16_t	dx;
+	uint16_t	di;
+	uint16_t	es;
+} PACKED t_PXENV_START_UNDI;
+
+#define	PXENV_UNDI_STARTUP		0x0001
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_STARTUP;
+
+#define	PXENV_UNDI_CLEANUP		0x0002
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLEANUP;
+
+#define	PXENV_UNDI_INITIALIZE		0x0003
+typedef struct {
+	PXENV_STATUS_t	Status;
+	ADDR32_t	ProtocolIni;	/* Phys addr of a copy of the driver module */
+	uint8_t		reserved[8];
+} PACKED t_PXENV_UNDI_INITIALIZE;
+
+
+#define	MAXNUM_MCADDR		8
+typedef struct {
+	uint16_t	MCastAddrCount;
+	MAC_ADDR	McastAddr[MAXNUM_MCADDR];
+} PACKED t_PXENV_UNDI_MCAST_ADDRESS;
+
+#define	PXENV_UNDI_RESET_ADAPTER	0x0004		
+typedef struct {
+	PXENV_STATUS_t	Status;
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_RESET;
+
+#define	PXENV_UNDI_SHUTDOWN		0x0005
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_SHUTDOWN;
+
+#define	PXENV_UNDI_OPEN			0x0006
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	OpenFlag;
+	uint16_t	PktFilter;
+#	define FLTR_DIRECTED	0x0001
+#	define FLTR_BRDCST	0x0002
+#	define FLTR_PRMSCS	0x0003
+#	define FLTR_SRC_RTG	0x0004
+
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_OPEN;
+
+#define	PXENV_UNDI_CLOSE		0x0007
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLOSE;
+
+#define	PXENV_UNDI_TRANSMIT		0x0008
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		Protocol;
+#	define P_UNKNOWN	0
+#	define P_IP		1
+#	define P_ARP		2
+#	define P_RARP		3
+
+	uint8_t		XmitFlag;
+#	define XMT_DESTADDR	0x0000
+#	define XMT_BROADCAST	0x0001
+
+	SEGOFF16_t	DestAddr;
+	SEGOFF16_t	TBD;
+	uint32_t	Reserved[2];
+} PACKED t_PXENV_UNDI_TRANSMIT;
+
+#define	MAX_DATA_BLKS		8
+typedef struct {
+	uint16_t	ImmedLength;
+	SEGOFF16_t	Xmit;
+	uint16_t	DataBlkCount;
+	struct	DataBlk {
+		uint8_t		TDPtrType;
+		uint8_t		TDRsvdByte;
+		uint16_t	TDDataLen;
+		SEGOFF16_t	TDDataPtr;
+	} DataBlock[MAX_DATA_BLKS];
+} PACKED t_PXENV_UNDI_TBD;
+
+#define	PXENV_UNDI_SET_MCAST_ADDRESS	0x0009
+typedef struct {
+	PXENV_STATUS_t	Status;
+	t_PXENV_UNDI_MCAST_ADDRESS R_Mcast_Buf;
+} PACKED t_PXENV_UNDI_SET_MCAST_ADDR;
+
+#define	PXENV_UNDI_SET_STATION_ADDRESS	0x000A
+typedef struct {
+	PXENV_STATUS_t	Status;
+	MAC_ADDR	StationAddress;		/* Temp MAC addres to use */
+} PACKED t_PXENV_UNDI_SET_STATION_ADDRESS;
+
+#define	PXENV_UNDI_SET_PACKET_FILTER	0x000B
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		filter;			/* see UNDI_OPEN (0x0006) */
+} PACKED t_PXENV_UNDI_SET_PACKET_FILTER;
+
+#define	PXENV_UNDI_GET_INFORMATION	0x000C
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	BaseIo;			/* Adapter base I/O address */
+	uint16_t	IntNumber;		/* Adapter IRQ number */
+	uint16_t	MaxTranUnit;		/* Adapter maximum transmit unit */
+	uint16_t	HwType;			/* Type of protocol at the hardware addr */
+#	define ETHER_TYPE	1
+#	define EXP_ETHER_TYPE	2
+#	define IEEE_TYPE	6
+#	define ARCNET_TYPE	7
+
+	uint16_t	HwAddrLen;		/* Length of hardware address */
+	MAC_ADDR	CurrentNodeAddress;	/* Current hardware address */
+	MAC_ADDR	PermNodeAddress;	/* Permanent hardware address */
+	SEGSEL_t	ROMAddress;		/* Real mode ROM segment address */
+	uint16_t	RxBufCt;		/* Receive queue length */
+	uint16_t	TxBufCt;		/* Transmit queue length */
+} PACKED t_PXENV_UNDI_GET_INFORMATION;
+
+#define	PXENV_UNDI_GET_STATISTICS	0x000D
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint32_t	XmitGoodFrames;		/* Number of successful transmissions */
+	uint32_t	RcvGoodFrames;		/* Number of good frames received */
+	uint32_t	RcvCRCErrors;		/* Number of frames with CRC errors */
+	uint32_t	RcvResourceErrors;	/* Number of frames dropped */
+} PACKED t_PXENV_UNDI_GET_STATISTICS;
+
+#define	PXENV_UNDI_CLEAR_STATISTICS	0x000E
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_CLEAR_STATISTICS;
+
+#define	PXENV_UNDI_INITIATE_DIAGS	0x000F
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_INITIATE_DIAGS;
+
+#define	PXENV_UNDI_FORCE_INTERRUPT	0x0010
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_UNDI_FORCE_INTERRUPT;
+
+#define	PXENV_UNDI_GET_MCAST_ADDRESS	0x0011
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		InetAddr;		/* IP mulicast address */
+	MAC_ADDR	MediaAddr;		/* MAC multicast address */
+} PACKED t_PXENV_UNDI_GET_MCAST_ADDR;
+
+#define	PXENV_UNDI_GET_NIC_TYPE		0x0012
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		NicType;		/* Type of NIC */
+#	define PCI_NIC		2
+#	define PnP_NIC		3
+#	define CardBus_NIC	4
+
+	union {
+		struct {
+			uint16_t	Vendor_ID;
+			uint16_t	Dev_ID;
+			uint8_t		Base_Class;
+			uint8_t		Sub_Class;
+			uint8_t		Prog_Intf;
+			uint8_t		Rev;
+			uint16_t	BusDevFunc;
+			uint16_t	SubVendor_ID;
+			uint16_t	SubDevice_ID;
+		} pci, cardbus;
+		struct {
+			uint32_t	EISA_Dev_ID;
+			uint8_t		Base_Class;
+			uint8_t		Sub_Class;
+			uint8_t		Prog_Intf;
+			uint16_t	CardSelNum;
+		} pnp;
+	} info;
+} PACKED t_PXENV_UNDI_GET_NIC_TYPE;
+
+#define	PXENV_UNDI_GET_IFACE_INFO	0x0013
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		IfaceType[16];		/* Name of MAC type in ASCII. */
+	uint32_t	LinkSpeed;		/* Defined in NDIS 2.0 spec */
+	uint32_t	ServiceFlags;		/* Defined in NDIS 2.0 spec */
+	uint32_t	Reserved[4];		/* must be 0 */
+} PACKED t_PXENV_UNDI_GET_IFACE_INFO;
+
+#define	PXENV_UNDI_ISR			0x0014
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	FuncFlag;		/* PXENV_UNDI_ISR_OUT_xxx */
+	uint16_t	BufferLength;		/* Length of Frame */
+	uint16_t	FrameLength;		/* Total length of reciever frame */
+	uint16_t	FrameHeaderLength;	/* Length of the media header in Frame */
+	SEGOFF16_t	Frame;			/* receive buffer */
+	uint8_t		ProtType;		/* Protocol type */
+	uint8_t		PktType;		/* Packet Type */
+#	define PXENV_UNDI_ISR_IN_START		1
+#	define PXENV_UNDI_ISR_IN_PROCESS	2
+#	define PXENV_UNDI_ISR_IN_GET_NEXT	3
+
+	/* one of these will be returned for PXENV_UNDI_ISR_IN_START */
+#	define PXENV_UNDI_ISR_OUT_OURS		0
+#	define PXENV_UNDI_ISR_OUT_NOT_OURS	1
+
+	/*
+	 * one of these will bre returnd for PXEND_UNDI_ISR_IN_PROCESS
+	 * and PXENV_UNDI_ISR_IN_GET_NEXT
+	 */
+#	define PXENV_UNDI_ISR_OUT_DONE		0
+#	define PXENV_UNDI_ISR_OUT_TRANSMIT	2
+#	define PXENV_UNDI_ISR_OUT_RECEIVE	3
+#	define PXENV_UNDI_ISR_OUT_BUSY		4
+} PACKED t_PXENV_UNDI_ISR;
+
+#define	PXENV_STOP_UNDI			0x0015
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_STOP_UNDI;
+
+#define	PXENV_TFTP_OPEN			0x0020
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAddress;
+	uint8_t		FileName[128];
+	UDP_PORT_t	TFTPPort;
+	uint16_t	PacketSize;
+} PACKED t_PXENV_TFTP_OPEN;
+
+#define	PXENV_TFTP_CLOSE		0x0021
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_TFTP_CLOSE;
+
+#define	PXENV_TFTP_READ			0x0022
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	PacketNumber;
+	uint16_t	BufferSize;
+	SEGOFF16_t	Buffer;
+} PACKED t_PXENV_TFTP_READ;
+
+#define	PXENV_TFTP_READ_FILE		0x0023
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		FileName[128];
+	uint32_t	BufferSize;
+	ADDR32_t	Buffer;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAddress;
+	IP4_t		McastIPAddress;
+	UDP_PORT_t	TFTPClntPort;
+	UDP_PORT_t	TFTPSrvPort;
+	uint16_t	TFTPOpenTimeOut;
+	uint16_t	TFTPReopenDelay;
+} PACKED t_PXENV_TFTP_READ_FILE;
+
+#define	PXENV_TFTP_GET_FSIZE		0x0025
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		ServerIPAddress;
+	IP4_t		GatewayIPAddress;
+	uint8_t		FileName[128];
+	uint32_t	FileSize;
+} PACKED t_PXENV_TFTP_GET_FSIZE;
+
+#define	PXENV_UDP_OPEN			0x0030
+typedef struct {
+	PXENV_STATUS_t	Status;
+	IP4_t		src_ip;		/* IP address of this station */
+} PACKED t_PXENV_UDP_OPEN;
+
+#define	PXENV_UDP_CLOSE			0x0031
+typedef struct {
+	PXENV_STATUS_t	status;
+} PACKED t_PXENV_UDP_CLOSE;
+
+#define	PXENV_UDP_READ			0x0032
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		src_ip;		/* IP of sender */
+	IP4_t		dest_ip;	/* Only accept packets sent to this IP */
+	UDP_PORT_t	s_port;		/* UDP source port of sender */
+	UDP_PORT_t	d_port;		/* Only accept packets sent to this port */
+	uint16_t	buffer_size;	/* Size of the packet buffer */
+	SEGOFF16_t	buffer;		/* SEG:OFF to the packet buffer */
+} PACKED t_PXENV_UDP_READ;
+
+#define	PXENV_UDP_WRITE			0x0033
+typedef struct {
+	PXENV_STATUS_t	status;
+	IP4_t		ip;		/* dest ip addr */
+	IP4_t		gw;		/* ip gateway */
+	UDP_PORT_t	src_port;	/* source udp port */
+	UDP_PORT_t	dst_port;	/* destination udp port */
+	uint16_t	buffer_size;	/* Size of the packet buffer */
+	SEGOFF16_t	buffer;		/* SEG:OFF to the packet buffer */
+} PACKED t_PXENV_UDP_WRITE;
+
+#define	PXENV_UNLOAD_STACK		0x0070
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint8_t		reserved[10];
+} PACKED t_PXENV_UNLOAD_STACK;
+
+
+#define	PXENV_GET_CACHED_INFO		0x0071
+typedef struct {
+	PXENV_STATUS_t	Status;
+	uint16_t	PacketType;	/* type (defined right here) */
+#	define PXENV_PACKET_TYPE_DHCP_DISCOVER  1
+#	define PXENV_PACKET_TYPE_DHCP_ACK       2
+#	define PXENV_PACKET_TYPE_BINL_REPLY     3
+	uint16_t	BufferSize;	/* max to copy, leave at 0 for pointer */
+	SEGOFF16_t	Buffer;		/* copy to, leave at 0 for pointer */
+	uint16_t	BufferLimit;	/* max size of buffer in BC dataseg ? */
+} PACKED t_PXENV_GET_CACHED_INFO;
+
+
+/* structure filled in by PXENV_GET_CACHED_INFO 
+ * (how we determine which IP we downloaded the initial bootstrap from)
+ * words can't describe...
+ */
+typedef struct {
+	uint8_t		opcode;
+#	define BOOTP_REQ	1
+#	define BOOTP_REP	2
+	uint8_t		Hardware;	/* hardware type */
+	uint8_t		Hardlen;	/* hardware addr len */
+	uint8_t		Gatehops;	/* zero it */
+	uint32_t	ident;		/* random number chosen by client */
+	uint16_t	seconds;	/* seconds since did initial bootstrap */
+	uint16_t	Flags;		/* seconds since did initial bootstrap */
+#	define BOOTP_BCAST	0x8000		/* ? */
+	IP4_t		cip;		/* Client IP */
+	IP4_t		yip;		/* Your IP */
+	IP4_t		sip;		/* IP to use for next boot stage */
+	IP4_t		gip;		/* Relay IP ? */
+	MAC_ADDR	CAddr;		/* Client hardware address */
+	uint8_t		Sname[64];	/* Server's hostname (Optional) */
+	uint8_t		bootfile[128];	/* boot filename */
+	union {
+#		if 1
+#		define BOOTP_DHCPVEND  1024    /* DHCP extended vendor field size */
+#		else
+#		define BOOTP_DHCPVEND  312	/* DHCP standard vendor field size */
+#		endif
+		uint8_t		d[BOOTP_DHCPVEND];	/* raw array of vendor/dhcp options */
+		struct {
+			uint8_t		magic[4];	/* DHCP magic cookie */
+#			ifndef		VM_RFC1048
+#			define		VM_RFC1048	0x63825363L	/* ? */
+#			endif
+			uint32_t	flags;		/* bootp flags/opcodes */
+			uint8_t		pad[56];	/* I don't think intel knows what a
+							   union does... */
+		} v;
+	} vendor;
+} PACKED BOOTPLAYER;
+
+#define	PXENV_RESTART_TFTP		0x0073
+#define	t_PXENV_RESTART_TFTP		t_PXENV_TFTP_READ_FILE
+
+#define	PXENV_START_BASE		0x0075
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_START_BASE;
+
+#define	PXENV_STOP_BASE			0x0076
+typedef struct {
+	PXENV_STATUS_t	Status;
+} PACKED t_PXENV_STOP_BASE;
Index: netboot/tlan.h
===================================================================
--- netboot/tlan.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/tlan.h	(.../trunk)	(revision 112)
@@ -0,0 +1,540 @@
+/**************************************************************************
+*
+*    tlan.c -- Etherboot device driver for the Texas Instruments ThunderLAN
+*    Written 2003-2003 by Timothy Legge <tlegge@rogers.com>
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the License, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*    Portions of this code (almost all) based on:
+*               tlan.c: Linux ThunderLan Driver:
+*
+*				by James Banks
+*
+*  				(C) 1997-1998 Caldera, Inc.
+*			  	(C) 1998 James Banks
+*				(C) 1999-2001 Torben Mathiasen
+*				(C) 2002 Samuel Chessman
+*
+*    $Revision$
+*    $Author$
+*    $Date 2003/07/18 $
+*
+*    REVISION HISTORY:
+*    ================
+*    v1.0	07-08-2003	timlegge	Initial not quite working version
+*
+* Indent Style: indent -kr -i8
+***************************************************************************/
+
+/*
+#include <asm/io.h>
+#include <asm/types.h>
+#include <linux/netdevice.h>
+*/
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+	/*****************************************************************
+	 * TLan Definitions
+	 *
+	 ****************************************************************/
+
+#define FALSE			0
+#define TRUE			1
+
+#define TLAN_MIN_FRAME_SIZE	64
+#define TLAN_MAX_FRAME_SIZE	1600
+
+#define TLAN_NUM_RX_LISTS	4
+#define TLAN_NUM_TX_LISTS	2
+
+#define TLAN_IGNORE		0
+#define TLAN_RECORD		1
+/*
+#define TLAN_DBG(lvl, format, args...)	if (debug&lvl) printf("TLAN: " format, ##args );
+*/
+#define TLAN_DEBUG_GNRL		0x0001
+#define TLAN_DEBUG_TX		0x0002
+#define TLAN_DEBUG_RX		0x0004
+#define TLAN_DEBUG_LIST		0x0008
+#define TLAN_DEBUG_PROBE	0x0010
+
+#define TX_TIMEOUT		(10*HZ)	/* We need time for auto-neg */
+#define MAX_TLAN_BOARDS		8	/* Max number of boards installed at a time */
+
+
+	/*****************************************************************
+	 * Device Identification Definitions
+	 *
+	 ****************************************************************/
+
+#define PCI_DEVICE_ID_NETELLIGENT_10_T2			0xB012
+#define PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100	0xB030
+#ifndef PCI_DEVICE_ID_OLICOM_OC2183
+#define PCI_DEVICE_ID_OLICOM_OC2183			0x0013
+#endif
+#ifndef PCI_DEVICE_ID_OLICOM_OC2325
+#define PCI_DEVICE_ID_OLICOM_OC2325			0x0012
+#endif
+#ifndef PCI_DEVICE_ID_OLICOM_OC2326
+#define PCI_DEVICE_ID_OLICOM_OC2326			0x0014
+#endif
+
+typedef struct tlan_adapter_entry {
+	u16 vendorId;
+	u16 deviceId;
+	char *deviceLabel;
+	u32 flags;
+	u16 addrOfs;
+} TLanAdapterEntry;
+
+#define TLAN_ADAPTER_NONE		0x00000000
+#define TLAN_ADAPTER_UNMANAGED_PHY	0x00000001
+#define TLAN_ADAPTER_BIT_RATE_PHY	0x00000002
+#define TLAN_ADAPTER_USE_INTERN_10	0x00000004
+#define TLAN_ADAPTER_ACTIVITY_LED	0x00000008
+
+#define TLAN_SPEED_DEFAULT	0
+#define TLAN_SPEED_10		10
+#define TLAN_SPEED_100		100
+
+#define TLAN_DUPLEX_DEFAULT	0
+#define TLAN_DUPLEX_HALF	1
+#define TLAN_DUPLEX_FULL	2
+
+
+
+	/*****************************************************************
+	 * EISA Definitions
+	 *
+	 ****************************************************************/
+
+#define EISA_ID      0xc80	/* EISA ID Registers */
+#define EISA_ID0     0xc80	/* EISA ID Register 0 */
+#define EISA_ID1     0xc81	/* EISA ID Register 1 */
+#define EISA_ID2     0xc82	/* EISA ID Register 2 */
+#define EISA_ID3     0xc83	/* EISA ID Register 3 */
+#define EISA_CR      0xc84	/* EISA Control Register */
+#define EISA_REG0    0xc88	/* EISA Configuration Register 0 */
+#define EISA_REG1    0xc89	/* EISA Configuration Register 1 */
+#define EISA_REG2    0xc8a	/* EISA Configuration Register 2 */
+#define EISA_REG3    0xc8f	/* EISA Configuration Register 3 */
+#define EISA_APROM   0xc90	/* Ethernet Address PROM */
+
+
+
+	/*****************************************************************
+	 * Rx/Tx List Definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_BUFFERS_PER_LIST	10
+#define TLAN_LAST_BUFFER	0x80000000
+#define TLAN_CSTAT_UNUSED	0x8000
+#define TLAN_CSTAT_FRM_CMP	0x4000
+#define TLAN_CSTAT_READY	0x3000
+#define TLAN_CSTAT_EOC		0x0800
+#define TLAN_CSTAT_RX_ERROR	0x0400
+#define TLAN_CSTAT_PASS_CRC	0x0200
+#define TLAN_CSTAT_DP_PR	0x0100
+
+
+
+
+
+
+	/*****************************************************************
+	 * PHY definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_PHY_MAX_ADDR	0x1F
+#define TLAN_PHY_NONE		0x20
+
+
+
+	/*****************************************************************
+	 * TLan Driver Timer Definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_TIMER_LINK_BEAT		1
+#define TLAN_TIMER_ACTIVITY		2
+#define TLAN_TIMER_PHY_PDOWN		3
+#define TLAN_TIMER_PHY_PUP		4
+#define TLAN_TIMER_PHY_RESET		5
+#define TLAN_TIMER_PHY_START_LINK	6
+#define TLAN_TIMER_PHY_FINISH_AN	7
+#define TLAN_TIMER_FINISH_RESET		8
+
+#define TLAN_TIMER_ACT_DELAY		(HZ/10)
+
+
+
+
+	/*****************************************************************
+	 * TLan Driver Eeprom Definitions
+	 *
+	 ****************************************************************/
+
+#define TLAN_EEPROM_ACK		0
+#define TLAN_EEPROM_STOP	1
+
+
+
+
+	/*****************************************************************
+	 * Host Register Offsets and Contents
+	 *
+	 ****************************************************************/
+
+#define TLAN_HOST_CMD			0x00
+#define 	TLAN_HC_GO		0x80000000
+#define		TLAN_HC_STOP		0x40000000
+#define		TLAN_HC_ACK		0x20000000
+#define		TLAN_HC_CS_MASK		0x1FE00000
+#define		TLAN_HC_EOC		0x00100000
+#define		TLAN_HC_RT		0x00080000
+#define		TLAN_HC_NES		0x00040000
+#define		TLAN_HC_AD_RST		0x00008000
+#define		TLAN_HC_LD_TMR		0x00004000
+#define		TLAN_HC_LD_THR		0x00002000
+#define		TLAN_HC_REQ_INT		0x00001000
+#define		TLAN_HC_INT_OFF		0x00000800
+#define		TLAN_HC_INT_ON		0x00000400
+#define		TLAN_HC_AC_MASK		0x000000FF
+#define TLAN_CH_PARM			0x04
+#define TLAN_DIO_ADR			0x08
+#define		TLAN_DA_ADR_INC		0x8000
+#define		TLAN_DA_RAM_ADR		0x4000
+#define TLAN_HOST_INT			0x0A
+#define		TLAN_HI_IV_MASK		0x1FE0
+#define		TLAN_HI_IT_MASK		0x001C
+#define TLAN_DIO_DATA			0x0C
+
+
+/* ThunderLAN Internal Register DIO Offsets */
+
+#define TLAN_NET_CMD			0x00
+#define		TLAN_NET_CMD_NRESET	0x80
+#define		TLAN_NET_CMD_NWRAP	0x40
+#define		TLAN_NET_CMD_CSF	0x20
+#define		TLAN_NET_CMD_CAF	0x10
+#define		TLAN_NET_CMD_NOBRX	0x08
+#define		TLAN_NET_CMD_DUPLEX	0x04
+#define		TLAN_NET_CMD_TRFRAM	0x02
+#define		TLAN_NET_CMD_TXPACE	0x01
+#define TLAN_NET_SIO			0x01
+#define 	TLAN_NET_SIO_MINTEN	0x80
+#define		TLAN_NET_SIO_ECLOK	0x40
+#define		TLAN_NET_SIO_ETXEN	0x20
+#define		TLAN_NET_SIO_EDATA	0x10
+#define		TLAN_NET_SIO_NMRST	0x08
+#define		TLAN_NET_SIO_MCLK	0x04
+#define		TLAN_NET_SIO_MTXEN	0x02
+#define		TLAN_NET_SIO_MDATA	0x01
+#define TLAN_NET_STS			0x02
+#define		TLAN_NET_STS_MIRQ	0x80
+#define		TLAN_NET_STS_HBEAT	0x40
+#define		TLAN_NET_STS_TXSTOP	0x20
+#define		TLAN_NET_STS_RXSTOP	0x10
+#define		TLAN_NET_STS_RSRVD	0x0F
+#define TLAN_NET_MASK			0x03
+#define		TLAN_NET_MASK_MASK7	0x80
+#define		TLAN_NET_MASK_MASK6	0x40
+#define		TLAN_NET_MASK_MASK5	0x20
+#define		TLAN_NET_MASK_MASK4	0x10
+#define		TLAN_NET_MASK_RSRVD	0x0F
+#define TLAN_NET_CONFIG			0x04
+#define 	TLAN_NET_CFG_RCLK	0x8000
+#define		TLAN_NET_CFG_TCLK	0x4000
+#define		TLAN_NET_CFG_BIT	0x2000
+#define		TLAN_NET_CFG_RXCRC	0x1000
+#define		TLAN_NET_CFG_PEF	0x0800
+#define		TLAN_NET_CFG_1FRAG	0x0400
+#define		TLAN_NET_CFG_1CHAN	0x0200
+#define		TLAN_NET_CFG_MTEST	0x0100
+#define		TLAN_NET_CFG_PHY_EN	0x0080
+#define		TLAN_NET_CFG_MSMASK	0x007F
+#define TLAN_MAN_TEST			0x06
+#define TLAN_DEF_VENDOR_ID		0x08
+#define TLAN_DEF_DEVICE_ID		0x0A
+#define TLAN_DEF_REVISION		0x0C
+#define TLAN_DEF_SUBCLASS		0x0D
+#define TLAN_DEF_MIN_LAT		0x0E
+#define TLAN_DEF_MAX_LAT		0x0F
+#define TLAN_AREG_0			0x10
+#define TLAN_AREG_1			0x16
+#define TLAN_AREG_2			0x1C
+#define TLAN_AREG_3			0x22
+#define TLAN_HASH_1			0x28
+#define TLAN_HASH_2			0x2C
+#define TLAN_GOOD_TX_FRMS		0x30
+#define TLAN_TX_UNDERUNS		0x33
+#define TLAN_GOOD_RX_FRMS		0x34
+#define TLAN_RX_OVERRUNS		0x37
+#define TLAN_DEFERRED_TX		0x38
+#define TLAN_CRC_ERRORS			0x3A
+#define TLAN_CODE_ERRORS		0x3B
+#define TLAN_MULTICOL_FRMS		0x3C
+#define TLAN_SINGLECOL_FRMS		0x3E
+#define TLAN_EXCESSCOL_FRMS		0x40
+#define TLAN_LATE_COLS			0x41
+#define TLAN_CARRIER_LOSS		0x42
+#define TLAN_ACOMMIT			0x43
+#define TLAN_LED_REG			0x44
+#define		TLAN_LED_ACT		0x10
+#define		TLAN_LED_LINK		0x01
+#define TLAN_BSIZE_REG			0x45
+#define TLAN_MAX_RX			0x46
+#define TLAN_INT_DIS			0x48
+#define		TLAN_ID_TX_EOC		0x04
+#define		TLAN_ID_RX_EOF		0x02
+#define		TLAN_ID_RX_EOC		0x01
+
+
+
+/* ThunderLAN Interrupt Codes */
+
+#define TLAN_INT_NUMBER_OF_INTS	8
+
+#define TLAN_INT_NONE			0x0000
+#define TLAN_INT_TX_EOF			0x0001
+#define TLAN_INT_STAT_OVERFLOW		0x0002
+#define TLAN_INT_RX_EOF			0x0003
+#define TLAN_INT_DUMMY			0x0004
+#define TLAN_INT_TX_EOC			0x0005
+#define TLAN_INT_STATUS_CHECK		0x0006
+#define TLAN_INT_RX_EOC			0x0007
+
+
+
+/* ThunderLAN MII Registers */
+
+/* Generic MII/PHY Registers */
+
+#define MII_GEN_CTL			0x00
+#define 	MII_GC_RESET		0x8000
+#define		MII_GC_LOOPBK		0x4000
+#define		MII_GC_SPEEDSEL		0x2000
+#define		MII_GC_AUTOENB		0x1000
+#define		MII_GC_PDOWN		0x0800
+#define		MII_GC_ISOLATE		0x0400
+#define		MII_GC_AUTORSRT		0x0200
+#define		MII_GC_DUPLEX		0x0100
+#define		MII_GC_COLTEST		0x0080
+#define		MII_GC_RESERVED		0x007F
+#define MII_GEN_STS			0x01
+#define		MII_GS_100BT4		0x8000
+#define		MII_GS_100BTXFD		0x4000
+#define		MII_GS_100BTXHD		0x2000
+#define		MII_GS_10BTFD		0x1000
+#define		MII_GS_10BTHD		0x0800
+#define		MII_GS_RESERVED		0x07C0
+#define		MII_GS_AUTOCMPLT	0x0020
+#define		MII_GS_RFLT		0x0010
+#define		MII_GS_AUTONEG		0x0008
+#define		MII_GS_LINK		0x0004
+#define		MII_GS_JABBER		0x0002
+#define		MII_GS_EXTCAP		0x0001
+#define MII_GEN_ID_HI			0x02
+#define MII_GEN_ID_LO			0x03
+#define 	MII_GIL_OUI		0xFC00
+#define 	MII_GIL_MODEL		0x03F0
+#define 	MII_GIL_REVISION	0x000F
+#define MII_AN_ADV			0x04
+#define MII_AN_LPA			0x05
+#define MII_AN_EXP			0x06
+
+/* ThunderLAN Specific MII/PHY Registers */
+
+#define TLAN_TLPHY_ID			0x10
+#define TLAN_TLPHY_CTL			0x11
+#define 	TLAN_TC_IGLINK		0x8000
+#define		TLAN_TC_SWAPOL		0x4000
+#define		TLAN_TC_AUISEL		0x2000
+#define		TLAN_TC_SQEEN		0x1000
+#define		TLAN_TC_MTEST		0x0800
+#define		TLAN_TC_RESERVED	0x07F8
+#define		TLAN_TC_NFEW		0x0004
+#define		TLAN_TC_INTEN		0x0002
+#define		TLAN_TC_TINT		0x0001
+#define TLAN_TLPHY_STS			0x12
+#define		TLAN_TS_MINT		0x8000
+#define		TLAN_TS_PHOK		0x4000
+#define		TLAN_TS_POLOK		0x2000
+#define		TLAN_TS_TPENERGY	0x1000
+#define		TLAN_TS_RESERVED	0x0FFF
+#define TLAN_TLPHY_PAR			0x19
+#define		TLAN_PHY_CIM_STAT	0x0020
+#define		TLAN_PHY_SPEED_100	0x0040
+#define		TLAN_PHY_DUPLEX_FULL	0x0080
+#define		TLAN_PHY_AN_EN_STAT     0x0400
+
+/* National Sem. & Level1 PHY id's */
+#define NAT_SEM_ID1			0x2000
+#define NAT_SEM_ID2			0x5C01
+#define LEVEL1_ID1			0x7810
+#define LEVEL1_ID2			0x0000
+
+#define CIRC_INC( a, b ) if ( ++a >= b ) a = 0
+
+/* Routines to access internal registers. */
+
+inline u8 TLan_DioRead8(u16 base_addr, u16 internal_addr)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	return (inb((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x3)));
+
+}				/* TLan_DioRead8 */
+
+
+
+
+inline u16 TLan_DioRead16(u16 base_addr, u16 internal_addr)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	return (inw((base_addr + TLAN_DIO_DATA) + (internal_addr & 0x2)));
+
+}				/* TLan_DioRead16 */
+
+
+
+
+inline u32 TLan_DioRead32(u16 base_addr, u16 internal_addr)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	return (inl(base_addr + TLAN_DIO_DATA));
+
+}				/* TLan_DioRead32 */
+
+
+
+
+inline void TLan_DioWrite8(u16 base_addr, u16 internal_addr, u8 data)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	outb(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x3));
+
+}
+
+
+
+
+inline void TLan_DioWrite16(u16 base_addr, u16 internal_addr, u16 data)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	outw(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+
+}
+
+
+
+
+inline void TLan_DioWrite32(u16 base_addr, u16 internal_addr, u32 data)
+{
+	outw(internal_addr, base_addr + TLAN_DIO_ADR);
+	outl(data, base_addr + TLAN_DIO_DATA + (internal_addr & 0x2));
+
+}
+
+
+
+#if 0
+inline void TLan_ClearBit(u8 bit, u16 port)
+{
+	outb_p(inb_p(port) & ~bit, port);
+}
+
+
+
+
+inline int TLan_GetBit(u8 bit, u16 port)
+{
+	return ((int) (inb_p(port) & bit));
+}
+
+
+
+
+inline void TLan_SetBit(u8 bit, u16 port)
+{
+	outb_p(inb_p(port) | bit, port);
+}
+#endif
+
+#define TLan_ClearBit( bit, port )	outb_p(inb_p(port) & ~bit, port)
+#define TLan_GetBit( bit, port )	((int) (inb_p(port) & bit))
+#define TLan_SetBit( bit, port )	outb_p(inb_p(port) | bit, port)
+
+#ifdef I_LIKE_A_FAST_HASH_FUNCTION
+/* given 6 bytes, view them as 8 6-bit numbers and return the XOR of those */
+/* the code below is about seven times as fast as the original code */
+inline u32 TLan_HashFunc(u8 * a)
+{
+	u8 hash;
+
+	hash = (a[0] ^ a[3]);	/* & 077 */
+	hash ^= ((a[0] ^ a[3]) >> 6);	/* & 003 */
+	hash ^= ((a[1] ^ a[4]) << 2);	/* & 074 */
+	hash ^= ((a[1] ^ a[4]) >> 4);	/* & 017 */
+	hash ^= ((a[2] ^ a[5]) << 4);	/* & 060 */
+	hash ^= ((a[2] ^ a[5]) >> 2);	/* & 077 */
+
+	return (hash & 077);
+}
+
+#else				/* original code */
+
+inline u32 xor(u32 a, u32 b)
+{
+	return ((a && !b) || (!a && b));
+}
+
+#define XOR8( a, b, c, d, e, f, g, h )	xor( a, xor( b, xor( c, xor( d, xor( e, xor( f, xor( g, h ) ) ) ) ) ) )
+#define DA( a, bit )					( ( (u8) a[bit/8] ) & ( (u8) ( 1 << bit%8 ) ) )
+
+inline u32 TLan_HashFunc(u8 * a)
+{
+	u32 hash;
+
+	hash =
+	    XOR8(DA(a, 0), DA(a, 6), DA(a, 12), DA(a, 18), DA(a, 24),
+		 DA(a, 30), DA(a, 36), DA(a, 42));
+	hash |=
+	    XOR8(DA(a, 1), DA(a, 7), DA(a, 13), DA(a, 19), DA(a, 25),
+		 DA(a, 31), DA(a, 37), DA(a, 43)) << 1;
+	hash |=
+	    XOR8(DA(a, 2), DA(a, 8), DA(a, 14), DA(a, 20), DA(a, 26),
+		 DA(a, 32), DA(a, 38), DA(a, 44)) << 2;
+	hash |=
+	    XOR8(DA(a, 3), DA(a, 9), DA(a, 15), DA(a, 21), DA(a, 27),
+		 DA(a, 33), DA(a, 39), DA(a, 45)) << 3;
+	hash |=
+	    XOR8(DA(a, 4), DA(a, 10), DA(a, 16), DA(a, 22), DA(a, 28),
+		 DA(a, 34), DA(a, 40), DA(a, 46)) << 4;
+	hash |=
+	    XOR8(DA(a, 5), DA(a, 11), DA(a, 17), DA(a, 23), DA(a, 29),
+		 DA(a, 35), DA(a, 41), DA(a, 47)) << 5;
+
+	return hash;
+
+}
+
+#endif				/* I_LIKE_A_FAST_HASH_FUNCTION */
Index: netboot/ns8390.c
===================================================================
--- netboot/ns8390.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/ns8390.c	(.../trunk)	(revision 112)
@@ -13,11 +13,15 @@
   the proper functioning of this software, nor do the authors assume any
   responsibility for damages incurred with its use.
 
+Multicast support added by Timothy Legge (timlegge@users.sourceforge.net) 09/28/2003
+Relocation support added by Ken Yap (ken_yap@users.sourceforge.net) 28/12/02
 3c503 support added by Bill Paul (wpaul@ctr.columbia.edu) on 11/15/94
 SMC8416 support added by Bill Paul (wpaul@ctr.columbia.edu) on 12/25/94
 3c503 PIO support added by Jim Hague (jim.hague@acm.org) on 2/17/98
 RX overrun by Klaus Espenlaub (espenlaub@informatik.uni-ulm.de) on 3/10/99
   parts taken from the Linux 8390 driver (by Donald Becker and Paul Gortmaker)
+SMC8416 PIO support added by Andrew Bettison (andrewb@zip.com.au) on 4/3/02
+  based on the Linux 8390 driver (by Donald Becker and Paul Gortmaker)
 
 **************************************************************************/
 
@@ -26,13 +30,17 @@
 #include "ns8390.h"
 #ifdef	INCLUDE_NS8390
 #include "pci.h"
+#else
+#include "isa.h"
 #endif
-#include "cards.h"
 
-static unsigned char	eth_vendor, eth_flags, eth_laar;
+static unsigned char	eth_vendor, eth_flags;
+#ifdef	INCLUDE_WD
+static unsigned char	eth_laar;
+#endif
 static unsigned short	eth_nic_base, eth_asic_base;
 static unsigned char	eth_memsize, eth_rx_start, eth_tx_start;
-static Address		eth_bmem, eth_rmem;
+static unsigned long    eth_bmem, eth_rmem;
 static unsigned char	eth_drain_receiver;
 
 #ifdef	INCLUDE_WD
@@ -66,6 +74,7 @@
 #endif
 
 #if	defined(INCLUDE_WD)
+#define	ASIC_PIO	WD_IAR
 #define	eth_probe	wd_probe
 #if	defined(INCLUDE_3C503) || defined(INCLUDE_NE) || defined(INCLUDE_NS8390)
 Error you must only define one of INCLUDE_WD, INCLUDE_3C503, INCLUDE_NE, INCLUDE_NS8390
@@ -101,13 +110,16 @@
 #endif
 #endif
 
-#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM))
+#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM)) || (defined(INCLUDE_WD) && defined(WD_790_PIO))
 /**************************************************************************
 ETH_PIO_READ - Read a frame via Programmed I/O
 **************************************************************************/
 static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt)
 {
-	if (eth_flags & FLAG_16BIT) { ++cnt; cnt &= ~1; }
+#ifdef	INCLUDE_WD
+	outb(src & 0xff, eth_asic_base + WD_GP2);
+	outb(src >> 8, eth_asic_base + WD_GP2);
+#else
 	outb(D8390_COMMAND_RD2 |
 		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
 	outb(cnt, eth_nic_base + D8390_P0_RBCR0);
@@ -122,9 +134,10 @@
 	outb(src >> 8, eth_asic_base + _3COM_DAMSB);
 	outb(t503_output | _3COM_CR_START, eth_asic_base + _3COM_CR);
 #endif
+#endif
 
 	if (eth_flags & FLAG_16BIT)
-		cnt >>= 1;
+		cnt = (cnt + 1) >> 1;
 
 	while(cnt--) {
 #ifdef	INCLUDE_3C503
@@ -153,7 +166,10 @@
 #ifdef	COMPEX_RL2000_FIX
 	unsigned int x;
 #endif	/* COMPEX_RL2000_FIX */
-	if (eth_flags & FLAG_16BIT) { ++cnt; cnt &= ~1; }
+#ifdef	INCLUDE_WD
+	outb(dst & 0xff, eth_asic_base + WD_GP2);
+	outb(dst >> 8, eth_asic_base + WD_GP2);
+#else
 	outb(D8390_COMMAND_RD2 |
 		D8390_COMMAND_STA, eth_nic_base + D8390_P0_COMMAND);
 	outb(D8390_ISR_RDC, eth_nic_base + D8390_P0_ISR);
@@ -170,9 +186,10 @@
 
 	outb(t503_output | _3COM_CR_DDIR | _3COM_CR_START, eth_asic_base + _3COM_CR);
 #endif
+#endif
 
 	if (eth_flags & FLAG_16BIT)
-		cnt >>= 1;
+		cnt = (cnt + 1) >> 1;
 
 	while(cnt--)
 	{
@@ -201,18 +218,41 @@
 	if (x >= COMPEX_RL2000_TRIES)
 		printf("Warning: Compex RL2000 aborted wait!\n");
 #endif	/* COMPEX_RL2000_FIX */
+#ifndef	INCLUDE_WD
 	while((inb(eth_nic_base + D8390_P0_ISR) & D8390_ISR_RDC)
 		!= D8390_ISR_RDC);
 #endif
+#endif
 }
 #else
 /**************************************************************************
 ETH_PIO_READ - Dummy routine when NE2000 not compiled in
 **************************************************************************/
-static void eth_pio_read(unsigned int src, unsigned char *dst, unsigned int cnt) {}
+static void eth_pio_read(unsigned int src __unused, unsigned char *dst  __unused, unsigned int cnt __unused) {}
 #endif
 
+
 /**************************************************************************
+enable_multycast - Enable Multicast
+**************************************************************************/
+static void enable_multicast(unsigned short eth_nic_base) 
+{
+	unsigned char mcfilter[8];
+	int i;
+	memset(mcfilter, 0xFF, 8);
+	outb(4, eth_nic_base+D8390_P0_RCR);	
+	outb(D8390_COMMAND_RD2 + D8390_COMMAND_PS1, eth_nic_base + D8390_P0_COMMAND);
+	for(i=0;i<8;i++)
+	{
+		outb(mcfilter[i], eth_nic_base + 8 + i);
+		if(inb(eth_nic_base + 8 + i)!=mcfilter[i])
+			printf("Error SMC 83C690 Multicast filter read/write mishap %d\n",i);
+	}
+	outb(D8390_COMMAND_RD2 + D8390_COMMAND_PS0, eth_nic_base + D8390_P0_COMMAND);
+	outb(4 | 0x08, eth_nic_base+D8390_P0_RCR);
+}
+
+/**************************************************************************
 NS8390_RESET - Reset adapter
 **************************************************************************/
 static void ns8390_reset(struct nic *nic)
@@ -238,8 +278,15 @@
 	outb(eth_tx_start, eth_nic_base+D8390_P0_TPSR);
 	outb(eth_rx_start, eth_nic_base+D8390_P0_PSTART);
 #ifdef	INCLUDE_WD
-	if (eth_flags & FLAG_790) outb(0, eth_nic_base + 0x09);
+	if (eth_flags & FLAG_790) {
+#ifdef	WD_790_PIO
+		outb(0x10, eth_asic_base + 0x06); /* disable interrupts, enable PIO */
+		outb(0x01, eth_nic_base + 0x09); /* enable ring read auto-wrap */
+#else
+		outb(0, eth_nic_base + 0x09);
 #endif
+	}
+#endif
 	outb(eth_memsize, eth_nic_base+D8390_P0_PSTOP);
 	outb(eth_memsize - 1, eth_nic_base+D8390_P0_BOUND);
 	outb(0xFF, eth_nic_base+D8390_P0_ISR);
@@ -266,9 +313,11 @@
 		outb(D8390_COMMAND_PS0 |
 			D8390_COMMAND_RD2 | D8390_COMMAND_STA, eth_nic_base+D8390_P0_COMMAND);
 	outb(0xFF, eth_nic_base+D8390_P0_ISR);
-	outb(0, eth_nic_base+D8390_P0_TCR);
-	outb(4, eth_nic_base+D8390_P0_RCR);	/* allow broadcast frames */
+	outb(0, eth_nic_base+D8390_P0_TCR);	/* transmitter on */
+	outb(4, eth_nic_base+D8390_P0_RCR);	/* allow rx broadcast frames */
 
+	enable_multicast(eth_nic_base);
+
 #ifdef	INCLUDE_3C503
         /*
          * No way to tell whether or not we're supposed to use
@@ -344,50 +393,52 @@
 	unsigned int s,			/* size */
 	const char *p)			/* Packet */
 {
+	unsigned long eth_vmem = bus_to_virt(eth_bmem);
 #ifdef	INCLUDE_3C503
         if (!(eth_flags & FLAG_PIO)) {
-                memcpy((char *)eth_bmem, d, ETH_ALEN);	/* dst */
-                memcpy((char *)eth_bmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
-                *((char *)eth_bmem+12) = t>>8;		/* type */
-                *((char *)eth_bmem+13) = t;
-                memcpy((char *)eth_bmem+ETH_HLEN, p, s);
+                memcpy((char *)eth_vmem, d, ETH_ALEN);	/* dst */
+                memcpy((char *)eth_vmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
+                *((char *)eth_vmem+12) = t>>8;		/* type */
+                *((char *)eth_vmem+13) = t;
+                memcpy((char *)eth_vmem+ETH_HLEN, p, s);
                 s += ETH_HLEN;
-                while (s < ETH_ZLEN) *((char *)eth_bmem+(s++)) = 0;
+                while (s < ETH_ZLEN) *((char *)eth_vmem+(s++)) = 0;
         }
 #endif
 
 #ifdef	INCLUDE_WD
-	/* Memory interface */
 	if (eth_flags & FLAG_16BIT) {
 		outb(eth_laar | WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
 		inb(0x84);
 	}
+#ifndef	WD_790_PIO
+	/* Memory interface */
 	if (eth_flags & FLAG_790) {
 		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
 	inb(0x84);
-	memcpy((char *)eth_bmem, d, ETH_ALEN);	/* dst */
-	memcpy((char *)eth_bmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
-	*((char *)eth_bmem+12) = t>>8;		/* type */
-	*((char *)eth_bmem+13) = t;
-	memcpy((char *)eth_bmem+ETH_HLEN, p, s);
+	memcpy((char *)eth_vmem, d, ETH_ALEN);	/* dst */
+	memcpy((char *)eth_vmem+ETH_ALEN, nic->node_addr, ETH_ALEN); /* src */
+	*((char *)eth_vmem+12) = t>>8;		/* type */
+	*((char *)eth_vmem+13) = t;
+	memcpy((char *)eth_vmem+ETH_HLEN, p, s);
 	s += ETH_HLEN;
-	while (s < ETH_ZLEN) *((char *)eth_bmem+(s++)) = 0;
+	while (s < ETH_ZLEN) *((char *)eth_vmem+(s++)) = 0;
 	if (eth_flags & FLAG_790) {
 		outb(0, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
-	if (eth_flags & FLAG_16BIT) {
-		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
-		inb(0x84);
-	}
+#else
+	inb(0x84);
 #endif
+#endif
 
 #if	defined(INCLUDE_3C503)
-	if (eth_flags & FLAG_PIO) {
+	if (eth_flags & FLAG_PIO)
 #endif
-#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM))
+#if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390) || (defined(INCLUDE_3C503) && !defined(T503_SHMEM)) || (defined(INCLUDE_WD) && defined(WD_790_PIO))
+	{
 		/* Programmed I/O */
 		unsigned short type;
 		type = (t >> 8) | (t << 8);
@@ -398,12 +449,16 @@
 		eth_pio_write(p, (eth_tx_start<<8)+ETH_HLEN, s);
 		s += ETH_HLEN;
 		if (s < ETH_ZLEN) s = ETH_ZLEN;
+	}
 #endif
 #if	defined(INCLUDE_3C503)
-	}
 #endif
 
 #ifdef	INCLUDE_WD
+	if (eth_flags & FLAG_16BIT) {
+		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
+		inb(0x84);
+	}
 	if (eth_flags & FLAG_790)
 		outb(D8390_COMMAND_PS0 |
 			D8390_COMMAND_STA, eth_nic_base+D8390_P0_COMMAND);
@@ -458,17 +513,19 @@
 		outb(eth_laar | WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
 		inb(0x84);
 	}
+#ifndef	WD_790_PIO
 	if (eth_flags & FLAG_790) {
 		outb(WD_MSR_MENB, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
+#endif
 	inb(0x84);
 #endif
 	pktoff = next << 8;
 	if (eth_flags & FLAG_PIO)
 		eth_pio_read(pktoff, (char *)&pkthdr, 4);
 	else
-		memcpy(&pkthdr, (char *)eth_rmem + pktoff, 4);
+		memcpy(&pkthdr, bus_to_virt(eth_rmem + pktoff), 4);
 	pktoff += sizeof(pkthdr);
 	/* incoming length includes FCS so must sub 4 */
 	len = pkthdr.len - 4;
@@ -486,7 +543,7 @@
 			if (eth_flags & FLAG_PIO)
 				eth_pio_read(pktoff, p, frag);
 			else
-				memcpy(p, (char *)eth_rmem + pktoff, frag);
+				memcpy(p, bus_to_virt(eth_rmem + pktoff), frag);
 			pktoff = eth_rx_start << 8;
 			p += frag;
 			len -= frag;
@@ -495,14 +552,16 @@
 		if (eth_flags & FLAG_PIO)
 			eth_pio_read(pktoff, p, len);
 		else
-			memcpy(p, (char *)eth_rmem + pktoff, len);
+			memcpy(p, bus_to_virt(eth_rmem + pktoff), len);
 		ret = 1;
 	}
 #ifdef	INCLUDE_WD
+#ifndef	WD_790_PIO
 	if (eth_flags & FLAG_790) {
 		outb(0, eth_asic_base + WD_MSR);
 		inb(0x84);
 	}
+#endif
 	if (eth_flags & FLAG_16BIT) {
 		outb(eth_laar & ~WD_LAAR_M16EN, eth_asic_base + WD_LAAR);
 		inb(0x84);
@@ -519,31 +578,39 @@
 /**************************************************************************
 NS8390_DISABLE - Turn off adapter
 **************************************************************************/
-static void ns8390_disable(struct nic *nic)
+static void ns8390_disable(struct dev *dev)
 {
+	struct nic *nic = (struct nic *)dev;
+	/* reset and disable merge */
+	ns8390_reset(nic);
 }
 
 /**************************************************************************
 ETH_PROBE - Look for an adapter
 **************************************************************************/
 #ifdef	INCLUDE_NS8390
-struct nic *eth_probe(struct nic *nic, unsigned short *probe_addrs,
-		      struct pci_device *pci)
+static int eth_probe (struct dev *dev, struct pci_device *pci)
 #else
-struct nic *eth_probe(struct nic *nic, unsigned short *probe_addrs)
+static int eth_probe (struct dev *dev, unsigned short *probe_addrs __unused)
 #endif
 {
+	struct nic *nic = (struct nic *)dev;
 	int i;
-	struct wd_board *brd;
-	unsigned short chksum;
-	unsigned char c;
+#ifdef INCLUDE_NS8390
+	unsigned short pci_probe_addrs[] = { pci->ioaddr, 0 };
+	unsigned short *probe_addrs = pci_probe_addrs;
+#endif
 	eth_vendor = VENDOR_NONE;
 	eth_drain_receiver = 0;
 
 #ifdef	INCLUDE_WD
+{
 	/******************************************************************
 	Search for WD/SMC cards
 	******************************************************************/
+	struct wd_board *brd;
+	unsigned short chksum;
+	unsigned char c;
 	for (eth_asic_base = WD_LOW_BASE; eth_asic_base <= WD_HIGH_BASE;
 		eth_asic_base += 0x20) {
 		chksum = 0;
@@ -582,8 +649,9 @@
 	} else
 		eth_bmem = WD_DEFAULT_MEM;
 	if (brd->id == TYPE_SMC8216T || brd->id == TYPE_SMC8216C) {
-		*((unsigned int *)(eth_bmem + 8192)) = (unsigned int)0;
-		if (*((unsigned int *)(eth_bmem + 8192))) {
+		/* from Linux driver, 8416BT detects as 8216 sometimes */
+		unsigned int addr = inb(eth_asic_base + 0xb);
+		if (((addr >> 4) & 3) == 0) {
 			brd += 2;
 			eth_memsize = brd->memsize;
 		}
@@ -592,19 +660,27 @@
 	for (i=0; i<ETH_ALEN; i++) {
 		nic->node_addr[i] = inb(i+eth_asic_base+WD_LAR);
 	}
-	printf("\n%s base %#hx, memory %#hx, addr %!\n",
-		brd->name, eth_asic_base, eth_bmem, nic->node_addr);
+	printf("\n%s base %#hx", brd->name, eth_asic_base);
 	if (eth_flags & FLAG_790) {
+#ifdef	WD_790_PIO
+		printf(", PIO mode, addr %!\n", nic->node_addr);
+		eth_bmem = 0;
+		eth_flags |= FLAG_PIO;		/* force PIO mode */
+		outb(0, eth_asic_base+WD_MSR);
+#else
+		printf(", memory %#x, addr %!\n", eth_bmem, nic->node_addr);
 		outb(WD_MSR_MENB, eth_asic_base+WD_MSR);
 		outb((inb(eth_asic_base+0x04) |
 			0x80), eth_asic_base+0x04);
-		outb((((unsigned)eth_bmem >> 13) & 0x0F) |
-			(((unsigned)eth_bmem >> 11) & 0x40) |
+		outb(((unsigned)(eth_bmem >> 13) & 0x0F) |
+			((unsigned)(eth_bmem >> 11) & 0x40) |
 			(inb(eth_asic_base+0x0B) & 0xB0), eth_asic_base+0x0B);
 		outb((inb(eth_asic_base+0x04) &
 			~0x80), eth_asic_base+0x04);
+#endif
 	} else {
-		outb((((unsigned)eth_bmem >> 13) & 0x3F) | 0x40, eth_asic_base+WD_MSR);
+		printf(", memory %#x, addr %!\n", eth_bmem, nic->node_addr);
+		outb(((unsigned)(eth_bmem >> 13) & 0x3F) | 0x40, eth_asic_base+WD_MSR);
 	}
 	if (eth_flags & FLAG_16BIT) {
 		if (eth_flags & FLAG_790) {
@@ -624,8 +700,14 @@
 		}
 		inb(0x84);
 	}
+}
 #endif
 #ifdef	INCLUDE_3C503
+#ifdef	T503_AUI
+	nic->flags = 1;		/* aui */
+#else
+	nic->flags = 0;		/* no aui */
+#endif
         /******************************************************************
         Search for 3Com 3c503 if no WD/SMC cards
         ******************************************************************/
@@ -712,7 +794,7 @@
                 if (eth_flags & FLAG_PIO)
 			printf("PIO mode");
                 else
-			printf("memory %#hx", eth_bmem);
+			printf("memory %#x", eth_bmem);
                 for (i=0; i<ETH_ALEN; i++) {
                         nic->node_addr[i] = inb(eth_nic_base+i);
                 }
@@ -734,9 +816,9 @@
          */
 
 		if (!(eth_flags & FLAG_PIO)) {
-			memset((char *)eth_bmem, 0, 0x2000);
+			memset(bus_to_virt(eth_bmem), 0, 0x2000);
 			for(i = 0; i < 0x2000; ++i)
-				if (*(((char *)eth_bmem)+i)) {
+				if (*((char *)(bus_to_virt(eth_bmem+i)))) {
 					printf ("Failed to clear 3c503 shared mem.\n");
 					return (0);
 				}
@@ -749,9 +831,11 @@
         }
 #endif
 #if	defined(INCLUDE_NE) || defined(INCLUDE_NS8390)
+{
 	/******************************************************************
 	Search for NE1000/2000 if no WD/SMC or 3com cards
 	******************************************************************/
+	unsigned char c;
 	if (eth_vendor == VENDOR_NONE) {
 		char romdata[16], testbuf[32];
 		int idx;
@@ -814,19 +898,88 @@
 			(eth_flags & FLAG_16BIT) ? '2' : '1', eth_nic_base,
 			nic->node_addr);
 	}
+}
 #endif
 	if (eth_vendor == VENDOR_NONE)
 		return(0);
         if (eth_vendor != VENDOR_3COM)
 		eth_rmem = eth_bmem;
 	ns8390_reset(nic);
-	nic->reset = ns8390_reset;
-	nic->poll = ns8390_poll;
+
+	dev->disable  = ns8390_disable; 
+	nic->poll     = ns8390_poll;
 	nic->transmit = ns8390_transmit;
-	nic->disable = ns8390_disable;
-	return(nic);
+
+        /* Based on PnP ISA map */
+#ifdef	INCLUDE_WD
+        dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+        dev->devid.device_id = htons(0x812a);
+#endif
+#ifdef	INCLUDE_3C503
+        dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+        dev->devid.device_id = htons(0x80f3);
+#endif
+#ifdef	INCLUDE_NE
+        dev->devid.vendor_id = htons(GENERIC_ISAPNP_VENDOR);
+        dev->devid.device_id = htons(0x80d6);
+#endif
+	return 1;
 }
 
+#ifdef	INCLUDE_WD
+static struct isa_driver wd_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "WD",
+	.probe   = wd_probe,
+	.ioaddrs = 0, 
+};
+#endif
+
+#ifdef	INCLUDE_3c503
+static struct isa_driver t503_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "3C503",
+	.probe   = t503_probe,
+	.ioaddrs = 0, 
+};
+#endif
+
+#ifdef	INCLUDE_NE
+static struct isa_driver ne_driver __isa_driver = {
+	.type    = NIC_DRIVER,
+	.name    = "NE*000",
+	.probe   = ne_probe,
+	.ioaddrs = 0, 
+};
+#endif
+
+#ifdef	INCLUDE_NS8390
+static struct pci_id nepci_nics[] = {
+/* A few NE2000 PCI clones, list not exhaustive */
+PCI_ROM(0x10ec, 0x8029, "rtl8029",      "Realtek 8029"),
+PCI_ROM(0x1186, 0x0300, "dlink-528",    "D-Link DE-528"),
+PCI_ROM(0x1050, 0x0940, "winbond940",   "Winbond NE2000-PCI"),		/* Winbond 86C940 / 89C940 */
+PCI_ROM(0x1050, 0x5a5a, "winbond940f",  "Winbond W89c940F"),		/* Winbond 89C940F */
+PCI_ROM(0x11f6, 0x1401, "compexrl2000", "Compex ReadyLink 2000"),
+PCI_ROM(0x8e2e, 0x3000, "ktiet32p2",    "KTI ET32P2"),
+PCI_ROM(0x4a14, 0x5000, "nv5000sc",     "NetVin NV5000SC"),
+PCI_ROM(0x12c3, 0x0058, "holtek80232",  "Holtek HT80232"),
+PCI_ROM(0x12c3, 0x5598, "holtek80229",  "Holtek HT80229"),
+PCI_ROM(0x10bd, 0x0e34, "surecom-ne34", "Surecom NE34"),
+PCI_ROM(0x1106, 0x0926, "via86c926",    "Via 86c926"),
+};
+
+struct pci_driver nepci_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "NE2000/PCI",
+	.probe    = nepci_probe,
+	.ids      = nepci_nics,
+	.id_count = sizeof(nepci_nics)/sizeof(nepci_nics[0]),
+	.class    = 0,
+};
+
+#endif /* INCLUDE_NS8390 */
+
 /*
  * Local variables:
  *  c-basic-offset: 8
Index: netboot/undi.h
===================================================================
--- netboot/undi.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/undi.h	(.../trunk)	(revision 112)
@@ -0,0 +1,241 @@
+/**************************************************************************
+Etherboot -  BOOTP/TFTP Bootstrap Program
+UNDI NIC driver for Etherboot - header file
+
+This file Copyright (C) 2003 Michael Brown <mbrown@fensystems.co.uk>
+of Fen Systems Ltd. (http://www.fensystems.co.uk/).  All rights
+reserved.
+
+$Id$
+***************************************************************************/
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+
+/* Include pxe.h from FreeBSD.
+ * pxe.h defines PACKED, which etherboot.h has already defined.
+ */
+
+#undef PACKED
+#include "pxe.h"
+
+/* __undi_call is the assembler wrapper to the real-mode UNDI calls.
+ * Pass it the real-mode segment:offset address of an undi_call_info_t
+ * structure.  The parameters are only uint16_t, but GCC will push
+ * them on the stack as uint32_t anyway for the sake of alignment.  We
+ * specify them here as uint32_t to remove ambiguity.
+ */
+
+typedef struct undi_call_info {
+	SEGOFF16_t	routine;
+	uint16_t	stack[3];
+} undi_call_info_t;
+
+typedef uint16_t PXENV_EXIT_t;
+#define PXENV_EXIT_SUCCESS 0x0000
+#define PXENV_EXIT_FAILURE 0x0001
+PXENV_EXIT_t __undi_call ( uint32_t, uint32_t );
+
+/* The UNDI loader parameter structure is not defined in pxe.h
+ */
+
+typedef struct undi_loader {
+	PXENV_STATUS_t	status;
+	uint16_t	ax;
+	uint16_t	bx;
+	uint16_t	dx;
+	uint16_t	di;
+	uint16_t	es;
+	uint16_t	undi_ds;
+	uint16_t	undi_cs;
+	uint16_t	pxe_off;
+	uint16_t	pxenv_off;
+} undi_loader_t;
+
+/* A union that can function as the parameter block for any UNDI API call.
+ */
+
+typedef union pxenv_structure {
+	PXENV_STATUS_t			Status; /* Make it easy to read status
+						   for any operation */
+	undi_loader_t			loader;
+	t_PXENV_START_UNDI		start_undi;
+	t_PXENV_UNDI_STARTUP		undi_startup;
+	t_PXENV_UNDI_CLEANUP		undi_cleanup;
+	t_PXENV_UNDI_INITIALIZE		undi_initialize;
+	t_PXENV_UNDI_SHUTDOWN		undi_shutdown;
+	t_PXENV_UNDI_OPEN		undi_open;
+	t_PXENV_UNDI_CLOSE		undi_close;
+	t_PXENV_UNDI_TRANSMIT		undi_transmit;
+	t_PXENV_UNDI_SET_STATION_ADDRESS undi_set_station_address;
+	t_PXENV_UNDI_GET_INFORMATION	undi_get_information;
+	t_PXENV_UNDI_GET_IFACE_INFO	undi_get_iface_info;
+	t_PXENV_UNDI_ISR		undi_isr;
+	t_PXENV_STOP_UNDI		stop_undi;
+	t_PXENV_UNLOAD_STACK		unload_stack;
+
+	t_PXENV_TFTP_OPEN		tftp_open;
+	t_PXENV_TFTP_CLOSE		tftp_close;
+	t_PXENV_TFTP_READ		tftp_read;
+	t_PXENV_TFTP_READ_FILE		tftp_read_file;
+	t_PXENV_TFTP_GET_FSIZE		tftp_get_fsize;
+
+	t_PXENV_GET_CACHED_INFO		cached_info;
+} pxenv_structure_t;
+
+/* UNDI status codes
+ */
+
+#define PXENV_STATUS_SUCCESS			0x0000
+#define PXENV_STATUS_FAILURE			0x0001
+#define PXENV_STATUS_KEEP_UNDI			0x0004
+#define PXENV_STATUS_KEEP_ALL			0x0005
+#define PXENV_STATUS_UNDI_MEDIATEST_FAILED	0x0061
+
+/* BIOS PnP parameter block.  We scan for this so that we can pass it
+ * to the UNDI driver.
+ */
+
+#define PNP_BIOS_SIGNATURE ( ('$'<<0) + ('P'<<8) + ('n'<<16) + ('P'<<24) )
+typedef struct pnp_bios {
+	uint32_t	signature;
+	uint8_t		version;
+	uint8_t		length;
+	uint16_t	control;
+	uint8_t		checksum;
+	uint8_t		dontcare[24];
+} PACKED pnp_bios_t;
+
+/* Structures within the PXE ROM.
+ */
+
+#define ROM_SIGNATURE 0xaa55
+typedef struct rom {
+	uint16_t	signature;
+	uint8_t		unused[0x14];
+	uint16_t	undi_rom_id_off;
+	uint16_t	pcir_off;
+	uint16_t	pnp_off;
+} PACKED rom_t;	
+
+#define PCIR_SIGNATURE ( ('P'<<0) + ('C'<<8) + ('I'<<16) + ('R'<<24) )
+typedef struct pcir_header {
+	uint32_t	signature;
+	uint16_t	vendor_id;
+	uint16_t	device_id;
+} PACKED pcir_header_t;
+
+#define PNP_SIGNATURE ( ('$'<<0) + ('P'<<8) + ('n'<<16) + ('P'<<24) )
+typedef struct pnp_header {
+	uint32_t	signature;
+	uint8_t		struct_revision;
+	uint8_t		length;
+	uint16_t	next;
+	uint8_t		reserved;
+	uint8_t		checksum;
+	uint16_t	id[2];
+	uint16_t	manuf_str_off;
+	uint16_t	product_str_off;
+	uint8_t		base_type;
+	uint8_t		sub_type;
+	uint8_t		interface_type;
+	uint8_t		indicator;
+	uint16_t	boot_connect_off;
+	uint16_t	disconnect_off;
+	uint16_t	initialise_off;
+	uint16_t	reserved2;
+	uint16_t	info;
+} PACKED pnp_header_t;
+
+#define UNDI_SIGNATURE ( ('U'<<0) + ('N'<<8) + ('D'<<16) + ('I'<<24) )
+typedef struct undi_rom_id {
+	uint32_t	signature;
+	uint8_t		struct_length;
+	uint8_t		struct_cksum;
+	uint8_t		struct_rev;
+	uint8_t		undi_rev[3];
+	uint16_t	undi_loader_off;
+	uint16_t	stack_size;
+	uint16_t	data_size;
+	uint16_t	code_size;
+} PACKED undi_rom_id_t;
+
+/* Storage buffers that we need in base memory.  We collect these into
+ * a single structure to make allocation simpler.
+ */
+
+typedef struct undi_base_mem_xmit_data {
+	MAC_ADDR		destaddr;
+	t_PXENV_UNDI_TBD	tbd;
+} undi_base_mem_xmit_data_t;
+
+typedef struct undi_base_mem_data {
+	undi_call_info_t	undi_call_info;
+	pxenv_structure_t	pxs;
+	undi_base_mem_xmit_data_t xmit_data;
+	char			xmit_buffer[ETH_FRAME_LEN];
+	char			irq_handler[0]; /* Must be last in structure */
+} undi_base_mem_data_t;
+
+/* Macros and data structures used when freeing bits of base memory
+ * used by the UNDI driver.
+ */
+
+#define FIRING_SQUAD_TARGET_SIZE 8
+#define FIRING_SQUAD_TARGET_INDEX(x) ( (x) / FIRING_SQUAD_TARGET_SIZE )
+#define FIRING_SQUAD_TARGET_BIT(x) ( (x) % FIRING_SQUAD_TARGET_SIZE )
+typedef struct firing_squad_lineup {
+	uint8_t targets[ 640 / FIRING_SQUAD_TARGET_SIZE ];
+} firing_squad_lineup_t;
+typedef enum firing_squad_shoot {
+	DONTSHOOT = 0,
+	SHOOT = 1
+} firing_squad_shoot_t;
+
+/* Driver private data structure.
+ */
+
+typedef struct undi {
+	/* Pointers to various data structures */
+	pnp_bios_t		*pnp_bios;
+	rom_t			*rom;
+	undi_rom_id_t		*undi_rom_id;
+	pxe_t			*pxe;
+	undi_call_info_t	*undi_call_info;
+	pxenv_structure_t	*pxs;
+	undi_base_mem_xmit_data_t *xmit_data;
+	/* Pointers and sizes to keep track of allocated base memory */
+	undi_base_mem_data_t	*base_mem_data;
+	void			*driver_code;
+	size_t			driver_code_size;
+	void			*driver_data;
+	size_t			driver_data_size;
+	char			*xmit_buffer;
+	/* Flags.  We keep our own instead of trusting the UNDI driver
+	 * to have implemented PXENV_UNDI_GET_STATE correctly.  Plus
+	 * there's the small issue of PXENV_UNDI_GET_STATE being the
+	 * same API call as PXENV_STOP_UNDI...
+	 */
+	uint8_t prestarted;	/* pxenv_start_undi() has been called */
+	uint8_t started;	/* pxenv_undi_startup() has been called */
+	uint8_t	initialized;	/* pxenv_undi_initialize() has been called */
+	uint8_t opened;		/* pxenv_undi_open() has been called */
+	/* Parameters that we need to store for future reference
+	 */
+	struct pci_device	pci;
+	//irq_t			irq;
+        uint8_t irq;
+} undi_t;
+
+/* Constants
+ */
+
+#define HUNT_FOR_PIXIES 0
+#define HUNT_FOR_UNDI_ROMS 1
+
+/* IRQ/PIC/stuff we do not need */
+#define IRQ_NONE 0xff
Index: netboot/3c90x.c
===================================================================
--- netboot/3c90x.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/3c90x.c	(.../trunk)	(revision 112)
@@ -1,7 +1,7 @@
 /*
  * 3c90x.c -- This file implements the 3c90x driver for etherboot.  Written
  * by Greg Beeley, Greg.Beeley@LightSys.org.  Modified by Steve Smith,
- * Steve.Smith@Juno.Com
+ * Steve.Smith@Juno.Com. Alignment bug fix Neil Newell (nn@icenoir.net).
  *
  * This program Copyright (C) 1999 LightSys Technology Services, Inc.
  * Portions Copyright (C) 1999 Steve Smith
@@ -31,13 +31,15 @@
  *					Re-wrote poll and transmit for
  *					better error recovery and heavy
  *					network traffic operation
+ * v2.01    5-26-2993 NN Fixed driver alignment issue which
+ *                  caused system lockups if driver structures
+ *                  not 8-byte aligned.
  *
  */
 
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
 #define	XCVR_MAGIC	(0x5A00)
@@ -47,9 +49,6 @@
  **/
 #define	XMIT_RETRIES	250
 
-#undef	virt_to_bus
-#define	virt_to_bus(x)	((unsigned long)x)
-
 /*** Register definitions for the 3c905 ***/
 enum Registers
     {
@@ -225,7 +224,7 @@
     unsigned int	DataAddr;
     unsigned int	DataLength;
     }
-    TXD;
+    TXD __attribute__ ((aligned(8))); /* 64-bit aligned for bus mastering */
 
 /*** RX descriptor ***/
 typedef struct
@@ -235,7 +234,7 @@
     unsigned int	DataAddr;
     unsigned int	DataLength;
     }
-    RXD;
+    RXD __attribute__ ((aligned(8))); /* 64-bit aligned for bus mastering */
 
 /*** Global variables ***/
 static struct
@@ -393,12 +392,10 @@
  *** not alter the selected transceiver that we used to download the boot
  *** image.
  ***/
-static void
-a3c90x_reset(struct nic *nic)
+static void a3c90x_reset(void)
     {
+#ifdef	CFG_3C90X_PRESERVE_XCVR
     int cfg;
-
-#ifdef	CFG_3C90X_PRESERVE_XCVR
     /** Read the current InternalConfig value. **/
     a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winTxRxOptions3);
     cfg = inl(INF_3C90X.IOAddr + regInternalConfig_3_l);
@@ -473,7 +470,7 @@
  *** p - the pointer to the packet data itself.
  ***/
 static void
-a3c90x_transmit(struct nic *nic, const char *d, unsigned int t,
+a3c90x_transmit(struct nic *nic __unused, const char *d, unsigned int t,
                 unsigned int s, const char *p)
     {
 
@@ -553,7 +550,7 @@
 	if (status & 0x02)
 	    {
 	    printf("3C90X: Tx Reclaim Error (%hhX)\n", status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	else if (status & 0x04)
 	    {
@@ -572,18 +569,18 @@
 	else if (status & 0x10)
 	    {
 	    printf("3C90X: Tx Underrun (%hhX)\n", status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	else if (status & 0x20)
 	    {
 	    printf("3C90X: Tx Jabber (%hhX)\n", status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	else if ((status & 0x80) != 0x80)
 	    {
 	    printf("3C90X: Internal Error - Incomplete Transmission (%hhX)\n",
 	           status);
-	    a3c90x_reset(NULL);
+	    a3c90x_reset();
 	    }
 	}
 
@@ -663,12 +660,14 @@
  *** [Ken]
  ***/
 static void
-a3c90x_disable(struct nic *nic)
-    {
+a3c90x_disable(struct dev *dev __unused)
+{
+	/* reset and disable merge */
+	a3c90x_reset();
 	/* Disable the receiver and transmitter. */
 	outw(cmdRxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
 	outw(cmdTxDisable, INF_3C90X.IOAddr + regCommandIntStatus_w);
-    }
+}
 
 
 
@@ -676,21 +675,23 @@
  *** initialization.  If this routine is called, the pci functions did find the
  *** card.  We just have to init it here.
  ***/
-struct nic*
-a3c90x_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *pci)
-    {
+static int a3c90x_probe(struct dev *dev, struct pci_device *pci)
+{
+    struct nic *nic = (struct nic *)dev;
     int i, c;
     unsigned short eeprom[0x21];
     unsigned int cfg;
     unsigned int mopt;
+    unsigned int mstat;
     unsigned short linktype;
+#define	HWADDR_OFFSET	10
 
-    if (probeaddrs == 0 || probeaddrs[0] == 0)
+    if (pci->ioaddr == 0)
           return 0;
 
     adjust_pci_device(pci);
 
-    INF_3C90X.IOAddr = probeaddrs[0] & ~3;
+    INF_3C90X.IOAddr = pci->ioaddr & ~3;
     INF_3C90X.CurrentWindow = 255;
     switch (a3c90x_internal_ReadEeprom(INF_3C90X.IOAddr, 0x03))
 	{
@@ -756,30 +757,45 @@
            "Copyright 1999 LightSys Technology Services, Inc.\n"
            "Portions Copyright 1999 Steve Smith\n");
     printf("Provided with ABSOLUTELY NO WARRANTY.\n");
+#ifdef	CFG_3C90X_BOOTROM_FIX
+    if (INF_3C90X.isBrev)
+        {
+        printf("NOTE: 3c905b bootrom fix enabled; has side "
+	   "effects.  See 3c90x.txt for info.\n");
+	}
+#endif
     printf("-------------------------------------------------------"
            "------------------------\n");
 
     /** Retrieve the Hardware address and print it on the screen. **/
-    INF_3C90X.HWAddr[0] = eeprom[0]>>8;
-    INF_3C90X.HWAddr[1] = eeprom[0]&0xFF;
-    INF_3C90X.HWAddr[2] = eeprom[1]>>8;
-    INF_3C90X.HWAddr[3] = eeprom[1]&0xFF;
-    INF_3C90X.HWAddr[4] = eeprom[2]>>8;
-    INF_3C90X.HWAddr[5] = eeprom[2]&0xFF;
+    INF_3C90X.HWAddr[0] = eeprom[HWADDR_OFFSET + 0]>>8;
+    INF_3C90X.HWAddr[1] = eeprom[HWADDR_OFFSET + 0]&0xFF;
+    INF_3C90X.HWAddr[2] = eeprom[HWADDR_OFFSET + 1]>>8;
+    INF_3C90X.HWAddr[3] = eeprom[HWADDR_OFFSET + 1]&0xFF;
+    INF_3C90X.HWAddr[4] = eeprom[HWADDR_OFFSET + 2]>>8;
+    INF_3C90X.HWAddr[5] = eeprom[HWADDR_OFFSET + 2]&0xFF;
     printf("MAC Address = %!\n", INF_3C90X.HWAddr);
 
+    /* Test if the link is good, if not continue */
+    a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winDiagnostics4);
+    mstat = inw(INF_3C90X.IOAddr + regMediaStatus_4_w);
+    if((mstat & (1<<11)) == 0) {
+	printf("Valid link not established\n");
+	return 0;
+    }
+
     /** Program the MAC address into the station address registers **/
     a3c90x_internal_SetWindow(INF_3C90X.IOAddr, winAddressing2);
-    outw(htons(eeprom[0]), INF_3C90X.IOAddr + regStationAddress_2_3w);
-    outw(htons(eeprom[1]), INF_3C90X.IOAddr + regStationAddress_2_3w+2);
-    outw(htons(eeprom[2]), INF_3C90X.IOAddr + regStationAddress_2_3w+4);
+    outw(htons(eeprom[HWADDR_OFFSET + 0]), INF_3C90X.IOAddr + regStationAddress_2_3w);
+    outw(htons(eeprom[HWADDR_OFFSET + 1]), INF_3C90X.IOAddr + regStationAddress_2_3w+2);
+    outw(htons(eeprom[HWADDR_OFFSET + 2]), INF_3C90X.IOAddr + regStationAddress_2_3w+4);
     outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+0);
     outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+2);
     outw(0, INF_3C90X.IOAddr + regStationMask_2_3w+4);
 
     /** Fill in our entry in the etherboot arp table **/
     for(i=0;i<ETH_ALEN;i++)
-	nic->node_addr[i] = (eeprom[i/2] >> (8*((i&1)^1))) & 0xff;
+	nic->node_addr[i] = (eeprom[HWADDR_OFFSET + i/2] >> (8*((i&1)^1))) & 0xff;
 
     /** Read the media options register, print a message and set default
      ** xcvr.
@@ -903,8 +919,8 @@
     while (inw(INF_3C90X.IOAddr + regCommandIntStatus_w) & INT_CMDINPROGRESS)
 	;
 
-    /** Set the RX filter = receive only individual pkts & bcast. **/
-    a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdSetRxFilter, 0x01 + 0x04);
+    /** Set the RX filter = receive only individual pkts & multicast & bcast. **/
+    a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdSetRxFilter, 0x01 + 0x02 + 0x04);
     a3c90x_internal_IssueCommand(INF_3C90X.IOAddr, cmdRxEnable, 0);
 
 
@@ -918,12 +934,42 @@
                                  cmdAcknowledgeInterrupt, 0x661);
 
     /** Set our exported functions **/
-    nic->reset    = a3c90x_reset;
+    dev->disable  = a3c90x_disable;
     nic->poll     = a3c90x_poll;
     nic->transmit = a3c90x_transmit;
-    nic->disable  = a3c90x_disable;
 
-    return nic;
-    }
+    return 1;
+}
 
 
+static struct pci_id a3c90x_nics[] = {
+/* Original 90x revisions: */
+PCI_ROM(0x10b7, 0x9000, "3c905-tpo",     "3Com900-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9001, "3c905-t4",      "3Com900-Combo"),	/* 10/100 T4 */
+PCI_ROM(0x10b7, 0x9050, "3c905-tpo100",  "3Com905-TX"),		/* 100 Base TX / 10/100 TPO */
+PCI_ROM(0x10b7, 0x9051, "3c905-combo",   "3Com905-T4"),		/* 100 Base T4 / 10 Base Combo */
+/* Newer 90xB revisions: */
+PCI_ROM(0x10b7, 0x9004, "3c905b-tpo",    "3Com900B-TPO"),	/* 10 Base TPO */
+PCI_ROM(0x10b7, 0x9005, "3c905b-combo",  "3Com900B-Combo"),	/* 10 Base Combo */
+PCI_ROM(0x10b7, 0x9006, "3c905b-tpb2",   "3Com900B-2/T"),	/* 10 Base TP and Base2 */
+PCI_ROM(0x10b7, 0x900a, "3c905b-fl",     "3Com900B-FL"),	/* 10 Base FL */
+PCI_ROM(0x10b7, 0x9055, "3c905b-tpo100", "3Com905B-TX"),	/* 10/100 TPO */
+PCI_ROM(0x10b7, 0x9056, "3c905b-t4",     "3Com905B-T4"),	/* 10/100 T4 */
+PCI_ROM(0x10b7, 0x9058, "3c905b-9058",   "3Com905B-9058"),	/* Cyclone 10/100/BNC */
+PCI_ROM(0x10b7, 0x905a, "3c905b-fx",     "3Com905B-FL"),	/* 100 Base FX / 10 Base FX */
+/* Newer 90xC revision: */
+PCI_ROM(0x10b7, 0x9200, "3c905c-tpo",    "3Com905C-TXM"),	/* 10/100 TPO (3C905C-TXM) */
+PCI_ROM(0x10b7, 0x9800, "3c980",         "3Com980-Cyclone"),	/* Cyclone */
+PCI_ROM(0x10b7, 0x9805, "3c9805",        "3Com9805"),		/* Dual Port Server Cyclone */
+PCI_ROM(0x10b7, 0x7646, "3csoho100-tx",  "3CSOHO100-TX"),	/* Hurricane */
+PCI_ROM(0x10b7, 0x4500, "3c450",         "3Com450 HomePNA Tornado"),
+};
+
+struct pci_driver a3c90x_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "3C90X",
+	.probe    = a3c90x_probe,
+	.ids      = a3c90x_nics,
+	.id_count = sizeof(a3c90x_nics)/sizeof(a3c90x_nics[0]),
+	.class    = 0,
+};
Index: netboot/pci.c
===================================================================
--- netboot/pci.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/pci.c	(.../trunk)	(revision 112)
@@ -1,15 +1,3 @@
-/*
-** Support for NE2000 PCI clones added David Monro June 1997
-** Generalised to other NICs by Ken Yap July 1997
-**
-** Most of this is taken from:
-**
-** /usr/src/linux/drivers/pci/pci.c
-** /usr/src/linux/include/linux/pci.h
-** /usr/src/linux/arch/i386/bios32.c
-** /usr/src/linux/include/linux/bios32.h
-** /usr/src/linux/drivers/net/ne.c
-*/
 
 /*
  * This program is free software; you can redistribute it and/or
@@ -18,402 +6,257 @@
  * your option) any later version.
  */
 
-#include "etherboot.h"
+#include "grub.h"
 #include "pci.h"
 
-/*#define	DEBUG	1*/
-#define DEBUG	0
+#ifdef INCLUDE_3C595
+extern struct pci_driver t595_driver;
+#endif /* INCLUDE_3C595 */
 
-#ifdef	CONFIG_PCI_DIRECT
-#define  PCIBIOS_SUCCESSFUL                0x00
+#ifdef INCLUDE_3C90X
+extern struct pci_driver a3c90x_driver;
+#endif /* INCLUDE_3C90X */
 
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
+#ifdef INCLUDE_DAVICOM
+extern struct pci_driver davicom_driver;
+#endif /* INCLUDE_DAVICOM */
 
-#define CONFIG_CMD(bus, device_fn, where)   (0x80000000 | (bus << 16) | (device_fn << 8) | (where & ~3))
+#ifdef INCLUDE_E1000
+extern struct pci_driver e1000_driver;
+#endif /* INCLUDE_E1000 */
 
-int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn,
-			       unsigned int where, unsigned char *value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    *value = inb(0xCFC + (where&3));
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_EEPRO100
+extern struct pci_driver eepro100_driver;
+#endif /* INCLUDE_EEPRO100 */
 
-int pcibios_read_config_word (unsigned int bus,
-    unsigned int device_fn, unsigned int where, unsigned short *value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    *value = inw(0xCFC + (where&2));
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_EPIC100
+extern struct pci_driver epic100_driver;
+#endif /* INCLUDE_EPIC100 */
 
-int pcibios_read_config_dword (unsigned int bus, unsigned int device_fn,
-				 unsigned int where, unsigned int *value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    *value = inl(0xCFC);
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_NATSEMI
+extern struct pci_driver natsemi_driver;
+#endif /* INCLUDE_NATSEMI */
 
-int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn,
-				 unsigned int where, unsigned char value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    outb(value, 0xCFC + (where&3));
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_NS8390
+extern struct pci_driver nepci_driver;
+#endif /* INCLUDE_NS8390 */
 
-int pcibios_write_config_word (unsigned int bus, unsigned int device_fn,
-				 unsigned int where, unsigned short value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    outw(value, 0xCFC + (where&2));
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_PCNET32
+extern struct pci_driver pcnet32_driver;
+#endif /* INCLUDE_PCNET32 */
 
-int pcibios_write_config_dword (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int value)
-{
-    outl(CONFIG_CMD(bus,device_fn,where), 0xCF8);
-    outl(value, 0xCFC);
-    return PCIBIOS_SUCCESSFUL;
-}
+#ifdef INCLUDE_RTL8139
+extern struct pci_driver rtl8139_driver;
+#endif /* INCLUDE_RTL8139 */
 
-#undef CONFIG_CMD
+#ifdef INCLUDE_SIS900
+extern struct pci_driver sis900_driver;
+#endif /* INCLUDE_SIS900 */
 
-#else	 /* CONFIG_PCI_DIRECT  not defined */
+#ifdef INCLUDE_TG3
+extern struct pci_driver  tg3_driver;
+#endif /* INCLUDE_TG3 */
 
-static struct {
-	unsigned long address;
-	unsigned short segment;
-} bios32_indirect = { 0, KERN_CODE_SEG };
+#ifdef INCLUDE_TLAN
+extern struct pci_driver tlan_driver;
+#endif /* INCLUDE_TLAN */
 
-static long pcibios_entry;
-static struct {
-	unsigned long address;
-	unsigned short segment;
-} pci_indirect = { 0, KERN_CODE_SEG };
+#ifdef INCLUDE_TULIP
+extern struct pci_driver tulip_driver;
+#endif /* INCLUDE_TULIP */
 
-static unsigned long bios32_service(unsigned long service)
-{
-	unsigned char return_code;	/* %al */
-	unsigned long address;		/* %ebx */
-	unsigned long length;		/* %ecx */
-	unsigned long entry;		/* %edx */
-	unsigned long flags;
+#ifdef INCLUDE_VIA_RHINE
+extern struct pci_driver rhine_driver;
+#endif/* INCLUDE_VIA_RHINE */
 
-	save_flags(flags);
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%edi)"
-#else
-		"lcall *(%%edi)"
+#ifdef INCLUDE_PXE_TFTP
+extern struct pci_driver pxe_driver;
+#endif /* INCLUDE_PXE_TFTP */
+
+#ifdef INCLUDE_W89C840
+extern struct pci_driver w89c840_driver;
+#endif /* INCLUDE_W89C840 */
+
+#ifdef INCLUDE_SUNDANCE
+extern struct pci_driver sundance_driver;
 #endif
-		: "=a" (return_code),
-		  "=b" (address),
-		  "=c" (length),
-		  "=d" (entry)
-		: "0" (service),
-		  "1" (0),
-		  "D" (&bios32_indirect));
-	restore_flags(flags);
 
-	switch (return_code) {
-		case 0:
-			return address + entry;
-		case 0x80:	/* Not present */
-			printf("bios32_service(%d) : not present\n", service);
-			return 0;
-		default: /* Shouldn't happen */
-			printf("bios32_service(%d) : returned %#X, mail drew@colorado.edu\n",
-				service, return_code);
-			return 0;
-	}
-}
+#ifdef INCLUDE_R8169
+extern struct pci_driver r8169_driver;
+#endif /* INCLUDE_R8169 */
 
-int pcibios_read_config_byte(unsigned int bus,
-        unsigned int device_fn, unsigned int where, unsigned char *value)
-{
-        unsigned long ret;
-        unsigned long bx = (bus << 8) | device_fn;
-        unsigned long flags;
+static const struct pci_driver *pci_drivers[] = {
 
-        save_flags(flags);
-        __asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-                "jc 1f\n\t"
-                "xor %%ah, %%ah\n"
-                "1:"
-                : "=c" (*value),
-                  "=a" (ret)
-                : "1" (PCIBIOS_READ_CONFIG_BYTE),
-                  "b" (bx),
-                  "D" ((long) where),
-                  "S" (&pci_indirect));
-        restore_flags(flags);
-        return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_3C595
+	&t595_driver,
+#endif /* INCLUDE_3C595 */
 
-int pcibios_read_config_word(unsigned int bus,
-        unsigned int device_fn, unsigned int where, unsigned short *value)
-{
-        unsigned long ret;
-        unsigned long bx = (bus << 8) | device_fn;
-        unsigned long flags;
+#ifdef INCLUDE_3C90X
+	&a3c90x_driver,
+#endif /* INCLUDE_3C90X */
 
-        save_flags(flags);
-        __asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-                "jc 1f\n\t"
-                "xor %%ah, %%ah\n"
-                "1:"
-                : "=c" (*value),
-                  "=a" (ret)
-                : "1" (PCIBIOS_READ_CONFIG_WORD),
-                  "b" (bx),
-                  "D" ((long) where),
-                  "S" (&pci_indirect));
-        restore_flags(flags);
-        return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_DAVICOM
+	&davicom_driver,
+#endif /* INCLUDE_DAVICOM */
 
-int pcibios_read_config_dword(unsigned int bus,
-        unsigned int device_fn, unsigned int where, unsigned int *value)
-{
-        unsigned long ret;
-        unsigned long bx = (bus << 8) | device_fn;
-        unsigned long flags;
+#ifdef INCLUDE_E1000
+	&e1000_driver,
+#endif /* INCLUDE_E1000 */
 
-        save_flags(flags);
-        __asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-                "jc 1f\n\t"
-                "xor %%ah, %%ah\n"
-                "1:"
-                : "=c" (*value),
-                  "=a" (ret)
-                : "1" (PCIBIOS_READ_CONFIG_DWORD),
-                  "b" (bx),
-                  "D" ((long) where),
-                  "S" (&pci_indirect));
-        restore_flags(flags);
-        return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_EEPRO100
+	&eepro100_driver,
+#endif /* INCLUDE_EEPRO100 */
 
-int pcibios_write_config_byte (unsigned int bus,
-	unsigned int device_fn, unsigned int where, unsigned char value)
-{
-	unsigned long ret;
-	unsigned long bx = (bus << 8) | device_fn;
-	unsigned long flags;
+#ifdef INCLUDE_EPIC100
+	&epic100_driver,
+#endif /* INCLUDE_EPIC100 */
 
-	save_flags(flags); cli();
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-		"jc 1f\n\t"
-		"xor %%ah, %%ah\n"
-		"1:"
-		: "=a" (ret)
-		: "0" (PCIBIOS_WRITE_CONFIG_BYTE),
-		  "c" (value),
-		  "b" (bx),
-		  "D" ((long) where),
-		  "S" (&pci_indirect));
-	restore_flags(flags);
-	return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_NATSEMI
+	&natsemi_driver,
+#endif /* INCLUDE_NATSEMI */
 
-int pcibios_write_config_word (unsigned int bus,
-	unsigned int device_fn, unsigned int where, unsigned short value)
-{
-	unsigned long ret;
-	unsigned long bx = (bus << 8) | device_fn;
-	unsigned long flags;
+#ifdef INCLUDE_NS8390
+	&nepci_driver,
+#endif /* INCLUDE_NS8390 */
 
-	save_flags(flags); cli();
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
-#endif
-		"jc 1f\n\t"
-		"xor %%ah, %%ah\n"
-		"1:"
-		: "=a" (ret)
-		: "0" (PCIBIOS_WRITE_CONFIG_WORD),
-		  "c" (value),
-		  "b" (bx),
-		  "D" ((long) where),
-		  "S" (&pci_indirect));
-	restore_flags(flags);
-	return (int) (ret & 0xff00) >> 8;
-}
+#ifdef INCLUDE_PCNET32
+	&pcnet32_driver,
+#endif /* INCLUDE_PCNET32 */
 
-int pcibios_write_config_dword (unsigned int bus,
-	unsigned int device_fn, unsigned int where, unsigned int value)
-{
-	unsigned long ret;
-	unsigned long bx = (bus << 8) | device_fn;
-	unsigned long flags;
+#ifdef INCLUDE_RTL8139
+	&rtl8139_driver,
+#endif /* INCLUDE_RTL8139 */
 
-	save_flags(flags); cli();
-	__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-		"lcall (%%esi)\n\t"
-#else
-		"lcall *(%%esi)\n\t"
+#ifdef INCLUDE_SIS900
+	&sis900_driver,
+#endif /* INCLUDE_SIS900 */
+
+#ifdef INCLUDE_SUNDANCE
+	&sundance_driver,
 #endif
-		"jc 1f\n\t"
-		"xor %%ah, %%ah\n"
-		"1:"
-		: "=a" (ret)
-		: "0" (PCIBIOS_WRITE_CONFIG_DWORD),
-		  "c" (value),
-		  "b" (bx),
-		  "D" ((long) where),
-		  "S" (&pci_indirect));
-	restore_flags(flags);
-	return (int) (ret & 0xff00) >> 8;
-}
 
-static void check_pcibios(void)
-{
-	unsigned long signature;
-	unsigned char present_status;
-	unsigned char major_revision;
-	unsigned char minor_revision;
-	unsigned long flags;
-	int pack;
+#ifdef INCLUDE_TG3
+	& tg3_driver,
+#endif /* INCLUDE_TG3 */
 
-	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
-		pci_indirect.address = pcibios_entry;
+#ifdef INCLUDE_TLAN
+	&tlan_driver,
+#endif /* INCLUDE_TLAN */
 
-		save_flags(flags);
-		__asm__(
-#ifdef ABSOLUTE_WITHOUT_ASTERISK
-			"lcall (%%edi)\n\t"
-#else
-			"lcall *(%%edi)\n\t"
-#endif
-			"jc 1f\n\t"
-			"xor %%ah, %%ah\n"
-			"1:\tshl $8, %%eax\n\t"
-			"movw %%bx, %%ax"
-			: "=d" (signature),
-			  "=a" (pack)
-			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
-			  "D" (&pci_indirect)
-			: "bx", "cx");
-		restore_flags(flags);
+#ifdef INCLUDE_TULIP
+	& tulip_driver,
+#endif /* INCLUDE_TULIP */
 
-		present_status = (pack >> 16) & 0xff;
-		major_revision = (pack >> 8) & 0xff;
-		minor_revision = pack & 0xff;
-		if (present_status || (signature != PCI_SIGNATURE)) {
-			printf("ERROR: BIOS32 says PCI BIOS, but no PCI "
-				"BIOS????\n");
-			pcibios_entry = 0;
-		}
-#if	DEBUG
-		if (pcibios_entry) {
-			printf ("pcibios_init : PCI BIOS revision %hhX.%hhX"
-				" entry at %#X\n", major_revision,
-				minor_revision, pcibios_entry);
-		}
-#endif
-	}
-}
+#ifdef INCLUDE_VIA_RHINE
+	&rhine_driver,
+#endif/* INCLUDE_VIA_RHINE */
 
-static void pcibios_init(void)
-{
-	union bios32 *check;
-	unsigned char sum;
-	int i, length;
-	unsigned long bios32_entry = 0;
+#ifdef INCLUDE_W89C840
+	&w89c840_driver,
+#endif /* INCLUDE_W89C840 */
 
-	/*
-	 * Follow the standard procedure for locating the BIOS32 Service
-	 * directory by scanning the permissible address range from
-	 * 0xe0000 through 0xfffff for a valid BIOS32 structure.
-	 *
-	 */
+#ifdef INCLUDE_R8169
+	&r8169_driver,
+#endif /* INCLUDE_R8169 */
 
-	for (check = (union bios32 *) 0xe0000; check <= (union bios32 *) 0xffff0; ++check) {
-		if (check->fields.signature != BIOS32_SIGNATURE)
+/* We must be the last one */
+#ifdef INCLUDE_PXE_TFTP
+	&pxe_driver,
+#endif /* INCLUDE_PXE_TFTP */
+
+	0
+};
+
+static void scan_drivers(
+	int type, 
+	uint32_t class, uint16_t vendor, uint16_t device,
+	const struct pci_driver *last_driver, struct pci_device *dev)
+{
+	const struct pci_driver *skip_driver = last_driver;
+	/* Assume there is only one match of the correct type */
+	const struct pci_driver *driver;
+	int i, j;
+	
+	for(j = 0; pci_drivers[j] != 0; j++){
+		driver = pci_drivers[j];
+		if (driver->type != type)
 			continue;
-		length = check->fields.length * 16;
-		if (!length)
+		if (skip_driver) {
+			if (skip_driver == driver) 
+				skip_driver = 0;
 			continue;
-		sum = 0;
-		for (i = 0; i < length ; ++i)
-			sum += check->chars[i];
-		if (sum != 0)
+		}
+		for(i = 0; i < driver->id_count; i++) {
+			if ((vendor == driver->ids[i].vendor) &&
+			    (device == driver->ids[i].dev_id)) {
+				
+				dev->driver = driver;
+				dev->name   = driver->ids[i].name;
+
+				goto out;
+			}
+		}
+	}
+	if (!class) {
+		goto out;
+	}
+	for(j = 0; pci_drivers[j] != 0; j++){
+		driver = pci_drivers[j];
+		if (driver->type != type)
 			continue;
-		if (check->fields.revision != 0) {
-			printf("pcibios_init : unsupported revision %d at %#X, mail drew@colorado.edu\n",
-				check->fields.revision, check);
+		if (skip_driver) {
+			if (skip_driver == driver)
+				skip_driver = 0;
 			continue;
 		}
-#if	DEBUG
-		printf("pcibios_init : BIOS32 Service Directory "
-			"structure at %#X\n", check);
-#endif
-		if (!bios32_entry) {
-			if (check->fields.entry >= 0x100000) {
-				printf("pcibios_init: entry in high "
-					"memory, giving up\n");
-				return;
-			} else {
-				bios32_entry = check->fields.entry;
-#if	DEBUG
-				printf("pcibios_init : BIOS32 Service Directory"
-					" entry at %#X\n", bios32_entry);
-#endif
-				bios32_indirect.address = bios32_entry;
-			}
+		if (last_driver == driver)
+			continue;
+		if ((class >> 8) == driver->class) {
+			dev->driver = driver;
+			dev->name   = driver->name;
+			goto out;
 		}
 	}
-	if (bios32_entry)
-		check_pcibios();
+ out:
+	return;
 }
-#endif	/* CONFIG_PCI_DIRECT not defined*/
 
-static void scan_bus(struct pci_device *pcidev)
+void scan_pci_bus(int type, struct pci_device *dev)
 {
-	unsigned int devfn, l, bus, buses;
+	unsigned int first_bus, first_devfn;
+	const struct pci_driver *first_driver;
+	unsigned int devfn, bus, buses;
 	unsigned char hdr_type = 0;
-	unsigned short vendor, device;
-	unsigned int membase, ioaddr, romaddr;
-	int i, reg;
-	unsigned int pci_ioaddr = 0;
+	uint32_t class;
+	uint16_t vendor, device;
+	uint32_t l, membase, ioaddr, romaddr;
+	int reg;
 
+	EnterFunction("scan_pci_bus");
+	first_bus    = 0;
+	first_devfn  = 0;
+	first_driver = 0;
+	if (dev->driver) {
+		first_driver = dev->driver;
+		first_bus    = dev->bus;
+		first_devfn  = dev->devfn;
+		/* Re read the header type on a restart */
+		pcibios_read_config_byte(first_bus, first_devfn & ~0x7, 
+			PCI_HEADER_TYPE, &hdr_type);
+		dev->driver  = 0;
+		dev->bus     = 0;
+		dev->devfn   = 0;
+	}
+		
 	/* Scan all PCI buses, until we find our card.
-	 * We could be smart only scan the required busses but that
+	 * We could be smart only scan the required buses but that
 	 * is error prone, and tricky.
-	 * By scanning all possible pci busses in order we should find
+	 * By scanning all possible pci buses in order we should find
 	 * our card eventually. 
 	 */
 	buses=256;
-	for (bus = 0; bus < buses; ++bus) {
-		for (devfn = 0; devfn < 0xff; ++devfn) {
+	for (bus = first_bus; bus < buses; ++bus) {
+		for (devfn = first_devfn; devfn < 0xff; ++devfn, first_driver = 0) {
 			if (PCI_FUNC (devfn) == 0)
 				pcibios_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);
 			else if (!(hdr_type & 0x80))	/* not a multi-function device */
@@ -421,62 +264,90 @@
 			pcibios_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l);
 			/* some broken boards return 0 if a slot is empty: */
 			if (l == 0xffffffff || l == 0x00000000) {
-				hdr_type = 0;
 				continue;
 			}
 			vendor = l & 0xffff;
 			device = (l >> 16) & 0xffff;
 
+			pcibios_read_config_dword(bus, devfn, PCI_REVISION, &l);
+			class = (l >> 8) & 0xffffff;
 #if	DEBUG
-			printf("bus %hhX, function %hhX, vendor %hX, device %hX\n",
-				bus, devfn, vendor, device);
+		{
+			printf("%hhx:%hhx.%hhx [%hX/%hX] ---- ",
+				bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
+				vendor, device);
+#if	DEBUG > 1
+			for(int i = 0; i < 256; i++) {
+				unsigned char byte;
+				if ((i & 0xf) == 0) {
+					printf("%hhx: ", i);
+				}
+				pcibios_read_config_byte(bus, devfn, i, &byte);
+				printf("%hhx ", byte);
+				if ((i & 0xf) == 0xf) {
+					printf("\n");
+				}
+			}
 #endif
-			for (i = 0; pcidev[i].vendor != 0; i++) {
-				if (vendor != pcidev[i].vendor
-				    || device != pcidev[i].dev_id)
-					continue;
-				pcidev[i].devfn = devfn;
-				pcidev[i].bus = bus;
-				for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
-					pcibios_read_config_dword(bus, devfn, reg, &ioaddr);
 
-					if ((ioaddr & PCI_BASE_ADDRESS_IO_MASK) == 0 || (ioaddr & PCI_BASE_ADDRESS_SPACE_IO) == 0)
-						continue;
-					/* Strip the I/O address out of the returned value */
-					ioaddr &= PCI_BASE_ADDRESS_IO_MASK;
-					/* Get the memory base address */
-					pcibios_read_config_dword(bus, devfn,
-						PCI_BASE_ADDRESS_1, &membase);
-					/* Get the ROM base address */
-					pcibios_read_config_dword(bus, devfn, PCI_ROM_ADDRESS, &romaddr);
-					romaddr >>= 10;
-					printf("Found %s at %#hx, ROM address %#hx\n",
-						pcidev[i].name, ioaddr, romaddr);
-					/* Take the first one or the one that matches in boot ROM address */
-					if (pci_ioaddr == 0 || romaddr == ((unsigned long) rom.rom_segment << 4)) {
-						pcidev[i].membase = membase;
-						pcidev[i].ioaddr = ioaddr;
-						return;
-					}
-				}
+		}
+#endif
+			scan_drivers(type, class, vendor, device, first_driver, dev);
+			if (!dev->driver){
+#if DEBUG
+				printf("No driver fit.\n");
+#endif
+				continue;
 			}
+#if DEBUG
+			printf("Get Driver:\n");
+#endif
+			dev->devfn = devfn;
+			dev->bus = bus;
+			dev->class = class;
+			dev->vendor = vendor;
+			dev->dev_id = device;
+			
+			
+			/* Get the ROM base address */
+			pcibios_read_config_dword(bus, devfn, 
+				PCI_ROM_ADDRESS, &romaddr);
+			romaddr >>= 10;
+			dev->romaddr = romaddr;
+			
+			/* Get the ``membase'' */
+			pcibios_read_config_dword(bus, devfn,
+				PCI_BASE_ADDRESS_1, &membase);
+			dev->membase = membase;
+				
+			/* Get the ``ioaddr'' */
+			for (reg = PCI_BASE_ADDRESS_0; reg <= PCI_BASE_ADDRESS_5; reg += 4) {
+				pcibios_read_config_dword(bus, devfn, reg, &ioaddr);
+				if ((ioaddr & PCI_BASE_ADDRESS_IO_MASK) == 0 || (ioaddr & PCI_BASE_ADDRESS_SPACE_IO) == 0)
+					continue;
+				
+				
+				/* Strip the I/O address out of the returned value */
+				ioaddr &= PCI_BASE_ADDRESS_IO_MASK;
+				
+				/* Take the first one or the one that matches in boot ROM address */
+				dev->ioaddr = ioaddr;
+			}
+#if DEBUG > 2
+			printf("Found %s ROM address %#hx\n",
+				dev->name, romaddr);
+#endif
+			LeaveFunction("scan_pci_bus");
+			return;
 		}
+		first_devfn = 0;
 	}
+	first_bus = 0;
+	LeaveFunction("scan_pci_bus");
 }
 
-void eth_pci_init(struct pci_device *pcidev)
-{
-#ifndef	CONFIG_PCI_DIRECT
-	pcibios_init();
-	if (!pcibios_entry) {
-		printf("pci_init: no BIOS32 detected\n");
-		return;
-	}
-#endif
-	scan_bus(pcidev);
-	/* return values are in pcidev structures */
-}
 
+
 /*
  *	Set device to be a busmaster in case BIOS neglected to do so.
  *	Also adjust PCI latency timer to a reasonable value, 32.
@@ -489,13 +360,134 @@
 	pcibios_read_config_word(p->bus, p->devfn, PCI_COMMAND, &pci_command);
 	new_command = pci_command | PCI_COMMAND_MASTER|PCI_COMMAND_IO;
 	if (pci_command != new_command) {
-		printf("The PCI BIOS has not enabled this device!\nUpdating PCI command %hX->%hX. pci_bus %hhX pci_device_fn %hhX\n",
+#if DEBUG > 0
+		printf(
+			"The PCI BIOS has not enabled this device!\n"
+			"Updating PCI command %hX->%hX. pci_bus %hhX pci_device_fn %hhX\n",
 			   pci_command, new_command, p->bus, p->devfn);
+#endif
 		pcibios_write_config_word(p->bus, p->devfn, PCI_COMMAND, new_command);
 	}
 	pcibios_read_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, &pci_latency);
 	if (pci_latency < 32) {
-		printf("PCI latency timer (CFLT) is unreasonably low at %d. Setting to 32 clocks.\n", pci_latency);
+#if DEBUG > 0
+		printf("PCI latency timer (CFLT) is unreasonably low at %d. Setting to 32 clocks.\n", 
+			pci_latency);
+#endif
 		pcibios_write_config_byte(p->bus, p->devfn, PCI_LATENCY_TIMER, 32);
 	}
 }
+
+/*
+ * Find the start of a pci resource.
+ */
+unsigned long pci_bar_start(struct pci_device *dev, unsigned int index)
+{
+	uint32_t lo, hi;
+	unsigned long bar;
+	pci_read_config_dword(dev, index, &lo);
+	if (lo & PCI_BASE_ADDRESS_SPACE_IO) {
+		bar = lo & PCI_BASE_ADDRESS_IO_MASK;
+	} else {
+		bar = 0;
+		if ((lo & PCI_BASE_ADDRESS_MEM_TYPE_MASK) == PCI_BASE_ADDRESS_MEM_TYPE_64) {
+			pci_read_config_dword(dev, index + 4, &hi);
+			if (hi) {
+				if (sizeof(unsigned long) > sizeof(uint32_t)) {
+					bar = hi;
+					/* It's REALLY interesting:-) */
+					bar <<=32;
+				}
+				else {
+					printf("Unhandled 64bit BAR\n");
+					return -1UL;
+				}
+			}
+		}
+		bar |= lo & PCI_BASE_ADDRESS_MEM_MASK;
+	}
+	return bar + pcibios_bus_base(dev->bus);
+}
+
+/*
+ * Find the size of a pci resource.
+ */
+unsigned long pci_bar_size(struct pci_device *dev, unsigned int bar)
+{
+	uint32_t start, size;
+	/* Save the original bar */
+	pci_read_config_dword(dev, bar, &start);
+	/* Compute which bits can be set */
+	pci_write_config_dword(dev, bar, ~0);
+	pci_read_config_dword(dev, bar, &size);
+	/* Restore the original size */
+	pci_write_config_dword(dev, bar, start);
+	/* Find the significant bits */
+	if (start & PCI_BASE_ADDRESS_SPACE_IO) {
+		size &= PCI_BASE_ADDRESS_IO_MASK;
+	} else {
+		size &= PCI_BASE_ADDRESS_MEM_MASK;
+	}
+	/* Find the lowest bit set */
+	size = size & ~(size - 1);
+	return size;
+}
+
+/**
+ * pci_find_capability - query for devices' capabilities 
+ * @dev: PCI device to query
+ * @cap: capability code
+ *
+ * Tell if a device supports a given PCI capability.
+ * Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it.  Possible values for @cap:
+ *
+ *  %PCI_CAP_ID_PM           Power Management 
+ *
+ *  %PCI_CAP_ID_AGP          Accelerated Graphics Port 
+ *
+ *  %PCI_CAP_ID_VPD          Vital Product Data 
+ *
+ *  %PCI_CAP_ID_SLOTID       Slot Identification 
+ *
+ *  %PCI_CAP_ID_MSI          Message Signalled Interrupts
+ *
+ *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap 
+ */
+int pci_find_capability(struct pci_device *dev, int cap)
+{
+	uint16_t status;
+	uint8_t pos, id;
+	uint8_t hdr_type;
+	int ttl = 48;
+
+	pci_read_config_word(dev, PCI_STATUS, &status);
+	if (!(status & PCI_STATUS_CAP_LIST))
+		return 0;
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type);
+	switch (hdr_type & 0x7F) {
+	case PCI_HEADER_TYPE_NORMAL:
+	case PCI_HEADER_TYPE_BRIDGE:
+	default:
+		pci_read_config_byte(dev, PCI_CAPABILITY_LIST, &pos);
+		break;
+	case PCI_HEADER_TYPE_CARDBUS:
+		pci_read_config_byte(dev, PCI_CB_CAPABILITY_LIST, &pos);
+		break;
+	}
+	while (ttl-- && pos >= 0x40) {
+		pos &= ~3;
+		pci_read_config_byte(dev, pos + PCI_CAP_LIST_ID, &id);
+#if	DEBUG > 0
+		printf("Capability: %d\n", id);
+#endif
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pci_read_config_byte(dev, pos + PCI_CAP_LIST_NEXT, &pos);
+	}
+	return 0;
+}
+
Index: netboot/osdep.h
===================================================================
--- netboot/osdep.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/osdep.h	(.../trunk)	(revision 112)
@@ -1,94 +1,14 @@
-#ifndef	__OSDEP_H__
-#define __OSDEP_H__
+#ifndef	_OSDEP_H
+#define _OSDEP_H
 
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2, or (at
- * your option) any later version.
- */
+#define __unused __attribute__((unused))
+#define __aligned __attribute__((aligned(16)))
 
-#define	__LITTLE_ENDIAN		/* x86 */
-
-/* Taken from /usr/include/linux/hfs_sysdep.h */
-#if defined(__BIG_ENDIAN)
-#	if !defined(__constant_htonl)
-#		define __constant_htonl(x) (x)
-#	endif
-#	if !defined(__constant_htons)
-#		define __constant_htons(x) (x)
-#	endif
-#elif defined(__LITTLE_ENDIAN)
-#	if !defined(__constant_htonl)
-#		define __constant_htonl(x) \
-        ((unsigned long int)((((unsigned long int)(x) & 0x000000ffU) << 24) | \
-                             (((unsigned long int)(x) & 0x0000ff00U) <<  8) | \
-                             (((unsigned long int)(x) & 0x00ff0000U) >>  8) | \
-                             (((unsigned long int)(x) & 0xff000000U) >> 24)))
-#	endif
-#	if !defined(__constant_htons)
-#		define __constant_htons(x) \
-        ((unsigned short int)((((unsigned short int)(x) & 0x00ff) << 8) | \
-                              (((unsigned short int)(x) & 0xff00) >> 8)))
-#	endif
-#else
-#	error "Don't know if bytes are big- or little-endian!"
-#endif
-
-#define ntohl(x) \
-(__builtin_constant_p(x) ? \
- __constant_htonl((x)) : \
- __swap32(x))
-#define htonl(x) \
-(__builtin_constant_p(x) ? \
- __constant_htonl((x)) : \
- __swap32(x))
-#define ntohs(x) \
-(__builtin_constant_p(x) ? \
- __constant_htons((x)) : \
- __swap16(x))
-#define htons(x) \
-(__builtin_constant_p(x) ? \
- __constant_htons((x)) : \
- __swap16(x))
-
-static inline unsigned long int __swap32(unsigned long int x)
-{
-	__asm__("xchgb %b0,%h0\n\t"
-		"rorl $16,%0\n\t"
-		"xchgb %b0,%h0"
-		: "=q" (x)
-		: "0" (x));
-	return x;
-}
-
-static inline unsigned short int __swap16(unsigned short int x)
-{
-	__asm__("xchgb %b0,%h0"
-		: "=q" (x)
-		: "0" (x));
-	return x;
-}
-
-/* Make routines available to all */
-#define	swap32(x)	__swap32(x)
-#define	swap16(x)	__swap16(x)
-
-#include "linux-asm-io.h"
-
-typedef	unsigned long Address;
-
 /* ANSI prototyping macro */
 #ifdef	__STDC__
-#define	P(x)	x
+#  define	P(x)	x
 #else
-#define	P(x)	()
+#  define	P(x)	()
 #endif
 
 #endif
-
-/*
- * Local variables:
- *  c-basic-offset: 8
- * End:
- */
Index: netboot/pci.h
===================================================================
--- netboot/pci.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/pci.h	(.../trunk)	(revision 112)
@@ -1,4 +1,4 @@
-#ifndef	PCI_H
+#if !defined(PCI_H) && defined(CONFIG_PCI)
 #define PCI_H
 
 /*
@@ -21,10 +21,20 @@
  * your option) any later version.
  */
 
+#include "pci_ids.h"
+#include "types.h"
+
 #define PCI_COMMAND_IO			0x1	/* Enable response in I/O space */
 #define PCI_COMMAND_MEM			0x2	/* Enable response in mem space */
 #define PCI_COMMAND_MASTER		0x4	/* Enable bus mastering */
 #define PCI_LATENCY_TIMER		0x0d	/* 8 bits */
+#define PCI_COMMAND_SPECIAL		0x8	/* Enable response to special cycles */
+#define PCI_COMMAND_INVALIDATE		0x10	/* Use memory write and invalidate */
+#define  PCI_COMMAND_VGA_PALETTE 0x20	/* Enable palette snooping */
+#define  PCI_COMMAND_PARITY	0x40	/* Enable parity checking */
+#define  PCI_COMMAND_WAIT 	0x80	/* Enable address/data stepping */
+#define  PCI_COMMAND_SERR	0x100	/* Enable SERR */
+#define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
 
 #define PCIBIOS_PCI_FUNCTION_ID         0xb1XX
 #define PCIBIOS_PCI_BIOS_PRESENT        0xb101
@@ -42,11 +52,38 @@
 #define PCI_DEVICE_ID           0x02    /* 16 bits */
 #define PCI_COMMAND             0x04    /* 16 bits */
 
+#define PCI_STATUS		0x06	/* 16 bits */
+#define  PCI_STATUS_CAP_LIST	0x10	/* Support Capability List */
+#define  PCI_STATUS_66MHZ	0x20	/* Support 66 Mhz PCI 2.1 bus */
+#define  PCI_STATUS_UDF		0x40	/* Support User Definable Features [obsolete] */
+#define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
+#define  PCI_STATUS_PARITY	0x100	/* Detected parity error */
+#define  PCI_STATUS_DEVSEL_MASK	0x600	/* DEVSEL timing */
+#define  PCI_STATUS_DEVSEL_FAST	0x000	
+#define  PCI_STATUS_DEVSEL_MEDIUM 0x200
+#define  PCI_STATUS_DEVSEL_SLOW 0x400
+#define  PCI_STATUS_SIG_TARGET_ABORT 0x800 /* Set on target abort */
+#define  PCI_STATUS_REC_TARGET_ABORT 0x1000 /* Master ack of " */
+#define  PCI_STATUS_REC_MASTER_ABORT 0x2000 /* Set on master abort */
+#define  PCI_STATUS_SIG_SYSTEM_ERROR 0x4000 /* Set when we drive SERR */
+#define  PCI_STATUS_DETECTED_PARITY 0x8000 /* Set on parity error */
+
 #define PCI_REVISION            0x08    /* 8 bits  */
+#define PCI_REVISION_ID         0x08    /* 8 bits  */
+#define PCI_CLASS_REVISION      0x08    /* 32 bits  */
 #define PCI_CLASS_CODE          0x0b    /* 8 bits */
 #define PCI_SUBCLASS_CODE       0x0a    /* 8 bits */
 #define PCI_HEADER_TYPE         0x0e    /* 8 bits */
+#define  PCI_HEADER_TYPE_NORMAL	0
+#define  PCI_HEADER_TYPE_BRIDGE 1
+#define  PCI_HEADER_TYPE_CARDBUS 2
 
+
+/* Header type 0 (normal devices) */
+#define PCI_CARDBUS_CIS		0x28
+#define PCI_SUBSYSTEM_VENDOR_ID	0x2c
+#define PCI_SUBSYSTEM_ID	0x2e  
+
 #define PCI_BASE_ADDRESS_0      0x10    /* 32 bits */
 #define PCI_BASE_ADDRESS_1      0x14    /* 32 bits */
 #define PCI_BASE_ADDRESS_2      0x18    /* 32 bits */
@@ -54,15 +91,152 @@
 #define PCI_BASE_ADDRESS_4      0x20    /* 32 bits */
 #define PCI_BASE_ADDRESS_5      0x24    /* 32 bits */
 
+#define PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
+#define PCI_BASE_ADDRESS_MEM_TYPE_32	0x00	/* 32 bit address */
+#define PCI_BASE_ADDRESS_MEM_TYPE_1M	0x02	/* Below 1M [obsolete] */
+#define PCI_BASE_ADDRESS_MEM_TYPE_64	0x04	/* 64 bit address */
+
 #ifndef	PCI_BASE_ADDRESS_IO_MASK
 #define	PCI_BASE_ADDRESS_IO_MASK       (~0x03)
 #endif
+#ifndef	PCI_BASE_ADDRESS_MEM_MASK
+#define	PCI_BASE_ADDRESS_MEM_MASK       (~0x0f)
+#endif
 #define	PCI_BASE_ADDRESS_SPACE_IO	0x01
 #define	PCI_ROM_ADDRESS		0x30	/* 32 bits */
 #define	PCI_ROM_ADDRESS_ENABLE	0x01	/* Write 1 to enable ROM,
 					   bits 31..11 are address,
 					   10..2 are reserved */
 
+#define PCI_CAPABILITY_LIST	0x34	/* Offset of first capability list entry */
+
+/* Header type 1 (PCI-to-PCI bridges) */
+#define PCI_PRIMARY_BUS		0x18	/* Primary bus number */
+#define PCI_SECONDARY_BUS	0x19	/* Secondary bus number */
+#define PCI_SUBORDINATE_BUS	0x1a	/* Highest bus number behind the bridge */
+#define PCI_SEC_LATENCY_TIMER	0x1b	/* Latency timer for secondary interface */
+#define PCI_IO_BASE		0x1c	/* I/O range behind the bridge */
+#define PCI_IO_LIMIT		0x1d
+#define  PCI_IO_RANGE_TYPE_MASK	0x0f	/* I/O bridging type */
+#define  PCI_IO_RANGE_TYPE_16	0x00
+#define  PCI_IO_RANGE_TYPE_32	0x01
+#define  PCI_IO_RANGE_MASK	~0x0f
+#define PCI_SEC_STATUS		0x1e	/* Secondary status register, only bit 14 used */
+#define PCI_MEMORY_BASE		0x20	/* Memory range behind */
+#define PCI_MEMORY_LIMIT	0x22
+#define  PCI_MEMORY_RANGE_TYPE_MASK 0x0f
+#define  PCI_MEMORY_RANGE_MASK	~0x0f
+#define PCI_PREF_MEMORY_BASE	0x24	/* Prefetchable memory range behind */
+#define PCI_PREF_MEMORY_LIMIT	0x26
+#define  PCI_PREF_RANGE_TYPE_MASK 0x0f
+#define  PCI_PREF_RANGE_TYPE_32	0x00
+#define  PCI_PREF_RANGE_TYPE_64	0x01
+#define  PCI_PREF_RANGE_MASK	~0x0f
+#define PCI_PREF_BASE_UPPER32	0x28	/* Upper half of prefetchable memory range */
+#define PCI_PREF_LIMIT_UPPER32	0x2c
+#define PCI_IO_BASE_UPPER16	0x30	/* Upper half of I/O addresses */
+#define PCI_IO_LIMIT_UPPER16	0x32
+/* 0x34 same as for htype 0 */
+/* 0x35-0x3b is reserved */
+#define PCI_ROM_ADDRESS1	0x38	/* Same as PCI_ROM_ADDRESS, but for htype 1 */
+/* 0x3c-0x3d are same as for htype 0 */
+#define PCI_BRIDGE_CONTROL	0x3e
+#define  PCI_BRIDGE_CTL_PARITY	0x01	/* Enable parity detection on secondary interface */
+#define  PCI_BRIDGE_CTL_SERR	0x02	/* The same for SERR forwarding */
+#define  PCI_BRIDGE_CTL_NO_ISA	0x04	/* Disable bridging of ISA ports */
+#define  PCI_BRIDGE_CTL_VGA	0x08	/* Forward VGA addresses */
+#define  PCI_BRIDGE_CTL_MASTER_ABORT 0x20  /* Report master aborts */
+#define  PCI_BRIDGE_CTL_BUS_RESET 0x40	/* Secondary bus reset */
+#define  PCI_BRIDGE_CTL_FAST_BACK 0x80	/* Fast Back2Back enabled on secondary interface */
+
+#define PCI_CB_CAPABILITY_LIST	0x14
+
+/* Capability lists */
+
+#define PCI_CAP_LIST_ID		0	/* Capability ID */
+#define  PCI_CAP_ID_PM		0x01	/* Power Management */
+#define  PCI_CAP_ID_AGP		0x02	/* Accelerated Graphics Port */
+#define  PCI_CAP_ID_VPD		0x03	/* Vital Product Data */
+#define  PCI_CAP_ID_SLOTID	0x04	/* Slot Identification */
+#define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
+#define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
+#define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
+#define PCI_CAP_FLAGS		2	/* Capability defined flags (16 bits) */
+#define PCI_CAP_SIZEOF		4
+
+/* Power Management Registers */
+
+#define PCI_PM_PMC              2       /* PM Capabilities Register */
+#define  PCI_PM_CAP_VER_MASK	0x0007	/* Version */
+#define  PCI_PM_CAP_PME_CLOCK	0x0008	/* PME clock required */
+#define  PCI_PM_CAP_RESERVED    0x0010  /* Reserved field */
+#define  PCI_PM_CAP_DSI		0x0020	/* Device specific initialization */
+#define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxilliary power support mask */
+#define  PCI_PM_CAP_D1		0x0200	/* D1 power state support */
+#define  PCI_PM_CAP_D2		0x0400	/* D2 power state support */
+#define  PCI_PM_CAP_PME		0x0800	/* PME pin supported */
+#define  PCI_PM_CAP_PME_MASK    0xF800  /* PME Mask of all supported states */
+#define  PCI_PM_CAP_PME_D0      0x0800  /* PME# from D0 */
+#define  PCI_PM_CAP_PME_D1      0x1000  /* PME# from D1 */
+#define  PCI_PM_CAP_PME_D2      0x2000  /* PME# from D2 */
+#define  PCI_PM_CAP_PME_D3      0x4000  /* PME# from D3 (hot) */
+#define  PCI_PM_CAP_PME_D3cold  0x8000  /* PME# from D3 (cold) */
+#define PCI_PM_CTRL		4	/* PM control and status register */
+#define  PCI_PM_CTRL_STATE_MASK	0x0003	/* Current power state (D0 to D3) */
+#define  PCI_PM_CTRL_PME_ENABLE	0x0100	/* PME pin enable */
+#define  PCI_PM_CTRL_DATA_SEL_MASK	0x1e00	/* Data select (??) */
+#define  PCI_PM_CTRL_DATA_SCALE_MASK	0x6000	/* Data scale (??) */
+#define  PCI_PM_CTRL_PME_STATUS	0x8000	/* PME pin status */
+#define PCI_PM_PPB_EXTENSIONS	6	/* PPB support extensions (??) */
+#define  PCI_PM_PPB_B2_B3	0x40	/* Stop clock when in D3hot (??) */
+#define  PCI_PM_BPCC_ENABLE	0x80	/* Bus power/clock control enable (??) */
+#define PCI_PM_DATA_REGISTER	7	/* (??) */
+#define PCI_PM_SIZEOF		8
+
+/* AGP registers */
+
+#define PCI_AGP_VERSION		2	/* BCD version number */
+#define PCI_AGP_RFU		3	/* Rest of capability flags */
+#define PCI_AGP_STATUS		4	/* Status register */
+#define  PCI_AGP_STATUS_RQ_MASK	0xff000000	/* Maximum number of requests - 1 */
+#define  PCI_AGP_STATUS_SBA	0x0200	/* Sideband addressing supported */
+#define  PCI_AGP_STATUS_64BIT	0x0020	/* 64-bit addressing supported */
+#define  PCI_AGP_STATUS_FW	0x0010	/* FW transfers supported */
+#define  PCI_AGP_STATUS_RATE4	0x0004	/* 4x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE2	0x0002	/* 2x transfer rate supported */
+#define  PCI_AGP_STATUS_RATE1	0x0001	/* 1x transfer rate supported */
+#define PCI_AGP_COMMAND		8	/* Control register */
+#define  PCI_AGP_COMMAND_RQ_MASK 0xff000000  /* Master: Maximum number of requests */
+#define  PCI_AGP_COMMAND_SBA	0x0200	/* Sideband addressing enabled */
+#define  PCI_AGP_COMMAND_AGP	0x0100	/* Allow processing of AGP transactions */
+#define  PCI_AGP_COMMAND_64BIT	0x0020 	/* Allow processing of 64-bit addresses */
+#define  PCI_AGP_COMMAND_FW	0x0010 	/* Force FW transfers */
+#define  PCI_AGP_COMMAND_RATE4	0x0004	/* Use 4x rate */
+#define  PCI_AGP_COMMAND_RATE2	0x0002	/* Use 2x rate */
+#define  PCI_AGP_COMMAND_RATE1	0x0001	/* Use 1x rate */
+#define PCI_AGP_SIZEOF		12
+
+/* Slot Identification */
+
+#define PCI_SID_ESR		2	/* Expansion Slot Register */
+#define  PCI_SID_ESR_NSLOTS	0x1f	/* Number of expansion slots available */
+#define  PCI_SID_ESR_FIC	0x20	/* First In Chassis Flag */
+#define PCI_SID_CHASSIS_NR	3	/* Chassis Number */
+
+/* Message Signalled Interrupts registers */
+
+#define PCI_MSI_FLAGS		2	/* Various flags */
+#define  PCI_MSI_FLAGS_64BIT	0x80	/* 64-bit addresses allowed */
+#define  PCI_MSI_FLAGS_QSIZE	0x70	/* Message queue size configured */
+#define  PCI_MSI_FLAGS_QMASK	0x0e	/* Maximum queue size available */
+#define  PCI_MSI_FLAGS_ENABLE	0x01	/* MSI feature enabled */
+#define PCI_MSI_RFU		3	/* Rest of capability flags */
+#define PCI_MSI_ADDRESS_LO	4	/* Lower 32 bits */
+#define PCI_MSI_ADDRESS_HI	8	/* Upper 32 bits (if PCI_MSI_FLAGS_64BIT set) */
+#define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
+#define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
+
+#define PCI_SLOT(devfn)		  ((devfn) >> 3)
 #define PCI_FUNC(devfn)           ((devfn) & 0x07)
 
 #define BIOS32_SIGNATURE        (('_' << 0) + ('3' << 8) + ('2' << 16) + ('_' << 24))
@@ -73,6 +247,7 @@
 /* PCI service signature: "$PCI" */
 #define PCI_SERVICE             (('$' << 0) + ('P' << 8) + ('C' << 16) + ('I' << 24))
 
+/* The following is from old Grub :-( */
 union bios32 {
 	struct {
 		unsigned long signature;	/* _32_ */
@@ -85,108 +260,96 @@
 	char chars[16];
 };
 
-#define KERN_CODE_SEG	0x8	/* This _MUST_ match start.S */
+struct pci_device;
+struct dev;
+typedef int (*pci_probe_t)(struct dev *, struct pci_device *);
 
-/* Stuff for asm */
-#define save_flags(x) \
-__asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")
+struct pci_device {
+	uint32_t		class;
+	uint16_t		vendor, dev_id;
+	const char		*name;
+	/* membase and ioaddr are silly and depricated */
+	unsigned int		membase;
+	unsigned int		ioaddr;
+	unsigned int		romaddr;
+	unsigned char		devfn;
+	unsigned char		bus;
+	const struct pci_driver	*driver;
+};
 
-#define cli() __asm__ __volatile__ ("cli": : :"memory")
+extern void scan_pci_bus(int type, struct pci_device *dev);
+extern void find_pci(int type, struct pci_device *dev);
 
-#define restore_flags(x) \
-__asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")
+extern int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn, unsigned int where, uint8_t *value);
+extern int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn, unsigned int where, uint8_t value);
+extern int pcibios_read_config_word(unsigned int bus, unsigned int device_fn, unsigned int where, uint16_t *value);
+extern int pcibios_write_config_word (unsigned int bus, unsigned int device_fn, unsigned int where, uint16_t value);
+extern int pcibios_read_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t *value);
+extern int pcibios_write_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, uint32_t value);
+extern unsigned long pcibios_bus_base(unsigned int bus);
+extern void adjust_pci_device(struct pci_device *p);
 
-#define PCI_VENDOR_ID_ADMTEK            0x1317
-#define PCI_DEVICE_ID_ADMTEK_0985       0x0985
-#define PCI_VENDOR_ID_REALTEK           0x10ec
-#define PCI_DEVICE_ID_REALTEK_8029      0x8029
-#define PCI_DEVICE_ID_REALTEK_8139      0x8139
-#define PCI_VENDOR_ID_WINBOND2          0x1050
-#define PCI_DEVICE_ID_WINBOND2_89C940   0x0940
-#define PCI_DEVICE_ID_WINBOND2_89C840   0x0840
-#define PCI_VENDOR_ID_COMPEX            0x11f6
-#define PCI_DEVICE_ID_COMPEX_RL2000     0x1401
-#define PCI_DEVICE_ID_COMPEX_RL100ATX   0x2011
-#define PCI_VENDOR_ID_KTI               0x8e2e
-#define PCI_DEVICE_ID_KTI_ET32P2        0x3000
-#define PCI_VENDOR_ID_NETVIN            0x4a14
-#define PCI_DEVICE_ID_NETVIN_NV5000SC   0x5000
-#define	PCI_VENDOR_ID_HOLTEK		0x12c3
-#define	PCI_DEVICE_ID_HOLTEK_HT80232	0x0058
-#define PCI_VENDOR_ID_3COM		0x10b7
-#define PCI_DEVICE_ID_3COM_3C590	0x5900
-#define PCI_DEVICE_ID_3COM_3C595	0x5950
-#define PCI_DEVICE_ID_3COM_3C595_1	0x5951
-#define PCI_DEVICE_ID_3COM_3C595_2	0x5952
-#define PCI_DEVICE_ID_3COM_3C900TPO	0x9000
-#define PCI_DEVICE_ID_3COM_3C900COMBO	0x9001
-#define PCI_DEVICE_ID_3COM_3C905TX	0x9050
-#define PCI_DEVICE_ID_3COM_3C905T4	0x9051
-#define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
-#define PCI_DEVICE_ID_3COM_3C905C_TXM	0x9200
-#define PCI_VENDOR_ID_INTEL		0x8086
-#define PCI_DEVICE_ID_INTEL_82557	0x1229
-#define PCI_DEVICE_ID_INTEL_82559ER	0x1209
-#define PCI_DEVICE_ID_INTEL_ID1029	0x1029
-#define PCI_DEVICE_ID_INTEL_ID1030	0x1030
-#define PCI_DEVICE_ID_INTEL_82562	0x2449
-#define PCI_VENDOR_ID_AMD		0x1022
-#define PCI_DEVICE_ID_AMD_LANCE		0x2000
-#define PCI_VENDOR_ID_AMD_HOMEPNA	0x1022
-#define PCI_DEVICE_ID_AMD_HOMEPNA	0x2001
-#define PCI_VENDOR_ID_SMC_1211          0x1113
-#define PCI_DEVICE_ID_SMC_1211          0x1211
-#define PCI_VENDOR_ID_DEC		0x1011
-#define PCI_DEVICE_ID_DEC_TULIP		0x0002
-#define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
-#define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
-#define PCI_DEVICE_ID_DEC_21142		0x0019
-#define PCI_VENDOR_ID_SMC		0x10B8
-#ifndef	PCI_DEVICE_ID_SMC_EPIC100
-# define PCI_DEVICE_ID_SMC_EPIC100	0x0005
-#endif
-#define PCI_VENDOR_ID_MACRONIX		0x10d9
-#define PCI_DEVICE_ID_MX987x5		0x0531
-#define PCI_VENDOR_ID_LINKSYS		0x11AD
-#define PCI_DEVICE_ID_LC82C115		0xC115
-#define PCI_VENDOR_ID_VIATEC		0x1106
-#define PCI_DEVICE_ID_VIA_RHINE_I	0x3043
-#define PCI_DEVICE_ID_VIA_VT6102	0x3065
-#define PCI_DEVICE_ID_VIA_86C100A	0x6100
-#define PCI_VENDOR_ID_DAVICOM		0x1282
-#define	PCI_DEVICE_ID_DM9009		0x9009
-#define PCI_DEVICE_ID_DM9102		0x9102
-#define PCI_VENDOR_ID_SIS         	0x1039
-#define PCI_DEVICE_ID_SIS900     	0x0900   
-#define PCI_DEVICE_ID_SIS7016    	0x7016  
-#define	PCI_VENDOR_ID_DLINK		0x1186
-#define	PCI_DEVICE_ID_DFE530TXP		0x1300
-#define	PCI_VENDOR_ID_NS		0x100B
-#define	PCI_DEVICE_ID_DP83815		0x0020
-#define PCI_VENDOR_ID_OLICOM		0x108d
-#define PCI_DEVICE_ID_OLICOM_OC3136	0x0001
-#define PCI_DEVICE_ID_OLICOM_OC2315	0x0011
-#define PCI_DEVICE_ID_OLICOM_OC2325	0x0012
-#define PCI_DEVICE_ID_OLICOM_OC2183	0x0013
-#define PCI_DEVICE_ID_OLICOM_OC2326	0x0014
-#define PCI_DEVICE_ID_OLICOM_OC6151	0x0021
 
-struct pci_device {
-	unsigned short	vendor, dev_id;
-	const char	*name;
-	unsigned int	membase;
-	unsigned short	ioaddr;
-	unsigned char	devfn;
-	unsigned char	bus;
+static inline int 
+pci_read_config_byte(struct pci_device *dev, unsigned int where, uint8_t *value)
+{
+	return pcibios_read_config_byte(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_write_config_byte(struct pci_device *dev, unsigned int where, uint8_t value)
+{
+	return pcibios_write_config_byte(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_read_config_word(struct pci_device *dev, unsigned int where, uint16_t *value)
+{
+	return pcibios_read_config_word(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_write_config_word(struct pci_device *dev, unsigned int where, uint16_t value)
+{
+	return pcibios_write_config_word(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_read_config_dword(struct pci_device *dev, unsigned int where, uint32_t *value)
+{
+	return pcibios_read_config_dword(dev->bus, dev->devfn, where, value);
+}
+static inline int 
+pci_write_config_dword(struct pci_device *dev, unsigned int where, uint32_t value)
+{
+	return pcibios_write_config_dword(dev->bus, dev->devfn, where, value);
+}
+
+/* Helper functions to find the size of a pci bar */
+extern unsigned long pci_bar_start(struct pci_device *dev, unsigned int bar);
+extern unsigned long pci_bar_size(struct pci_device *dev, unsigned int bar);
+/* Helper function to find pci capabilities */
+extern int pci_find_capability(struct pci_device *dev, int cap);
+struct pci_id {
+	unsigned short vendor, dev_id;
+	const char *name;
 };
 
-extern void	eth_pci_init(struct pci_device *);
+struct dev;
+/* Most pci drivers will use this */
+struct pci_driver {
+	int type;
+	const char *name;
+	pci_probe_t probe;
+	struct pci_id *ids;
+	int id_count;
 
-extern int pcibios_read_config_byte(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned char *value);
-extern int pcibios_write_config_byte (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned char value);
-extern int pcibios_read_config_word(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned short *value);
-extern int pcibios_write_config_word (unsigned int bus, unsigned int device_fn, unsigned int where, unsigned short value);
-extern int pcibios_read_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int *value);
-extern int pcibios_write_config_dword(unsigned int bus, unsigned int device_fn, unsigned int where, unsigned int value);
-void adjust_pci_device(struct pci_device *p);
+/* On a few occasions the hardware is standardized enough that
+ * we only need to know the class of the device and not the exact
+ * type to drive the device correctly.  If this is the case
+ * set a class value other than 0.
+ */
+	unsigned short class;
+};
+
+
+#define PCI_ROM(VENDOR_ID, DEVICE_ID, IMAGE, DESCRIPTION) \
+	{ VENDOR_ID, DEVICE_ID, IMAGE, }
+
 #endif	/* PCI_H */
Index: netboot/timer.c
===================================================================
--- netboot/timer.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/timer.c	(.../trunk)	(revision 112)
@@ -6,122 +6,24 @@
  * published by the Free Software Foundation; either version 2, or (at
  * your option) any later version.
  */
-
-#include	"etherboot.h"
+#include        "grub.h"
 #include	"timer.h"
 
-void load_timer2(unsigned int ticks)
-{
-	/* Set up the timer gate, turn off the speaker */
-	outb((inb(PPC_PORTB) & ~PPCB_SPKR) | PPCB_T2GATE, PPC_PORTB);
-	outb(TIMER2_SEL|WORD_ACCESS|MODE0|BINARY_COUNT, TIMER_MODE_PORT);
-	outb(ticks & 0xFF, TIMER2_PORT);
-	outb(ticks >> 8, TIMER2_PORT);
-}
+/* Machine Independant timer helper functions */
 
-#if defined(CONFIG_TSC_CURRTICKS)
-#define rdtsc(low,high) \
-     __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
-
-#define rdtscll(val) \
-     __asm__ __volatile__ ("rdtsc" : "=A" (val))
-
-
-#define HZ TICKS_PER_SEC
-#define CLOCK_TICK_RATE	1193180U /* Underlying HZ */
-/* LATCH is used in the interval timer and ftape setup. */
-#define LATCH  ((CLOCK_TICK_RATE + HZ/2) / HZ)	/* For divider */
-
-
-/* ------ Calibrate the TSC ------- 
- * Return 2^32 * (1 / (TSC clocks per usec)) for do_fast_gettimeoffset().
- * Too much 64-bit arithmetic here to do this cleanly in C, and for
- * accuracy's sake we want to keep the overhead on the CTC speaker (channel 2)
- * output busy loop as low as possible. We avoid reading the CTC registers
- * directly because of the awkward 8-bit access mechanism of the 82C54
- * device.
- */
-
-#define CALIBRATE_LATCH	(5 * LATCH)
-
-static unsigned long long calibrate_tsc(void)
+void mdelay(unsigned int msecs)
 {
-	/* Set the Gate high, disable speaker */
-	outb((inb(0x61) & ~0x02) | 0x01, 0x61);
-
-	/*
-	 * Now let's take care of CTC channel 2
-	 *
-	 * Set the Gate high, program CTC channel 2 for mode 0,
-	 * (interrupt on terminal count mode), binary count,
-	 * load 5 * LATCH count, (LSB and MSB) to begin countdown.
-	 */
-	outb(0xb0, 0x43);			/* binary, mode 0, LSB/MSB, Ch 2 */
-	outb(CALIBRATE_LATCH & 0xff, 0x42);	/* LSB of count */
-	outb(CALIBRATE_LATCH >> 8, 0x42);	/* MSB of count */
-
-	{
-		unsigned long startlow, starthigh;
-		unsigned long endlow, endhigh;
-		unsigned long count;
-
-		rdtsc(startlow,starthigh);
-		count = 0;
-		do {
-			count++;
-		} while ((inb(0x61) & 0x20) == 0);
-		rdtsc(endlow,endhigh);
-
-		/* Error: ECTCNEVERSET */
-		if (count <= 1)
-			goto bad_ctc;
-
-		/* 64-bit subtract - gcc just messes up with long longs */
-		__asm__("subl %2,%0\n\t"
-			"sbbl %3,%1"
-			:"=a" (endlow), "=d" (endhigh)
-			:"g" (startlow), "g" (starthigh),
-			 "0" (endlow), "1" (endhigh));
-
-		/* Error: ECPUTOOFAST */
-		if (endhigh)
-			goto bad_ctc;
-
-		endlow /= 5;
-		return endlow;
+	unsigned int i;
+	for(i = 0; i < msecs; i++) {
+		udelay(1000);
+		poll_interruptions();
 	}
-
-	/*
-	 * The CTC wasn't reliable: we got a hit on the very first read,
-	 * or the CPU was so fast/slow that the quotient wouldn't fit in
-	 * 32 bits..
-	 */
-bad_ctc:
-	printf("bad_ctc\n");
-	return 0;
 }
 
-
-unsigned long currticks(void)
+void waiton_timer2(unsigned int ticks)
 {
-	static unsigned long clocks_per_tick;
-	unsigned long clocks_high, clocks_low;
-	unsigned long currticks;
-	if (!clocks_per_tick) {
-		clocks_per_tick = calibrate_tsc();
-		printf("clocks_per_tick = %d\n", clocks_per_tick);
+	load_timer2(ticks);
+	while(timer2_running()) {
+		poll_interruptions();
 	}
-
-	/* Read the Time Stamp Counter */
-	rdtsc(clocks_low, clocks_high);
-
-	/* currticks = clocks / clocks_per_tick; */
-	__asm__("divl %1"
-		:"=a" (currticks)
-		:"r" (clocks_per_tick), "0" (clocks_low), "d" (clocks_high));
-
-
-	return currticks;
 }
-
-#endif /* RTC_CURRTICKS */
Index: netboot/isa.h
===================================================================
--- netboot/isa.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/isa.h	(.../trunk)	(revision 112)
@@ -0,0 +1,27 @@
+#if !defined(ISA_H) && defined(CONFIG_ISA)
+#define ISA_H
+
+struct dev;
+
+#define ISAPNP_VENDOR(a,b,c)	(((((a)-'A'+1)&0x3f)<<2)|\
+				((((b)-'A'+1)&0x18)>>3)|((((b)-'A'+1)&7)<<13)|\
+				((((c)-'A'+1)&0x1f)<<8))
+
+#define	GENERIC_ISAPNP_VENDOR	ISAPNP_VENDOR('P','N','P')
+
+struct isa_driver
+{
+	int type;
+	const char *name;
+	int (*probe)(struct dev *, unsigned short *);
+	unsigned short *ioaddrs;
+};
+
+#define __isa_driver	__attribute__ ((unused,__section__(".drivers.isa")))
+extern const struct isa_driver isa_drivers[];
+extern const struct isa_driver isa_drivers_end[];
+
+#define ISA_ROM(IMAGE, DESCRIPTION)
+
+#endif /* ISA_H */
+
Index: netboot/fsys_tftp.c
===================================================================
--- netboot/fsys_tftp.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/fsys_tftp.c	(.../trunk)	(revision 112)
@@ -26,17 +26,19 @@
 
 **************************************************************************/
 
-/* #define TFTP_DEBUG	1 */
+/* #define TFTP_DEBUG	 1 */
 
 #include <filesys.h>
+#include <shared.h>
 
-#define GRUB	1
-#include <etherboot.h>
-#include <nic.h>
+#include "grub.h"
+#include "tftp.h"
+#include "nic.h"
+#include "pxe_tftp.h"
 
 static int retry;
 static unsigned short iport = 2000;
-static unsigned short oport;
+static unsigned short oport = 0;
 static unsigned short block, prevblock;
 static int bcounter;
 static struct tftp_t tp, saved_tp;
@@ -46,6 +48,181 @@
 static unsigned short len, saved_len;
 static char *buf;
 
+/**
+ * tftp_read
+ *
+ * Read file with _name_, data handled by _fnc_. In fact, grub never
+ * use it, we just use it to read dhcp config file.
+ */
+static int await_tftp(int ival, void *ptr __unused, 
+		      unsigned short ptype __unused, struct iphdr *ip, 
+		      struct udphdr *udp)
+{
+	if (!udp) {
+		return 0;
+	}
+	if (arptable[ARP_CLIENT].ipaddr.s_addr != ip->dest.s_addr)
+		return 0;
+	if (ntohs(udp->dest) != ival)
+		return 0;
+	return 1;
+}
+
+int tftp_file_read(const char *name, int (*fnc)(unsigned char *, unsigned int, unsigned int, int))
+{
+	struct tftpreq_t tpr;
+	struct tftp_t  *tr;
+	int		rc;
+
+#ifdef INCLUDE_PXE_TFTP
+	if (pxe_tftp_driver_active())
+	  {
+	    printf("tftp_file_read() called in PXE TFTP mode\n");
+	    return 1;
+	  }
+#endif
+
+	retry = 0;
+	block = 0;
+	prevblock = 0;
+	bcounter = 0;
+	
+
+	rx_qdrain();
+
+	tpr.opcode = htons(TFTP_RRQ);
+	/* Warning: the following assumes the layout of bootp_t.
+	   But that's fixed by the IP, UDP and BOOTP specs. */
+	len = sizeof(tpr.ip) + sizeof(tpr.udp) + sizeof(tpr.opcode) +
+		sprintf((char *)tpr.u.rrq, "%s%coctet%cblksize%c%d",
+		name, 0, 0, 0, TFTP_MAX_PACKET) + 1;
+	if (!udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr, ++iport,
+			  TFTP_PORT, len, &tpr))
+		return (0);
+	for (;;)
+	{
+		long timeout;
+#ifdef	CONGESTED
+		timeout = rfc2131_sleep_interval(block?TFTP_REXMT: TIMEOUT, retry);
+#else
+		timeout = rfc2131_sleep_interval(TIMEOUT, retry);
+#endif
+		if (!await_reply(await_tftp, iport, NULL, timeout))
+		{
+			if (!block && retry++ < MAX_TFTP_RETRIES)
+			{	/* maybe initial request was lost */
+				if (!udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+						  ++iport, TFTP_PORT, len,
+						  &tpr))
+					return (0);
+				continue;
+			}
+#ifdef	CONGESTED
+			if (block && ((retry += TFTP_REXMT) < TFTP_TIMEOUT))
+			{	/* we resend our last ack */
+#ifdef	MDEBUG
+				printf("<REXMT>\n");
+#endif
+				udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+					     iport, oport,
+					     TFTP_MIN_PACKET, &tpr);
+				continue;
+			}
+#endif
+			break;	/* timeout */
+		}
+		tr = (struct tftp_t *)&nic.packet[ETH_HLEN];
+		if (tr->opcode == ntohs(TFTP_ERROR))
+		{
+			printf("TFTP error %d (%s)\n",
+			       ntohs(tr->u.err.errcode),
+			       tr->u.err.errmsg);
+			break;
+		}
+
+		if (tr->opcode == ntohs(TFTP_OACK)) {
+			const char *p = tr->u.oack.data, *e;
+
+			if (prevblock)		/* shouldn't happen */
+				continue;	/* ignore it */
+			len = ntohs(tr->udp.len) - sizeof(struct udphdr) - 2;
+			if (len > TFTP_MAX_PACKET)
+				goto noak;
+			e = p + len;
+			while (*p != '\0' && p < e) {
+/* 				if (!strcasecmp("blksize", p)) { */
+				if (!grub_strcmp("blksize", p)) {
+					p += 8;
+/* 					if ((packetsize = strtoul(p, &p, 10)) < */
+					if ((packetsize = getdec((char **)&p)) < TFTP_DEFAULTSIZE_PACKET)
+						goto noak;
+					while (p < e && *p) p++;
+					if (p < e)
+						p++;
+				}
+				else {
+				noak:
+					tpr.opcode = htons(TFTP_ERROR);
+					tpr.u.err.errcode = 8;
+/*
+ *	Warning: the following assumes the layout of bootp_t.
+ *	But that's fixed by the IP, UDP and BOOTP specs.
+ */
+					len = sizeof(tpr.ip) + sizeof(tpr.udp) + sizeof(tpr.opcode) + sizeof(tpr.u.err.errcode) +
+/*
+ *	Normally bad form to omit the format string, but in this case
+ *	the string we are copying from is fixed. sprintf is just being
+ *	used as a strcpy and strlen.
+ */
+						sprintf((char *)tpr.u.err.errmsg,
+						"RFC1782 error") + 1;
+					udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr,
+						     iport, ntohs(tr->udp.src),
+						     len, &tpr);
+					return (0);
+				}
+			}
+			if (p > e)
+				goto noak;
+			block = tpr.u.ack.block = 0; /* this ensures, that */
+						/* the packet does not get */
+						/* processed as data! */
+		}
+		else if (tr->opcode == htons(TFTP_DATA)) {
+			len = ntohs(tr->udp.len) - sizeof(struct udphdr) - 4;
+			if (len > packetsize)	/* shouldn't happen */
+				continue;	/* ignore it */
+			block = ntohs(tpr.u.ack.block = tr->u.data.block); }
+		else {/* neither TFTP_OACK nor TFTP_DATA */
+			break;
+		}
+
+		if ((block || bcounter) && (block != (unsigned short)(prevblock+1))) {
+			/* Block order should be continuous */
+			tpr.u.ack.block = htons(block = prevblock);
+		}
+		tpr.opcode = htons(TFTP_ACK);
+		oport = ntohs(tr->udp.src);
+		udp_transmit(arptable[ARP_SERVER].ipaddr.s_addr, iport,
+			     oport, TFTP_MIN_PACKET, &tpr);	/* ack */
+		if ((unsigned short)(block-prevblock) != 1) {
+			/* Retransmission or OACK, don't process via callback
+			 * and don't change the value of prevblock.  */
+			continue;
+		}
+		prevblock = block;
+		retry = 0;	/* It's the right place to zero the timer? */
+		if ((rc = fnc(tr->u.data.download,
+			      ++bcounter, len, len < packetsize)) <= 0)
+			return(rc);
+		if (len < packetsize) {	/* End of data --- fnc should not have returned */
+			printf("tftp download complete, but\n");
+			return (1);
+		}
+	}
+	return (0);
+}
+
 /* Fill the buffer by receiving the data via the TFTP protocol.  */
 static int
 buf_fill (int abort)
@@ -65,9 +242,9 @@
       timeout = rfc2131_sleep_interval (TIMEOUT, retry);
 #endif
   
-      if (! await_reply (AWAIT_TFTP, iport, NULL, timeout))
+      if (! await_reply (await_tftp, iport, NULL, timeout))
 	{
-	  if (ip_abort)
+	  if (user_abort)
 	    return 0;
 
 	  if (! block && retry++ < MAX_TFTP_RETRIES)
@@ -270,13 +447,7 @@
   buf_read = 0;
   saved_filepos = 0;
 
-  /* Clear out the Rx queue first.  It contains nothing of interest,
-   * except possibly ARP requests from the DHCP/TFTP server.  We use
-   * polling throughout Etherboot, so some time may have passed since we
-   * last polled the receive queue, which may now be filled with
-   * broadcast packets.  This will cause the reply to the packets we are
-   * about to send to be lost immediately.  Not very clever.  */
-  await_reply (AWAIT_QDRAIN, 0, NULL, 0);
+  rx_qdrain();
   
 #ifdef TFTP_DEBUG
   grub_printf ("send_rrq ()\n");
@@ -324,7 +495,20 @@
 #ifdef TFTP_DEBUG
   grub_printf ("tftp_read (0x%x, %d)\n", (int) addr, size);
 #endif
-  
+
+#ifdef INCLUDE_PXE_TFTP
+  if (pxe_tftp_driver_active())
+    {
+      if ((ret = pxe_tftp_read(addr, size)) == -1)
+        {
+	  printf("pxe_tftp_read() failed\n");
+	  errnum = ERR_READ;
+	  return 0;
+	}
+      return ret;
+    }
+#endif
+
   if (filepos < saved_filepos)
     {
       /* Uggh.. FILEPOS has been moved backwards. So reopen the file.  */
@@ -421,6 +605,36 @@
   if (print_possibilities)
     return 1;
 
+  if (pxe_tftp_driver_active())
+    {
+      int ret = 1;
+      ch = nul_terminate(dirname);
+
+      if (!pxe_tftp_close())
+	{
+	  printf("%s: pxe_tftp_close() failed\n", __func__);
+	}
+
+      if ((filemax = pxe_tftp_get_file_size(dirname)) == -1)
+	{
+          errnum = ERR_FILE_NOT_FOUND;
+	  ret = 0;
+	  goto ret;
+	}
+
+      if (!pxe_tftp_open(dirname))
+	{
+	  printf("%s: pxe_tftp_open(%s) failed\n", __func__, dirname);
+          errnum = ERR_FILE_NOT_FOUND;
+	  ret = 0;
+	  goto ret;
+	}
+
+ret:
+      dirname[grub_strlen (dirname)] = ch;
+      return ret;
+    }
+
   /* Don't know the size yet.  */
   filemax = -1;
   
@@ -491,7 +705,15 @@
 #ifdef TFTP_DEBUG
   grub_printf ("tftp_close ()\n");
 #endif
-  
+
   buf_read = 0;
+
+  if (pxe_tftp_driver_active())
+    {
+      pxe_tftp_close();
+      return;
+    }
+
   buf_fill (1);
+
 }
Index: netboot/dev.h
===================================================================
--- netboot/dev.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/dev.h	(.../trunk)	(revision 112)
@@ -0,0 +1,83 @@
+#ifndef _DEV_H
+#define _DEV_H
+
+#include "isa.h"
+#include "pci.h"
+
+/* Need to check the packing of this struct if Etherboot is ported */
+struct dev_id
+{
+	unsigned short	vendor_id;
+	unsigned short	device_id;
+	unsigned char	bus_type;
+#define	PCI_BUS_TYPE	1
+#define	ISA_BUS_TYPE	2
+};
+
+/* Dont use sizeof, that will include the padding */
+#define	DEV_ID_SIZE	8
+
+
+struct pci_probe_state 
+{
+#ifdef CONFIG_PCI
+	struct pci_device dev;
+	int advance;
+#else
+	int dummy;
+#endif
+};
+struct isa_probe_state
+{
+#ifdef CONFIG_ISA
+	const struct isa_driver *driver;
+	int advance;
+#else
+	int dummy;
+#endif
+};
+
+union probe_state
+{
+	struct pci_probe_state pci;
+	struct isa_probe_state isa;
+};
+
+struct dev
+{
+	void		(*disable)P((struct dev *));
+	struct dev_id	devid;	/* device ID string (sent to DHCP server) */
+	int		index;  /* Index of next device on this controller to probe */
+	int		type;		/* Type of device I am probing for */
+	int		how_probe;	/* First, next or awake */
+	int 		to_probe;	/* Flavor of device I am probing */
+	int		failsafe;	/* Failsafe probe requested */
+	int		type_index;	/* Index of this device (within type) */
+#define	PROBE_NONE 0
+#define PROBE_PCI  1
+#define PROBE_ISA  2
+	union probe_state state;
+};
+
+
+#define NIC_DRIVER    0
+#define DISK_DRIVER   1
+#define FLOPPY_DRIVER 2
+
+#define BRIDGE_DRIVER 1000
+
+#define PROBE_FIRST  (-1)
+#define PROBE_NEXT   0
+#define PROBE_AWAKE  1		/* After calling disable bring up the same device */
+
+/* The probe result codes are selected
+ * to allow them to be fed back into the probe
+ * routine and get a successful probe.
+ */
+#define PROBE_FAILED PROBE_FIRST
+#define PROBE_WORKED  PROBE_NEXT
+
+extern int probe(struct dev *dev);
+extern void disable(struct dev *dev);
+
+#endif /* _DEV_H */
Index: netboot/sis900.txt
===================================================================
--- netboot/sis900.txt	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/sis900.txt	(.../trunk)	(revision 112)
@@ -74,14 +74,14 @@
 ***********************************************************************
 
 At this point, you can begin creating your driver source file.  See
-the "Writing and Etherboot Driver" section of the Etherboot
+the "Writing an Etherboot Driver" section of the Etherboot
 documentation for some hints.  See the skel.c file for a starting
 point.  If there is a Linux driver for the card, you may be able to
 use that.  Copy and learn from existing Etherboot drivers (this is GPL
 / Open Source software!).
 
 Join the etherboot-developers and etherboot-users mailing lists
-(information is on etherboot.sourceforge.net) for information and
+(information is on http://etherboot.sourceforge.net) for information and
 assistance. We invite more developers to help improve Etherboot.
 
 Visit the http://etherboot.sourceforge.net, http://thinguin.org, 
Index: netboot/i386_elf.h
===================================================================
--- netboot/i386_elf.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/i386_elf.h	(.../trunk)	(revision 112)
@@ -0,0 +1,91 @@
+#ifndef I386_BITS_ELF_H
+#define I386_BITS_ELF_H
+
+#include "cpu.h"
+
+#ifdef CONFIG_X86_64
+/* ELF Defines for the 64bit version of the current architecture */
+#define EM_CURRENT_64	EM_X86_64
+#define EM_CURRENT_64_PRESENT ( \
+	CPU_FEATURE_P(cpu_info.x86_capability, LM) && \
+	CPU_FEATURE_P(cpu_info.x86_capability, PAE) && \
+	CPU_FEATURE_P(cpu_info.x86_capability, PSE))
+			
+#define ELF_CHECK_X86_64_ARCH(x) \
+	(EM_CURRENT_64_PRESENT && ((x).e_machine == EM_X86_64))
+#define __unused_i386
+#else
+#define ELF_CHECK_X86_64_ARCH(x) 0
+#define __unused_i386 __unused
+#endif
+
+
+/* ELF Defines for the current architecture */
+#define	EM_CURRENT	EM_386
+#define ELFDATA_CURRENT	ELFDATA2LSB
+
+#define ELF_CHECK_I386_ARCH(x) \
+	(((x).e_machine == EM_386) || ((x).e_machine == EM_486))
+
+#define ELF_CHECK_ARCH(x) \
+	((ELF_CHECK_I386_ARCH(x) || ELF_CHECK_X86_64_ARCH(x)) && \
+		((x).e_entry <= 0xffffffffUL))
+
+#ifdef  IMAGE_FREEBSD
+/*
+ * FreeBSD has this rather strange "feature" of its design.
+ * At some point in its evolution, FreeBSD started to rely
+ * externally on private/static/debug internal symbol information.
+ * That is, some of the interfaces that software uses to access
+ * and work with the FreeBSD kernel are made available not
+ * via the shared library symbol information (the .DYNAMIC section)
+ * but rather the debug symbols.  This means that any symbol, not
+ * just publicly defined symbols can be (and are) used by system
+ * tools to make the system work.  (such as top, swapinfo, swapon,
+ * etc)
+ *
+ * Even worse, however, is the fact that standard ELF loaders do
+ * not know how to load the symbols since they are not within
+ * an ELF PT_LOAD section.  The kernel needs these symbols to
+ * operate so the following changes/additions to the boot
+ * loading of EtherBoot have been made to get the kernel to load.
+ * All of the changes are within IMAGE_FREEBSD such that the
+ * extra/changed code only compiles when FREEBSD support is
+ * enabled.
+ */
+
+/*
+ * Section header for FreeBSD (debug symbol kludge!) support
+ */
+typedef struct {
+	Elf32_Word	sh_name;	/* Section name (index into the
+					   section header string table). */
+	Elf32_Word	sh_type;	/* Section type. */
+	Elf32_Word	sh_flags;	/* Section flags. */
+	Elf32_Addr	sh_addr;	/* Address in memory image. */
+	Elf32_Off	sh_offset;	/* Offset in file. */
+	Elf32_Size	sh_size;	/* Size in bytes. */
+	Elf32_Word	sh_link;	/* Index of a related section. */
+	Elf32_Word	sh_info;	/* Depends on section type. */
+	Elf32_Size	sh_addralign;	/* Alignment in bytes. */
+	Elf32_Size	sh_entsize;	/* Size of each entry in section. */
+} Elf32_Shdr;
+
+/* sh_type */
+#define SHT_SYMTAB	2		/* symbol table section */
+#define SHT_STRTAB	3		/* string table section */
+
+/*
+ * Module information subtypes (for the metadata that we need to build)
+ */
+#define MODINFO_END		0x0000		/* End of list */
+#define MODINFO_NAME		0x0001		/* Name of module (string) */
+#define MODINFO_TYPE		0x0002		/* Type of module (string) */
+#define MODINFO_METADATA	0x8000		/* Module-specfic */
+
+#define MODINFOMD_SSYM		0x0003		/* start of symbols */
+#define MODINFOMD_ESYM		0x0004		/* end of symbols */
+
+#endif	/* IMAGE_FREEBSD */
+
+#endif /* I386_BITS_ELF_H */
Index: netboot/timer.h
===================================================================
--- netboot/timer.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/timer.h	(.../trunk)	(revision 112)
@@ -36,7 +36,8 @@
 #define	BCD_COUNT	0x01
 
 /* Timers tick over at this rate */
-#define	TICKS_PER_MS	1193
+#define CLOCK_TICK_RATE	1193180U
+#define	TICKS_PER_MS	(CLOCK_TICK_RATE/1000)
 
 /* Parallel Peripheral Controller Port B */
 #define	PPC_PORTB	0x61
@@ -49,16 +50,19 @@
 /* Ticks must be between 0 and 65535 (0 == 65536)
    because it is a 16 bit counter */
 extern void load_timer2(unsigned int ticks);
-extern inline int timer2_running(void)
-{
-	return ((inb(PPC_PORTB) & PPCB_T2OUT) == 0);
-}
+extern inline int timer2_running(void);
+extern void waiton_timer2(unsigned int ticks);
+extern void __load_timer2(unsigned int ticks);
 
-extern inline void waiton_timer2(unsigned int ticks)
-{
-	load_timer2(ticks);
-	while ((inb(PPC_PORTB) & PPCB_T2OUT) == 0)
-		;
-}
+extern void setup_timers(void);
+extern void ndelay(unsigned int nsecs);
+extern void udelay(unsigned int usecs);
+extern void mdelay(unsigned int msecs);
+//extern unsigned long currticks(void);
 
+struct timeval {
+	long tv_sec;
+	long tv_usec;
+};
+
 #endif	/* TIMER_H */
Index: netboot/sis900.c
===================================================================
--- netboot/sis900.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/sis900.c	(.../trunk)	(revision 112)
@@ -27,6 +27,11 @@
 /* Revision History */
 
 /*
+  07 Dec 2003  timlegge - Enabled Multicast Support
+  06 Dec 2003  timlegge - Fixed relocation issue in 5.2
+  04 Jan 2002  Chien-Yu Chen, Doug Ambrisko, Marty Connor  Patch to Etherboot 5.0.5
+     Added support for the SiS 630ET plus various bug fixes from linux kernel
+     source 2.4.17.
   01 March 2001  mdc     1.0
      Initial Release.  Tested with PCI based sis900 card and ThinkNIC
      computer.
@@ -41,7 +46,7 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
+#include "timer.h"
 
 #include "sis900.h"
 
@@ -51,6 +56,7 @@
 
 static unsigned short vendor, dev_id;
 static unsigned long ioaddr;
+static u8 pci_revision;
 
 static unsigned int cur_phy;
 
@@ -58,14 +64,8 @@
 
 static BufferDesc txd;
 static BufferDesc rxd[NUM_RX_DESC];
-
-#ifdef USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - TX_BUF_SIZE)
-#define rxb ((char *)0x10000 - NUM_RX_DESC*RX_BUF_SIZE - TX_BUF_SIZE)
-#else
 static unsigned char txb[TX_BUF_SIZE];
 static unsigned char rxb[NUM_RX_DESC * RX_BUF_SIZE];
-#endif
 
 static struct mac_chip_info {
     const char *name;
@@ -83,6 +83,7 @@
 static void amd79c901_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 static void ics1893_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 static void rtl8201_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
+static void vt6103_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex);
 
 static struct mii_chip_info {
     const char * name;
@@ -96,6 +97,7 @@
     {"AMD 79C901 HomePNA PHY",   0x0000, 0x35c8, amd79c901_read_mode},
     {"ICS 1893 Integrated PHYceiver"   , 0x0015, 0xf441,ics1893_read_mode},
     {"RTL 8201 10/100Mbps Phyceiver"   , 0x0000, 0x8201,rtl8201_read_mode},
+    {"VIA 6103 10/100Mbps Phyceiver", 0x0101, 0x8f20,vt6103_read_mode},
     {0,0,0,0}
 };
 
@@ -108,15 +110,23 @@
 
 
 // PCI to ISA bridge for SIS640E access
-static struct pci_device   pci_isa_bridge_list[] = {
+static struct pci_id   pci_isa_bridge_list[] = {
 	{ 0x1039, 0x0008,
-		"SIS 85C503/5513 PCI to ISA bridge", 0, 0, 0, 0},
-	{0, 0, NULL, 0, 0, 0, 0}
+		"SIS 85C503/5513 PCI to ISA bridge"},
 };
 
+static struct pci_driver sis_bridge_driver = {
+	.type     = BRIDGE_DRIVER,
+	.name     = "",
+	.probe    = 0,
+	.ids      = pci_isa_bridge_list,
+	.id_count = sizeof(pci_isa_bridge_list)/sizeof(pci_isa_bridge_list[0]),
+	.class    = 0,
+};
+
 /* Function Prototypes */
 
-struct nic *sis900_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci);
+static int sis900_probe(struct dev *dev, struct pci_device *pci);
 
 static u16  sis900_read_eeprom(int location);
 static void sis900_mdio_reset(long mdio_addr);
@@ -138,7 +148,7 @@
                             unsigned int t, unsigned int s, const char *p);
 static int  sis900_poll(struct nic *nic);
 
-static void sis900_disable(struct nic *nic);
+static void sis900_disable(struct dev *dev);
 
 /**
  *	sis900_get_mac_addr: - Get MAC address for stand alone SiS900 model
@@ -149,7 +159,7 @@
  *	MAC address is read from read_eeprom() into @net_dev->dev_addr.
  */
 
-static int sis900_get_mac_addr(struct pci_device * pci_dev , struct nic *nic)
+static int sis900_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
 {
 	u16 signature;
 	int i;
@@ -168,6 +178,50 @@
 }
 
 /**
+ *	sis96x_get_mac_addr: - Get MAC address for SiS962 or SiS963 model
+ *	@pci_dev: the sis900 pci device
+ *	@net_dev: the net device to get address for 
+ *
+ *	SiS962 or SiS963 model, use EEPROM to store MAC address. And EEPROM 
+ *	is shared by
+ *	LAN and 1394. When access EEPROM, send EEREQ signal to hardware first 
+ *	and wait for EEGNT. If EEGNT is ON, EEPROM is permitted to be access 
+ *	by LAN, otherwise is not. After MAC address is read from EEPROM, send
+ *	EEDONE signal to refuse EEPROM access by LAN. 
+ *	The EEPROM map of SiS962 or SiS963 is different to SiS900. 
+ *	The signature field in SiS962 or SiS963 spec is meaningless. 
+ *	MAC address is read into @net_dev->dev_addr.
+ */
+
+static int sis96x_get_mac_addr(struct pci_device * pci_dev, struct nic *nic)
+{
+/* 	long ioaddr = net_dev->base_addr; */
+	long ee_addr = ioaddr + mear;
+	u32 waittime = 0;
+	int i;
+	
+	printf("Alternate function\n");
+
+	outl(EEREQ, ee_addr);
+	while(waittime < 2000) {
+		if(inl(ee_addr) & EEGNT) {
+
+			/* get MAC address from EEPROM */
+			for (i = 0; i < 3; i++)
+			        ((u16 *)(nic->node_addr))[i] = sis900_read_eeprom(i+EEPROMMACAddr);
+
+			outl(EEDONE, ee_addr);
+			return 1;
+		} else {
+			udelay(1);	
+			waittime ++;
+		}
+	}
+	outl(EEDONE, ee_addr);
+	return 0;
+}
+
+/**
  *	sis630e_get_mac_addr: - Get MAC address for SiS630E model
  *	@pci_dev: the sis900 pci device
  *	@net_dev: the net device to get address for
@@ -177,17 +231,21 @@
  *	MAC address is read into @net_dev->dev_addr.
  */
 
-static int sis630e_get_mac_addr(struct pci_device * pci_dev, struct nic *nic)
+static int sis630e_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
 {
 	u8 reg;
 	int i;
-	struct pci_device	*p;
+	struct pci_device	p[1];
 
-	// find PCI to ISA bridge
-	eth_pci_init(pci_isa_bridge_list);
+	/* find PCI to ISA bridge */
+	memset(p, 0, sizeof(p));
+	do {
+		find_pci(BRIDGE_DRIVER, p);
+	} while(p->driver && p->driver != &sis_bridge_driver);
 
-    /* the firts entry in this list should contain bus/devfn */
-    p = pci_isa_bridge_list;
+	/* error on failure */
+	if (!p->driver)
+	    return 0;
 
 	pcibios_read_config_byte(p->bus,p->devfn, 0x48, &reg);
 	pcibios_write_config_byte(p->bus,p->devfn, 0x48, reg | 0x40);
@@ -201,6 +259,42 @@
 
 	return 1;
 }
+
+/**
+ *      sis630e_get_mac_addr: - Get MAC address for SiS630E model
+ *      @pci_dev: the sis900 pci device
+ *      @net_dev: the net device to get address for
+ *
+ *      SiS630E model, use APC CMOS RAM to store MAC address.
+ *      APC CMOS RAM is accessed through ISA bridge.
+ *      MAC address is read into @net_dev->dev_addr.
+ */
+
+static int sis635_get_mac_addr(struct pci_device * pci_dev __unused, struct nic *nic)
+{
+        u32 rfcrSave;
+        u32 i;
+	
+	
+        rfcrSave = inl(rfcr + ioaddr);
+
+        outl(rfcrSave | RELOAD, ioaddr + cr);
+        outl(0, ioaddr + cr);
+
+        /* disable packet filtering before setting filter */
+        outl(rfcrSave & ~RFEN, rfcr + ioaddr);
+
+        /* load MAC addr to filter data register */
+        for (i = 0 ; i < 3 ; i++) {
+                outl((i << RFADDR_shift), ioaddr + rfcr);
+                *( ((u16 *)nic->node_addr) + i) = inw(ioaddr + rfdr);
+        }
+
+        /* enable packet filitering */
+        outl(rfcrSave | RFEN, rfcr + ioaddr);
+
+        return 1;
+}
 
 /* 
  * Function: sis900_probe
@@ -216,19 +310,19 @@
  * Returns:   struct nic *:          pointer to NIC data structure
  */
 
-struct nic *sis900_probe(struct nic *nic, unsigned short *io_addrs, struct pci_device *pci)
+static int sis900_probe(struct dev *dev, struct pci_device *pci)
 {
+    struct nic *nic = (struct nic *)dev;
     int i;
     int found=0;
     int phy_addr;
-    u16 signature;
     u8 revision;
     int ret;
 
-    if (io_addrs == 0 || *io_addrs == 0)
-        return NULL;
+    if (pci->ioaddr == 0)
+        return 0;
 
-    ioaddr  = *io_addrs & ~3;
+    ioaddr  = pci->ioaddr & ~3;
     vendor  = pci->vendor;
     dev_id  = pci->dev_id;
 
@@ -240,19 +334,29 @@
     /* get MAC address */
     ret = 0;
     pcibios_read_config_byte(pci->bus,pci->devfn, PCI_REVISION, &revision);
-    if (revision == SIS630E_900_REV || revision == SIS630EA1_900_REV)
-       ret = sis630e_get_mac_addr(pci, nic);
-    else if (revision == SIS630S_900_REV)
+    
+    /* save for use later in sis900_reset() */
+    pci_revision = revision; 
+
+    if (revision == SIS630E_900_REV)
         ret = sis630e_get_mac_addr(pci, nic);
+    else if ((revision > 0x81) && (revision <= 0x90))
+        ret = sis635_get_mac_addr(pci, nic);
+    else if (revision == SIS96x_900_REV)
+	ret = sis96x_get_mac_addr(pci, nic);
     else
         ret = sis900_get_mac_addr(pci, nic);
 
     if (ret == 0)
     {
         printf ("sis900_probe: Error MAC address not found\n");
-        return NULL;
+        return 0;
     }
 
+    /* 630ET : set the mii access mode as software-mode */
+    if (revision == SIS630ET_900_REV)
+	outl(ACCESSMODE | inl(ioaddr + cr), ioaddr + cr);
+
     printf("\nsis900_probe: MAC addr %! at ioaddr %#hX\n",
            nic->node_addr, ioaddr);
     printf("sis900_probe: Vendor:%#hX Device:%#hX\n", vendor, dev_id);
@@ -264,7 +368,7 @@
     for (phy_addr = 0; phy_addr < 32; phy_addr++) {
         u16 mii_status;
         u16 phy_id0, phy_id1;
-                
+
         mii_status = sis900_mdio_read(phy_addr, MII_STATUS);
         if (mii_status == 0xffff || mii_status == 0x0000)
             /* the mii is not accessable, try next one */
@@ -272,7 +376,7 @@
                 
         phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
         phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
-                
+
         /* search our mii table for the current mii */ 
         for (i = 0; mii_chip_table[i].phy_id1; i++) {
 
@@ -294,7 +398,7 @@
         
     if (found == 0) {
         printf("sis900_probe: No MII transceivers found!\n");
-        return NULL;
+        return 0;
     }
 
     /* Arbitrarily select the last PHY found as current PHY */
@@ -304,12 +408,11 @@
     /* initialize device */
     sis900_init(nic);
 
-    nic->reset    = sis900_init;
+    dev->disable  = sis900_disable;
     nic->poll     = sis900_poll;
     nic->transmit = sis900_transmit;
-    nic->disable  = sis900_disable;
 
-    return nic;
+    return 1;
 }
 
 
@@ -432,6 +535,7 @@
         outl(MDC, mdio_addr);
         sis900_mdio_delay();
     }
+    outl(0x00, mdio_addr);
     return retval;
 }
 
@@ -471,6 +575,7 @@
         outb(MDC, mdio_addr);
         sis900_mdio_delay();
     }
+    outl(0x00, mdio_addr);
     return;
 }
 
@@ -500,7 +605,7 @@
 
     sis900_check_mode(nic);
 
-    outl(RxENA, ioaddr + cr);
+    outl(RxENA| inl(ioaddr + cr), ioaddr + cr);
 }
 
 
@@ -515,7 +620,7 @@
  */
 
 static void 
-sis900_reset(struct nic *nic)
+sis900_reset(struct nic *nic __unused)
 {
     int i = 0;
     u32 status = TxRCMP | RxRCMP;
@@ -524,13 +629,17 @@
     outl(0, ioaddr + imr);
     outl(0, ioaddr + rfcr);
 
-    outl(RxRESET | TxRESET | RESET, ioaddr + cr);
-        
+    outl(RxRESET | TxRESET | RESET | inl(ioaddr + cr), ioaddr + cr);
+
     /* Check that the chip has finished the reset. */
     while (status && (i++ < 1000)) {
         status ^= (inl(isr + ioaddr) & status);
     }
-    outl(PESEL, ioaddr + cfg);
+
+    if( (pci_revision == SIS635A_900_REV) || (pci_revision == SIS900B_900_REV) )
+            outl(PESEL | RND_CNT, ioaddr + cfg);
+    else
+            outl(PESEL, ioaddr + cfg);
 }
 
 
@@ -552,7 +661,7 @@
     rfcrSave = inl(rfcr + ioaddr);
 
     /* disable packet filtering before setting filter */
-    outl(rfcrSave & ~RFEN, rfcr);
+    outl(rfcrSave & ~RFEN, rfcr + ioaddr);
 
     /* load MAC addr to filter data register */
     for (i = 0 ; i < 3 ; i++) {
@@ -583,14 +692,14 @@
  */
 
 static void
-sis900_init_txd(struct nic *nic)
+sis900_init_txd(struct nic *nic __unused)
 {
     txd.link   = (u32) 0;
     txd.cmdsts = (u32) 0;
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + txdp); 
+    outl(virt_to_bus(&txd), ioaddr + txdp); 
     if (sis900_debug > 0)
         printf("sis900_init_txd: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + txdp));
@@ -607,7 +716,7 @@
  */
 
 static void 
-sis900_init_rxd(struct nic *nic) 
+sis900_init_rxd(struct nic *nic __unused) 
 { 
     int i;
 
@@ -615,16 +724,16 @@
 
     /* init RX descriptor */
     for (i = 0; i < NUM_RX_DESC; i++) {
-        rxd[i].link   = (i+1 < NUM_RX_DESC) ? (u32) &rxd[i+1] : (u32) &rxd[0];
+        rxd[i].link   = virt_to_bus((i+1 < NUM_RX_DESC) ? &rxd[i+1] : &rxd[0]);
         rxd[i].cmdsts = (u32) RX_BUF_SIZE;
-        rxd[i].bufptr = (u32) &rxb[i*RX_BUF_SIZE];
+        rxd[i].bufptr = virt_to_bus(&rxb[i*RX_BUF_SIZE]);
         if (sis900_debug > 0)
             printf("sis900_init_rxd: rxd[%d]=%X link=%X cmdsts=%X bufptr=%X\n", 
                    i, &rxd[i], rxd[i].link, rxd[i].cmdsts, rxd[i].bufptr);
     }
 
     /* load Receive Descriptor Register */
-    outl((u32) &rxd[0], ioaddr + rxdp);
+    outl(virt_to_bus(&rxd[0]), ioaddr + rxdp);
 
     if (sis900_debug > 0)
         printf("sis900_init_rxd: RX descriptor register loaded with: %X\n", 
@@ -644,20 +753,32 @@
  * Returns:   void.
  */
 
-static void sis900_set_rx_mode(struct nic *nic)
+static void sis900_set_rx_mode(struct nic *nic __unused)
 {
-    int i;
+    int i, table_entries;
+    u32 rx_mode; 
+    u16 mc_filter[16] = {0};	/* 256/128 bits multicast hash table */
+    	
+    if((pci_revision == SIS635A_900_REV) || (pci_revision == SIS900B_900_REV))
+	table_entries = 16;
+    else
+	table_entries = 8;
 
-    /* Configure Multicast Hash Table in Receive Filter 
-       to reject all MCAST packets */
-    for (i = 0; i < 8; i++) {
+    /* accept all multicast packet */
+    rx_mode = RFAAB | RFAAM;
+    for (i = 0; i < table_entries; i++)
+		mc_filter[i] = 0xffff;
+					
+    /* update Multicast Hash Table in Receive Filter */
+    for (i = 0; i < table_entries; i++) {
         /* why plus 0x04? That makes the correct value for hash table. */
         outl((u32)(0x00000004+i) << RFADDR_shift, ioaddr + rfcr);
-        outl((u32)(0x0), ioaddr + rfdr);
+        outl(mc_filter[i], ioaddr + rfdr);
     }
-    /* Accept Broadcast packets, destination addresses that match 
+
+    /* Accept Broadcast and multicast packets, destination addresses that match 
        our MAC address */
-    outl(RFEN | RFAAB, ioaddr + rfcr);
+    outl(RFEN | rx_mode, ioaddr + rfcr);
 
     return;
 }
@@ -674,15 +795,21 @@
  */
 
 static void
-sis900_check_mode (struct nic *nic)
+sis900_check_mode(struct nic *nic)
 {
     int speed, duplex;
     u32 tx_flags = 0, rx_flags = 0;
 
     mii.chip_info->read_mode(nic, cur_phy, &speed, &duplex);
 
-    tx_flags = TxATP | (TX_DMA_BURST << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
-    rx_flags = RX_DMA_BURST << RxMXDMA_shift;
+    if( inl(ioaddr + cfg) & EDB_MASTER_EN ) {
+        tx_flags = TxATP | (DMA_BURST_64 << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
+	rx_flags = DMA_BURST_64 << RxMXDMA_shift;
+    }
+    else {
+            tx_flags = TxATP | (DMA_BURST_512 << TxMXDMA_shift) | (TX_FILL_THRESH << TxFILLT_shift);
+            rx_flags = DMA_BURST_512 << RxMXDMA_shift;
+    }
 
     if (speed == HW_SPEED_HOME || speed == HW_SPEED_10_MBPS) {
         rx_flags |= (RxDRNT_10 << RxDRNT_shift);
@@ -714,25 +841,34 @@
  */
 
 static void
-sis900_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+sis900_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
     int i = 0;
     u32 status;
+    u16 phy_id0, phy_id1;
         
     /* STSOUT register is Latched on Transition, read operation updates it */
     while (i++ < 2)
         status = sis900_mdio_read(phy_addr, MII_STSOUT);
 
-    if (status & MII_STSOUT_SPD)
-        *speed = HW_SPEED_100_MBPS;
-    else
-        *speed = HW_SPEED_10_MBPS;
+    *speed = HW_SPEED_10_MBPS;
+    *duplex = FDX_CAPABLE_HALF_SELECTED;
+    
+    if (status & (MII_NWAY_TX | MII_NWAY_TX_FDX))
+	*speed = HW_SPEED_100_MBPS;
+    if (status & ( MII_NWAY_TX_FDX | MII_NWAY_T_FDX))
+	*duplex = FDX_CAPABLE_FULL_SELECTED;
+	
+    /* Workaround for Realtek RTL8201 PHY issue */
+    phy_id0 = sis900_mdio_read(phy_addr, MII_PHY_ID0);
+    phy_id1 = sis900_mdio_read(phy_addr, MII_PHY_ID1);
+    if((phy_id0 == 0x0000) && ((phy_id1 & 0xFFF0) == 0x8200)){
+	if(sis900_mdio_read(phy_addr, MII_CONTROL) & MII_CNTL_FDX)
+	    *duplex = FDX_CAPABLE_FULL_SELECTED;
+	if(sis900_mdio_read(phy_addr, 0x0019) & 0x01)
+	    *speed = HW_SPEED_100_MBPS;
+    }
 
-    if (status & MII_STSOUT_DPLX)
-        *duplex = FDX_CAPABLE_FULL_SELECTED;
-    else
-        *duplex = FDX_CAPABLE_HALF_SELECTED;
-
     if (status & MII_STSOUT_LINK_FAIL)
         printf("sis900_read_mode: Media Link Off\n");
     else
@@ -755,7 +891,7 @@
  */
 
 static void
-amd79c901_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+amd79c901_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
     int i;
     u16 status;
@@ -808,7 +944,7 @@
  *	to determine the speed and duplex mode for sis900
  */
 
-static void ics1893_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+static void ics1893_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
 	int i = 0;
 	u32 status;
@@ -848,7 +984,7 @@
  *	to determine the speed and duplex mode for sis900
  */
 
-static void rtl8201_read_mode(struct nic *nic, int phy_addr, int *speed, int *duplex)
+static void rtl8201_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
 {
 	u32 status;
 
@@ -878,9 +1014,53 @@
 		       *duplex == FDX_CAPABLE_FULL_SELECTED ?
 		       "full" : "half");
 	else
-		printf("rtl9201_read_config_mode: Media Link Off\n");
+		printf("rtl8201_read_config_mode: Media Link Off\n");
 }
 
+/**
+ *	vt6103_read_mode: - read media mode for vt6103 phy
+ *	@nic: the net device to read mode for
+ *	@phy_addr: mii phy address
+ *	@speed: the transmit speed to be determined
+ *	@duplex: the duplex mode to be determined
+ *
+ *	read MII_STATUS register from rtl8201 phy
+ *	to determine the speed and duplex mode for sis900
+ */
+
+static void vt6103_read_mode(struct nic *nic __unused, int phy_addr, int *speed, int *duplex)
+{
+	u32 status;
+
+	status = sis900_mdio_read(phy_addr, MII_STATUS);
+
+	if (status & MII_STAT_CAN_TX_FDX) {
+		*speed = HW_SPEED_100_MBPS;
+		*duplex = FDX_CAPABLE_FULL_SELECTED;
+	}
+	else if (status & MII_STAT_CAN_TX) {
+		*speed = HW_SPEED_100_MBPS;
+		*duplex = FDX_CAPABLE_HALF_SELECTED;
+	}
+	else if (status & MII_STAT_CAN_T_FDX) {
+		*speed = HW_SPEED_10_MBPS;
+		*duplex = FDX_CAPABLE_FULL_SELECTED;
+	}
+	else if (status & MII_STAT_CAN_T) {
+		*speed = HW_SPEED_10_MBPS;
+		*duplex = FDX_CAPABLE_HALF_SELECTED;
+	}
+
+	if (status & MII_STAT_LINK)
+		printf("vt6103_read_mode: Media Link On %s %s-duplex \n",
+		       *speed == HW_SPEED_100_MBPS ?
+		       "100mbps" : "10mbps",
+		       *duplex == FDX_CAPABLE_FULL_SELECTED ?
+		       "full" : "half");
+	else
+		printf("vt6103_read_config_mode: Media Link Off\n");
+}
+
 /* Function: sis900_transmit
  *
  * Description: transmits a packet and waits for completion or timeout.
@@ -900,14 +1080,14 @@
                 unsigned int s,     /* size */
                 const char  *p)     /* Packet */
 {
-    u32 status, to, nstype;
+    u32 to, nstype;
     u32 tx_status;
     
     /* Stop the transmitter */
-    outl(TxDIS, ioaddr + cr);
+    outl(TxDIS | inl(ioaddr + cr), ioaddr + cr);
 
     /* load Transmit Descriptor Register */
-    outl((u32) &txd, ioaddr + txdp); 
+    outl(virt_to_bus(&txd), ioaddr + txdp); 
     if (sis900_debug > 1)
         printf("sis900_transmit: TX descriptor register loaded with: %X\n", 
                inl(ioaddr + txdp));
@@ -929,11 +1109,11 @@
         txb[s++] = '\0';
 
     /* set the transmit buffer descriptor and enable Transmit State Machine */
-    txd.bufptr = (u32) &txb[0];
+    txd.bufptr = virt_to_bus(&txb[0]);
     txd.cmdsts = (u32) OWN | s;
 
     /* restart the transmitter */
-    outl(TxENA, ioaddr + cr);
+    outl(TxENA | inl(ioaddr + cr), ioaddr + cr);
 
     if (sis900_debug > 1)
         printf("sis900_transmit: Queued Tx packet size %d.\n", (int) s);
@@ -1001,15 +1181,16 @@
 
     /* return the descriptor and buffer to receive ring */
     rxd[cur_rx].cmdsts = RX_BUF_SIZE;
-    rxd[cur_rx].bufptr = (u32) &rxb[cur_rx*RX_BUF_SIZE];
+    rxd[cur_rx].bufptr = virt_to_bus(&rxb[cur_rx*RX_BUF_SIZE]);
         
     if (++cur_rx == NUM_RX_DESC)
         cur_rx = 0;
 
     /* re-enable the potentially idle receive state machine */
-    outl(RxENA , ioaddr + cr);
+    outl(RxENA | inl(ioaddr + cr), ioaddr + cr);
 
     return retstat;
+
 }
 
 
@@ -1023,12 +1204,30 @@
  */
 
 static void
-sis900_disable(struct nic *nic)
+sis900_disable(struct dev *dev)
 {
+    struct nic *nic = (struct nic *)dev;
+    /* merge reset and disable */
+    sis900_init(nic);
+
     /* Disable interrupts by clearing the interrupt mask. */
     outl(0, ioaddr + imr);
     outl(0, ioaddr + ier);
     
     /* Stop the chip's Tx and Rx Status Machine */
-    outl(RxDIS | TxDIS, ioaddr + cr);
+    outl(RxDIS | TxDIS | inl(ioaddr + cr), ioaddr + cr);
 }
+
+static struct pci_id sis900_nics[] = {
+PCI_ROM(0x1039, 0x0900, "sis900",  "SIS900"),
+PCI_ROM(0x1039, 0x7016, "sis7016", "SIS7016"),
+};
+
+struct pci_driver sis900_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "SIS900",
+	.probe    = sis900_probe,
+	.ids      = sis900_nics,
+	.id_count = sizeof(sis900_nics)/sizeof(sis900_nics[0]),
+	.class    = 0,
+};
Index: netboot/Makefile.am
===================================================================
--- netboot/Makefile.am	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/Makefile.am	(.../trunk)	(revision 112)
@@ -10,58 +10,68 @@
 
 noinst_LIBRARIES = $(LIBDRIVERS)
 
-libdrivers_a_SOURCES = cards.h config.c etherboot.h \
-	fsys_tftp.c linux-asm-io.h linux-asm-string.h \
-	main.c misc.c nic.h osdep.h pci.c pci.h timer.c timer.h
-EXTRA_libdrivers_a_SOURCES = 3c509.c 3c509.h 3c595.c 3c595.h 3c90x.c \
-	cs89x0.c cs89x0.h davicom.c depca.c eepro.c eepro100.c \
-	epic100.c epic100.h fa311.c i82586.c lance.c natsemi.c \
-	ni5010.c ns8390.c ns8390.h otulip.c otulip.h rtl8139.c \
-	sis900.c sis900.h sk_g16.c sk_g16.h smc9000.c smc9000.h \
-	tiara.c tlan.c tulip.c via-rhine.c w89c840.c
+libdrivers_a_SOURCES = big_bswap.h bootp.h byteswap.h config.c cpu.h \
+	dev.h elf.h endian.h etherboot.h fsys_tftp.c grub.h \
+	i386_byteswap.h i386_elf.h i386_endian.h i386_timer.c \
+	if_arp.h if_ether.h igmp.h in.h io.h ip.h isa.h latch.h \
+	little_bswap.h misc.c nic.c nic.h osdep.h pci.c pci.h \
+	pci_ids.h pci_io.c stdint.h tftp.h timer.c timer.h \
+	types.h udp.h rpc.c rpc.h pxe.h segoff.h
+EXTRA_libdrivers_a_SOURCES = 3c595.c 3c595.h 3c90x.c davicom.c \
+	e1000.c e1000_hw.h eepro100.c epic100.c epic100.h natsemi.c \
+	ns8390.c ns8390.h pcnet32.c rtl8139.c sis900.c sis900.h \
+	sundance.c tg3.c tg3.h tlan.c tlan.h tulip.c via-rhine.c \
+	w89c840.c r8169.c pxe_tftp.c undi.h
 libdrivers_a_CFLAGS = $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	-DFSYS_TFTP=1 $(NET_CFLAGS) $(NET_EXTRAFLAGS)
 # Filled by configure.
 libdrivers_a_LIBADD = @NETBOOT_DRIVERS@
 libdrivers_a_DEPENDENCIES = $(libdrivers_a_LIBADD)
 
-EXTRA_DIST = README.netboot 3c90x.txt cs89x0.txt sis900.txt tulip.txt
+EXTRA_DIST = README.netboot 3c90x.txt sis900.txt tulip.txt skel.c
 
 # These below are several special rules for the device drivers.
 # We cannot use a simple rule for them...
 
 # What objects are derived from a driver?
-3c509_drivers = 3c509.o 3c529.o
+#3c509_drivers = 3c509.o 3c529.o
 3c595_drivers = 3c595.o
 3c90x_drivers = 3c90x.o
-cs89x0_drivers = cs89x0.o
+#cs89x0_drivers = cs89x0.o
 davicom_drivers = davicom.o
-depca_drivers = depca.o
-eepro_drivers = eepro.o
+#depca_drivers = depca.o
+#eepro_drivers = eepro.o
+e1000_drivers = e1000.o
 eepro100_drivers = eepro100.o
 epic100_drivers = epic100.o
 #fa311_drivers = fa311.o
-i82586_drivers = 3c507.o exos205.o ni5210.o
-lance_drivers = lance.o ne2100.o ni6510.o
+#i82586_drivers = 3c507.o exos205.o ni5210.o
+#lance_drivers = lance.o ne2100.o ni6510.o
 natsemi_drivers = natsemi.o
-ni5010_drivers = ni5010.o
+#ni5010_drivers = ni5010.o
 ns8390_drivers = 3c503.o ne.o ns8390.o wd.o
-otulip_drivers = otulip.o
+#otulip_drivers = otulip.o
+pcnet32_drivers = pcnet32.o
+pxe_tftp_drivers = pxe_tftp.o
+ntulip_drivers = ntulip.o
 rtl8139_drivers = rtl8139.o
+r8169_drivers = r8169.o
 sis900_drivers = sis900.o
-sk_g16_drivers = sk_g16.o
-smc9000_drivers = smc9000.o
-tiara_drivers = tiara.o
-#tlan_drivers = tlan.o
+#sk_g16_drivers = sk_g16.o
+sundance_driver = sundance.o
+#smc9000_drivers = smc9000.o
+tg3_drivers = tg3.o
+#tiara_drivers = tiara.o
+tlan_drivers = tlan.o
 tulip_drivers = tulip.o
 via_rhine_drivers = via_rhine.o
 w89c840_drivers = w89c840.o
 
 # Is it really necessary to specify dependecies explicitly?
-$(3c509_drivers): 3c509.c 3c509.h
-$(3c509_drivers): %.o: 3c509.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(3c509_drivers): 3c509.c 3c509.h
+#$(3c509_drivers): %.o: 3c509.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(3c595_drivers): 3c595.c 3c595.h
 $(3c595_drivers): %.o: 3c595.c
@@ -73,23 +83,28 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(cs89x0_drivers): cs89x0.c cs89x0.h
-$(cs89x0_drivers): %.o: cs89x0.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(cs89x0_drivers): cs89x0.c cs89x0.h
+#$(cs89x0_drivers): %.o: cs89x0.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(davicom_drivers): davicom.c
 $(davicom_drivers): %.o: davicom.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(depca_drivers): depca.c
-$(depca_drivers): %.o: depca.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(depca_drivers): depca.c
+#$(depca_drivers): %.o: depca.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(eepro_drivers): eepro.c
-$(eepro_drivers): %.o: eepro.c
+#$(eepro_drivers): eepro.c
+#$(eepro_drivers): %.o: eepro.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(e1000_drivers): e1000.c e1000_hw.h
+$(e1000_drivers): %.o: e1000.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -108,13 +123,18 @@
 #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(i82586_drivers): i82586.c
-$(i82586_drivers): %.o: i82586.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(i82586_drivers): i82586.c
+#$(i82586_drivers): %.o: i82586.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(lance_drivers): lance.c
-$(lance_drivers): %.o: lance.c
+#$(lance_drivers): lance.c
+#$(lance_drivers): %.o: lance.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(ntulip_drivers): ntulip.c
+$(ntulip_drivers): %.o: ntulip.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
@@ -123,51 +143,76 @@
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(ni5010_drivers): ni5010.c
-$(ni5010_drivers): %.o: ni5010.c
-	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
-	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+#$(ni5010_drivers): ni5010.c
+#$(ni5010_drivers): %.o: ni5010.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 $(ns8390_drivers): ns8390.c ns8390.h
 $(ns8390_drivers): %.o: ns8390.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(otulip_drivers): otulip.c otulip.h
-$(otulip_drivers): %.o: otulip.c
+#$(otulip_drivers): otulip.c otulip.h
+#$(otulip_drivers): %.o: otulip.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(pcnet32_drivers): pcnet32.c
+$(pcnet32_drivers): %.o: pcnet32.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(pxe_tftp_drivers): pxe_tftp.c pxe_tftp.h
+$(pxe_tftp_drivers): %.o: pxe_tftp.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 $(rtl8139_drivers): rtl8139.c
 $(rtl8139_drivers): %.o: rtl8139.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(sis900_drivers): sis900.c
-$(sis900_drivers): %.o: sis900.c sis900.h
+$(r8169_drivers): r8169.c
+$(r8169_drivers): %.o: r8169.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(sk_g16_drivers): sk_g16.c sk_g16.h
-$(sk_g16_drivers): %.o: sk_g16.c
+$(sis900_drivers): sis900.c sis900.h
+$(sis900_drivers): %.o: sis900.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(smc9000_drivers): smc9000.c smc9000.h
-$(smc9000_drivers): %.o: smc9000.c
+#$(sk_g16_drivers): sk_g16.c sk_g16.h
+#$(sk_g16_drivers): %.o: sk_g16.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+#$(smc9000_drivers): smc9000.c smc9000.h
+#$(smc9000_drivers): %.o: smc9000.c
+#	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+#	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
+$(sundance_drivers): sundance.c
+$(sundance_drivers): %.o: sundance.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-$(tiara_drivers): tiara.c
-$(tiara_drivers): %.o: tiara.c
+$(tg3_drivers): tg3.c tg3.h
+$(tg3_drivers): %.o: tg3.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
-#$(tlan_drivers): tlan.c
-#$(tlan_drivers): %.o: tlan.c
+#$(tiara_drivers): tiara.c
+#$(tiara_drivers): %.o: tiara.c
 #	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
 #	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
+$(tlan_drivers): tlan.c tlan.h
+$(tlan_drivers): %.o: tlan.c
+	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
+	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
+
 $(tulip_drivers): tulip.c
 $(tulip_drivers): %.o: tulip.c
 	$(COMPILE) $(STAGE2_CFLAGS) -fno-builtin -nostdinc \
@@ -184,36 +229,43 @@
 	  $(NET_EXTRAFLAGS) $($(basename $@)_o_CFLAGS) -o $@ -c $<
 
 # Per-object flags.
-3c509_o_CFLAGS = -DINCLUDE_3C509=1
-3c529_o_CFLAGS = -DINCLUDE_3C529=1
+#3c509_o_CFLAGS = -DINCLUDE_3C509=1
+#3c529_o_CFLAGS = -DINCLUDE_3C529=1
 3c595_o_CFLAGS = -DINCLUDE_3C595=1
 3c90x_o_CFLAGS = -DINCLUDE_3C90X=1
-cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
+#cs89x0_o_CFLAGS = -DINCLUDE_CS89X0=1
 davicom_o_CFLAGS = -DINCLUDE_DAVICOM=1
-depca_o_CFLAGS = -DINCLUDE_DEPCA=1
-eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+#depca_o_CFLAGS = -DINCLUDE_DEPCA=1
+#eepro_o_CFLAGS = -DINCLUDE_EEPRO=1
+e1000_o_CFLAGS = -DINCLUDE_E1000=1
 eepro100_o_CFLAGS = -DINCLUDE_EEPRO100=1
 epic100_o_CFLAGS = -DINCLUDE_EPIC100=1
 #fa311_o_CFLAGS = -DINCLUDE_FA311=1
-3c507_o_CFLAGS = -DINCLUDE_3C507=1
-exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
-ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
-lance_o_CFLAGS = -DINCLUDE_LANCE=1
-ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
-ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
+#3c507_o_CFLAGS = -DINCLUDE_3C507=1
+#exos205_o_CFLAGS = -DINCLUDE_EXOS205=1
+#ni5210_o_CFLAGS = -DINCLUDE_NI5210=1
+#lance_o_CFLAGS = -DINCLUDE_LANCE=1
+#ne2100_o_CFLAGS = -DINCLUDE_NE2100=1
+#ni6510_o_CFLAGS = -DINCLUDE_NI6510=1
 natsemi_o_CFLAGS = -DINCLUDE_NATSEMI=1
-ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
-3c503_o_CFLAGS = -DINCLUDE_3C503=1
-ne_o_CFLAGS = -DINCLUDE_NE=1
+#ni5010_o_CFLAGS = -DINCLUDE_NI5010=1
+#3c503_o_CFLAGS = -DINCLUDE_3C503=1
+#ne_o_CFLAGS = -DINCLUDE_NE=1
 ns8390_o_CFLAGS = -DINCLUDE_NS8390=1
-wd_o_CFLAGS = -DINCLUDE_WD=1
-otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+#wd_o_CFLAGS = -DINCLUDE_WD=1
+#otulip_o_CFLAGS = -DINCLUDE_OTULIP=1
+pcnet32_o_CFLAGS = -DINCLUDE_PCNET32=1
+pxe_tftp_o_CFLAGS = -DINCLUDE_PXE_TFTP=1
+ntulip_o_CFLAGS = -DINCLUDE_NTULIP=1
 rtl8139_o_CFLAGS = -DINCLUDE_RTL8139=1
 sis900_o_CFLAGS = -DINCLUDE_SIS900=1
-sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
-smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
-tiara_o_CFLAGS = -DINCLUDE_TIARA=1
-#tlan_o_CFLAGS = -DINCLUDE_TLAN=1
+#sk_g16_o_CFLAGS = -DINCLUDE_SK_G16=1
+#smc9000_o_CFLAGS = -DINCLUDE_SMC9000=1
+sundance_o_CFLAGS = -DINCLUDE_SUNDANCE=1
+#tiara_o_CFLAGS = -DINCLUDE_TIARA=1
+tg3_o_CFLAGS = -DINCLUDE_TG3=1
+tlan_o_CFLAGS = -DINCLUDE_TLAN=1
 tulip_o_CFLAGS = -DINCLUDE_TULIP=1
 via_rhine_o_CFLAGS = -DINCLUDE_VIA_RHINE=1
 w89c840_o_CFLAGS = -DINCLUDE_W89C840=1
+r8169_o_CFLAGS = -DINCLUDE_R8169=1
Index: netboot/if_ether.h
===================================================================
--- netboot/if_ether.h	(.../upstream/grub-0.97)	(revision 0)
+++ netboot/if_ether.h	(.../trunk)	(revision 112)
@@ -0,0 +1,21 @@
+#ifndef	_IF_ETHER_H
+#define	_IF_ETHER_H
+
+/*
+   I'm moving towards the defined names in linux/if_ether.h for clarity.
+   The confusion between 60/64 and 1514/1518 arose because the NS8390
+   counts the 4 byte frame checksum in the incoming packet, but not
+   in the outgoing packet. 60/1514 are the correct numbers for most
+   if not all of the other NIC controllers.
+*/
+
+#define ETH_ALEN		6	/* Size of Ethernet address */
+#define ETH_HLEN		14	/* Size of ethernet header */
+#define	ETH_ZLEN		60	/* Minimum packet */
+#define	ETH_FRAME_LEN		1514	/* Maximum packet */
+#define ETH_DATA_ALIGN		2	/* Amount needed to align the data after an ethernet header */
+#ifndef	ETH_MAX_MTU
+#define	ETH_MAX_MTU		(ETH_FRAME_LEN-ETH_HLEN)
+#endif
+
+#endif	/* _IF_ETHER_H */
Index: netboot/misc.c
===================================================================
--- netboot/misc.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/misc.c	(.../trunk)	(revision 112)
@@ -19,37 +19,90 @@
 
 /* Based on "src/misc.c" in etherboot-5.0.5.  */
 
-#define GRUB	1
-#include <etherboot.h>
+#include "grub.h"
+#include "timer.h"
 
-void
-sleep (int secs)
+#include "nic.h"
+
+/**************************************************************************
+RANDOM - compute a random number between 0 and 2147483647L or 2147483562?
+**************************************************************************/
+int32_t random(void)
 {
-  unsigned long tmo = currticks () + secs;
+	static int32_t seed = 0;
+	int32_t q;
+	if (!seed) /* Initialize linear congruential generator */
+		seed = currticks() + *(int32_t *)&arptable[ARP_CLIENT].node
+		       + ((int16_t *)arptable[ARP_CLIENT].node)[2];
+	/* simplified version of the LCG given in Bruce Schneier's
+	   "Applied Cryptography" */
+	q = seed/53668;
+	if ((seed = 40014*(seed-53668*q) - 12211*q) < 0) seed += 2147483563L;
+	return seed;
+}
 
-  while (currticks () < tmo)
-    ;
+/**************************************************************************
+POLL INTERRUPTIONS
+**************************************************************************/
+void poll_interruptions(void)
+{
+	if (checkkey() != -1 && ASCII_CHAR(getkey()) == K_INTR) {
+		user_abort++;
+	}
 }
 
-void
-twiddle (void)
+/**************************************************************************
+SLEEP
+**************************************************************************/
+void sleep(int secs)
 {
-  static unsigned long lastticks = 0;
-  static int count = 0;
-  static const char tiddles[]="-\\|/";
-  unsigned long ticks;
+	unsigned long tmo;
 
-  if (debug)
-    {
-      if ((ticks = currticks ()) == lastticks)
-	return;
-      
-      lastticks = ticks;
-      grub_putchar (tiddles[(count++) & 3]);
-      grub_putchar ('\b');
-    }
+	for (tmo = currticks()+secs*TICKS_PER_SEC; currticks() < tmo; ) {
+		poll_interruptions();
+	}
 }
 
+/**************************************************************************
+INTERRUPTIBLE SLEEP
+**************************************************************************/
+void interruptible_sleep(int secs)
+{
+	printf("<sleep>\n");
+	return sleep(secs);
+}
+
+/**************************************************************************
+TWIDDLE
+**************************************************************************/
+void twiddle(void)
+{
+#ifdef BAR_PROGRESS
+	static int count=0;
+	static const char tiddles[]="-\\|/";
+	static unsigned long lastticks = 0;
+	unsigned long ticks;
+#endif
+#ifdef FREEBSD_PXEEMU
+	extern char pxeemu_nbp_active;
+	if(pxeemu_nbp_active != 0)
+		return;
+#endif
+#ifdef	BAR_PROGRESS
+	/* Limit the maximum rate at which characters are printed */
+	ticks = currticks();
+	if ((lastticks + (TICKS_PER_SEC/18)) > ticks)
+		return;
+	lastticks = ticks;
+
+	putchar(tiddles[(count++)&3]);
+	putchar('\b');
+#else
+	//putchar('.');
+#endif	/* BAR_PROGRESS */
+}
+
+
 /* Because Etherboot uses its own formats for the printf family,
    define separate definitions from GRUB.  */
 /**************************************************************************
@@ -264,3 +317,5 @@
   
   return ret;
 }
+
+
Index: netboot/eepro100.c
===================================================================
--- netboot/eepro100.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/eepro100.c	(.../trunk)	(revision 112)
@@ -80,8 +80,8 @@
  *
  * Caveats:
  *
- * The etherboot framework moves the code to the 32k segment from
- * 0x98000 to 0xa0000. There is just a little room between the end of
+ * The Etherboot framework moves the code to the 48k segment from
+ * 0x94000 to 0xa0000. There is just a little room between the end of
  * this driver and the 0xa0000 address. If you compile in too many
  * features, this will overflow.
  * The number under "hex" in the output of size that scrolls by while
@@ -92,17 +92,13 @@
 /* The etherboot authors seem to dislike the argument ordering in
  * outb macros that Linux uses. I disklike the confusion that this
  * has caused even more.... This file uses the Linux argument ordering.  */
-/* Sorry not us. It's inherted code from FreeBSD. [The authors] */
+/* Sorry not us. It's inherited code from FreeBSD. [The authors] */
 
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 #include "timer.h"
 
-#undef	virt_to_bus
-#define	virt_to_bus(x)	((unsigned long)x)
-
 static int ioaddr;
 
 typedef unsigned char  u8;
@@ -139,8 +135,6 @@
 #define EE_WRITE_1      0x4806
 #define EE_ENB          (0x4800 | EE_CS)
 
-#define udelay(n)       waiton_timer2(((n)*TICKS_PER_MS)/1000)
-
 /* The EEPROM commands include the alway-set leading bit. */
 #define EE_READ_CMD     6
 
@@ -184,9 +178,18 @@
    Typically this takes 0 ticks. */
 static inline void wait_for_cmd_done(int cmd_ioaddr)
 {
-  short wait = 100;
-  do   ;
-  while(inb(cmd_ioaddr) && --wait >= 0);
+  int wait = 0;
+  int delayed_cmd;
+
+  do
+    if (inb(cmd_ioaddr) == 0) return;
+  while(++wait <= 100);
+  delayed_cmd = inb(cmd_ioaddr);
+  do
+    if (inb(cmd_ioaddr) == 0) break;
+  while(++wait <= 10000);
+  printf("Command %2.2x was not immediately accepted, %d ticks!\n",
+      delayed_cmd, wait);
 }
 
 /* Elements of the dump_statistics block. This block must be lword aligned. */
@@ -212,35 +215,30 @@
 
 /* A speedo3 TX buffer descriptor with two buffers... */
 static struct TxFD {
-  volatile s16 status;
-  s16 command;
-  u32 link;          /* void * */
-  u32 tx_desc_addr;  /* (almost) Always points to the tx_buf_addr element. */
-  s32 count;         /* # of TBD (=2), Tx start thresh., etc. */
-                     /* This constitutes two "TBD" entries: hdr and data */
-  u32 tx_buf_addr0;  /* void *, header of frame to be transmitted.  */
-  s32 tx_buf_size0;  /* Length of Tx hdr. */
-  u32 tx_buf_addr1;  /* void *, data to be transmitted.  */
-  s32 tx_buf_size1;  /* Length of Tx data. */
+	volatile s16 status;
+	s16 command;
+	u32 link;          /* void * */
+	u32 tx_desc_addr;  /* (almost) Always points to the tx_buf_addr element. */
+	s32 count;         /* # of TBD (=2), Tx start thresh., etc. */
+	/* This constitutes two "TBD" entries: hdr and data */
+	u32 tx_buf_addr0;  /* void *, header of frame to be transmitted.  */
+	s32 tx_buf_size0;  /* Length of Tx hdr. */
+	u32 tx_buf_addr1;  /* void *, data to be transmitted.  */
+	s32 tx_buf_size1;  /* Length of Tx data. */
 } txfd;
 
 struct RxFD {               /* Receive frame descriptor. */
-  volatile s16 status;
-  s16 command;
-  u32 link;                 /* struct RxFD * */
-  u32 rx_buf_addr;          /* void * */
-  u16 count;
-  u16 size;
-  char packet[1518];
+	volatile s16 status;
+	s16 command;
+	u32 link;                 /* struct RxFD * */
+	u32 rx_buf_addr;          /* void * */
+	u16 count;
+	u16 size;
+	char packet[1518];
 };
 
-#ifdef	USE_LOWMEM_BUFFER
-#define rxfd ((struct RxFD *)(0x10000 - sizeof(struct RxFD)))
-#define ACCESS(x) x->
-#else
 static struct RxFD rxfd;
 #define ACCESS(x) x.
-#endif
 
 static int congenb = 0;         /* Enable congestion control in the DP83840. */
 static int txfifo = 8;          /* Tx FIFO threshold in 4 byte units, 0-15 */
@@ -256,8 +254,7 @@
   u32 link;
   unsigned char data[22];
 } confcmd = {
-  0, CmdConfigure,
-  (u32) & txfd,
+  0, 0, 0, /* filled in later */
   {22, 0x08, 0, 0,  0, 0x80, 0x32, 0x03,  1, /* 1=Use MII  0=Use AUI */
    0, 0x2E, 0,  0x60, 0,
    0xf2, 0x48,   0, 0x40, 0xf2, 0x80,        /* 0x40=Force full-duplex */
@@ -276,19 +273,20 @@
 
 static int mdio_write(int phy_id, int location, int value)
 {
-  int val, boguscnt = 64*4;         /* <64 usec. to complete, typ 27 ticks */
+	int val, boguscnt = 64*4;         /* <64 usec. to complete, typ 27 ticks */
 
-  outl(0x04000000 | (location<<16) | (phy_id<<21) | value,
-       ioaddr + SCBCtrlMDI);
-  do {
-    udelay(16);
-
-    val = inl(ioaddr + SCBCtrlMDI);
-    if (--boguscnt < 0) {
-      printf(" mdio_write() timed out with val = %X.\n", val);
-    }
-  } while (! (val & 0x10000000));
-  return val & 0xffff;
+	outl(0x04000000 | (location<<16) | (phy_id<<21) | value,
+	     ioaddr + SCBCtrlMDI);
+	do {
+		udelay(16);
+		
+		val = inl(ioaddr + SCBCtrlMDI);
+		if (--boguscnt < 0) {
+			printf(" mdio_write() timed out with val = %X.\n", val);
+			break;
+		}
+	} while (! (val & 0x10000000));
+	return val & 0xffff;
 }
 
 /* Support function: mdio_read
@@ -298,17 +296,19 @@
  */
 static int mdio_read(int phy_id, int location)
 {
-  int val, boguscnt = 64*4;               /* <64 usec. to complete, typ 27 ticks */
-  outl(0x08000000 | (location<<16) | (phy_id<<21), ioaddr + SCBCtrlMDI);
-  do {
-    udelay(16);
+	int val, boguscnt = 64*4;               /* <64 usec. to complete, typ 27 ticks */
+	outl(0x08000000 | (location<<16) | (phy_id<<21), ioaddr + SCBCtrlMDI);
+	do {
+		udelay(16);
+		
+		val = inl(ioaddr + SCBCtrlMDI);
 
-    val = inl(ioaddr + SCBCtrlMDI);
-    if (--boguscnt < 0) {
-      printf( " mdio_read() timed out with val = %X.\n", val);
-    }
-  } while (! (val & 0x10000000));
-  return val & 0xffff;
+		if (--boguscnt < 0) {
+			printf( " mdio_read() timed out with val = %X.\n", val);
+			break;
+		}
+	} while (! (val & 0x10000000));
+	return val & 0xffff;
 }
 
 /* The fixes for the code were kindly provided by Dragan Stancevic
@@ -340,27 +340,16 @@
 	return retval;
 }
 
+#if 0
 static inline void whereami (const char *str)
 {
-#if	0
   printf ("%s\n", str);
   sleep (2);
+}
+#else
+#define whereami(s)
 #endif
-}
 
-/* function: eepro100_reset
- * resets the card. This is used to allow Etherboot to probe the card again
- * from a "virginal" state....
- * Arguments: none
- *
- * returns:   void.
- */
-
-static void eepro100_reset(struct nic *nic)
-{
-  outl(0, ioaddr + SCBPort);
-}
-
 /* function: eepro100_transmit
  * This transmits a packet.
  *
@@ -373,61 +362,89 @@
 
 static void eepro100_transmit(struct nic *nic, const char *d, unsigned int t, unsigned int s, const char *p)
 {
-  struct eth_hdr {
-    unsigned char dst_addr[ETH_ALEN];
-    unsigned char src_addr[ETH_ALEN];
-    unsigned short type;
-  } hdr;
-  unsigned short status;
-  int to;
-  int s1, s2;
+	struct eth_hdr {
+		unsigned char dst_addr[ETH_ALEN];
+		unsigned char src_addr[ETH_ALEN];
+		unsigned short type;
+	} hdr;
+	unsigned short status;
+	int s1, s2;
 
-  status = inw(ioaddr + SCBStatus);
-  /* Acknowledge all of the current interrupt sources ASAP. */
-  outw(status & 0xfc00, ioaddr + SCBStatus);
+	status = inw(ioaddr + SCBStatus);
+	/* Acknowledge all of the current interrupt sources ASAP. */
+	outw(status & 0xfc00, ioaddr + SCBStatus);
 
-#ifdef	DEBUG
-  printf ("transmitting type %hX packet (%d bytes). status = %hX, cmd=%hX\n",
-	  t, s, status, inw (ioaddr + SCBCmd));
+#if	DEBUG
+	printf ("transmitting type %hX packet (%d bytes). status = %hX, cmd=%hX\n",
+		t, s, status, inw (ioaddr + SCBCmd));
 #endif
 
-  memcpy (&hdr.dst_addr, d, ETH_ALEN);
-  memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
+	memcpy (&hdr.dst_addr, d, ETH_ALEN);
+	memcpy (&hdr.src_addr, nic->node_addr, ETH_ALEN);
 
-  hdr.type = htons (t);
+	hdr.type = htons (t);
 
-  txfd.status = 0;
-  txfd.command = CmdSuspend | CmdTx | CmdTxFlex;
-  txfd.link   = virt_to_bus (&txfd);
-  txfd.count   = 0x02208000;
-  txfd.tx_desc_addr = (u32)&txfd.tx_buf_addr0;
+	txfd.status = 0;
+	txfd.command = CmdSuspend | CmdTx | CmdTxFlex;
+	txfd.link   = virt_to_bus (&txfd);
+	txfd.count   = 0x02208000;
+	txfd.tx_desc_addr = virt_to_bus(&txfd.tx_buf_addr0);
 
-  txfd.tx_buf_addr0 = virt_to_bus (&hdr);
-  txfd.tx_buf_size0 = sizeof (hdr);
+	txfd.tx_buf_addr0 = virt_to_bus (&hdr);
+	txfd.tx_buf_size0 = sizeof (hdr);
 
-  txfd.tx_buf_addr1 = virt_to_bus (p);
-  txfd.tx_buf_size1 = s;
+	txfd.tx_buf_addr1 = virt_to_bus (p);
+	txfd.tx_buf_size1 = s;
 
-#ifdef	DEBUG
-  printf ("txfd: \n");
-  hd (&txfd, sizeof (txfd));
+#if	DEBUG
+	printf ("txfd: \n");
+	hd (&txfd, sizeof (txfd));
 #endif
 
-  outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
-  outw(INT_MASK | CU_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
+	outw(INT_MASK | CU_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
 
-  s1 = inw (ioaddr + SCBStatus);
-  load_timer2(10*TICKS_PER_MS);		/* timeout 10 ms for transmit */
-  while (!txfd.status && timer2_running())
-    /* Wait */;
-  s2 = inw (ioaddr + SCBStatus);
+	s1 = inw (ioaddr + SCBStatus);
+	load_timer2(10*TICKS_PER_MS);		/* timeout 10 ms for transmit */
+	while (!txfd.status && timer2_running())
+		/* Wait */;
+	s2 = inw (ioaddr + SCBStatus);
 
-#ifdef	DEBUG
-  printf ("s1 = %hX, s2 = %hX.\n", s1, s2);
+#if	DEBUG
+	printf ("s1 = %hX, s2 = %hX.\n", s1, s2);
 #endif
 }
 
+/*
+ * Sometimes the receiver stops making progress.  This routine knows
+ * how to get it going again, without losing packets or being
+ * otherwise nasty like a chip reset would be.  Previously the driver
+ * had a whole sequence of if RxSuspended, if it's no buffers do one
+ * thing, if it's no resources, do another, etc.  But those things
+ * don't really matter.  Separate logic in the ISR provides for
+ * allocating buffers--the other half of operation is just making sure
+ * the receiver is active.  speedo_rx_soft_reset does that.  This
+ * problem with the old, more involved algorithm is shown up under
+ * ping floods on the order of 60K packets/second on a 100Mbps fdx
+ * network.
+ */
+static void
+speedo_rx_soft_reset(void)
+{
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	/*
+	 * Put the hardware into a known state.
+	 */
+	outb(RX_ABORT, ioaddr + SCBCmd);
+	
+	ACCESS(rxfd)rx_buf_addr = 0xffffffff;
+	
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	
+	outb(RX_START, ioaddr + SCBCmd);
+}
+
 /* function: eepro100_poll / eth_poll
  * This recieves a packet from the network.
  *
@@ -442,32 +459,82 @@
 
 static int eepro100_poll(struct nic *nic)
 {
-  if (!ACCESS(rxfd)status)
-    return 0;
+	unsigned int status;
 
-  /* Ok. We got a packet. Now restart the reciever.... */
-  ACCESS(rxfd)status = 0;
-  ACCESS(rxfd)command = 0xc000;
-  outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
-  outw(INT_MASK | RX_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	status = inw(ioaddr + SCBStatus);
+	if (!ACCESS(rxfd)status)
+		return 0;
 
-#ifdef	DEBUG
-  printf ("Got a packet: Len = %d.\n", ACCESS(rxfd)count & 0x3fff);
+	/*
+	 * The chip may have suspended reception for various reasons.
+	 * Check for that, and re-prime it should this be the case.
+	 */
+	switch ((status >> 2) & 0xf) {
+	case 0: /* Idle */
+		break;
+	case 1:     /* Suspended */
+	case 2:     /* No resources (RxFDs) */
+	case 9:     /* Suspended with no more RBDs */
+	case 10: /* No resources due to no RBDs */
+	case 12: /* Ready with no RBDs */
+		speedo_rx_soft_reset();
+		break;
+	case 3:  case 5:  case 6:  case 7:  case 8:
+	case 11:  case 13:  case 14:  case 15:
+		/* these are all reserved values */
+		break;
+	}
+
+	/* Ok. We got a packet. Now restart the reciever.... */
+	ACCESS(rxfd)status = 0;
+	ACCESS(rxfd)command = 0xc000;
+	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
+	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+
+#if	DEBUG
+	printf ("Got a packet: Len = %d.\n", ACCESS(rxfd)count & 0x3fff);
 #endif
-  nic->packetlen =  ACCESS(rxfd)count & 0x3fff;
-  memcpy (nic->packet, ACCESS(rxfd)packet, nic->packetlen);
-#ifdef	DEBUG
-  hd (nic->packet, 0x30);
+	nic->packetlen =  ACCESS(rxfd)count & 0x3fff;
+	memcpy (nic->packet, ACCESS(rxfd)packet, nic->packetlen);
+#if	DEBUG
+	hd (nic->packet, 0x30);
 #endif
-  return 1;
+	return 1;
 }
 
-static void eepro100_disable(struct nic *nic)
+/* function: eepro100_disable
+ * resets the card. This is used to allow Etherboot or Linux
+ * to probe the card again from a "virginal" state....
+ * Arguments: none
+ *
+ * returns:   void.
+ */
+static void eepro100_disable(struct dev *dev __unused)
 {
-    /* See if this PartialReset solves the problem with interfering with
-       kernel operation after Etherboot hands over. - Ken 20001102 */
-    outl(2, ioaddr + SCBPort);
+/* from eepro100_reset */
+	outl(0, ioaddr + SCBPort);
+/* from eepro100_disable */
+	/* See if this PartialReset solves the problem with interfering with
+	   kernel operation after Etherboot hands over. - Ken 20001102 */
+	outl(2, ioaddr + SCBPort);
+
+	/* The following is from the Intel e100 driver.
+	 * This hopefully solves the problem with hanging hard DOS images. */
+
+	/* wait for the reset to take effect */
+	udelay(20);
+
+	/* Mask off our interrupt line -- it is unmasked after reset */
+	{
+		u16 intr_status;
+		/* Disable interrupts on our PCI board by setting the mask bit */
+		outw(INT_MASK, ioaddr + SCBCmd);
+		intr_status = inw(ioaddr + SCBStatus);
+		/* ack and clear intrs */
+		outw(intr_status, ioaddr + SCBStatus);
+		inw(ioaddr + SCBStatus);
+	}
 }
 
 /* exported function: eepro100_probe / eth_probe
@@ -478,22 +545,22 @@
  *            leaves the 82557 initialized, and ready to recieve packets.
  */
 
-struct nic *eepro100_probe(struct nic *nic, unsigned short *probeaddrs, struct pci_device *p)
+static int eepro100_probe(struct dev *dev, struct pci_device *p)
 {
+	struct nic *nic = (struct nic *)dev;
 	unsigned short sum = 0;
 	int i;
 	int read_cmd, ee_size;
-	unsigned short value;
 	int options;
-	int promisc;
+	int rx_mode;
 
 	/* we cache only the first few words of the EEPROM data
 	   be careful not to access beyond this array */
 	unsigned short eeprom[16];
 
-	if (probeaddrs == 0 || probeaddrs[0] == 0)
+	if (p->ioaddr == 0)
 		return 0;
-	ioaddr = probeaddrs[0] & ~3; /* Mask the bit that says "this is an io addr" */
+	ioaddr = p->ioaddr & ~3; /* Mask the bit that says "this is an io addr" */
 
 	adjust_pci_device(p);
 
@@ -513,142 +580,200 @@
 		sum += value;
 	}
 
-  for (i=0;i<ETH_ALEN;i++) {
-	nic->node_addr[i] =  (eeprom[i/2] >> (8*(i&1))) & 0xff;
-  }
-  printf ("Ethernet addr: %!\n", nic->node_addr);
+	for (i=0;i<ETH_ALEN;i++) {
+		nic->node_addr[i] =  (eeprom[i/2] >> (8*(i&1))) & 0xff;
+	}
+	printf ("Ethernet addr: %!\n", nic->node_addr);
 
-  if (sum != 0xBABA)
-	printf("eepro100: Invalid EEPROM checksum %#hX, "
-	       "check settings before activating this device!\n", sum);
-  outl(0, ioaddr + SCBPort);
-  udelay (10000);
+	if (sum != 0xBABA)
+		printf("eepro100: Invalid EEPROM checksum %#hX, "
+		       "check settings before activating this device!\n", sum);
+	outl(0, ioaddr + SCBPort);
+	udelay (10000);
+	whereami ("Got eeprom.");
 
-  whereami ("Got eeprom.");
+	/* Base = 0 */
+	outl(0, ioaddr + SCBPointer);
+	outw(INT_MASK | RX_ADDR_LOAD, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	whereami ("set rx base addr.");
 
-  outl(virt_to_bus(&lstats), ioaddr + SCBPointer);
-  outw(INT_MASK | CU_STATSADDR, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	outl(virt_to_bus(&lstats), ioaddr + SCBPointer);
+	outw(INT_MASK | CU_STATSADDR, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
+	whereami ("set stats addr.");
 
-  whereami ("set stats addr.");
-  /* INIT RX stuff. */
+	/* INIT RX stuff. */
+	ACCESS(rxfd)status  = 0x0001;
+	ACCESS(rxfd)command = 0x0000;
+	ACCESS(rxfd)link    = virt_to_bus(&(ACCESS(rxfd)status));
+	ACCESS(rxfd)rx_buf_addr = virt_to_bus(&nic->packet);
+	ACCESS(rxfd)count   = 0;
+	ACCESS(rxfd)size    = 1528;
 
-  /* Base = 0 */
-  outl(0, ioaddr + SCBPointer);
-  outw(INT_MASK | RX_ADDR_LOAD, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
+	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
 
-  whereami ("set rx base addr.");
+	whereami ("started RX process.");
 
-  ACCESS(rxfd)status  = 0x0001;
-  ACCESS(rxfd)command = 0x0000;
-  ACCESS(rxfd)link    = virt_to_bus(&(ACCESS(rxfd)status));
-  ACCESS(rxfd)rx_buf_addr = (int) &nic->packet;
-  ACCESS(rxfd)count   = 0;
-  ACCESS(rxfd)size    = 1528;
+	/* Start the reciever.... */
+	ACCESS(rxfd)status = 0;
+	ACCESS(rxfd)command = 0xc000;
+	outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
+	outw(INT_MASK | RX_START, ioaddr + SCBCmd);
 
-  outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
-  outw(INT_MASK | RX_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	/* INIT TX stuff. */
 
-  whereami ("started RX process.");
+	/* Base = 0 */
+	outl(0, ioaddr + SCBPointer);
+	outw(INT_MASK | CU_CMD_BASE, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
 
-  /* Start the reciever.... */
-  ACCESS(rxfd)status = 0;
-  ACCESS(rxfd)command = 0xc000;
-  outl(virt_to_bus(&(ACCESS(rxfd)status)), ioaddr + SCBPointer);
-  outw(INT_MASK | RX_START, ioaddr + SCBCmd);
+	whereami ("set TX base addr.");
 
-  /* INIT TX stuff. */
+	txfd.command      = (CmdIASetup);
+	txfd.status       = 0x0000;
+	txfd.link         = virt_to_bus (&confcmd);
 
-  /* Base = 0 */
-  outl(0, ioaddr + SCBPointer);
-  outw(INT_MASK | CU_CMD_BASE, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	{
+		char *t = (char *)&txfd.tx_desc_addr;
+		
+		for (i=0;i<ETH_ALEN;i++)
+			t[i] = nic->node_addr[i];
+	}
 
-  whereami ("set TX base addr.");
+#if	DEBUG
+	printf ("Setup_eaddr:\n");
+	hd (&txfd, 0x20);
+#endif
+	/*      options = 0x40; */ /* 10mbps half duplex... */
+	options = 0x00;            /* Autosense */
 
-  txfd.command      = (CmdIASetup);
-  txfd.status       = 0x0000;
-  txfd.link         = virt_to_bus (&confcmd);
-
-  {
-	char *t = (char *)&txfd.tx_desc_addr;
-
-	for (i=0;i<ETH_ALEN;i++)
-		t[i] = nic->node_addr[i];
-  }
-
-#ifdef	DEBUG
-  printf ("Setup_eaddr:\n");
-  hd (&txfd, 0x20);
+#ifdef PROMISC
+	rx_mode = 3;
+#elif ALLMULTI
+	rx_mode = 1;
+#else
+	rx_mode = 0;
 #endif
-  /*      options = 0x40; */ /* 10mbps half duplex... */
-  options = 0x00;            /* Autosense */
 
-  promisc = 0;
+	if (   ((eeprom[6]>>8) & 0x3f) == DP83840
+	       || ((eeprom[6]>>8) & 0x3f) == DP83840A) {
+		int mdi_reg23 = mdio_read(eeprom[6] & 0x1f, 23) | 0x0422;
+		if (congenb)
+			mdi_reg23 |= 0x0100;
+		printf("  DP83840 specific setup, setting register 23 to %hX.\n",
+		       mdi_reg23);
+		mdio_write(eeprom[6] & 0x1f, 23, mdi_reg23);
+	}
+	whereami ("Done DP8340 special setup.");
+	if (options != 0) {
+		mdio_write(eeprom[6] & 0x1f, 0,
+			   ((options & 0x20) ? 0x2000 : 0) |    /* 100mbps? */
+			   ((options & 0x10) ? 0x0100 : 0)); /* Full duplex? */
+		whereami ("set mdio_register.");
+	}
 
-  if (   ((eeprom[6]>>8) & 0x3f) == DP83840
-	  || ((eeprom[6]>>8) & 0x3f) == DP83840A) {
-	int mdi_reg23 = mdio_read(eeprom[6] & 0x1f, 23) | 0x0422;
-	if (congenb)
-	  mdi_reg23 |= 0x0100;
-	printf("  DP83840 specific setup, setting register 23 to %hX.\n",
-	       mdi_reg23);
-	mdio_write(eeprom[6] & 0x1f, 23, mdi_reg23);
-  }
-  whereami ("Done DP8340 special setup.");
-  if (options != 0) {
-	mdio_write(eeprom[6] & 0x1f, 0,
-		   ((options & 0x20) ? 0x2000 : 0) |    /* 100mbps? */
-		   ((options & 0x10) ? 0x0100 : 0)); /* Full duplex? */
-	whereami ("set mdio_register.");
-  }
+	confcmd.command  = CmdSuspend | CmdConfigure;
+	confcmd.status   = 0x0000;
+	confcmd.link     = virt_to_bus (&txfd);
+	confcmd.data[1]  = (txfifo << 4) | rxfifo;
+	confcmd.data[4]  = rxdmacount;
+	confcmd.data[5]  = txdmacount + 0x80;
+	confcmd.data[15] = (rx_mode & 2) ? 0x49: 0x48;
+	confcmd.data[19] = (options & 0x10) ? 0xC0 : 0x80;
+	confcmd.data[21] = (rx_mode & 1) ? 0x0D: 0x05;
 
-  confcmd.command  = CmdSuspend | CmdConfigure;
-  confcmd.status   = 0x0000;
-  confcmd.link     = virt_to_bus (&txfd);
-  confcmd.data[1]  = (txfifo << 4) | rxfifo;
-  confcmd.data[4]  = rxdmacount;
-  confcmd.data[5]  = txdmacount + 0x80;
-  confcmd.data[15] = promisc ? 0x49: 0x48;
-  confcmd.data[19] = (options & 0x10) ? 0xC0 : 0x80;
-  confcmd.data[21] = promisc ? 0x0D: 0x05;
+	outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
+	outw(INT_MASK | CU_START, ioaddr + SCBCmd);
+	wait_for_cmd_done(ioaddr + SCBCmd);
 
-  outl(virt_to_bus(&txfd), ioaddr + SCBPointer);
-  outw(INT_MASK | CU_START, ioaddr + SCBCmd);
-  wait_for_cmd_done(ioaddr + SCBCmd);
+	whereami ("started TX thingy (config, iasetup).");
 
-  whereami ("started TX thingy (config, iasetup).");
+	load_timer2(10*TICKS_PER_MS);
+	while (!txfd.status && timer2_running())
+		/* Wait */;
 
-  load_timer2(10*TICKS_PER_MS);
-  while (!txfd.status && timer2_running())
-	/* Wait */;
+	/* Read the status register once to disgard stale data */
+	mdio_read(eeprom[6] & 0x1f, 1);
+	/* Check to see if the network cable is plugged in.
+	 * This allows for faster failure if there is nothing
+	 * we can do.
+	 */
+	if (!(mdio_read(eeprom[6] & 0x1f, 1) & (1 << 2))) {
+		printf("Valid link not established\n");
+		eepro100_disable(dev);
+		return 0;
+	}
 
-  nic->reset = eepro100_reset;
-  nic->poll = eepro100_poll;
-  nic->transmit = eepro100_transmit;
-  nic->disable = eepro100_disable;
-  return nic;
+	dev->disable  = eepro100_disable;
+	nic->poll     = eepro100_poll;
+	nic->transmit = eepro100_transmit;
+	return 1;
 }
 
 /*********************************************************************/
 
-#ifdef	DEBUG
+#if	DEBUG
 
 /* Hexdump a number of bytes from memory... */
 void hd (void *where, int n)
 {
-  int i;
+	int i;
 
-  while (n > 0) {
-    printf ("%X ", where);
-    for (i=0;i < ( (n>16)?16:n);i++)
-      printf (" %hhX", ((char *)where)[i]);
-    printf ("\n");
-    n -= 16;
-    where += 16;
-  }
+	while (n > 0) {
+		printf ("%X ", where);
+		for (i=0;i < ( (n>16)?16:n);i++)
+			printf (" %hhX", ((char *)where)[i]);
+		printf ("\n");
+		n -= 16;
+		where += 16;
+	}
 }
 #endif
 
+static struct pci_id eepro100_nics[] = {
+PCI_ROM(0x8086, 0x1029, "id1029",        "Intel EtherExpressPro100 ID1029"),
+PCI_ROM(0x8086, 0x1030, "id1030",        "Intel EtherExpressPro100 ID1030"),
+PCI_ROM(0x8086, 0x1031, "82801cam",      "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1032, "eepro100-1032", "Intel PRO/100 VE Network Connection"),
+PCI_ROM(0x8086, 0x1033, "eepro100-1033", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1034, "eepro100-1034", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1035, "eepro100-1035", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1036, "eepro100-1036", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1037, "eepro100-1037", "Intel 82801CAM (ICH3) Chipset Ethernet Controller"),
+PCI_ROM(0x8086, 0x1038, "id1038",        "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1039, "82562et",       "Intel PRO100 VE 82562ET"),
+PCI_ROM(0x8086, 0x103a, "id103a",        "Intel Corporation 82559 InBusiness 10/100"),
+PCI_ROM(0x8086, 0x103b, "82562etb",      "Intel PRO100 VE 82562ETB"),
+PCI_ROM(0x8086, 0x103c, "eepro100-103c", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x103d, "eepro100-103d", "Intel PRO/100 VE Network Connection"),
+PCI_ROM(0x8086, 0x103e, "eepro100-103e", "Intel PRO/100 VM Network Connection"),
+PCI_ROM(0x8086, 0x1059, "82551qm",       "Intel PRO/100 M Mobile Connection"),
+PCI_ROM(0x8086, 0x1209, "82559er",       "Intel EtherExpressPro100 82559ER"),
+PCI_ROM(0x8086, 0x1227, "82865",         "Intel 82865 EtherExpress PRO/100A"),
+PCI_ROM(0x8086, 0x1228, "82556",         "Intel 82556 EtherExpress PRO/100 Smart"),
+PCI_ROM(0x8086, 0x1229, "eepro100",      "Intel EtherExpressPro100"),
+PCI_ROM(0x8086, 0x2449, "82562em",       "Intel EtherExpressPro100 82562EM"),
+PCI_ROM(0x8086, 0x2459, "82562-1",       "Intel 82562 based Fast Ethernet Connection"),
+PCI_ROM(0x8086, 0x245d, "82562-2",       "Intel 82562 based Fast Ethernet Connection"),
+PCI_ROM(0x8086, 0x27dc, "82562GX/GZ",    "Intel 82801GB/GR (ICH7) Ethernet Connection"),
+PCI_ROM(0x8086, 0x1050, "82562ez",       "Intel 82562EZ Network Connection"),
+PCI_ROM(0x8086, 0x5200, "eepro100-5200", "Intel EtherExpress PRO/100 Intelligent Server"),
+PCI_ROM(0x8086, 0x5201, "eepro100-5201", "Intel EtherExpress PRO/100 Intelligent Server"),
+};
+
+/* Cards with device ids 0x1030 to 0x103F, 0x2449, 0x2459 or 0x245D might need
+ * a workaround for hardware bug on 10 mbit half duplex (see linux driver eepro100.c)
+ * 2003/03/17 gbaum */
+
+
+struct pci_driver eepro100_driver = {
+	.type      = NIC_DRIVER,
+	.name      = "EEPRO100",
+	.probe     = eepro100_probe,
+	.ids       = eepro100_nics,
+	.id_count  = sizeof(eepro100_nics)/sizeof(eepro100_nics[0]),
+	.class     = 0
+};
Index: netboot/sis900.h
===================================================================
--- netboot/sis900.h	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/sis900.h	(.../trunk)	(revision 112)
@@ -39,14 +39,16 @@
 
 /* Symbolic names for bits in various registers */
 enum sis900_command_register_bits {
-    RESET   = 0x00000100, 
-    SWI     = 0x00000080, 
-    RxRESET = 0x00000020,
-    TxRESET = 0x00000010, 
-    RxDIS   = 0x00000008, 
-    RxENA   = 0x00000004,
-    TxDIS   = 0x00000002, 
-    TxENA   = 0x00000001
+    RELOAD     = 0x00000400,
+    ACCESSMODE = 0x00000200,
+    RESET      = 0x00000100, 
+    SWI        = 0x00000080, 
+    RxRESET    = 0x00000020,
+    TxRESET    = 0x00000010, 
+    RxDIS      = 0x00000008, 
+    RxENA      = 0x00000004,
+    TxDIS      = 0x00000002, 
+    TxENA      = 0x00000001
 };
 
 enum sis900_configuration_register_bits {
@@ -57,7 +59,10 @@
     EXD      = 0x00000010, 
     PESEL    = 0x00000008, 
     LPM      = 0x00000004, 
-    BEM      = 0x00000001
+    BEM      = 0x00000001,
+    RND_CNT  = 0x00000400,
+    FAIR_BACKOFF = 0x00000200,
+    EDB_MASTER_EN = 0x00002000
 };
 
 enum sis900_eeprom_access_reigster_bits {
@@ -108,6 +113,10 @@
 #define TX_DMA_BURST    0
 #define RX_DMA_BURST    0
 
+enum sis900_tx_rx_dma{
+	        DMA_BURST_512 = 0,      DMA_BURST_64 = 5
+};
+
 /* transmit FIFO threshholds */
 #define TX_FILL_THRESH  16      /* 1/4 FIFO size */
 #define TxFILLT_shift   8
@@ -172,7 +181,12 @@
     EEeraseAll      = 0x0120,
     EEwriteAll      = 0x0110, 
     EEaddrMask      = 0x013F, 
+    EEcmdShift 	    = 16
 };
+/* For SiS962 or SiS963, request the eeprom software access */
+enum sis96x_eeprom_command {
+	EEREQ = 0x00000400, EEDONE = 0x00000200, EEGNT = 0x00000100
+};
 
 /* Manamgement Data I/O (mdio) frame */
 #define MIIread         0x6000
@@ -236,7 +250,8 @@
     MII_CONFIG1 = 0x0010,
     MII_CONFIG2 = 0x0011,
     MII_STSOUT  = 0x0012,
-    MII_MASK    = 0x0013
+    MII_MASK    = 0x0013,
+    MII_RESV    = 0x0014
 };
 
 /* mii registers specific to AMD 79C901 */
@@ -320,7 +335,9 @@
 
 enum sis900_revision_id {
 	SIS630A_900_REV = 0x80,		SIS630E_900_REV = 0x81,
-	SIS630S_900_REV = 0x82,		SIS630EA1_900_REV = 0x83
+	SIS630S_900_REV = 0x82,		SIS630EA1_900_REV = 0x83,
+	SIS630ET_900_REV = 0x84,        SIS635A_900_REV = 0x90,
+	SIS96x_900_REV = 0X91,		SIS900B_900_REV = 0x03
 };
 
 enum sis630_revision_id {
Index: netboot/tulip.c
===================================================================
--- netboot/tulip.c	(.../upstream/grub-0.97)	(revision 112)
+++ netboot/tulip.c	(.../trunk)	(revision 112)
@@ -48,6 +48,7 @@
 /*********************************************************************/
 
 /*
+  07 Sep 2003  timlegge	Multicast Support Added
   11 Apr 2001  mdc     [patch to etherboot 4.7.24]
      Major rewrite to include Linux tulip driver media detection
      code.  This driver should support a lot more cards now.
@@ -106,31 +107,29 @@
 #include "etherboot.h"
 #include "nic.h"
 #include "pci.h"
-#include "cards.h"
 
 /* User settable parameters */
 
-#undef   TULIP_DEBUG
-#undef   TULIP_DEBUG_WHERE
+#undef	TULIP_DEBUG
+#undef	TULIP_DEBUG_WHERE
+#ifdef	TULIP_DEBUG
 static int tulip_debug = 2;             /* 1 normal messages, 0 quiet .. 7 verbose. */
+#endif
 
 #define TX_TIME_OUT       2*TICKS_PER_SEC
 
-typedef unsigned char  u8;
-typedef   signed char  s8;
-typedef unsigned short u16;
-typedef   signed short s16;
-typedef unsigned int   u32;
-typedef   signed int   s32;
+typedef uint8_t    u8;
+typedef  int8_t    s8;
+typedef uint16_t   u16;
+typedef  int16_t   s16;
+typedef uint32_t   u32;
+typedef  int32_t   s32;
 
 /* helpful macros if on a big_endian machine for changing byte order.
    not strictly needed on Intel */
-#define le16_to_cpu(val) (val)
-#define cpu_to_le32(val) (val)
 #define get_unaligned(ptr) (*(ptr))
 #define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
 #define get_u16(ptr) (*(u16 *)(ptr))
-#define virt_to_bus(x) ((unsigned long)x)
 #define virt_to_le32desc(addr)  virt_to_bus(addr)
 
 #define TULIP_IOTYPE  PCI_USES_MASTER | PCI_USES_IO | PCI_ADDR0
@@ -212,6 +211,8 @@
       TULIP_IOTYPE, 256, PNIC2 },
     { "ADMtek AN981 Comet", { 0x09811317, 0xffffffff, 0, 0, 0, 0 },
       TULIP_IOTYPE, 256, COMET },
+    { "ADMTek AN983 Comet", { 0x12161113, 0xffffffff, 0, 0, 0, 0 },
+      TULIP_IOTYPE, 256, COMET },
     { "ADMtek Centaur-P", { 0x09851317, 0xffffffff, 0, 0, 0, 0 },
       TULIP_IOTYPE, 256, COMET },
     { "ADMtek Centaur-C", { 0x19851317, 0xffffffff, 0, 0, 0, 0 },
@@ -280,9 +281,13 @@
 static u16 t21041_csr14[] = { 0xFFFF, 0xF7FD, 0xF7FD, 0x7F3F, 0x7F3D, };
 static u16 t21041_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
 
+/* not used
 static u16 t21142_csr13[] = { 0x0001, 0x0009, 0x0009, 0x0000, 0x0001, };
+*/
 static u16 t21142_csr14[] = { 0xFFFF, 0x0705, 0x0705, 0x0000, 0x7F3D, };
+/* not used
 static u16 t21142_csr15[] = { 0x0008, 0x0006, 0x000E, 0x0008, 0x0008, };
+*/
 
 /* Offsets to the Command and Status Registers, "CSRs".  All accesses
    must be longword instructions and quadword aligned. */
@@ -300,6 +305,14 @@
     TxFIFOUnderflow=0x20, TxJabber=0x08, TxNoBuf=0x04, TxDied=0x02, TxIntr=0x01,
 };
 
+/* The configuration bits in CSR6. */
+enum csr6_mode_bits {
+	TxOn=0x2000, RxOn=0x0002, FullDuplex=0x0200,
+	AcceptBroadcast=0x0100, AcceptAllMulticast=0x0080,
+	AcceptAllPhys=0x0040, AcceptRunt=0x0008,
+};
+
+
 enum desc_status_bits {
     DescOwnded=0x80000000, RxDescFatalErr=0x8000, RxWholePkt=0x0300,
 };
@@ -384,21 +397,11 @@
 
 #define TX_RING_SIZE	2
 static struct tulip_tx_desc tx_ring[TX_RING_SIZE] __attribute__ ((aligned(4)));
-
-#ifdef USE_LOWMEM_BUFFER
-#define txb ((char *)0x10000 - BUFLEN)
-#else
 static unsigned char txb[BUFLEN] __attribute__ ((aligned(4)));
-#endif
 
 #define RX_RING_SIZE	4
 static struct tulip_rx_desc rx_ring[RX_RING_SIZE] __attribute__ ((aligned(4)));
-
-#ifdef USE_LOWMEM_BUFFER
-#define rxb ((char *)0x10000 - RX_RING_SIZE * BUFLEN - BUFLEN)
-#else
 static unsigned char rxb[RX_RING_SIZE * BUFLEN] __attribute__ ((aligned(4)));
-#endif
 
 static struct tulip_private {
     int cur_rx;
@@ -479,14 +482,13 @@
 static void mdio_write(struct nic *nic, int phy_id, int location, int value);
 static int read_eeprom(unsigned long ioaddr, int location, int addr_len);
 static void parse_eeprom(struct nic *nic);
-struct nic *tulip_probe(struct nic *nic, unsigned short *io_addrs,
-                        struct pci_device *pci);
+static int tulip_probe(struct dev *dev, struct pci_device *pci);
 static void tulip_init_ring(struct nic *nic);
 static void tulip_reset(struct nic *nic);
 static void tulip_transmit(struct nic *nic, const char *d, unsigned int t,
                            unsigned int s, const char *p);
 static int tulip_poll(struct nic *nic);
-static void tulip_disable(struct nic *nic);
+static void tulip_disable(struct dev *dev);
 static void nway_start(struct nic *nic);
 static void pnic_do_nway(struct nic *nic);
 static void select_media(struct nic *nic, int startup);
@@ -565,7 +567,7 @@
    MDIO protocol.  See the MII specifications or DP83840A data sheet
    for details. */
 
-int mdio_read(struct nic *nic, int phy_id, int location)
+int mdio_read(struct nic *nic __unused, int phy_id, int location)
 {
     int i;
     int read_cmd = (0xf6 << 10) | (phy_id << 5) | location;
@@ -626,7 +628,7 @@
     return (retval>>1) & 0xffff;
 }
 
-void mdio_write(struct nic *nic, int phy_id, int location, int value)
+void mdio_write(struct nic *nic __unused, int phy_id, int location, int value)
 {
     int i;
     int cmd = (0x5002 << 16) | (phy_id << 23) | (location<<18) | value;
@@ -899,7 +901,7 @@
 /*********************************************************************/
 /* tulip_init_ring - setup the tx and rx descriptors                */
 /*********************************************************************/
-static void tulip_init_ring(struct nic *nic)
+static void tulip_init_ring(struct nic *nic __unused)
 {
     int i;
 
@@ -936,6 +938,22 @@
     tx_ring[1].length  = cpu_to_le32(DESC_RING_WRAP | BUFLEN);
 }
 
+
+static void set_rx_mode(struct nic *nic __unused) {
+	int csr6 = inl(ioaddr + CSR6) & ~0x00D5;
+
+	tp->csr6 &= ~0x00D5;
+ 
+	/* !IFF_PROMISC */
+	tp->csr6 |= AcceptAllMulticast;
+	csr6 |= AcceptAllMulticast;
+
+	outl(csr6, ioaddr + CSR6);
+
+	
+	
+}
+
 /*********************************************************************/
 /* eth_reset - Reset adapter                                         */
 /*********************************************************************/
@@ -943,7 +961,6 @@
 {
     int i;
     unsigned long to;
-    u32 addr_low, addr_high;
 
 #ifdef TULIP_DEBUG_WHERE
     whereami("tulip_reset\n");
@@ -956,7 +973,7 @@
     if (tp->mii_cnt  ||  (tp->mtable  &&  tp->mtable->has_mii)) {
 	outl(0x814C0000, ioaddr + CSR6);
     }
-  
+ 
     /* Reset the chip, holding bit 0 set at least 50 PCI cycles. */
     outl(0x00000001, ioaddr + CSR0);
     tulip_wait(1);
@@ -1022,8 +1039,8 @@
     }
 
     /* Point to rx and tx descriptors */
-    outl((unsigned long)&rx_ring[0], ioaddr + CSR3);
-    outl((unsigned long)&tx_ring[0], ioaddr + CSR4);
+    outl(virt_to_le32desc(&rx_ring[0]), ioaddr + CSR3);
+    outl(virt_to_le32desc(&tx_ring[0]), ioaddr + CSR4);
 
     init_media(nic);
 
@@ -1049,6 +1066,8 @@
     if (tp->chip_id == LC82C168)
 	tulip_check_duplex(nic);
 
+    set_rx_mode(nic); 	
+        
     /* enable transmit and receive */
     outl(tp->csr6 | 0x00002002, ioaddr + CSR6);
 }
@@ -1095,7 +1114,7 @@
     tx_ring[0].status = cpu_to_le32(0x80000000);
 
     /* Point to transmit descriptor */
-    outl((u32)&tx_ring[0], ioaddr + CSR4);
+    outl(virt_to_le32desc(&tx_ring[0]), ioaddr + CSR4);
 
     /* Enable Tx */
     outl(csr6 | 0x00002000, ioaddr + CSR6);
@@ -1155,13 +1174,16 @@
 /*********************************************************************/
 /* eth_disable - Disable the interface                               */
 /*********************************************************************/
-static void tulip_disable(struct nic *nic)
+static void tulip_disable(struct dev *dev)
 {
-
+    struct nic *nic = (struct nic *)dev;
 #ifdef TULIP_DEBUG_WHERE
     whereami("tulip_disable\n");
 #endif
 
+    /* merge reset and disable */
+    tulip_reset(nic);
+
     /* disable interrupts */
     outl(0x00000000, ioaddr + CSR7);
 
@@ -1175,20 +1197,20 @@
 /*********************************************************************/
 /* eth_probe - Look for an adapter                                   */
 /*********************************************************************/
-struct nic *tulip_probe(struct nic *nic, unsigned short *io_addrs,
-                        struct pci_device *pci)
+static int tulip_probe(struct dev *dev, struct pci_device *pci)
 {
-    u32 i, l1, l2;
+    struct nic *nic = (struct nic *)dev;
+    u32 i;
     u8  chip_rev;
     u8 ee_data[EEPROM_SIZE];
     unsigned short sum;
     int chip_idx;
     static unsigned char last_phys_addr[ETH_ALEN] = {0x00, 'L', 'i', 'n', 'u', 'x'};
 
-    if (io_addrs == 0 || *io_addrs == 0)
+    if (pci->ioaddr == 0)
         return 0;
 
-    ioaddr         = *io_addrs;
+    ioaddr         = pci->ioaddr;
 
     /* point to private storage */
     tp = &tpx;
@@ -1378,15 +1400,14 @@
     /* reset the device and make ready for tx and rx of packets */
     tulip_reset(nic);
 
-    nic->reset    = tulip_reset;
+    dev->disable  = tulip_disable;
     nic->poll     = tulip_poll;
     nic->transmit = tulip_transmit;
-    nic->disable  = tulip_disable;
 
     /* give the board a chance to reset before returning */
     tulip_wait(4*TICKS_PER_SEC);
 
-    return nic;
+    return 1;
 }
 
 static void start_link(struct nic *nic)
@@ -1508,7 +1529,7 @@
     }
 }
 
-static void nway_start(struct nic *nic)
+static void nway_start(struct nic *nic __unused)
 {
     int csr14 = ((tp->sym_advertise & 0x0780) << 9)  |
         ((tp->sym_advertise&0x0020)<<1) | 0xffbf;
@@ -1662,7 +1683,7 @@
     }
 }
 
-static void pnic_do_nway(struct nic *nic)
+static void pnic_do_nway(struct nic *nic __unused)
 {
     u32 phy_reg = inl(ioaddr + 0xB8);
     u32 new_csr6 = tp->csr6 & ~0x40C40200;
@@ -1987,3 +2008,47 @@
 
         return 0;
 }
+
+static struct pci_id tulip_nics[] = {
+PCI_ROM(0x1011, 0x0002, "dc21040",     "Digital Tulip"),
+PCI_ROM(0x1011, 0x0009, "ds21140",     "Digital Tulip Fast"),
+PCI_ROM(0x1011, 0x0014, "dc21041",     "Digital Tulip+"),
+PCI_ROM(0x1011, 0x0019, "ds21142",     "Digital Tulip 21142"),
+PCI_ROM(0x10d9, 0x0512, "mx98713",     "Macronix MX987x3"),
+PCI_ROM(0x10d9, 0x0531, "mx98715",     "Macronix MX987x5"),
+PCI_ROM(0x1113, 0x1217, "mxic-98715",  "Macronix MX987x5"),
+PCI_ROM(0x11ad, 0xc115, "lc82c115",    "LinkSys LNE100TX"),
+PCI_ROM(0x11ad, 0x0002, "82c168",      "Netgear FA310TX"),
+PCI_ROM(0x1282, 0x9100, "dm9100",      "Davicom 9100"),
+PCI_ROM(0x1282, 0x9102, "dm9102",      "Davicom 9102"),
+PCI_ROM(0x1282, 0x9009, "dm9009",      "Davicom 9009"),
+PCI_ROM(0x1317, 0x0985, "centaur-p",   "ADMtek Centaur-P"),
+PCI_ROM(0x1317, 0x0981, "an981",       "ADMtek AN981 Comet"),		/* ADMTek Centaur-P (stmicro) */
+PCI_ROM(0x1113, 0x1216, "an983",       "ADMTek AN983 Comet"),
+PCI_ROM(0x1317, 0x9511, "an983b",      "ADMTek Comet 983b"),
+PCI_ROM(0x1317, 0x1985, "centaur-c",   "ADMTek Centaur-C"),
+PCI_ROM(0x8086, 0x0039, "intel21145",  "Intel Tulip"),
+PCI_ROM(0x125b, 0x1400, "ax88140",     "ASIX AX88140"),
+PCI_ROM(0x11f6, 0x9881, "rl100tx",     "Compex RL100-TX"),
+PCI_ROM(0x115d, 0x0003, "xircomtulip", "Xircom Tulip"),
+PCI_ROM(0x104a, 0x0981, "tulip-0981",  "Tulip 0x104a 0x0981"),
+PCI_ROM(0x104a, 0x2774, "tulip-2774",  "Tulip 0x104a 0x2774"),
+PCI_ROM(0x1113, 0x9511, "tulip-9511",  "Tulip 0x1113 0x9511"),
+PCI_ROM(0x1186, 0x1561, "tulip-1561",  "Tulip 0x1186 0x1561"),
+PCI_ROM(0x1259, 0xa120, "tulip-a120",  "Tulip 0x1259 0xa120"),
+PCI_ROM(0x13d1, 0xab02, "tulip-ab02",  "Tulip 0x13d1 0xab02"),
+PCI_ROM(0x13d1, 0xab03, "tulip-ab03",  "Tulip 0x13d1 0xab03"),
+PCI_ROM(0x13d1, 0xab08, "tulip-ab08",  "Tulip 0x13d1 0xab08"),
+PCI_ROM(0x14f1, 0x1803, "lanfinity",   "Conexant LANfinity"),
+PCI_ROM(0x1626, 0x8410, "tulip-8410",  "Tulip 0x1626 0x8410"),
+PCI_ROM(0x1737, 0xab09, "tulip-ab09",  "Tulip 0x1737 0xab09"),
+};
+
+struct pci_driver tulip_driver = {
+	.type     = NIC_DRIVER,
+	.name     = "Tulip",
+	.probe    = tulip_probe,
+	.ids      = tulip_nics,
+	.id_count = sizeof(tulip_nics)/sizeof(tulip_nics[0]),
+	.class    = 0,
+};

Property changes on: netboot
___________________________________________________________________
Name: svn:ignore
   + .deps
Makefile
libdrivers.a


